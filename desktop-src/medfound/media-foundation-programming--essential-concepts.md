---
description: Если вы не знакомы с цифровыми носителями, в этом разделе рассматриваются некоторые понятия, которые необходимо знать перед написанием Media Foundation приложения.
ms.assetid: d76d655e-23f3-407c-97a1-be015b0de37d
title: 'Media Foundation: основные понятия'
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0298a20518df91dab4439770e0f1193802969ae8
ms.sourcegitcommit: c16214e53680dc71d1c07111b51f72b82a4512d8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/03/2021
ms.locfileid: "104424110"
---
# <a name="media-foundation-essential-concepts"></a>Media Foundation: основные понятия

Если вы не знакомы с цифровыми носителями, в этом разделе рассматриваются некоторые понятия, которые необходимо знать перед написанием Media Foundation приложения.

-   [Потоки](#streams)
-   [Сжатие](#compression)
-   [Контейнеры мультимедиа](#media-containers)
-   [Форматы](#formats)
-   [См. также](#related-topics)

## <a name="streams"></a>Потоки

*Поток* — это последовательность данных мультимедиа с равномерным типом. Наиболее распространенными типами являются аудио и видео, но поток может содержать почти любые данные, включая текст, команды сценариев и все еще изображения. Термин *поток* в этой документации не подразумевает доставку по сети. Файл мультимедиа, предназначенный для локального воспроизведения, также содержит потоки.

Как правило, файл мультимедиа содержит либо один аудиопоток, либо только один поток видео и один звуковой поток. Однако файл мультимедиа может содержать несколько потоков одного типа. Например, видеофайл может содержать звуковые потоки на нескольких разных языках. Во время выполнения приложение выбирает используемый поток.

## <a name="compression"></a>Сжатие

*Сжатие* относится к любому процессу, который уменьшает размер потока данных за счет удаления избыточных данных. Алгоритмы сжатия делятся на две основные категории:

-   Сжатие *без потерь* . При использовании алгоритма без потерь перестроенные данные идентичны исходным.
-   Сжатие с *потерей* данных. При использовании алгоритма потери данных перестроенные данные являются приближением исходного, но не является точным соответствием.

В большинстве других доменов сжатие с потерей данных неприемлемо. (Представьте, что вы получаете «приближение» к электронной таблице!) Но схемы сжатия с потерей данных хорошо подходят для аудио и видео по нескольким причинам.

Первая причина заключается в том, что необходимо сделать с физикой человеческого восприятия. При прослушивании сложного звука, например записи музыки, некоторые сведения, содержащиеся в этом звуке, не являются ощутимыми. С помощью теории обработки сигнала можно анализировать и разделять частоты, которые не могут быть воспринимаемы. Эти частоты можно удалить без искусственного. Несмотря на то, что воссозданное аудио не соответствует исходному в точности, оно будет *звучать* так же, как и прослушиватель. Аналогичные принципы применимы к видео.

Во вторых, качество звука или изображения может быть приемлемым, в зависимости от предполагаемой цели. Например, в телефонии звук часто сильно сжимается. Результат является достаточно хорошим для общения с телефоном, но вы не хотите ожидать Symphony оркестре по телефону.

Сжатие также называется *кодированием*, а устройство, закодированное, называется *кодировщиком*. Обратный процесс *декодируется*, и устройство является естественным названием *декодера*. Общим термином для кодировщиков и декодеров является *кодек*. Кодеки могут быть реализованы в аппаратном или программном обеспечении.

Технология сжатия быстро изменилась с момента появления цифрового мультимедиа, и в настоящее время используется большое количество схем сжатия. Это одна из основных задач для программирования цифрового носителя.

## <a name="media-containers"></a>Контейнеры мультимедиа

В редких случаях хранение необработанного аудио-или видеопотока в виде файла компьютера или отправка его напрямую по сети. В одном случае было бы невозможно декодировать такой поток, не зная заранее, какой кодек использовать. Таким образом, файлы мультимедиа обычно содержат по крайней мере некоторые из следующих элементов:

-   Заголовки файлов, описывающие количество потоков, формат каждого потока и т. д.
-   Индекс, который обеспечивает произвольный доступ к содержимому.
-   Метаданные, описывающие содержимое (например, исполнитель или заголовок).
-   Заголовки пакетов, чтобы включить передачу по сети или произвольный доступ.

В этой документации термин *контейнер* используется для описания всего пакета потоков, заголовков, индексов, метаданных и т. д. Причиной использования термина *контейнер* , а не *файла* является то, что некоторые форматы контейнеров предназначены для вещания в реальном времени. Приложение может создать контейнер в режиме реального времени, никогда не сохраняя его в файле.

Ранний пример контейнера мультимедиа — это формат AVI-файла. К другим примерам относятся MP4 и расширенный системный формат (ASF). Контейнеры можно идентифицировать по расширению имени файла (например, MP4) или по типу MIME.

На следующей диаграмме показана типичная структура для контейнера мультимедиа. Схема не представляет никакой конкретный формат. сведения о каждом формате могут сильно различаться.

![Схема, показывающая типичный контейнер мультимедиа](images/concepts01.png)

Обратите внимание, что структура, показанная на диаграмме, является иерархической, а сведения о заголовке появляются в начале контейнера. Эта структура обычно имеет много (но не все) форматов контейнеров. Также обратите внимание, что в разделе данных содержатся пакеты аудио и видео с чередованием. Этот тип использования часто встречается в контейнерах мультимедиа.

Термин " *мультиплексирование* " относится к процессу паккетизинг потоков аудио и видео и покидает пакеты в контейнер. Обратный процесс, при котором выполняется сборка потоков из пакетных данных, называется *демультиплексированием*.

## <a name="formats"></a>Форматы

В цифровом носителе термин *Формат* неоднозначна. Формат может ссылаться на тип *кодировки*, например H. 264 Video или *контейнер*, например MP4. Это различие часто вызывает путаницу для обычных пользователей. Имена, предоставленные форматам мультимедиа, не всегда помогают. Например, *MP3* ссылается как на формат кодирования (звуковой слой MPEG-1 3), так и на формат файла.

Различие очень важно, так как чтение файла мультимедиа фактически состоит из двух этапов:

1.  Сначала необходимо выполнить синтаксический анализ контейнера. В большинстве случаев число потоков и формат каждого потока не могут быть известны до завершения этого шага.
2.  Затем, если потоки сжимаются, они должны быть декодированы с помощью соответствующих декодеров.

Этот факт довольно естественно подходит для проектирования программного обеспечения, где отдельные компоненты используются для анализа контейнеров и декодирования потоков. Кроме того, этот подход предоставляется модели подключаемых модулей, чтобы сторонние стороны могли предоставлять собственные средства синтаксического анализа и кодеки. В Windows объектная модель компонента (COM) предоставляет стандартный способ отделения API от реализации, что является требованием для любой модели подключаемых модулей. По этой причине (в других случаях) Media Foundation использует COM-интерфейсы.

На следующей схеме показаны компоненты, используемые для чтения файла мультимедиа.

![Схема, на которой показаны компоненты для чтения файла мультимедиа](images/concepts02.png)

Для записи файла мультимедиа также необходимо выполнить два действия:

1.  Кодирование несжатых аудио-и видеоданных.
2.  Перевод сжатых данных в определенный формат контейнера.

На следующей схеме показаны компоненты, используемые для записи файла мультимедиа.

![Схема, на которой показаны компоненты для записи файла мультимедиа.](images/concepts03.png)

## <a name="related-topics"></a>См. также

<dl> <dt>

[Media Foundationое программное руководством](media-foundation-programming-guide.md)
</dt> </dl>

 

 



