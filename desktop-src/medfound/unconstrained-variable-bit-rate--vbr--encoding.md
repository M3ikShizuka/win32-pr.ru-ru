---
description: Кодирование переменной скорости с неограниченным битом
ms.assetid: 35fb4bd7-87c5-4f46-ae71-10278670ef9c
title: Кодирование переменной скорости с неограниченным битом
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0b216629991b466aa8560e26e0ada623f9c26efa
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "105692772"
---
# <a name="unconstrained-variable-bit-rate-encoding"></a>Кодирование переменной скорости с неограниченным битом

В режиме кодирования с переменной скоростью без ограничений (VBR) содержимое кодируется на максимально возможное качество, сохраняя при этом указанную скорость.

Для кодирования с неограниченной VBR используется два прохода кодирования. При использовании кодирования с неограниченным числом VBR необходимо указать скорость потока, как в случае с [постоянной кодировкой битовой скорости](constant-bit-rate-encoding.md). Однако кодировщик использует это значение только в качестве средней скорости потока и кодирует, чтобы качество по мере возможности максимально велико при сохранении среднего значения. Отдельные выборки, созданные кодировщиком, зависят от размера без явных ограничений буфера. Однако средняя скорость потока в течение сеанса кодирования и длительность потоковой передачи не должны превышать значение, указанное вами. Реальная скорость потока в любой момент в закодированном потоке может сильно отличаться от среднего значения. Не задается окно буфера для кодирования с неограниченными VBR. Вместо этого кодировщик вычислит размер требуемого окна буфера на основе требований закодированных образцов. Это означает, что ограничение размера отдельных выборок в потоке не ограничено, если средняя скорость потока меньше или равна заданному значению.

Преимуществом кодирования с неограниченным числом VBR является то, что сжатый поток имеет наивысшее возможное качество, сохраняя при этом прогнозируемую среднюю пропускную способность. Используйте этот параметр, если необходимо указать пропускную способность, но колебания, окружающие указанную пропускную способность, приемлемы. Например, для локальных файлов или только для загрузки.

Недостаток этого режима кодирования заключается в том, что кодировщик может установить окно буфера в любое значение, необходимое после кодирования, что дает вам контроль над размером буфера. В большинстве случаев, если нет опасений относительно размера буфера или согласованности использования пропускной способности, следует использовать [кодирование с переменной скоростью с переменным качеством](quality-based-variable-bit-rate--vbr--encoding.md) .

### <a name="configuring-the-encoder-for-unconstrained-vbr"></a>Настройка кодировщика для неограниченных VBR

Конфигурация кодировщика задается с помощью значений свойств. Эти свойства определены в вмкодекдсп. h. Перед согласованием типа выходного носителя необходимо установить свойства конфигурации в кодировщике. Дополнительные сведения о настройке свойств кодировщика см. в разделе [Настройка кодировщика](configuring-the-encoder.md). На основе указанных значений свойств можно перечислить Поддерживаемые типы выходных данных VBR и выбрать требуемый тип на кодировщике [Media Foundation преобразование](media-foundation-transforms.md) (MFT) на основе средней скорости.

В следующем списке перечислены свойства, которые необходимо задать для этого типа кодирования.

-   Укажите режим кодирования VBR, задав \_ для свойства мфпкэй вбренаблед значение Variant \_ true.
-   Присвойте параметру пассесусед МФПКЭЙ значение \_ 2, так как в режиме неограниченных VBR используется два прохода кодирования.
-   При перечислении типа выходного носителя проверьте атрибут [**" \_ \_ \_ Среднее \_ число байт \_ в \_ секунду MF MT**](mf-mt-audio-avg-bytes-per-second-attribute.md) " (для звуковых потоков) или атрибут с [**\_ \_ средним \_ скоростью MF MT**](mf-mt-avg-bitrate-attribute.md) (для видеопотоков) доступных типов выходного носителя. Выберите тип выходного носителя с средней скоростью, ближайшей к требуемой средней скорости, которую должен поддерживать кодировщик в закодированном содержимом. Дополнительные сведения о выборе типа выходного носителя см. в разделе [Согласование типа носителя в кодировщике](media-type-negotiation-on-the-encoder.md).

Чтобы получить значение окна буфера, заданное кодировщиком, вызовите **ивмкодеклеакибуккет:: жетбуфферсизебитс**, определенный в вмкодеЦифацес. h и вмкодекдспууид. lib, после сеанса кодирования. Чтобы добавить поддержку неограниченных VBR для потоков, необходимо задать это значение в атрибуте [**MF \_ асфстреамконфиг \_ LEAKYBUCKET1**](mf-asfstreamconfig-leakybucket1-attribute.md) (среднее значение сегмента утечки) в объекте конфигурации потока при настройке профиля ASF.

В следующем примере метод Сетенкодингтипе класса Sample Ценкодер изменяется для настройки режима с неограниченным числом VBR. Сведения об этом классе см. в разделе [пример кода кодировщика](encoder-example-code.md). Сведения о вспомогательных макросах, используемых в этом примере, см. в разделе Использование Media Foundation примеров кода.


```
//////////////////////////////////////////////////////////////////////////
//  Name: SetEncodingType
//  Description: Sets the encoding type to unconstrained VBR
//
/////////////////////////////////////////////////////////////////////////

HRESULT CEncoder::SetEncodingType(EncodeMode mode)
{
    if (!m_pMFT)
    {
        return MF_E_NOT_INITIALIZED;
    }

    HRESULT hr = S_OK;

    IPropertyStore* pProp = NULL;

    PROPVARIANT var;
    PropVariantInit(&var);

    //Query the encoder for its property store
    CHECK_HR(hr = m_pMFT->QueryInterface(__uuidof(IPropertyStore), (void**)&pProp));
    
    if (mode == EncodeMode_VBR_Unconstrained)
    {
        //Set the VBR property to TRUE, which indicates VBR encoding
        var.vt = VT_BOOL;
        var.boolVal = TRUE;
        CHECK_HR(hr = pProp->SetValue(MFPKEY_VBRENABLED, var));
        PropVariantClear(&var);

        //Set number of passes
        var.vt = VT_I4;
        var.lVal  =2;
        CHECK_HR(hr = pProp->SetValue(MFPKEY_PASSESUSED, var));
        PropVariantClear(&var);
    }

done:
    PropVariantClear(&var);
    SAFE_RELEASE (pProp);
    return hr;
    
}
```



## <a name="related-topics"></a>См. также

<dl> <dt>

[Типы кодирования ASF](asf-encoding-types.md)
</dt> <dt>

[Модель буфера для контейнера утечки](the-leaky-bucket-buffer-model.md)
</dt> <dt>

[Создание топологии для Two-Pass кодирования Windows Media](how-to-create-a-topology-for-2-pass-windows-media-encoding.md)
</dt> </dl>

 

 



