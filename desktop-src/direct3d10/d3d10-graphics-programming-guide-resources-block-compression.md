---
description: Сжатие блока — это метод сжатия текстур для уменьшения их размера.
ms.assetid: add98d8f-6846-4dd6-b0e2-a4b6e89cbcc5
title: Блочное сжатие (Direct3D 10)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: f7c3a74fba0b4c7c2adade210a9a54952b5d1269
ms.sourcegitcommit: 5a78723ad484955ac91a23cf282cf9c176c1eab6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/22/2021
ms.locfileid: "114436550"
---
# <a name="block-compression-direct3d-10"></a>Блочное сжатие (Direct3D 10)

Сжатие блока — это метод сжатия текстур для уменьшения их размера. По сравнению с текстурой с 32 битами на цвет текстура со сжатыми блоками может быть до 75 % меньше. Как правило, приложения начинают работать быстрее при использовании сжатия блоков, поскольку нагрузка на память снижается.

Сжатие блоков выполняется с потерями, однако работает хорошо и рекомендуется для всех текстур, преобразуемых и фильтруемых конвейером. Текстуры, которые напрямую сопоставляются экрану (элементы пользовательского интерфейса, такие как значки и текст), не очень подходят для сжатия, поскольку артефакты более заметны.

Текстура со сжатыми блоками должна создаваться как кратная размеру 4 во всех измерениях, ее невозможно использовать в качестве выходных данных конвейера.

-   [Как работает сжатие блокировок?](#how-does-block-compression-work)
    -   [Хранение несжатых данных](#storing-uncompressed-data)
    -   [Хранение сжатых данных](#storing-compressed-data)
-   [Использование блочного сжатия](#using-block-compression)
    -   [Виртуальный размер и физический размер](#virtual-size-versus-physical-size)
-   [Алгоритмы сжатия](#compression-algorithms)
    -   [BC1](#bc1)
    -   [BC2](#bc2)
    -   [BC3](#bc3)
    -   [BC4](#bc4)
    -   [BC5](#bc5)
-   [Преобразование формата с помощью Direct3D 10,1](#format-conversion-using-direct3d-101)
-   [См. также](#related-topics)

## <a name="how-does-block-compression-work"></a>Как работает сжатие блокировок?

Сжатие блоков — это метод уменьшения объема памяти, необходимой для хранения данных цвета. Сохраняя некоторые цвета в первоначальном размере, а другие — с использованием схемы кодирования, можно существенно уменьшить объем памяти, необходимый для хранения изображения. Поскольку оборудование автоматически декодирует сжатые данные, использование сжатых текстур не приводит к снижению производительности.

Чтобы узнать, как работает сжатие, рассмотрите следующие два примера. В первом примере описывается объем памяти, используемой при хранении несжатых данных; а второй — объем памяти при хранении сжатых данных.

### <a name="storing-uncompressed-data"></a>Хранение несжатых данных

На следующем рисунке показана текстура 4×4 без сжатия. Допустим, каждый цвет имеет один компонент цвета (например, красный) и хранится в одном байте памяти.

![Иллюстрация несжатой текстуры 4x4](images/d3d10-block-compress-1.png)

Несжатые данные располагаются в памяти последовательно и требуют 16 байтов для хранения, как показано на следующем рисунке.

![Иллюстрация несжатых данных в последовательной памяти](images/d3d10-block-compress-2.png)

### <a name="storing-compressed-data"></a>Хранение сжатых данных

Вы увидели, сколько памяти требуется для хранения несжатого изображения. А теперь посмотрим, сколько памяти экономит сжатое изображение. Формат сжатия [BC4](#bc4) сохраняет 2 цвета (1 байт каждый) и 16 3-разрядные индексы (48 бит или 6 байт), которые используются для интерполяции исходных цветов в текстуре, как показано на следующем рисунке.

![Иллюстрация формата сжатия BC4](images/d3d10-block-compress-3.png)

Совокупное пространство, необходимое для хранения сжатых данных, равно 8 байтов, то есть экономия памяти составляет 50 % по сравнению с примером без сжатия. Экономия увеличивается, если используется несколько компонентов цвета.

Значительная экономия памяти, обеспечиваемая сжатием блоков, позволяет существенно повысить производительность. Это повышение производительности происходит за счет снижения качества изображения (из-за интерполяции цвета); однако более низкое качество не всегда заметно.

В следующем разделе показано, как Direct3D 10 упрощает использование блочного сжатия в приложении.

## <a name="using-block-compression"></a>Использование блочного сжатия

Создайте текстуру с сжатием блока точно так же, как несжатая текстура (см. раздел [Создание текстуры из файла](d3d10-graphics-programming-guide-resources-creating-textures.md)), за исключением того, что вы указали формат, сжатый в виде блока.


```
loadInfo.Format = DXGI_FORMAT_BC1_UNORM;
D3DX10CreateTextureFromFile(...);
```



Затем создайте представление для привязки текстуры к конвейеру. Так как текстура с сжатием блока может использоваться только в качестве входных данных для этапа шейдера, необходимо создать представление шейдера, вызвав [**креатешадерресаурцевиев**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-createshaderresourceview).

Используйте текстуру со сжатыми блоками так же, как вы бы использовали текстуру без сжатия. Если ваше приложение будет использовать указатель памяти на данные со сжатием блоков, потребуется учетная запись для заполнения памяти в MIP-карте, из-за чего объявленный размер может отличаться от фактического.

### <a name="virtual-size-versus-physical-size"></a>Виртуальный размер и физический размер

Если у вас есть код приложения, который использует указатель памяти для прохода памяти текстуры со сжатием блоков, существует один важный аспект, который может потребовать изменения кода приложения. Текстура со сжатием блоков должна быть кратна 4 во всех измерениях, поскольку алгоритмы сжатия блоков работают с блоками текселей 4x4. Это может представлять проблему для MIP-карты, первоначальные габариты которой кратны 4, а подразделенные уровни — нет. На следующей схеме показаны различия областей между виртуальным (объявленным) и физическим (фактическим) размером каждого уровня MIP-карты.

![Схема несжатых и сжатых уровней mipmap](images/d3d10-block-compress-pad.png)

В левой части схемы показаны размеры уровня MIP-карты, создаваемые для несжатой текстуры 60×40. Размер верхнего уровня взят из вызова API, создающего текстуру; размер каждого последующего уровня равен половине размера предыдущего уровня. Для несжатой текстуры нет различия между виртуальным (объявленным) и физическим (фактическим) размером.

В правой части схемы показаны размеры уровня MIP-карты, которые создаются для той же текстуры 60×40 со сжатием. Обратите внимание, что на втором и третьем уровнях используется заполнение памяти, чтобы сделать размеры кратными 4 на каждом уровне. Это необходимо, чтобы эти алгоритмы могли работать с блоками текселей 4×4. Это особенно очевидно, если вы рассматриваете уровни MIP-карт менее 4×4; размеры этих очень маленьких MIP-карт при выделении памяти текстуры будут округляться до ближайшего кратного 4 числа.

Оборудование для выборки использует виртуальный размер; при выборке текстуры заполнение памяти игнорируется. Для уровней MIP-карт менее 4×4 только первые четыре текселя будут использоваться для карты 2×2 и только первый тексель будет использоваться для блока 1×1. Однако нет структуры API, которая предоставляет физический размер (включая заполнение памяти).

Необходимо с большой осторожностью пользоваться выровненными блоками памяти при копировании регионов, которые содержат данные со сжатием блоков. Чтобы сделать это в приложении с указателем памяти, убедитесь, что указатель использует шаг поверхности для учета размера физической памяти.

## <a name="compression-algorithms"></a>Алгоритмы сжатия

Техника сжатия блоков в Direct3D подразумевает разделение данных несжатой текстуры в блоки 4×4, сжатие каждого блока и последующее сохранение файлов. По этой причине сжимаемые текстуры должны иметь габариты, кратные 4.

![Схема блочного сжатия](images/d3d10-compression-1.png)

На предыдущей схеме показана текстура, разделенная на блоки текселей. Первый блок показывает структуру 16 текселей, помеченных с a до p, однако во всех блоках данные организованы одинаково.

Direct3D реализует несколько схем сжатия, каждая из которых представляет собой разные компромиссы между количеством хранимых компонентов, количеством битов на компонент и объемом потребляемой памяти. Воспользуйтесь этой таблицей, чтобы выбрать формат, который больше всего подходит для вашего типа и разрешения данных в приложении.



| Исходные данные                     | Разрешение сжатия данных (в битах) | Выберите этот формат сжатия |
|---------------------------------|---------------------------------------|--------------------------------|
| Трех-компонентный цвет и альфа | Цвет (5:6:5), альфа (1) или без альфа  | BC1                            |
| Трех-компонентный цвет и альфа | Цвет (5:6:5), альфа (4)              | [BC2](#bc2)                    |
| Трех-компонентный цвет и альфа | Цвет (5:6:5), альфа (8)              | [BC3](#bc3)                    |
| Однокомпонентный цвет             | Один компонент (8)                     | [BC4](#bc4)                    |
| Двухкомпонентный цвет             | Два компонента (8:8)                  | [BC5](#bc5)                    |



 

### <a name="bc1"></a>BC1

Используйте первый формат сжатия блоков (BC1) (в формате DXGI \_ \_ BC1 \_ Type, \_ \_ BC1 \_ UNORM или DXGI \_ BC1 \_ UNORM \_ sRGB) для хранения данных цвета с тремя компонентами, используя цвет 5:6:5 (5 бит красного, 6 бит зеленого, 5 бит синего цвета). Это актуально, даже если данные также содержат 1-битовый альфа-канал. Допустим, текстура 4×4 использует самый крупный из возможных форматов данных. В этом случае формат BC1 уменьшает объем необходимой памяти с 48 байтов (16 цветов × 3 компонента/цвет × 1 байт/компонент) до 8 байтов.

Этот алгоритм работает в блоках текселей 4×4. Вместо того чтобы хранить 16 цветов, алгоритм сохраняет 2 эталонных цвета (цвет \_ 0 и цвет \_ 1) и 16 2-разрядные индексы цвета (Block a – p), как показано на следующей схеме.

![Схема макета для сжатия BC1](images/d3d10-compression-bc1.png)

Индексы цвета (a–p) используются для поиска первоначальных цветов в таблице цветов. Таблица цветов содержит 4 цвета. Первые два цвета — цвет \_ 0 и цвет \_ 1 — являются минимальным и максимальным цветом. Другие два цвета, цвет \_ 2 и цвет \_ 3, являются промежуточными цветами, вычисляемыми с помощью линейной интерполяции.


```
color_2 = 2/3*color_0 + 1/3*color_1
color_3 = 1/3*color_0 + 2/3*color_1
```



Четырем цветам назначаются 2-битовые значения индекса, которые сохраняются в блоках a–p.


```
color_0 = 00
color_1 = 01
color_2 = 10
color_3 = 11
```



Наконец, все цвета в блоках a–p сравниваются с четырьмя цветами в таблице цветов, и индекс ближайшего цвета сохраняется в 2-битовых блоках.

Этот алгоритм пригоден для данных, которые также содержит 1-битовый альфа-канал. Единственное отличие заключается в том, что цвет \_ 3 имеет значение 0 (что представляет собой прозрачный цвет), а цвет \_ 2 — линейное смешение цвета \_ 0 и цвета \_ 1.


```
color_2 = 1/2*color_0 + 1/2*color_1;
color_3 = 0;
```





<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td>Различия между Direct3D 9 и Direct3D 10:<br/> Этот формат существует как в Direct3D 9, так и в 10.<br/>
<ul>
<li>В Direct3D 9 формат BC1 называется D3DFMT_DXT1.</li>
<li>В Direct3D 10 формат BC1 представлен DXGI_FORMAT_BC1_UNORM или DXGI_FORMAT_BC1_UNORM_SRGB.</li>
</ul></td>
</tr>
</tbody>
</table>



 

### <a name="bc2"></a>BC2

Используйте формат BC2 (в формате DXGI \_ \_ BC2 без \_ типов, в \_ формате DXGI \_ BC2 \_ UNORM или DXGI \_ BC2 \_ UNORM \_ sRGB) для хранения данных, содержащих цвет и альфа-данные с низкой согласованностью (используйте [BC3](#bc3) для обеспечения высокой согласованности альфа-данных). Формат BC2 хранит данные RGB как цвет 5:6:5 (5 битов на красный, 6 битов на зеленый, 5 битов на синий), а альфа-канал — как отдельное 4-битовое значение. Допустим, текстура 4×4 использует самый крупный из возможных форматов данных. В этом случае эта техника сжатия уменьшает объем необходимой памяти с 64 байтов (16 цветов × 4 компонента/цвет × 1 байт/компонент) до 16 байтов памяти.

Формат BC2 сохраняет цвета с тем же количеством битов и той же структурой данных, что и формат [BC1](#bc1); однако формату BC2 требуются дополнительно 64 бита памяти для хранения альфа-данных, как показано на следующей схеме.

![Схема макета для сжатия BC2](images/d3d10-compression-bc2.png)

<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td>Различия между Direct3D 9 и Direct3D 10:<br/> Этот формат существует как в Direct3D 9, так и в 10.<br/>
<ul>
<li>В Direct3D 9 формат BC2 называется D3DFMT_DXT2 и D3DFMT_DXT3.</li>
<li>В Direct3D 10 формат BC2 представлен DXGI_FORMAT_BC2_UNORM или DXGI_FORMAT_BC2_UNORM_SRGB.</li>
</ul></td>
</tr>
</tbody>
</table>



 

### <a name="bc3"></a>BC3

Используйте формат BC3 (в формате DXGI \_ \_ BC3 \_ без типов, в \_ формате DXGI \_ BC3 \_ UNORM или DXGI \_ BC3 \_ UNORM \_ sRGB) для хранения данных цвета с высокой степенью согласованности (используйте [BC2](#bc2) с менее согласованными альфа-данными). Формат BC3 сохраняет данные цвета с использованием цвета 5:6:5 (5 битов красного, 6 битов зеленого, 5 битов синего) и альфа-данные с использованием одного байта. Допустим, текстура 4×4 использует самый крупный из возможных форматов данных. В этом случае эта техника сжатия уменьшает объем необходимой памяти с 64 байтов (16 цветов × 4 компонента/цвет × 1 байт/компонент) до 16 байтов памяти.

Формат BC3 сохраняет цвета с тем же количеством битов и той же структурой данных, что и формат [BC1](#bc1); однако формату BC3 требуются дополнительно 64 бита памяти для хранения альфа-данных. Формат BC3 обрабатывает альфа-канал, сохраняя два эталонных значения и выполняя интерполяцию между ними (аналогично сохранению цвета RGB в формате BC1).

Этот алгоритм работает в блоках текселей 4×4. Вместо того чтобы хранить 16 альфа-значений, алгоритм сохраняет 2 ссылки (альфа \_ 0 и альфа \_ 1) и 16 3-битные индексы цвета (от Альфа a до p), как показано на следующей схеме.

![Схема макета для сжатия BC3](images/d3d10-compression-bc3.png)

Формат BC3 использует альфа-индексы (a–p) для поиска первоначальных цветов в таблице поиска, которая содержит 8 значений. Первые два значения (альфа \_ 0 и альфа \_ 1) — это минимальное и максимальное значения; остальные шесть промежуточных значений рассчитываются с помощью линейной интерполяции.

Алгоритм определяет количество интерполированных альфа-значений, анализируя два эталонных альфа-значения. Если альфа \_ 0 больше альфа \_ 1, то BC3 интерполирует 6 альфа-значений; в противном случае — интерполяцию 4. Если BC3 интерполирует только 4 альфа-значения, он задает два дополнительных альфа-значения (0 для полностью прозрачного и 255 для полностью непрозрачного). BC3 сжимает альфа-значения в области текселей 4×4, сохраняя битовый код, соответствующий интерполированным альфа-значениям, которые наиболее полно соответствуют исходному альфа-значению для заданного текселя.


```
if( alpha_0 > alpha_1 )
{
  // 6 interpolated alpha values.
  alpha_2 = 6/7*alpha_0 + 1/7*alpha_1; // bit code 010
  alpha_3 = 5/7*alpha_0 + 2/7*alpha_1; // bit code 011
  alpha_4 = 4/7*alpha_0 + 3/7*alpha_1; // bit code 100
  alpha_5 = 3/7*alpha_0 + 4/7*alpha_1; // bit code 101
  alpha_6 = 2/7*alpha_0 + 5/7*alpha_1; // bit code 110
  alpha_7 = 1/7*alpha_0 + 6/7*alpha_1; // bit code 111
}
else
{
  // 4 interpolated alpha values.
  alpha_2 = 4/5*alpha_0 + 1/5*alpha_1; // bit code 010
  alpha_3 = 3/5*alpha_0 + 2/5*alpha_1; // bit code 011
  alpha_4 = 2/5*alpha_0 + 3/5*alpha_1; // bit code 100
  alpha_5 = 1/5*alpha_0 + 4/5*alpha_1; // bit code 101
  alpha_6 = 0;                         // bit code 110
  alpha_7 = 255;                       // bit code 111
}
```





<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td>Различия между Direct3D 9 и Direct3D 10:<br/>
<ul>
<li>В Direct3D 9 формат BC3 называется D3DFMT_DXT4 и D3DFMT_DXT5.</li>
<li>В Direct3D 10 формат BC3 представлен DXGI_FORMAT_BC3_UNORM или DXGI_FORMAT_BC3_UNORM_SRGB.</li>
</ul></td>
</tr>
</tbody>
</table>



 

### <a name="bc4"></a>BC4

Используйте формат BC4 для хранения данных об однокомпонентном цвете с использованием 8 битов каждого цвета. В результате повышения точности (по сравнению с [BC1](#bc1)) BC4 идеально подходит для хранения данных с плавающей запятой в диапазоне от \[ 0 до 1 \] с помощью формата DXGI \_ \_ BC4 \_ UNORM и \[ от-1 до + 1 \] с использованием \_ формата DXGI \_ BC4 \_ снорм. Допустим, текстура 4×4 использует самый крупный из возможных форматов данных. В этом случае эта техника сжатия уменьшает объем необходимой памяти с 16 байтов (16 цветов × 1 компонент/цвет × 1 байт/компонент) до 8 байтов.

Этот алгоритм работает в блоках текселей 4×4. Вместо того чтобы хранить 16 цветов, алгоритм сохраняет 2 эталонных цвета (красный \_ 0 и красный \_ 1) и 16 3-битные индексы цвета (от красного до Красного p), как показано на следующей схеме.

![Схема макета для сжатия BC4](images/d3d10-compression-bc4.png)

Алгоритм использует 3-битовые индексы для поиска цветов в таблице цветов, которая содержит 8 элементов. Первые два цвета (красный \_ 0 и красный \_ 1) — это минимальное и максимальное цвета. Этот алгоритм вычисляет оставшиеся цвета с использованием линейной интерполяции.

Алгоритм определяет количество интерполированных значений цвета, анализируя два эталонных значения. Если красный \_ 0 больше, чем красный \_ 1, BC4 интерполирует 6 значений цвета; в противном случае — интерполяцию 4. Если BC4 интерполирует только 4 значения цвета, задается два дополнительных значения цвета (0.0f для полностью прозрачного и 1.0f для полностью непрозрачного). BC4 сжимает альфа-значения в области текселей 4×4, сохраняя битовый код, соответствующий интерполированным альфа-значениям, которые наиболее полно соответствуют исходному альфа-значению для заданного текселя.

-   [BC4 \_ UNORM](/windows)
-   [BC4 \_ снорм](/windows)

### <a name="bc4_unorm"></a>BC4 \_ UNORM

Следующий пример кода показывает, как выполняется интерполяция однокомпонентных данных.


```
unsigned word red_0, red_1;

if( red_0 > red_1 )
{
  // 6 interpolated color values
  red_2 = (6*red_0 + 1*red_1)/7.0f; // bit code 010
  red_3 = (5*red_0 + 2*red_1)/7.0f; // bit code 011
  red_4 = (4*red_0 + 3*red_1)/7.0f; // bit code 100
  red_5 = (3*red_0 + 4*red_1)/7.0f; // bit code 101
  red_6 = (2*red_0 + 5*red_1)/7.0f; // bit code 110
  red_7 = (1*red_0 + 6*red_1)/7.0f; // bit code 111
}
else
{
  // 4 interpolated color values
  red_2 = (4*red_0 + 1*red_1)/5.0f; // bit code 010
  red_3 = (3*red_0 + 2*red_1)/5.0f; // bit code 011
  red_4 = (2*red_0 + 3*red_1)/5.0f; // bit code 100
  red_5 = (1*red_0 + 4*red_1)/5.0f; // bit code 101
  red_6 = 0.0f;                     // bit code 110
  red_7 = 1.0f;                     // bit code 111
}
```



Эталонным цветам назначаются 3-битовые индексы (000–111, поскольку значений 8), которые сохраняются в блоках с red a до red p во время сжатия.

### <a name="bc4_snorm"></a>BC4 \_ снорм

Формат DXGI \_ \_ BC4 \_ снорм точно такой же, за исключением того, что данные КОДИРУЮТСЯ в диапазоне снорм, а 4 значения цвета интерполируются. Следующий пример кода показывает, как выполняется интерполяция однокомпонентных данных.


```
signed word red_0, red_1;

if( red_0 > red_1 )
{
  // 6 interpolated color values
  red_2 = (6*red_0 + 1*red_1)/7.0f; // bit code 010
  red_3 = (5*red_0 + 2*red_1)/7.0f; // bit code 011
  red_4 = (4*red_0 + 3*red_1)/7.0f; // bit code 100
  red_5 = (3*red_0 + 4*red_1)/7.0f; // bit code 101
  red_6 = (2*red_0 + 5*red_1)/7.0f; // bit code 110
  red_7 = (1*red_0 + 6*red_1)/7.0f; // bit code 111
}
else
{
  // 4 interpolated color values
  red_2 = (4*red_0 + 1*red_1)/5.0f; // bit code 010
  red_3 = (3*red_0 + 2*red_1)/5.0f; // bit code 011
  red_4 = (2*red_0 + 3*red_1)/5.0f; // bit code 100
  red_5 = (1*red_0 + 4*red_1)/5.0f; // bit code 101
  red_6 = -1.0f;                     // bit code 110
  red_7 =  1.0f;                     // bit code 111
}
```



Эталонным цветам назначаются 3-битовые индексы (000–111, поскольку значений 8), которые сохраняются в блоках с red a до red p во время сжатия.

### <a name="bc5"></a>BC5

Используйте формат BC5 для хранения данных о двухкомпонентном цвете с использованием 8 битов каждого цвета. В результате повышения точности (по сравнению с [BC1](#bc1)) Bc5 идеально подходит для хранения данных с плавающей запятой в диапазоне от \[ 0 до 1 \] с помощью формата DXGI \_ \_ Bc5 \_ UNORM и \[ от-1 до + 1 \] с использованием \_ формата DXGI \_ Bc5 \_ снорм. Допустим, текстура 4×4 использует самый крупный из возможных форматов данных. В этом случае эта техника сжатия уменьшает объем необходимой памяти с 32 байтов (16 цветов × 2 компонента/цвет × 1 байт/компонент) до 16 байтов.

Этот алгоритм работает в блоках текселей 4×4. Вместо того чтобы хранить 16 цветов для обоих компонентов, алгоритм сохраняет 2 эталонных цвета для каждого компонента (красный \_ 0, красный \_ 1, зеленый \_ 0 и зеленый \_ 1) и 16 3-битные индексы цвета для каждого компонента (от красного до Красного p и зеленого a до зеленого p), как показано на следующей схеме.

![Схема макета для сжатия Bc5](images/d3d10-compression-bc5.png)

Алгоритм использует 3-битовые индексы для поиска цветов в таблице цветов, которая содержит 8 элементов. Первые два цвета — красный \_ 0 и красный \_ 1 (или зеленый \_ 0 и зеленый \_ 1) — — это минимальное и максимальное цвета. Этот алгоритм вычисляет оставшиеся цвета с использованием линейной интерполяции.

Алгоритм определяет количество интерполированных значений цвета, анализируя два эталонных значения. Если красный \_ 0 больше, чем красный \_ 1, Bc5 интерполирует 6 значений цвета; в противном случае — интерполяцию 4. Если BC5 интерполирует только 4 значения цвета, он задает остальные два значения цвета равными 0.0f и 1.0f.

-   [BC5 \_ UNORM](/windows)
-   [BC5 \_ снорм](/windows)

### <a name="bc5_unorm"></a>BC5 \_ UNORM

Следующий пример кода показывает, как выполняется интерполяция однокомпонентных данных. Вычисления для зеленых компонентов похожи.


```
unsigned word red_0, red_1;

if( red_0 > red_1 )
{
  // 6 interpolated color values
  red_2 = (6*red_0 + 1*red_1)/7.0f; // bit code 010
  red_3 = (5*red_0 + 2*red_1)/7.0f; // bit code 011
  red_4 = (4*red_0 + 3*red_1)/7.0f; // bit code 100
  red_5 = (3*red_0 + 4*red_1)/7.0f; // bit code 101
  red_6 = (2*red_0 + 5*red_1)/7.0f; // bit code 110
  red_7 = (1*red_0 + 6*red_1)/7.0f; // bit code 111
}
else
{
  // 4 interpolated color values
  red_2 = (4*red_0 + 1*red_1)/5.0f; // bit code 010
  red_3 = (3*red_0 + 2*red_1)/5.0f; // bit code 011
  red_4 = (2*red_0 + 3*red_1)/5.0f; // bit code 100
  red_5 = (1*red_0 + 4*red_1)/5.0f; // bit code 101
  red_6 = 0.0f;                     // bit code 110
  red_7 = 1.0f;                     // bit code 111
}
```



Эталонным цветам назначаются 3-битовые индексы (000–111, поскольку значений 8), которые сохраняются в блоках с red a до red p во время сжатия.

### <a name="bc5_snorm"></a>BC5 \_ снорм

Формат DXGI \_ \_ Bc5 \_ снорм точно такой же, за исключением того, что данные КОДИРУЮТСЯ в диапазоне снорм и когда 4 значения данных интерполируются, два дополнительных значения:-1,0 f и 1,0 f. Следующий пример кода показывает, как выполняется интерполяция однокомпонентных данных. Вычисления для зеленых компонентов похожи.


```
signed word red_0, red_1;

if( red_0 > red_1 )
{
  // 6 interpolated color values
  red_2 = (6*red_0 + 1*red_1)/7.0f; // bit code 010
  red_3 = (5*red_0 + 2*red_1)/7.0f; // bit code 011
  red_4 = (4*red_0 + 3*red_1)/7.0f; // bit code 100
  red_5 = (3*red_0 + 4*red_1)/7.0f; // bit code 101
  red_6 = (2*red_0 + 5*red_1)/7.0f; // bit code 110
  red_7 = (1*red_0 + 6*red_1)/7.0f; // bit code 111
}
else
{
  // 4 interpolated color values
  red_2 = (4*red_0 + 1*red_1)/5.0f; // bit code 010
  red_3 = (3*red_0 + 2*red_1)/5.0f; // bit code 011
  red_4 = (2*red_0 + 3*red_1)/5.0f; // bit code 100
  red_5 = (1*red_0 + 4*red_1)/5.0f; // bit code 101
  red_6 = -1.0f;                    // bit code 110
  red_7 =  1.0f;                    // bit code 111
}
```



Эталонным цветам назначаются 3-битовые индексы (000–111, поскольку значений 8), которые сохраняются в блоках с red a до red p во время сжатия.

## <a name="format-conversion-using-direct3d-101"></a>Преобразование формата с помощью Direct3D 10,1

Direct3D 10,1 обеспечивает копирование между предварительно структурированными текстурами и текстурами с блочным сжатием одинаковой битовой ширины. Это можно сделать с помощью функций [**копиресаурце**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) и [**кописубресаурцерегион**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion).

Начиная с Direct3D 10,1, можно использовать [**копиресаурце**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) и [**кописубресаурцерегион**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) для копирования между несколькими типами форматов. Этот тип операции копирования выполняет тип преобразования формата, который интерпретирует исходные данные как другой тип формата. Рассмотрите этот пример, в котором показана разница между повторной интерпретацией данных с поведением более стандартного типа преобразования.


```
    FLOAT32 f = 1.0f;
    UINT32 u;
```



Чтобы пересчитать "f" в качестве типа "u", используйте [memcpy](/cpp/c-runtime-library/reference/memcpy-wmemcpy):


```
    memcpy( &u, &f, sizeof( f ) ); // ‘u’ becomes equal to 0x3F800000.
```



В предыдущем примере повторной интерпретации базовое значение данных не меняется; [memcpy](/cpp/c-runtime-library/reference/memcpy-wmemcpy) повторно интерпретирует число с плавающей запятой как целое число без знака.

Для выполнения более стандартного преобразования используйте следующее назначение:


```
    u = f; // ‘u’ becomes 1.
```



В предыдущем преобразовании базовое значение изменений данных.

В следующей таблице перечислены допустимые форматы исходного объекта и объекта назначения, которые можно использовать в данном типе повторной интерпретации преобразования формата. Необходимо кодировать значения надлежащим образом, чтобы повторная интерпретация работала правильно.



| Ширина бита | Несжатый ресурс                                                                                                                                               | Ресурс со сжатием блоков                                                                                                                                           |
|-----------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 32        | \_Формат DXGI \_ R32 \_ uint<br/> \_Формат DXGI \_ R32 \_ Синт<br/>                                                                                               | \_Формат DXGI \_ R9G9B9E5 \_ шаредексп                                                                                                                                   |
| 64        | \_Формат DXGI \_ R16G16B16A16 \_ uint<br/> \_Формат DXGI \_ R16G16B16A16 \_ Синт<br/> \_Формат DXGI \_ R32G32 \_ uint<br/> \_Формат DXGI \_ R32G32 \_ Синт<br/> | \_Формат DXGI \_ BC1 \_ UNORM \[ \_ sRGB\]<br/> \_Формат DXGI \_ BC4 \_ UNORM<br/> \_Формат DXGI \_ BC4 \_ снорм<br/>                                               |
| 128       | \_Формат DXGI \_ R32G32B32A32 \_ uint<br/> \_Формат DXGI \_ R32G32B32A32 \_ Синт<br/>                                                                             | \_Формат DXGI \_ BC2 \_ UNORM \[ \_ sRGB\]<br/> \_Формат DXGI \_ BC3 \_ UNORM \[ \_ sRGB\]<br/> \_Формат DXGI \_ Bc5 \_ UNORM<br/> \_Формат DXGI \_ Bc5 \_ снорм<br/> |



 

## <a name="related-topics"></a>См. также

<dl> <dt>

[Ресурсы (Direct3D 10)](d3d10-graphics-programming-guide-resources.md)
</dt> </dl>

 

 
