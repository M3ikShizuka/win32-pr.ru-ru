---
description: Копирование и доступ к данным ресурсов (Direct3D 10)
ms.assetid: 34fd4d15-ee64-4acf-967d-a4afb6f26329
title: Копирование и доступ к данным ресурсов (Direct3D 10)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bdbe3ec1dc970635a08cea455927f21d8928f48d
ms.sourcegitcommit: 9b5faa61c38b2d0c432b7f2dbee8c127b0e28a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/19/2021
ms.locfileid: "122466841"
---
# <a name="copying-and-accessing-resource-data-direct3d-10"></a>Копирование и доступ к данным ресурсов (Direct3D 10)

Больше не нужно думать о ресурсах, создаваемых в видеопамяти или системной памяти. А также вне зависимости от того, должна ли среда выполнения управлять памятью. благодаря архитектуре новой модели WDDM (модель видеодрайверов Windows) приложения теперь создают ресурсы Direct3D 10 с различными флагами [**использования**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) для указания того, как приложение планирует использовать данные ресурсов. Новая модель драйвера используется для виртуализации памяти, используемой ресурсами. Затем она отвечает за использование операционной системы, драйвера или диспетчера памяти для размещения ресурсов в наиболее производительной области памяти с учетом ожидаемого использования.

Сценарий по умолчанию подразумевает доступность ресурсов графическому процессору. Конечно, есть случаи, когда данные ресурсов должны быть доступны для ЦП. Чтобы копировать данные ресурсов из разных расположений, чтобы соответствующий процессор мог осуществлять к ним доступ, не влияя на производительность, требует определенных знаний о принципах работы методов API.

-   [Копирование данных ресурсов](#copying-and-accessing-resource-data-direct3d-10)
-   [Доступ к данным ресурсов](#copying-and-accessing-resource-data-direct3d-10)

## <a name="copying-resource-data"></a>Копирование данных ресурсов

Ресурсы создаются в памяти, когда Direct3D вызывает метод Create. Они могут создаваться в видеопамяти, системной памяти и любой другой памяти. Поскольку модель драйвера WDDM виртуализирует эту память, приложениям больше не нужно отслеживать, в какой памяти создаются ресурсы.

В идеале все ресурсы должны быть размещены в видеопамяти и быть мгновенно доступны для графического процессора. Однако иногда нужно, чтобы ЦП считал данные ресурсов или графический процессор осуществил доступ к данным ресурсов, в которые был записан ЦП. Direct3D 10 обрабатывает эти различные сценарии, запросив приложение указать использование, а затем предлагает несколько методов копирования данных ресурсов при необходимости.

В зависимости от того как был создан ресурс, не всегда возможно осуществить прямой доступ к базовым данным. Это может подразумевать необходимость копирования данных ресурса из исходного ресурса в другой, доступный соответствующему процессору. С точки зрения Direct3D 10 доступ к ресурсам по умолчанию можно получить напрямую с помощью GPU, динамическое и промежуточное ресурсы могут получить прямой доступ к ресурсам ЦП.

После создания ресурса его [**Использование**](/windows/desktop/api/D3D10/ne-d3d10-d3d10_usage) невозможно изменить. Вместо этого необходимо копировать содержимое одного ресурса в другой, созданный с другим использованием. Direct3D 10 предоставляет эту функцию с помощью трех различных методов. Первые два метода ( [**ID3D10Device:: копиресаурце**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) и [**ID3D10Device:: кописубресаурцерегион**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion)) предназначены для копирования данных ресурсов из одного ресурса в другой. Третий метод ([**ID3D10Device:: упдатесубресаурце**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-updatesubresource)) предназначен для копирования данных из памяти в ресурс.

Существует два основных типа ресурсов: сопоставляемые и несопоставляемые. Ресурсы, созданные с динамическим или промежуточным использованием, сопоставимы, в то время как ресурсы, созданные с использованием по умолчанию или неизменяемым использованием, не сопоставляются.

Копирование данных между несопоставляемыми ресурсами выполняется очень быстро, потому что это наиболее распространенный сценарий, выполнение которого максимально оптимизировано. Так как эти ресурсы недоступны непосредственно ЦП, они оптимизированы таким образом, чтобы графический процессор мог быстро выполнять с ними различные операции.

Копирование данных среди сопоставляемых ресурсов является более проблематичным, поскольку производительность будет зависеть от использования, назначенного ресурсу при создании. Например, графический процессор может считывать динамический ресурс относительно быстро, но не может выполнять в него запись. Кроме того, графический процессор не может выполнять запись напрямую в промежуточные ресурсы или чтение из них.

Приложения, которые хотят копировать данные из ресурса с использованием по умолчанию к ресурсу с использованием промежуточного хранения (чтобы ресурсы ЦП могли считывать данные, т. е. проблема реадбакк GPU), должны делать это с осторожностью. Дополнительные сведения об этом последнем случае см. в разделе [доступ к данным ресурсов](#copying-and-accessing-resource-data-direct3d-10) .

## <a name="accessing-resource-data"></a>Доступ к данным ресурсов

Доступ к ресурсу требует сопоставления ресурса; по сути, сопоставление означает, что приложение пытается предоставить ЦП доступ к памяти. Сопоставление ресурса с тем, чтобы ЦП мог осуществлять доступ к базовой памяти, может вызывать "узкие места" производительности. По этой причине эту задачу нужно выполнять с большой осторожностью и тщательно выбирать время.

Производительность может упасть до нуля, если приложение попытается сопоставить ресурс в неподходящее время. Если приложение пытается осуществить доступ к результатам операции до того, как она будет завершена, произойдет зависание конвейера.

Выполнение операции сопоставления в неподходящее время может вызвать серьезное падение производительности, поскольку графический процессор и ЦП будут вынуждены синхронизироваться друг с другом. Синхронизация произойдет, если приложение хочет осуществлять доступ к ресурсу до того, как графический процессор завершит копирование ресурса в ресурс, доступный для сопоставления ЦП.

ЦП может считывать данные только из ресурсов, созданных с помощью \_ \_ флага промежуточного использования D3D10. Так как ресурсы, созданные с помощью этого флага, не могут быть установлены в качестве выходных данных конвейера, если ЦП хочет считывать данные в ресурсе, созданном GPU, данные должны быть скопированы в ресурс, созданный с помощью флага промежуточного хранения. Приложение может сделать это с помощью методов [**ID3D10Device:: копиресаурце**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) или [**ID3D10Device:: кописубресаурцерегион**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) , чтобы скопировать содержимое одного ресурса в другой. Затем приложение может получить доступ к этому ресурсу, вызвав соответствующий метод Map. Если доступ к ресурсу больше не нужен, приложение должно вызвать соответствующий метод сопоставления. Например, [**ID3D10Texture2D:: Map**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-map) и [**ID3D10Texture2D::**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture2d-unmap)unотмена сопоставления. Различные методы Map возвращают определенные значения в зависимости от входных флагов. Дополнительные сведения см. в [**разделе "Примечания к карте"**](/windows/desktop/api/D3D10/nf-d3d10-id3d10texture1d-map) .

> [!Note]  
> Когда приложение вызывает метод Map, оно получает указатель на данные ресурса для доступа. Среда выполнения гарантирует, что указатель имеет определенное выравнивание, в зависимости от [уровня компонента](../direct3d11/overviews-direct3d-11-devices-downlevel-intro.md). Для [**D3D- \_ компонента \_ уровня \_ 10 \_ 0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level) и выше указатель выдается по 16 байтам. Для менее чем [**D3D \_ \_ уровня компонентов \_ 10 \_ 0**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_feature_level)указатель выдается по 4 байтам. 16-байтное выравнивание позволяет приложению выполнять оптимизированные для [SSE](/previous-versions/visualstudio/visual-studio-2010/t467de55(v=vs.100))операции с данными в собственном режиме без повторного выравнивания или копирования.

 

### <a name="performance-considerations"></a>Вопросы производительности

Лучше всего воспринимать ПК как устройство, функционирующее в виде параллельной архитектуры с двумя основными типами процессоров: один или несколько ЦП и один или несколько графических процессоров. Как и в любой параллельной архитектуре, оптимальная производительность достигается, если для каждого процессора запланировано достаточно задач, чтобы не дать ему простаивать, и когда работе одного процессора не приходится ждать завершения работы другого.

В самом худшем сценарии параллелизма графического процессора и ЦП один процессор вынужден ждать результаты работы другого. Direct3D 10 пытается устранить эту стоимость, делая асинхронными методы [**ID3D10Device:: копиресаурце**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) и [**ID3D10Device:: кописубресаурцерегион**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) . копирование не обязательно выполнялось в момент возвращения метода. Преимущество такого подхода в том, что производительность приложения не снижается из-за фактического копирования данных до тех пор, пока ЦП не осуществит доступ к данным, то есть во время вызова метода Map. Если метод Map вызывается после фактического копирования данных, потерь производительности не происходит. С другой стороны, если метод Map вызывается до копирования данных, произойдет зависание конвейера.

Асинхронные вызовы в Direct3D 10 (которые являются подавляющим большинством методов и особенно вызовами отрисовки) хранятся в том, что называется буфером команд. Этот буфер является внутренним по отношению к графическому драйверу и используется для объединения в пакеты вызовов, адресованных базовому оборудованию, чтобы затратное переключение из режима пользователя в режим ядра в Microsoft Windows осуществлялось как можно реже.

Буфер команд очищается, вызывая переключение между режимом пользователя и режимом ядра, в одной из следующих четырех ситуаций.

1.  Вызывается метод [**Present**](/windows/win32/api/dxgi/nf-dxgi-idxgiswapchain-present) .
2.  Вызывается [**ID3D10Device:: Flush**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-flush) .
3.  Буфер команд заполнен; его размер является динамичным и контролируется операционной системой и графическим драйвером.
4.  ЦП требует доступа к результатам команды, дожидаясь выполнения в буфере команд.

Из четырех ситуаций последняя является наиболее неблагоприятной для производительности. Если приложение выдает вызов [**ID3D10Device:: копиресаурце**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) или [**ID3D10Device:: кописубресаурцерегион**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) , этот вызов помещается в буфер команд. Если приложение пытается сопоставлять промежуточный ресурс, который был целевым объектом вызова копирования до того, как буфер команд будет сброшен, произойдет ожидание конвейера, поскольку не только вызов метода Copy должен выполняться, но все остальные буферизованные команды в буфере команд также должны выполняться. Это вызовет синхронизацию графического процессора и ЦП, поскольку ЦП будет ждать доступа к промежуточному ресурсу, пока графический процессор очищает буфер команд и, наконец, заполняет необходимый ЦП ресурс. После того как графический процессор завершит копирование, ЦП начнет осуществлять доступ к промежуточному ресурсу, однако в это время графический процессор будет находиться в состоянии простоя.

Если делать так часто во время выполнения, производительность существенно снизится. По этой причине сопоставление ресурсов, созданных с использованием по умолчанию, должно выполняться осторожно. Приложению придется достаточно долго ожидать очищения буфера команд и завершения выполнения всех этих команд, прежде чем приложение попытается сопоставить соответствующий промежуточный ресурс. Сколько должно ждать приложение? По меньшей мере два кадра, поскольку это позволит максимально эффективно использовать параллелизм между ЦП и графическим процессором. Как работает графический процессор: в то время как приложение обрабатывает кадр N, отправляя вызовы в буфер команд, графический процессор выполняет вызовы из предыдущего кадра, N-1.

Таким образом, если приложению требуется связать ресурс, который является видеопамятью, и вызвать [**ID3D10Device:: копиресаурце**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copyresource) или [**ID3D10Device:: кописубресаурцерегион**](/windows/desktop/api/D3D10/nf-d3d10-id3d10device-copysubresourceregion) в кадре n, этот вызов начнет выполняться в кадре n + 1, когда приложение отправляет вызовы для следующего кадра. Копирование необходимо завершить, когда приложение обрабатывает кадр N+2.




| Frame | Состояние графического процессора/ЦП | 
|-------|----------------|
| Нет | <ul><li>ЦП создает вызовы отрисовки для текущего кадра.</li></ul> | 
| N+1 | <ul><li>Графический процессор выполняет вызовы, отправленные из ЦП во время кадра N.</li><li>ЦП создает вызовы отрисовки для текущего кадра.</li></ul> | 
| N+2 | <ul><li>Графический процессор завершает выполнение вызовов, отправленных из ЦП во время кадра N. Результаты готовы.</li><li>Графический процессор выполняет вызовы, отправленные из ЦП во время кадра N+1.</li><li>ЦП создает вызовы отрисовки для текущего кадра.</li></ul> | 
| N+3 | <ul><li>Графический процессор завершает выполнение вызовов, отправленных из ЦП во время кадра N+1. Результаты готовы.</li><li>Графический процессор выполняет вызовы, отправленные из ЦП во время кадра N+2.</li><li>ЦП создает вызовы отрисовки для текущего кадра.</li></ul> | 
| N+4 | ... | 




 

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Ресурсы (Direct3D 10)](d3d10-graphics-programming-guide-resources.md)
</dt> </dl>

 

 
