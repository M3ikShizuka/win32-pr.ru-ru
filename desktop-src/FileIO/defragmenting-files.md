---
description: Дефрагментация — это процесс перемещения частей файлов на диске для дефрагментации файлов, то есть процесса перемещения кластеров файлов на диске, чтобы сделать их непрерывными.
ms.assetid: 27ccaab7-ec89-489b-80dc-df9beb7969bc
title: Дефрагментация файлов
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2f04c0a3c961854b7e3ecab50d67db608178393113ca259b916db9623058e2f3
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119696294"
---
# <a name="defragmenting-files"></a>Дефрагментация файлов

Когда файл записывается на диск, иногда файл не может быть записан в непрерывные кластеры. Несмежные кластеры замедляют процесс чтения и записи файла. Чем дальше на диске несмежные кластеры, тем хуже причина проблемы, так как требуется переместить заголовок для чтения и записи жесткого диска. Файл с несмежными кластерами *фрагментирован*. Чтобы оптимизировать файлы для быстрого доступа, можно выполнить дефрагментацию тома.

*Дефрагментация* — это процесс перемещения частей файлов на диске для дефрагментации файлов, то есть процесса перемещения кластеров файлов на диске, чтобы сделать их непрерывными. Дополнительные сведения см. в следующих разделах.

-   [Дефрагментация файла](#defragmenting-a-file)
-   [Минимизация взаимодействия между дефрагментацией и теневыми копиями](#minimizing-interactions-between-defragmentation-and-shadow-copies)
-   [Файлы, потоки и типы потоков, поддерживаемые для дефрагментации](#files-streams-and-stream-types-supported-for-defragmentation)

## <a name="defragmenting-a-file"></a>Дефрагментация файла

В простой операционной системе с одной задачей программа дефрагментации является единственной задачей, и нет других процессов для чтения или записи на диск. Однако в многозадачной операционной системе некоторые процессы могут выполнять чтение и запись на жесткий диск, в то время как другой процесс выполняет дефрагментацию этого жесткого диска. Хитрость заключается в том, чтобы избежать записи в файл, дефрагментированный без остановки процесса записи. Решение этой проблемы нетривиально, но возможно.

Чтобы разрешить дефрагментацию без необходимости подробного знания структуры диска файловой системы, предоставляется набор из трех управляющих кодов. Управляющие коды предоставляют следующие функциональные возможности:

-   Разрешить приложениям размещать пустые кластеры
-   Определение расположения места на диске для кластеров файлов
-   Перемещение кластеров на диск

Управляющие коды также прозрачно обрабатывают проблему запрещения и позволяют другим процессам выполнять чтение и запись в файлы во время перемещения.

Эти операции могут выполняться без запрета на выполнение других процессов. Однако во время дефрагментации диска другие процессы имеют меньшее время отклика.

**Дефрагментация файла**

1.  Используйте управляющий код [**\_ получения \_ тома \_ фсктл Get**](/windows/win32/api/winioctl/ni-winioctl-fsctl_get_volume_bitmap) , чтобы найти место на томе, достаточно большое для приема всего файла.
    > [!Note]  
    > При необходимости переместите другие файлы, чтобы сделать место достаточно большим. В идеале имеется достаточное количество нераспределенных кластеров после первого экстента файла, после которого можно перемещать последующие экстенты в пространство после первого экстента.

     

2.  Используйте управляющий код [**фсктл \_ Get \_ \_ указателей**](/windows/win32/api/winioctl/ni-winioctl-fsctl_get_retrieval_pointers) , чтобы получить карту текущего макета файла на диске.
3.  Обучите структуру [**\_ \_ буфера указателей извлечения**](/windows/desktop/api/WinIoCtl/ns-winioctl-retrieval_pointers_buffer) , возвращаемую [**фсктл \_ получения \_ \_ указателей**](/windows/win32/api/winioctl/ni-winioctl-fsctl_get_retrieval_pointers).
4.  Используйте код [**управления \_ перемещением \_ файлов фсктл**](/windows/win32/api/winioctl/ni-winioctl-fsctl_move_file) для перемещения каждого кластера по мере проанализировать структуру.
    > [!Note]  
    > Может потребоваться обновить либо точечный рисунок, либо структуру извлечения, либо и то, и другое, как только другие процессы будут записывать на диск.

     

Две операции, используемые в процессе дефрагментации, нуждаются в обработке тома. Только администраторы могут получить маркер для тома, поэтому только администраторы могут дефрагментировать том. Приложение должно проверять права пользователя, пытающегося запустить программное обеспечение дефрагментации, и не должен разрешать пользователю выполнять дефрагментацию тома, если у пользователя нет соответствующих прав.

При использовании [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) для открытия каталога во время дефрагментации тома файловой системы FAT или FAT32 укажите универсальное значение маски доступа для **\_ чтения** . Не указывайте **максимально \_ допустимое** значение маски доступа. Если это сделано, доступ к каталогу будет запрещен.

Не пытайтесь переместить выделенные кластеры в файловой системе NTFS, выходящие за пределы размера округленного файла кластера, так как результатом будет ошибка.

Повторное синтаксический анализ точек, точечных рисунков и списков атрибутов в томах с файловой системой NTFS можно дефрагментировать, открыть для чтения и синхронизации и назвать с помощью синтаксиса *File*:*Name*:*Type* . Например, *dirname*: $i 30: $index \_ распределения, *MRP*:: $DATA, *MRP*:: $REPARSE \_ Point и *MRP*:: $Attribute \_ .

При дефрагментации томов файловой системы NTFS разрешается Дефрагментация виртуального кластера за пределами размера выделения файла.

## <a name="minimizing-interactions-between-defragmentation-and-shadow-copies"></a>Минимизация взаимодействия между дефрагментацией и теневыми копиями

По возможности переносите данные в блоки, согласованные по отношению друг к другу, с шагом в 16 килобайт (КБ). Это сокращает затраты на копирование при записи, когда теневые копии включены, так как пространство теневых копий увеличивается и снижается производительность при выполнении следующих условий.

-   Размер блока запроса перемещения меньше или равен 16 КБ.
-   Дельта перемещения не имеет приращения размером 16 КБ.

Дельта перемещения — это число байтов между началом исходного блока и началом целевого блока. Иными словами, блок, начинающийся с смещения X (на диске), можно переместить на начальное смещение Y, если абсолютное значение X минус Y четное, кратное 16 КБ. Таким образом, при условии, что кластеры размером 4 КБ оптимизированы, перемещение из кластера 3 в кластер 27 оптимизируется, но переход с кластера 18 на кластер 24 не будет выполняться. Обратите внимание, что mod (3, 4) = 3 = Mod (27, 4). Выбран mod 4, поскольку четыре кластера в 4 КБ каждый из них эквивалентны 16 КБ. Таким образом, том, отформатированный для размера кластера размером 16 КБ, приведет к оптимизации всех файлов перемещения.

Дополнительные сведения о теневых копиях см. в разделе [Служба теневого копирования томов](/windows/desktop/VSS/about-the-volume-shadow-copy-service).

## <a name="files-streams-and-stream-types-supported-for-defragmentation"></a>Файлы, потоки и типы потоков, поддерживаемые для дефрагментации

Хотя большинство файлов можно перемещать с помощью кода [**управления \_ перемещением \_ файла фсктл**](/windows/win32/api/winioctl/ni-winioctl-fsctl_move_file) , не все можно перемещать. Ниже приведен список файлов, потоков и типов потоков (также называемых кодами типов атрибутов), поддерживаемых **фсктл \_ Move \_ File**. Другие файлы, потоки и типы потоков не поддерживаются **\_ \_ файлом перемещения фсктл**.

Типы потоков, поддерживаемые для любого файла или каталога.

-   :: $DATA
-   :: $ATTRIBUTE \_ список
-   :: $REPARSE \_ точка
-   :: $EA
-   :: $LOGGEDный \_ поток служебной программы \_

* * Windows 7, Windows server 2008 R2, Windows server 2008, Windows Vista, Windows server 2003 и Windows XP: * *:: $EA и:: $LOGGED \_ \_ поток программы не поддерживается до Windows 8 и Windows Server 2012

Типы потоков, поддерживаемые для любого каталога.

-   :: $BITMAP
-   :: $INDEXное \_ выделение

Ниже приведены типы системных файлов, потоков и потоков, поддерживаемые [**фсктл \_ Move \_ File**](/windows/win32/api/winioctl/ni-winioctl-fsctl_move_file) в формате *filename*:*streamname*: $*TypeName*.

-   $MFT:: $DATA
-   $MFT:: $ATTRIBUTE \_ списка
-   $MFT:: $BITMAP
-   $AttrDef:: $DATA
-   $AttrDef:: $ATTRIBUTE \_ списка
-   $Secure: $SDS: $DATA
-   $Secure:: $ATTRIBUTE \_ списка
-   $Secure: $SDH: \_ выделение $index
-   $Secure: $SDH: $BITMAP
-   $Secure: $SII: \_ выделение $index
-   $Secure: $SII: $BITMAP
-   $UpCase:: $DATA
-   $UpCase:: $ATTRIBUTE \_ списка
-   $Extend: $I 30: \_ выделение $index
-   $Extend:: $ATTRIBUTE \_ списка
-   $Extend: $I 30: $BITMAP
-   $Extend \\ $UsnJrnl: $J: $Data
-   $Extend \\ $UsnJrnl:: $Attribute \_ список
-   $Extend \\ $UsnJrnl: $Max: $Data
-   $Extend \\ $Quota: $Q: $index \_ выделение памяти
-   $Extend \\ $Quota:: $Attribute \_ список
-   $Extend \\ $Quota: $Q: $Bitmap
-   $Extend \\ $Quota: $O: $index \_ выделение памяти
-   $Extend \\ $Quota: $O: $Bitmap
-   $Extend \\ $objID: $O: $index \_ выделение памяти
-   $Extend \\ $objID:: $Attribute \_ список
-   $Extend \\ $objID: $O: $Bitmap
-   $Extend \\ $reparse: $R: $index \_ выделение памяти
-   $Extend \\ $reparse:: $Attribute \_ список
-   $Extend \\ $reparse: $R: $Bitmap
-   $Extend \\ $RmMetadata: $I 30: $index \_ выделение памяти
-   $Extend \\ $RmMetadata: $I 30: $Bitmap
-   $Extend \\ $RmMetadata:: $Attribute \_ список
-   $Extend \\ $RmMetadata \\ $Repair:: $Data
-   $Extend \\ $RmMetadata \\ $Repair:: $Attribute \_
-   $Extend \\ $RmMetadata \\ $Repair: $Config: $Data
-   $Extend \\ $RmMetadata \\ $Txf: $I 30: $index \_ выделение
-   $Extend \\ $RmMetadata \\ $TxF:: $Attribute \_
-   $Extend \\ $RmMetadata \\ $Txf: $I 30: $Bitmap
-   $Extend \\ $RmMetadata \\ $TxF: \_ данные $TxF: $LOGGEDный \_ \_ поток программы
-   $Extend \\ $RmMetadata \\ $TxfLog: $I 30: $index \_ выделение
-   $Extend \\ $RmMetadata \\ $TxfLog:: $Attribute \_
-   $Extend \\ $RmMetadata \\ $TxfLog: $I 30: $Bitmap
-   $Extend \\ $RmMetadata \\ $TxfLog \\ $Tops:: $Data
-   $Extend \\ $RmMetadata \\ $TxfLog \\ $Tops:: $Attribute \_ списка
-   $Extend \\ $RmMetadata \\ $TxfLog \\ $Tops: $T: $Data
-   $Extend \\ $RmMetadata \\ $TxfLog \\ $TxfLog. блф:: $Data
-   $Extend \\ $RmMetadata \\ $TxfLog \\ $TxfLog. блф:: $Attribute \_

 

 
