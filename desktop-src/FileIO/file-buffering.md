---
description: Описывает вопросы управления приложениями для буферизации файлов, которые также называются небуферизованными файлами ввода-вывода.
ms.assetid: ae1e5d0f-9b55-4aae-8402-b9c8e33d9363
title: Буферизации файла
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a44f6724622b2c3116fa24a6109efb6c0d9f1d9f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "104272278"
---
# <a name="file-buffering"></a>Буферизации файла

В этом разделе рассматриваются различные вопросы управления приложениями для буферизации файлов, которые также называются небуферизованными файлами ввода-вывода. Буферизация файлов обычно обрабатывается системой в фоновом режиме и считается частью [кэширования файлов](file-caching.md) в операционной системе Windows, если не указано иное. Несмотря на то, что термины *кэширование* и *буферизация* иногда взаимозаменяемы, в этом разделе используется функция *буферизации* , в которой объясняется, как взаимодействовать с данными, которые не кэшируются в кэше (буферизованные) системой, где в основном нет непосредственного управления приложениями пользовательского режима.

При открытии или создании файла с помощью функции [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea) флаг **файла \_ \_ не \_** может быть указан для отключения системного кэширования данных, считываемых из файла или записываемых в него. Хотя это дает полный и прямой контроль над буферизацией ввода-вывода данных, в случае файлов и аналогичных устройств существуют требования к выравниванию данных, которые необходимо учитывать.

> [!Note]  
> Эти сведения о выравнивании применяются к операциям ввода-вывода на устройствах, например файлов, поддерживающих поиск, и концепции указателей позиции файла (или *смещений*). Для устройств, которые не выполняют поиск, например именованные каналы или устройства связи, отключение буферизации может не требовать определенного выравнивания. Все ограничения и эффективность, которые могут быть предоставлены по выравниванию в этом случае, зависят от базовой технологии.

 

В простом примере приложение откроет файл для доступа на запись с флагом **файла без флага \_ \_ \_ буферизации** , а затем выполнит вызов функции [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile) , используя буфер данных, определенный в приложении. Этот локальный буфер в этом случае фактически является единственным буфером файла, который существует для данной операции. Из-за структуры физических дисков, структуры хранилища файловой системы и отслеживания положения указателя файлов на уровне системы эта операция записи завершится ошибкой, если только локально определенные буферы данных не удовлетворяют определенным критериям выравнивания, описанным в следующем разделе.

> [!Note]  
> Обсуждение кэширования не учитывает аппаратное кэширование на самом физическом диске, которое не обязательно должно находиться в непосредственном управлении системой в любом случае. Это не влияет на требования, указанные в этом разделе.

 

Дополнительные сведения о том, **как \_ флаг файла \_ без \_ буферизации** взаимодействует с другими флагами, связанными с кэшем, см. в разделе [**CreateFile**](/windows/desktop/api/FileAPI/nf-fileapi-createfilea).

## <a name="alignment-and-file-access-requirements"></a>Требования к выравниванию и доступу к файлам

Как уже говорилось, приложение должно удовлетворять определенным требованиям при работе с файлами, открытыми с **\_ флагом файла \_ без \_ буферизации**. Применяются следующие особенности.

-   Размеры доступа к файлам, включая необязательное смещение файла в структуре [**OVERLAPPED**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) , если оно указано, должно быть целым числом, кратным размеру сектора тома. Например, если размер сектора составляет 512 байт, приложение может запрашивать операции чтения и записи для 512, 1 024, 1 536 или 2 048 байт, но не из 335, 981 или 7 171 байт.
-   Буферы доступа к файлам для операций чтения и записи должны быть согласованы с физическим сектором, что означает согласование по адресам в памяти, которые являются целыми числами, кратными размеру физического сектора тома. В зависимости от диска это требование может быть не применено.

Разработчикам приложений следует заметку о новых типах устройств хранения, представленных на рынке, с физическим размером сектора в 4 096 байт. Название отрасли для этих устройств — "Расширенный формат". Так как могут возникнуть проблемы совместимости с прямым введением 4 096 байт в качестве единицы адресации для носителя, временное решение совместимости предназначено для введения устройств, которые имитируют регулярное хранилище 512-байтового хранилища, но предоставляют доступ к информации о истинном размере сектора с помощью стандартных команд ATA и SCSI.

В результате эмуляции существует два размера секторов, которые разработчики должны понимать:

-   Логический сектор: единица, используемая для адресации логических блоков носителя. Мы также можем рассматривать его как наименьшую единицу записи, которую может принимать хранилище. Это «эмуляция».
-   Физический сектор. единица, для которой операции чтения и записи на устройстве выполняются за одну операцию. Это единица атомарной операции записи, которую необходимо вычислить для небуферизованного ввода-вывода, чтобы обеспечить оптимальные характеристики производительности и надежности.

Большинство текущих интерфейсов API Windows, таких как [**ioctl \_ диска \_ Get \_ Drive \_ Geometry**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_disk_get_drive_geometry) и [**жетдискфриспаце**](/windows/desktop/api/FileAPI/nf-fileapi-getdiskfreespacea), возвращают размер логического сектора, но размер физического сектора можно получить с помощью управляющего кода [**\_ \_ запроса \_ на хранение**](/windows/desktop/api/WinIoCtl/ni-winioctl-ioctl_storage_query_property) , с соответствующей информацией, содержащейся в элементе **битесперфисикалсектор** в структуре [**\_ \_ \_ дескриптора выравнивания доступа к хранилищу**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) . Пример см. в примере кода в [**\_ \_ \_ дескрипторе выравнивания доступа к хранилищу**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor). Корпорация Майкрософт настоятельно рекомендует разработчикам выдавать небуферизованные операции ввода-вывода в физический размер сектора, как показано в коде элемента управления **\_ \_ \_ Свойства запроса на хранение ioctl** , чтобы обеспечить подготовку приложений к переходу на этот размер сектора.

**Windows Server 2003 и Windows XP:** Структура [**\_ \_ \_ дескриптора выравнивания доступа к хранилищу**](/windows/desktop/api/WinIoCtl/ns-winioctl-storage_access_alignment_descriptor) недоступна. Он появился в Windows Vista и Windows Server 2008.

Так как буферные адреса для операций чтения и записи должны быть согласованы по секторам, приложение должно иметь прямой контроль над способом выделения этих буферов. Одним из способов распределения буферов по секторам является использование функции [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) для выделения буферов. Рассмотрим следующий пример.

-   [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) выделяет память, согласованную по адресам, которые являются целыми числами, кратными размеру страницы системы. Размер страницы составляет 4 096 байт на x64 и x86 или 8 192 байт для систем на базе процессоров Itanium. Дополнительные сведения см. в описании функции [**жетсистеминфо**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-getsysteminfo) .
-   Размер сектора обычно 512 – 4 096 байт для устройств хранения с прямым доступом (жестких дисков) и 2 048 байт для компакт-дисков.
-   Размеры страниц и секторов — это степени 2.

Таким образом, в большинстве случаев память с согласованием по страницам также будет соответствовать секторам, так как размер сектора больше, чем размер страницы, редко.

Другой способ получить буферы памяти, выданный вручную, — использовать функцию с [ \_ согласованной функцией \_ malloc](/cpp/c-runtime-library/reference/aligned-malloc?view=vs-2019) из библиотеки C Run-Time. Пример того, как можно вручную управлять выравниванием буфера, см. в примере кода языка C++ в разделе пример кода в [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile).

 

 
