---
description: Порты завершения ввода-вывода предоставляют эффективную потоковую модель для обработки нескольких асинхронных запросов ввода-вывода в многопроцессорной системе.
ms.assetid: 213c48e8-bb21-43ed-9c00-2a5cf8ac25f0
title: Порты завершения ввода-вывода
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2133bb14c661580eaf8004bd92c6f947b3b8777a4b1a5f6b330fe631b2be6c81
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "120050834"
---
# <a name="io-completion-ports"></a>Порты завершения ввода-вывода

Порты завершения ввода-вывода предоставляют эффективную потоковую модель для обработки нескольких асинхронных запросов ввода-вывода в многопроцессорной системе. Когда процесс создает порт завершения ввода-вывода, система создает связанный объект очереди для запросов, предназначенных исключительно для обслуживания этих запросов. Процессы, обрабатывающие множество параллельных асинхронных запросов ввода-вывода, могут сделать это быстрее и эффективнее с помощью портов завершения ввода-вывода в сочетании с предварительно выделенным пулом потоков, чем при создании потоков на момент получения запроса ввода-вывода.

## <a name="how-io-completion-ports-work"></a>Как работают порты завершения ввода-вывода

Функция [**CreateIoCompletionPort**](createiocompletionport.md) создает порт завершения ввода-вывода и связывает один или несколько дескрипторов файлов с этим портом. При завершении асинхронной операции ввода-вывода с одним из этих дескрипторов файлов пакет завершения ввода-вывода помещается в очередь в порядке "первым вошел — первым обслужен" (FIFO) к соответствующему порту завершения ввода-вывода. Одним из мощных способов использования этого механизма является объединение точки синхронизации для нескольких дескрипторов файлов в один объект, хотя существуют и другие полезные приложения. Обратите внимание, что хотя пакеты помещаются в очередь в порядке FIFO, они могут быть выведены из очереди в другом порядке.

> [!Note]
>
> Термин используемый здесь *описатель файла* означает абстракцию системы, представляющую перекрывающиеся конечные точки ввода-вывода, а не только файл на диске. Например, это может быть конечная точка сети, TCP-сокет, именованный канал или почтовый слот. Можно использовать любой системный объект, поддерживающий перекрывающиеся операции ввода-вывода. Список связанных функций ввода-вывода см. в конце этого раздела.

 

Если маркер файла связан с портом завершения, переданный блок состояния не будет обновляться до тех пор, пока пакет не будет удален из порта завершения. Единственное исключение — если исходная операция возвращает синхронное значение с ошибкой. Поток (созданный основным потоком или собственно основным потоком) использует функцию [**жеткуеуедкомплетионстатус**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) , чтобы ждать, пока пакет завершения помещается в очередь на порт завершения ввода-вывода, а не непосредственно в ожидании завершения асинхронного ввода-вывода. Потоки, которые блокируют выполнение на порте завершения ввода-вывода, освобождаются в порядке ЛИФО, а следующий пакет завершения извлекается из очереди FIFO порта завершения ввода-вывода для этого потока. Это означает, что при отпускании пакета завершения в поток система освобождает последний (самый последний) поток, связанный с этим портом, и передает ему сведения о завершении для самого старого завершения ввода-вывода.

Хотя любое количество потоков может вызывать [**жеткуеуедкомплетионстатус**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) для указанного порта завершения ввода-вывода, когда указанный поток вызывает **жеткуеуедкомплетионстатус** в первый раз, он связывается с указанным портом завершения ввода-вывода до тех пор, пока не произойдет одно из трех действий: поток завершает работу, задает другой порт завершения ввода-вывода или закрывает порт завершения ввода-вывода. Иными словами, один поток может быть связан с, по крайней мере, одним портом завершения ввода-вывода.

Когда пакет завершения помещается в очередь на порт завершения ввода-вывода, система сначала проверяет, сколько потоков, связанных с этим портом, выполняется. Если число выполняемых потоков меньше значения параллелизма (рассматривается в следующем разделе), одному из ожидающих потоков (самая последняя) разрешено обрабатывать пакет завершения. Когда выполняющийся поток завершает свою обработку, он обычно вызывает [**жеткуеуедкомплетионстатус**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) снова, после чего он либо возвращается со следующим пакетом завершения, либо ожидает, если очередь пуста.

Потоки могут использовать функцию [**PostQueuedCompletionStatus**](postqueuedcompletionstatus.md) для размещения пакетов завершения в очереди порта завершения ввода-вывода. Таким образом, порт завершения можно использовать для получения сообщений от других потоков процесса в дополнение к получению пакетов завершения ввода-вывода из системы ввода-вывода. Функция **PostQueuedCompletionStatus** позволяет приложению ставить в очередь собственные пакеты завершения специального назначения для порта завершения ввода-вывода, не запуская асинхронную операцию ввода-вывода. Это полезно, например, для уведомления о рабочих потоках внешних событий.

Обработчик порта завершения ввода-вывода и все файлы, связанные с этим конкретным портом завершения ввода-вывода, называются *ссылками на порт завершения ввода*-вывода. Порт завершения ввода-вывода освобождается при отсутствии ссылок на него. Поэтому все эти дескрипторы должны быть должным образом закрыты, чтобы освободить порт завершения ввода-вывода и связанные с ним системные ресурсы. После выполнения этих условий приложение должно закрыть обработчик порта завершения ввода-вывода, вызвав функцию [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) .

> [!Note]
>
> Порт завершения ввода-вывода связан с процессом, который его создал, и не может совместно находиться между процессами. Однако один и тот же обработчик может совместно работать между потоками в одном процессе.

 

## <a name="threads-and-concurrency"></a>Потоки и параллелизм

Наиболее важным свойством порта завершения ввода-вывода, который следует тщательно рассмотреть, является значение параллелизма. Значение параллелизма порта завершения указывается при его создании с помощью [**CreateIoCompletionPort**](createiocompletionport.md) через параметр *нумберофконкуррентсреадс* . Это значение ограничивает количество готовых к запуску потоков, связанных с портом завершения. Когда общее число готовых к работе потоков, связанных с портом завершения, достигает значения параллелизма, система блокирует выполнение всех последующих потоков, связанных с этим портом завершения, пока количество выполняемых потоков не станет меньше значения параллелизма.

Наиболее эффективный сценарий возникает, когда в очереди находятся ожидающие пакеты, но ожидания не могут быть удовлетворены, так как порт достиг ограничения параллелизма. Рассмотрим, что происходит со значением параллелизма одного и нескольких потоков, ожидающих в вызове функции [**жеткуеуедкомплетионстатус**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) . В этом случае, если очередь всегда содержит ожидающие выполнения пакеты, когда выполняющийся поток вызывает **жеткуеуедкомплетионстатус**, он не будет блокировать выполнение, поскольку, как упоминалось ранее, очередь потока — ЛИФО. Вместо этого этот поток немедленно будет принимать следующий пакет завершения в очереди. Переключение контекста потока не произойдет, так как запущенный поток постоянно выбирает пакеты завершения, и другие потоки не могут быть запущены.

> [!Note]
>
> В предыдущем примере дополнительные потоки могут быть бесполезными и никогда не запускаться, но это предполагает, что запущенный поток никогда не помещается в состояние ожидания каким-либо другим механизмом, завершается или закрывает связанный с ним порт завершения ввода-вывода. Учитывайте все подобные последствия выполнения потоков при проектировании приложения.

 

Наибольшее общее максимальное значение, которое нужно выбрать для параметра параллелизма, — число процессоров на компьютере. Если для транзакции требуется длительное вычисление, большее значение параллелизма позволит выполнять больше потоков. Каждый пакет завершения может занять больше времени, но пакеты завершения будут обрабатываться одновременно. Можно поэкспериментировать со значением параллелизма в сочетании со средствами профилирования, чтобы добиться оптимального результата для приложения.

Система также позволяет потоку, ожидающему в [**жеткуеуедкомплетионстатус**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) , обрабатывать пакет завершения, если другой выполняющийся поток, связанный с тем же портом завершения ввода-вывода, переходит в состояние ожидания по другим причинам, например к функции [**суспендсреад**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-suspendthread) . Когда поток в состоянии ожидания начинает выполняться снова, может быть короткий период, когда число активных потоков превысит значение параллелизма. Однако система быстро сокращает это число, не разрешая никаких новых активных потоков, пока число активных потоков не станет меньше значения параллелизма. Это одна из причин того, что приложение создаст больше потоков в пуле потоков, чем значение параллелизма. Управление пулом потоков выходит за рамки этого раздела, но хорошим правилом для Thumb является минимум два потока в пуле потоков, так как в системе есть процессоры. Дополнительные сведения о пуле потоков см. в разделе [Пулы потоков](/windows/desktop/ProcThread/thread-pools).

## <a name="supported-io-functions"></a>Поддерживаемые функции ввода-вывода

Следующие функции можно использовать для запуска операций ввода-вывода, которые завершаются с помощью портов завершения ввода-вывода. Необходимо передать функцию экземпляр [**ПЕРЕкрывающейся**](/windows/desktop/api/minwinbase/ns-minwinbase-overlapped) структуры и файловый обработчик, который ранее был связан с портом завершения ввода-вывода (путем вызова [**CreateIoCompletionPort**](createiocompletionport.md)), чтобы включить механизм порта завершения ввода-вывода:

-   [**коннектнамедпипе**](/windows/desktop/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe)
-   [**DeviceIoControl**](/windows/desktop/api/ioapiset/nf-ioapiset-deviceiocontrol)
-   [**локкфиликс**](/windows/desktop/api/FileAPI/nf-fileapi-lockfileex)
-   [**реаддиректоричанжесв**](/windows/desktop/api/WinBase/nf-winbase-readdirectorychangesw)
-   [**ReadFile**](/windows/desktop/api/FileAPI/nf-fileapi-readfile)
-   [**трансактнамедпипе**](/windows/desktop/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe)
-   [**ваиткоммевент**](/windows/desktop/api/winbase/nf-winbase-waitcommevent)
-   [**WriteFile**](/windows/desktop/api/FileAPI/nf-fileapi-writefile)
-   [**всасендмсг**](/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg)
-   [**всасендто**](/windows/desktop/api/winsock2/nf-winsock2-wsasendto)
-   [**всасенд**](/windows/desktop/api/winsock2/nf-winsock2-wsasend)
-   [**всареквфром**](/windows/desktop/api/winsock2/nf-winsock2-wsarecvfrom)
-   [**LPFN_WSARECVMSG (Всареквмсг)**](/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg)
-   [**всарекв**](/windows/desktop/api/winsock2/nf-winsock2-wsarecv)

## <a name="related-topics"></a>Связанные темы

<dl> <dt>


</dt> <dt>

[Процессы и потоки](/windows/desktop/ProcThread/about-processes-and-threads)
</dt> <dt>

[**BindIoCompletionCallback**](/windows/desktop/api/winbase/nf-winbase-bindiocompletioncallback)
</dt> <dt>

[**CreateIoCompletionPort**](createiocompletionport.md)
</dt> <dt>

[**жеткуеуедкомплетионстатус**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus)
</dt> <dt>

[**жеткуеуедкомплетионстатусекс**](getqueuedcompletionstatusex-func.md)
</dt> <dt>

[**PostQueuedCompletionStatus**](postqueuedcompletionstatus.md)
</dt> </dl>

 

 
