---
title: Формат BC6H
description: Формат BC6H — это формат сжатия текстуры, предназначенный для обеспечения поддержки цветовых пространств HDR в исходных данных.
ms.assetid: D6A1A729-5023-4A94-A8DB-5954D453E136
keywords:
- BC6H
- DXGI_FORMAT_BC6H
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 92ea15e0275bc478c0708ce08f531d8888a3c84d
ms.sourcegitcommit: ca37395fd832e798375e81142b97cffcffabf184
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/24/2021
ms.locfileid: "110335228"
---
# <a name="bc6h-format"></a>Формат BC6H

Формат BC6H — это формат сжатия текстуры, предназначенный для обеспечения поддержки цветовых пространств HDR в исходных данных.

-   [Сведения о формате BC6H/DXGI \_ \_ BC6H](/windows)
-   [Реализация BC6H](#bc6h-implementation)
-   [Декодирование формата BC6H](#decoding-the-bc6h-format)
-   [Формат сжатых конечных точек BC6H](#bc6h-compressed-endpoint-format)
-   [Расширение знака для значений конечных точек](#sign-extension-for-endpoint-values)
-   [Преобразование инверсии для значений конечной точки](#transform-inversion-for-endpoint-values)
-   [Ункуантизатион конечных точек цвета](#unquantization-of-color-endpoints)
-   [См. также](#related-topics)

## <a name="about-bc6hdxgi_format_bc6h"></a>Сведения о формате BC6H/DXGI \_ \_ BC6H

Формат BC6H обеспечивает высококачественное сжатие изображений, использующих три канала цветов HDR с 16-разрядным значением для каждого канала цвета в составе значения (16:16:16). Альфа-канал не поддерживается.

BC6H задается следующими \_ значениями перечисления в формате DXGI:

-   **DXGI \_ FORMAT \_ BC6H \_ Type**.
-   **DXGI \_ FORMAT \_ BC6H \_ UF16**. В этом формате BC6H не используется знаковый бит в 16-разрядных значениях канала цвета с плавающей запятой.
-   **DXGI \_ FORMAT \_ BC6H \_ SF16**. В этом формате BC6H используется бит знака в 16-битных значениях канала цвета с плавающей точкой.

> [!Note]  
> 16-разрядный формат с плавающей точкой для цветовых каналов часто называют "половинным" форматом с плавающей точкой. Формат имеет следующее расположение битов:
>
> |  Формат                     | Разрядный макет                                                |
> |-----------------------|-------------------------------------------------|
> | UF16 (без знака с плавающей запятой) | 5 разрядов экспоненты + 11 разрядов мантиссы              |
> | SF16 (со знаком с плавающей запятой)   | 1 разряд знака + 5 разрядов экспоненты + 10 разрядов мантиссы |
>
> 
>
>  

 

Формат BC6H можно использовать для ресурсов текстуры [Texture2D](/windows/desktop/direct3d10/d3d10-graphics-reference-resource-structures) (включая массивы), Texture3D или TextureCube (включая массивы). Аналогичным образом этот формат применяется к любым поверхностям MIP-карты, связанным с этими ресурсами.

В BC6H используется фиксируемый размер блоков — 16 байтов (128 битов) и фиксированный размер плитки — 4x4 текселя. Как и в случае с предыдущими форматами BC, изображения текстур крупнее, чем поддерживаемый размер плитки (4x4), сжимаются с использованием нескольких блоков. Это удостоверение адресации также применяется к трехмерным изображениям, MIP-картам, кубемапс и массивам текстур. Все плитки изображений должны иметь один формат.

Некоторые важные замечания о формате BC6H:

-   BC6H поддерживает денормализацию чисел с плавающей запятой, но не поддерживает сущности типа INF (бесконечность) и NaN (не число). Исключение — это режим со знаком для BC6H ( \_ Формат DXGI \_ BC6H \_ SF16), поддерживающий-INF (отрицательная бесконечность). Обратите внимание, что эта поддержка для-INF является просто артефактом самого формата и не поддерживается кодировщиками для этого формата. В общем случае, когда кодировщики сталкиваются с INF (положительными или отрицательными) или неоднородными входными данными, они должны \\ преобразовывать эти данные в максимально допустимое значение представления, отличного от INF, и сопоставлять NaN с 0 до сжатия.
-   Формат BC6H не поддерживает альфа-канал.
-   Декодер BC6H выполняет распаковку до того, как приступит к фильтрации текстур.
-   Распаковка BC6H должна быть точной. то есть оборудование должно вернуть результаты, идентичные декодеру, описанному в этой документации.

## <a name="bc6h-implementation"></a>Реализация BC6H

Блок BC6H состоит из битов режима, сжатых конечных точек, сжатых индексов и дополнительного индекса раздела. Этот формат задает 14 разных режимов.

Цвет конечной точки хранится в виде RGB-триады. BC6H определяет цветовую палитру по приблизительной линии, проходящей через несколько определенных конечных точек цвета. Кроме того, в зависимости от режима плитка может быть разделена на два региона или обрабатываться как один регион, где плитка с двумя регионами имеет отдельный набор конечных точек цвета для каждого региона. BC6H сохраняет один индекс палитры на тексель.

Если вы работаете с двумя регионами, число возможных разделов равно 32.

## <a name="decoding-the-bc6h-format"></a>Декодирование формата BC6H

В псевдокоде ниже изображены действия по распаковке пикселя в точке (x,y) при наличии 16-байтового блока BC6H.

``` syntax
decompress_bc6h(x, y, block)
{
    mode = extract_mode(block);
    endpoints;
    index;
    
    if(mode.type == ONE)
    {
        endpoints = extract_compressed_endpoints(mode, block);
        index = extract_index_ONE(x, y, block);
    }
    else //mode.type == TWO
    {
        partition = extract_partition(block);
        region = get_region(partition, x, y);
        endpoints = extract_compressed_endpoints(mode, region, block);
        index = extract_index_TWO(x, y, partition, block);
    }
    
    unquantize(endpoints);
    color = interpolate(index, endpoints);
    finish_unquantize(color);
}
```

В таблице ниже указано число битов и значения для каждого из 14 возможных форматов для блоков BC6H. 

| Режим | Индексы разделов | Секция | Конечные точки цвета                  | Биты режима      |
|------|-------------------|-----------|----------------------------------|----------------|
| 1    | 46 битов           | 5 битов    | 75 битов (10,555, 10,555, 10,555) | 2 бита (00)    |
| 2    | 46 битов           | 5 битов    | 75 битов (7666, 7666, 7666)       | 2 бита (01)    |
| 3    | 46 битов           | 5 битов    | 72 бита (11,555, 11,444, 11,444) | 5 битов (00010) |
| 4    | 46 битов           | 5 битов    | 72 бита (11,444, 11,555, 11,444) | 5 битов (00110) |
| 5    | 46 битов           | 5 битов    | 72 бита (11,444, 11,444, 11,555) | 5 битов (01010) |
| 6    | 46 битов           | 5 битов    | 72 бита (9555, 9555, 9555)       | 5 битов (01110) |
| 7    | 46 битов           | 5 битов    | 72 бита (8666, 8555, 8555)       | 5 битов (10010) |
| 8    | 46 битов           | 5 битов    | 72 бита (8555, 8666, 8555)       | 5 битов (10110) |
| 9    | 46 битов           | 5 битов    | 72 бита (8555, 8555, 8666)       | 5 битов (11010) |
| 10   | 46 битов           | 5 битов    | 72 бита (6666, 6666, 6666)       | 5 битов (11110) |
| 11   | 63 бита           | 0 битов    | 60 битов (10,10, 10,10, 10,10)    | 5 битов (00011) |
| 12   | 63 бита           | 0 битов    | 60 битов (11,9, 11,9, 11,9)       | 5 битов (00111) |
| 13   | 63 бита           | 0 битов    | 60 битов (12,8, 12,8, 12,8)       | 5 битов (01011) |
| 14   | 63 бита           | 0 битов    | 60 битов (16,4, 16,4, 16,4)       | 5 битов (01111) |



 

Каждый формат в этой таблице можно уникально идентифицировать битами режима. Первые десять режимов используются для плиток с двумя регионами, а поле бита режима может иметь длину два бита или пять битов. Эти блоки также имеют поля для конечных точек сжатого цвета (72 или 75 битов), раздела (5 битов) и индексов раздела (46 битов).

Для конечных точек сжатого цвета значения в предыдущей таблице обозначают точность сохраненных конечных точек RGB и число битов, используемых для каждого значения цвета. Например, режим 3 указывает на 11 уровень точности конечной точки цвета, а число битов, используемых для хранения дельта-значений преобразованных конечных точек для красного, синего и зеленого цветов (5, 4 и 4 соответственно). В режиме 10 не используется дельта-сжатие. Вместо этого все четыре конечные точки цвета сохраняются явно.

Последние четыре режима блока используются для плиток с одним регионом, где поле режима равно 5 битам. Эти блоки имеют поля для конечных точек (60 битов) и сжатых индексов (63 бита), В режиме 11 (как и в режиме 10) не используется дельта-сжатие. Вместо этого конечные точки цвета сохраняются явно.

Режимы 10011, 10111, 11011 и 11111 (не показан) зарезервированы. Не используйте их в своем кодировщике. Если оборудование представляет собой переданные блоки и задан один из этих режимов, полученный распакованный блок должен содержать все нули во всех каналах, кроме альфа-канала.

Для BC6H альфа-канал должен всегда возвращать 1,0 независимо от режима.

### <a name="bc6h-partition-set"></a>Набор разделов BC6H

Существует 32 возможных набора разделов для плитки с двумя регионами, которые определены в таблице ниже. Каждый блок 4x4 представляет одну фигуру.

![таблица наборов разделов bc6h](images/bc6h-partition-sets.png)

В этой таблице наборов разделов выделенная полужирным шрифтом и подчеркиванием запись является расположением индекса исправления для подмножества 1 (которое задается с количеством битов на 1 меньше). Индекс исправления для подмножества 0 — это всегда нулевой индекс, поскольку разделение на разделы всегда организовано так, чтобы нулевой индекс находился в нулевом подмножестве. Порядок разделения на разделы: из верхнего левого угла до нижнего правого, перемещаясь слева направо и сверху вниз.

## <a name="bc6h-compressed-endpoint-format"></a>Формат сжатых конечных точек BC6H

![битовые поля для форматов bc6h сжатой конечной точки](images/bc6h-headers-med.png)

В этой таблице показаны битовые поля для сжатых конечных точек в качестве функции формата конечной точки, при этом каждый столбец задает кодировку, а каждая строка — битовое поле. В рамках этого подхода число битов для плиток с двумя регионами составляет 82, а для плиток с одним регионом — 65. Например, первые 5 бит для \[ \] кодировки 16 4 (в частности, самый правый столбец) имеют бит m \[ 4:0 \] , а следующие 10 битов — биты RW \[ 9:0 \] и т. д. с последними 6 битами, содержащими BW \[ 10:15 \] .

Имена полей в таблице выше определяются следующим образом:

| Поле | Переменная          |
|-------|-------------------|
| М     | mode              |
| d     | индекс фигуры       |
| rw    | ендпт \[ 0 \] . Значение \[ 0\] |
| rx    | ендпт \[ 0 \] . Б \[ 0\] |
| ry    | ендпт \[ 1 \] . Значение \[ 0\] |
| rz    | ендпт \[ 1 \] . Б \[ 0\] |
| gw    | ендпт \[ 0 \] . Значение \[ 1\] |
| gx    | ендпт \[ 0 \] . B \[ 1\] |
| gy    | ендпт \[ 1 \] . Значение \[ 1\] |
| gz    | ендпт \[ 1 \] . B \[ 1\] |
| bw    | ендпт \[ 0 \] . A \[ 2\] |
| bx    | ендпт \[ 0 \] . B \[ 2\] |
| by    | ендпт \[ 1 \] . A \[ 2\] |
| bz    | ендпт \[ 1 \] . B \[ 2\] |



 

Ендпт \[ i \] , где i равно 0 или 1, ссылается на 0-й или первый набор конечных точек соответственно.

## <a name="sign-extension-for-endpoint-values"></a>Расширение знака для значений конечных точек

Для плиток с двумя регионами существует четыре значения конечных точек, для которых можно расширить знак. Ендпт \[ 0 \] . Подписывается, только если формат имеет формат со знаком; другие конечные точки подписываются только в том случае, если была преобразована конечная точка или если формат имеет формат со знаком. Приведенный ниже код демонстрирует алгоритм расширения знака значений конечной точки с двумя регионами.

``` syntax
static void sign_extend_two_region(Pattern &p, IntEndpts endpts[NREGIONS_TWO])
{
    for (int i=0; i<NCHANNELS; ++i)
    {
      if (BC6H::FORMAT == SIGNED_F16)
        endpts[0].A[i] = SIGN_EXTEND(endpts[0].A[i], p.chan[i].prec);
      if (p.transformed || BC6H::FORMAT == SIGNED_F16)
      {
        endpts[0].B[i] = SIGN_EXTEND(endpts[0].B[i], p.chan[i].delta[0]);
        endpts[1].A[i] = SIGN_EXTEND(endpts[1].A[i], p.chan[i].delta[1]);
        endpts[1].B[i] = SIGN_EXTEND(endpts[1].B[i], p.chan[i].delta[2]);
      }
    }
}
```

Для мозаичных плиток поведение аналогично удалено только с ендпт \[ 1 \] .

``` syntax
static void sign_extend_one_region(Pattern &p, IntEndpts endpts[NREGIONS_ONE])
{
    for (int i=0; i<NCHANNELS; ++i)
    {
    if (BC6H::FORMAT == SIGNED_F16)
        endpts[0].A[i] = SIGN_EXTEND(endpts[0].A[i], p.chan[i].prec);
    if (p.transformed || BC6H::FORMAT == SIGNED_F16) 
        endpts[0].B[i] = SIGN_EXTEND(endpts[0].B[i], p.chan[i].delta[0]);
    }
}
```

## <a name="transform-inversion-for-endpoint-values"></a>Преобразование инверсии для значений конечной точки

Для мозаичных плиток с двумя регионами преобразование применяет обратную кодировку для кодирования разницы, добавляя базовое значение в ендпт \[ 0 \] . А — для трех других записей — всего 9 операций добавления. На следующем рисунке базовое значение представляется в виде "A0" и имеет наивысшую точность плавающей точки. "A1" "B0" и "B1" — это дельты, вычисленные на основе значения привязки, и эти значения привязки представлены с более низкой точностью. (A0 соответствует ендпт \[ 0 \] . A, B0 соответствует ендпт \[ 0 \] . B, a1 соответствует ендпт \[ 1 \] . A, а B1 соответствует ендпт \[ 1 \] . B.)

![расчет значений конечных точек инверсии преобразования](images/bc6h-transform-inverse.png)

Для плиток с одним регионом существует только одно дельта-смещение и, следовательно, только три операции добавления.

Декомпрессор должен гарантировать, что результаты обратного преобразования не будут переполнить точность ендпт \[ 0 \] . a. В случае переполнения значения, которые являются результатом обратного преобразования, должны быть заключены в оболочку из того же числа битов. Если точность A0 — "p" битов, алгоритм преобразования выглядит следующим образом:

`B0 = (B0 + A0) & ((1 << p) - 1)`

Для форматов со знаком результаты вычисления дельты также должны иметь расширение со знаком. Если в ходе операции расширение знака рассматривается расширение обоих знаков, где 0 — положительное, а 1 — отрицательное, расширение знака 0 обработает фиксацию выше. Аналогично, после фиксации выше необходимо расширять знаком только значение 1 (отрицательное).

## <a name="unquantization-of-color-endpoints"></a>Ункуантизатион конечных точек цвета

Учитывая, что конечные точки не сжаты, следующий шаг — выполнить исходное расквантование конечных точек цвета. Этот процесс состоит из трех этапов.

-   Расквантование цветовых палитр
-   Интерполяция палитр
-   Завершение расквантования

Разделение процесса расквантования на две части (расквантование цветовой палитры перед интерполяцией и окончательное расквантование после интерполяции) уменьшает число необходимых операций умножения по сравнению с полным расквантованием перед интерполяцией палитры.

Код ниже иллюстрирует процесс извлечения оценок исходных 16-разрядных значений цвета с последующим использованием предоставленных значений веса для добавления в палитру 6 дополнительных значений цвета. Та же операция выполняется в каждом канале.

``` syntax
int aWeight3[] = {0, 9, 18, 27, 37, 46, 55, 64};
int aWeight4[] = {0, 4, 9, 13, 17, 21, 26, 30, 34, 38, 43, 47, 51, 55, 60, 64};

// c1, c2: endpoints of a component
void generate_palette_unquantized(UINT8 uNumIndices, int c1, int c2, int prec, UINT16 palette[NINDICES])
{
    int* aWeights;
    if(uNumIndices == 8)
        aWeights = aWeight3;
    else  // uNumIndices == 16
        aWeights = aWeight4;

    int a = unquantize(c1, prec); 
    int b = unquantize(c2, prec);

    // interpolate
    for(int i = 0; i < uNumIndices; ++i)
        palette[i] = finish_unquantize((a * (64 - aWeights[i]) + b * aWeights[i] + 32) >> 6);
}
```

В следующем примере кода показан процесс интерполяции с учетом следующих соображений:

-   Поскольку полный диапазон значений цвета для функции **unquantize** (ниже) — с -32 768 до 65 535, средство интерполяции реализуется с использованием 17-разрядного арифметического со знаком.
-   После интерполяции значения передаются в функцию **Finish \_ ункуантизе** (описывается в третьем примере в этом разделе), который применяет окончательное масштабирование.
-   Все аппаратные распаковщики должны возвращать из этих функций результаты с точными значениями разрядов.

``` syntax
int unquantize(int comp, int uBitsPerComp)
{
    int unq, s = 0;
    switch(BC6H::FORMAT)
    {
    case UNSIGNED_F16:
        if(uBitsPerComp >= 15)
            unq = comp;
        else if(comp == 0)
            unq = 0;
        else if(comp == ((1 << uBitsPerComp) - 1))
            unq = 0xFFFF;
        else
            unq = ((comp << 16) + 0x8000) >> uBitsPerComp;
        break;

    case SIGNED_F16:
        if(uBitsPerComp >= 16)
            unq = comp;
        else
        {
            if(comp < 0)
            {
                s = 1;
                comp = -comp;
            }

            if(comp == 0)
                unq = 0;
            else if(comp >= ((1 << (uBitsPerComp - 1)) - 1))
                unq = 0x7FFF;
            else
                unq = ((comp << 15) + 0x4000) >> (uBitsPerComp-1);

            if(s)
                unq = -unq;
        }
        break;
    }
    return unq;
}
```

метод **Finish \_ ункуантизе** вызывается после интерполяции палитры. Функция **unquantize** откладывает масштабирование на 31/32 для значений со знаком и на 31/64 для значений без знака. Это поведение необходимо, чтобы окончательное значение находилось в допустимом полудиапазоне (-0x7BFF–0x7BFF) по окончании интерполяции палитры с целью уменьшения общего количества необходимых умножений. **Finish \_ ункуантизе** применяет окончательное масштабирование и возвращает **короткое значение без знака** , которое возвращается в **половину**.

``` syntax
unsigned short finish_unquantize(int comp)
{
    if(BC6H::FORMAT == UNSIGNED_F16)
    {
        comp = (comp * 31) >> 6;                                         // scale the magnitude by 31/64
        return (unsigned short) comp;
    }
    else // (BC6H::FORMAT == SIGNED_F16)
    {
        comp = (comp < 0) ? -(((-comp) * 31) >> 5) : (comp * 31) >> 5;   // scale the magnitude by 31/32
        int s = 0;
        if(comp < 0)
        {
            s = 0x8000;
            comp = -comp;
        }
        return (unsigned short) (s | comp);
    }
}
```

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Сжатие блоков текстуры в Direct3D 11](texture-block-compression-in-direct3d-11.md)
</dt> </dl>

 

 