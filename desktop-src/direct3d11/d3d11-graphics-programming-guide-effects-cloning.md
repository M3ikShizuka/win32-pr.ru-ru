---
title: Клонирование результата
description: При клонировании действия создается вторая, почти идентичная копия этого результата.
ms.assetid: e3870363-5ee8-4fdc-a489-cdaeef8c9c39
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 195b4e9a42e595558acc4c512f8662c11b2acde7873e123b242ee272eeea7e8c
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118538008"
---
# <a name="cloning-an-effect"></a>Клонирование результата

При клонировании действия создается вторая, почти идентичная копия этого результата. См. следующий единственный квалификатор, поясняющий, почему он не является точным. Вторая копия эффекта полезна, когда одной из них требуется использовать платформу Effects в нескольких потоках, так как среда выполнения влияния не является потокобезопасной для поддержания высокой производительности.

Так как контексты устройств также не являются потокобезопасными, разные потоки должны передавать разные контексты устройств методу ID3DX11EffectPass:: Apply.

Результат можно клонировать с помощью следующего синтаксиса:


```
ID3DX11Effect* pClonedEffect = NULL;
UINT Flags = D3DX11_EFFECT_CLONE_FORCE_NONSINGLE;
HRESULT hr = pEffect->CloneEffect( Flags, &pClonedEffect );
```



В приведенном выше примере Клонированная копия будет инкапсулировать то же состояние, что и исходный результат, независимо от состояния, в котором находится исходный результат. В частности:

1.  Если Пеффект оптимизировано, Пклонедный результат оптимизирован
2.  Если Пеффект содержит некоторые переменные, управляемые пользователем, Пклонед воздействие будет иметь те же управляемые пользователем переменные (см. одно описание ниже).
3.  Все ожидающие обновления переменные (пока вызов Apply не обновляет состояние устройства) в Пеффект будет ожидать в Пклонедеффект

Следующие объекты устройств Direct3D 11 являются неизменяемыми или никогда не обновляются платформой Effects, поэтому клонированный эффект будет указывать на те же объекты, что и исходный эффект:

1.  Объекты блока State (ID3D11BlendState, ID3D11RasterizerState, ID3D11DepthStencilState, ID3D11SamplerState)
2.  Шейдеры
3.  Экземпляры класса
4.  Текстуры (не включая буферы текстур)
5.  Представления неупорядоченного доступа

Следующие объекты устройств Direct3D 11 как неизменяемые, так и изменяются средой выполнения Effect (если они не управляются пользователем или единственными в клонированном результате); новые копии этих объектов создаются, если они не являются отдельными:

1.  Буферы констант
2.  Буферы текстуры

## <a name="single-constant-buffers-and-texture-buffers"></a>Одноконстантные буферы и буферы текстур

Обратите внимание, что это обсуждение относится как к постоянным буферам, так и к текстурам, но для простоты чтения предполагается наличие постоянных буферов.

Возможны случаи, когда буфер констант обновляется только одним потоком, но эти данные будут использоваться состоянием устройства, установленным клонированными эффектами. Например, основной эффект может обновлять мир и просматривать матрицы, на которые имеются ссылки в виде шейдеров, в клонированных эффектах, которые не изменяют матрицы мира и представления. В таких случаях клонированные эффекты должны ссылаться на текущий буфер констант, а не воссоздавать его.

Существует два способа достижения этого результата:

1.  Используйте ID3DX11EffectConstantBuffer:: Сетконстантбуффер в клонированном результате, чтобы сделать его управляемым пользователем
2.  Пометьте константный буфер как "отдельный" в коде HLSL, чтобы среда выполнения Effect считалась как управляемая пользователем после клонирования

Существует два различия между двумя методами, приведенными выше. Во-первых, в методе 1 создается новый ID3D11Buffer и вызывается пользователь перед Сетконстантбуффер. Кроме того, после вызова Ундосетконстантбуффер в клонированном эффекте переменная в методе 1will указывает на только что созданный буфер (эффект, который будет обновляться при применении), а переменная в методе 2 продолжит указывать на исходный буфер (не обновляя его при применении).

См. Следующий пример в HLSL:


```
cbuffer ObjectData
{
    float4 Position;
};
single cbuffer ViewData
{
    float4x4 ViewMatrix;
};
```



При клонировании клонированный результат создаст новый ID3D11Buffer для ObjectData и заполнит его содержимое на Apply, но сослаться на исходный ID3D11Buffer для ViewData. Единственный квалификатор можно проигнорировать в процессе клонирования, установив флаг D3DX11 для \_ \_ клона действия \_ Force \_ .

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Эффекты (Direct3D 11)](d3d11-graphics-programming-guide-effects.md)
</dt> </dl>

 

 




