---
title: Настройка функциональных возможностей Depth-Stencil
description: В этом разделе приводится пошаговая инструкция по настройке буфера трафарета глубины и рассматривается состояние трафарета глубины для стадии слияния вывода.
ms.assetid: e8f52d5f-266f-4e2c-b38d-d7fd9e27fe1f
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 65bf48b0ba9a782be25568ac3fc0569314dae76e
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "103792708"
---
# <a name="configuring-depth-stencil-functionality"></a>Настройка функциональных возможностей Depth-Stencil

В этом разделе приводится пошаговая инструкция по настройке буфера трафарета глубины и рассматривается состояние трафарета глубины для стадии слияния вывода.

-   [Создание Depth-Stencil ресурса](#create-a-depth-stencil-resource)
-   [Создание состояния Depth-Stencil](#create-depth-stencil-state)
-   [Привязка Depth-Stencil данных к этапу OM](#bind-depth-stencil-data-to-the-om-stage)

Узнав, как использовать буфер трафарета глубины и соответствующее состояние трафарета глубины, приступайте к изучению [сложных техник работы с трафаретами](#advanced-stencil-techniques).

## <a name="create-a-depth-stencil-resource"></a>Создание Depth-Stencil ресурса

Создайте буфер шаблона глубины с помощью ресурса текстуры.


```
ID3D11Texture2D* pDepthStencil = NULL;
D3D11_TEXTURE2D_DESC descDepth;
descDepth.Width = backBufferSurfaceDesc.Width;
descDepth.Height = backBufferSurfaceDesc.Height;
descDepth.MipLevels = 1;
descDepth.ArraySize = 1;
descDepth.Format = pDeviceSettings->d3d11.AutoDepthStencilFormat;
descDepth.SampleDesc.Count = 1;
descDepth.SampleDesc.Quality = 0;
descDepth.Usage = D3D11_USAGE_DEFAULT;
descDepth.BindFlags = D3D11_BIND_DEPTH_STENCIL;
descDepth.CPUAccessFlags = 0;
descDepth.MiscFlags = 0;
hr = pd3dDevice->CreateTexture2D( &descDepth, NULL, &pDepthStencil );
```



## <a name="create-depth-stencil-state"></a>Создание состояния трафарета глубины

Состояние трафарета глубины сообщает стадии средства слияния вывода способ выполнения [проверки трафарета глубины](d3d10-graphics-programming-guide-output-merger-stage.md). Проверка трафарета глубины позволяет определить, нужно ли рисовать тот или иной пиксель.


```
D3D11_DEPTH_STENCIL_DESC dsDesc;

// Depth test parameters
dsDesc.DepthEnable = true;
dsDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
dsDesc.DepthFunc = D3D11_COMPARISON_LESS;

// Stencil test parameters
dsDesc.StencilEnable = true;
dsDesc.StencilReadMask = 0xFF;
dsDesc.StencilWriteMask = 0xFF;

// Stencil operations if pixel is front-facing
dsDesc.FrontFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
dsDesc.FrontFace.StencilDepthFailOp = D3D11_STENCIL_OP_INCR;
dsDesc.FrontFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
dsDesc.FrontFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

// Stencil operations if pixel is back-facing
dsDesc.BackFace.StencilFailOp = D3D11_STENCIL_OP_KEEP;
dsDesc.BackFace.StencilDepthFailOp = D3D11_STENCIL_OP_DECR;
dsDesc.BackFace.StencilPassOp = D3D11_STENCIL_OP_KEEP;
dsDesc.BackFace.StencilFunc = D3D11_COMPARISON_ALWAYS;

// Create depth stencil state
ID3D11DepthStencilState * pDSState;
pd3dDevice->CreateDepthStencilState(&dsDesc, &pDSState);
```



Депсенабле и СтенЦиленабле включают (и отключают) глубину и тестирование трафаретов. Задайте для Депсенабле **значение false** , чтобы отключить тестирование глубины и запретить запись в буфер глубины. Задайте для СтенЦиленабле **значение false** , чтобы отключить тестирование наборов элементов и предотвратить запись в буфер шаблона (если Депсенабле имеет **значение false** , а стенЦиленабле имеет **значение true**, тест глубины всегда передается в операцию с набором элементов).

Депсенабле влияет только на этап слияния (Output-слияние). он не влияет на обрезание, сдвиг глубины или фиксацию значений перед вводом данных в шейдер пикселей.

## <a name="bind-depth-stencil-data-to-the-om-stage"></a>Привязка данных трафарета глубины к стадии средства слияния вывода

Привязка состояния трафарета глубины.


```
// Bind depth stencil state
pDevice->OMSetDepthStencilState(pDSState, 1);
```



Привязка ресурса трафарета глубины с использованием представления.


```
D3D11_DEPTH_STENCIL_VIEW_DESC descDSV;
descDSV.Format = DXGI_FORMAT_D32_FLOAT_S8X24_UINT;
descDSV.ViewDimension = D3D11_DSV_DIMENSION_TEXTURE2D;
descDSV.Texture2D.MipSlice = 0;

// Create the depth stencil view
ID3D11DepthStencilView* pDSV;
hr = pd3dDevice->CreateDepthStencilView( pDepthStencil, // Depth stencil texture
                                         &descDSV, // Depth stencil desc
                                         &pDSV );  // [out] Depth stencil view

// Bind the depth stencil view
pd3dDeviceContext->OMSetRenderTargets( 1,          // One rendertarget view
                                &pRTV,      // Render target view, created earlier
                                pDSV );     // Depth stencil view for the render target
```



В [**ссылку ID3D11DeviceContext:: омсетрендертаржетс**](/windows/desktop/api/D3D11/nf-d3d11-id3d11devicecontext-omsetrendertargets)можно передать массив представлений целевого объекта визуализации, однако все эти представления целевого объекта будут соответствовать одному представлению трафарета глубины. Массив целевых объектов отрисовки в Direct3D 11 — это функция, которая позволяет приложению отображать несколько целевых объектов отрисовки одновременно на уровне примитивов. Целевые массивы визуализации обеспечивают повышенную производительность по сравнению с индивидуальной установкой целевых объектов отрисовки с несколькими вызовами метода **ссылку ID3D11DeviceContext:: омсетрендертаржетс** (по сути, метод, используемый в Direct3D 9).

Все однобуферные прорисовки должны относиться к одному типу ресурса. Если используется сглаживание с множественной дискретизацией, все связанные однобуферные прорисовки и буферы глубины должны иметь одинаковое число выборок.

Если буфер используется в качестве однобуферной прорисовки, проверка трафарета глубины и использование нескольких однобуферных прорисовок не поддерживаются.

-   Одновременно можно связать до 8 однобуферных прорисовок.
-   Все целевые объекты отрисовки должны иметь одинаковый размер во всех измерениях (ширина и высота, а также глубину для объемных массивов или массивов для \* типов массива).
-   Каждая однобуферная прорисовка может иметь свой формат данных.
-   Маски записи контролируют, какие данные записываются в однобуферную прорисовку. Маски записи вывода контролируют, какие данные записываются в однобуферные прорисовки на уровне однобуферных прорисовок и компонентов.

## <a name="advanced-stencil-techniques"></a>Сложные техники работы с трафаретами

Трафаретная часть буфера трафарета глубины может использоваться для создания эффектов отрисовки, таких как компоновка, переводные картинки и структурирование.

-   [Компоновка](#compositing)
-   [Переводные картинки](#decaling)
-   [Контуры и Силхауеттес](#outlines-and-silhouettes)
-   [Двухсторонний набор элементов](#two-sided-stencil)
-   [Считывание Depth-Stencil буфера в виде текстуры](#reading-the-depth-stencil-buffer-as-a-texture)

### <a name="compositing"></a>Компоновка

Ваше приложение может использовать буфер трафарета для создания двух- или трехмерных изображений в трехмерной сцене. Маска в буфере трафарета используется для ограждения области, которая является поверхностью однобуферной прорисовки. Сохраненную двухмерную информацию, такую как текст или точечные рисунки, затем можно записать в огороженную область. Кроме того, ваше приложение может отрисовывать дополнительные трехмерные примитивы в замаскированный трафаретом регион поверхности однобуферной прорисовки. Приложение даже может отрисовывать всю сцену.

Игры часто предполагают компоновку нескольких трехмерных сцен. Так, в симуляторах вождения, как правило, показано отражение в зеркале заднего вида. В нем отражается происходящее за водителем в трехмерном формате. Это вторая трехмерная сцена, скомпонованная с передним обзором водителя.

### <a name="decaling"></a>Переводные картинки

В приложениях Direct3D пользователи с помощью переводных картинок контролируют, какие пиксели из определенного изображения-примитива рисуются на поверхность однобуферной прорисовки. Приложения применяют переводные картинки к изображениям примитивов для правильной отрисовки многоугольников.

Например, следы шин и желтая дорожная разметка должны отображаться непосредственно на поверхности дороги. Однако значения разметки и дорожной поверхности по оси Z совпадают. Поэтому велика вероятность нечеткого разделения этих сущностей буфером глубины. Некоторые пиксели в примитиве заднего вида могут отображаться поверх пикселей в примитиве переднего вида, и наоборот. В результате изображение может дрожать при смене кадра. Этот эффект называется Z-буферизация или "мерцание".

Чтобы решить эту проблему, используйте трафарет для маскировки раздела примитива заднего вида, в котором будет отображаться переводная картинка. Выключите Z-буферизацию и отрисуйте изображение примитива переднего обзора в замаскированной области поверхности однобуферной прорисовки.

Для решения этой проблемы можно использовать наложение нескольких текстур.

### <a name="outlines-and-silhouettes"></a>Структуры и силуэты

Буфер трафарета можно использовать и для более абстрактных эффектов, таких как создание структур и силуэтов.

Если ваше приложение выполняет два прохода отрисовки (один — чтобы создать маску трафарета, а второй — чтобы применить маску трафарета к изображению, однако во втором проходе используются несколько более мелкие примитивы), получившееся изображение будет содержать только структуру примитива. Затем приложение может заполнить замаскированную трафаретом область изображения сплошным цветом, создавая для примитива эффект приподнятости.

Если маска трафарета имеет те же размеры и форму, что и примитив, который вы отрисовываете, на полученном изображении на месте примитива будет отверстие. Затем приложение может заполнить это отверстие черным, создавая силуэт примитива.

### <a name="two-sided-stencil"></a>Двусторонний трафарет

Теневые тома используются для рисования теней с использованием буфера трафарета. Приложение вычисляет теневые тома, переданные геометрией ограждения, вычисляя края силуэта и вытягивая их от света в набор трехмерных томов. Затем эти тома дважды отрисовываются в буфер трафарета.

В ходе первой отрисовки рисуются многоугольники переднего обзора и увеличиваются значения буфера трафарета. В ходе второй отрисовки рисуются многоугольники заднего вида, относящиеся к теневому тому, а значения буфера трафарета уменьшаются. Как правило, значения увеличения и уменьшения уравновешивают друг друга. Однако сцена уже была отрисована с нормальной геометрией, из-за чего некоторые пиксели не прошли проверку Z-буфера при отрисовке теневого тома. Значения, оставшиеся в буфере трафарета, соответствуют пикселям в тени. Оставшееся содержимое буфера трафарета используется в качестве маски, чтобы выполнить альфа-смешение крупного, всеобъемлющего черного квартета со сценой. Если буфер трафарета используется в качестве маски, в результате затеняются пиксели, которые находятся в тени.

Это означает, что теневая геометрия рисуется дважды для каждого источника света, оказывая давление на пропускную способность вершин графического процессора. Для устранения этого эффекта разработана функция двустороннего трафарета. При таком подходе существует два набора состояний трафарета (они указаны ниже): один — для треугольников переднего обзора, другой — для треугольников заднего вида. В этом случае для каждого теневого тома рисуется по одному проходу на источник освещения.

Пример двусторонней реализации трафарета можно найти в [примере ShadowVolume10](https://msdn.microsoft.com/library/Ee416427(v=VS.85).aspx).

### <a name="reading-the-depth-stencil-buffer-as-a-texture"></a>Считывание буфера трафарета глубины как текстуры

Неактивный буфер трафарета глубины может считываться шейдером как текстура. Приложение, считывающее буфер трафарета глубины как текстуру, отрисовывается за два прохода: первый проход выполняет запись в буфер трафарета глубины, а второй — чтение из этого буфера. Это позволяет шейдеру сравнить значения глубины или трафарета, ранее записанные в буфер, со значением для отрисовываемого в настоящее время пикселя. Результат сравнения может использоваться для создания эффектов, таких как сопоставление теней или мягкие частицы в системе частиц.

Чтобы создать буфер шаблона глубины, который можно использовать в качестве ресурса-шаблона глубины и ресурса шейдера, необходимо внести несколько изменений в пример кода в разделе [создание Depth-Stencil ресурса](#create-a-depth-stencil-resource) .

-   Ресурс шаблона глубины должен иметь нетипизированный формат, такой как формат DXGI \_ \_ R32 \_ Type.
    ```
    descDepth.Format = DXGI_FORMAT_R32_TYPELESS;
    ```

    

-   Ресурс шаблона глубины должен использовать \_ Флаги D3D10 привязки и привязки \_ \_ \_ \_ ресурса шейдера D3D10 BIND \_ .
    ```
    descDepth.BindFlags = D3D10_BIND_DEPTH_STENCIL | D3D10_BIND_SHADER_RESOURCE;
    ```

    

Кроме того, необходимо создать представление ресурсов шейдера для буфера глубины с помощью структуры D3D11 в [**\_ \_ \_ представлении \_ ресурсов шейдера**](/windows/desktop/api/d3d11/ns-d3d11-d3d11_shader_resource_view_desc) , а также [**ID3D11Device:: креатешадерресаурцевиев**](/windows/desktop/api/D3D11/nf-d3d11-id3d11device-createshaderresourceview). Представление ресурсов шейдера будет использовать типизированный формат, такой как **\_ \_ R32 \_ float** , который эквивалентен формату, указанному при создании ресурса-шаблона глубины.

На первом этапе отрисовки буфер глубины привязывается, как описано в разделе [привязка Depth-Stencil данных к этапу OM](#bind-depth-stencil-data-to-the-om-stage) . Обратите внимание, что формат, передаваемый в [**D3D11 \_ \_ представление трафарета глубины \_ \_**](/windows/desktop/api/D3D11/ns-d3d11-d3d11_depth_stencil_view_desc), — DESC. Формат будет использовать типизированный формат, такой **как \_ \_ d32 \_ float**, например, в формате DXGI. После первого прохода буфер глубины будет содержать значения глубины для сцены.

Во второй функции рендеринга функция [**ссылку ID3D11DeviceContext:: омсетрендертаржетс**](/windows/desktop/api/D3D11/nf-d3d11-id3d11devicecontext-omsetrendertargets) используется, чтобы задать для представления трафарета глубины **значение NULL** или другой ресурс трафарета глубины, а представление ресурсов шейдера передается шейдеру с помощью [**ID3D11EffectShaderResourceVariable:: сетресаурце**](id3dx11effectshaderresourcevariable-setresource.md). Это позволяет шейдеру искать значения глубины, вычисленные на первом этапе подготовки к просмотру. Обратите внимание, что преобразование необходимо применить для получения значений глубины, если точка представления первого прохода прорисовки отличается от второго прохода отрисовки. Например, если используется метод сопоставления теневого отображения, первый проход рендеринга будет с точки зрения источника освещения, а второй — с точки зрения средства просмотра.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Стадия средства слияния вывода](d3d10-graphics-programming-guide-output-merger-stage.md)
</dt> <dt>

[Этапы конвейера (Direct3D 10)](/windows/desktop/direct3d10/d3d10-graphics-programming-guide-pipeline-stages)
</dt> </dl>

 

 