---
title: Смещение глубины
description: Многоугольники, копланар в трехмерном пространстве, могут выглядеть так, как если бы они не копланар, добавляя z-смещение (или смещение глубины) к каждому из них.
ms.assetid: ee904316-dc6d-48a4-bdb7-0f7dcdb9d9d6
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c1f707a038a2da8ebe9c1adc21f6081c85f5a63fbbc1c360a4dfbbf5765d845d
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118990164"
---
# <a name="depth-bias"></a>Смещение глубины

Многоугольники, копланар в трехмерном пространстве, могут выглядеть так, как если бы они не копланар, добавляя z-смещение (или смещение глубины) к каждому из них.

Это метод, который обычно используется для обеспечения правильного отображения теней в сцене. Например, тень на стене, скорее всего, будет иметь то же значение глубины, что и стенка. Если приложение сначала отображает стену, а затем тень, то тень может быть невидимой, а артефакты глубины могут быть видимыми.


Приложение может обеспечить правильное отображение многоугольников копланар, добавив сдвиг (от элемента **депсбиас** средства [**\_ прорисовки D3D11 \_ DESC1**](/windows/desktop/api/D3D11_1/ns-d3d11_1-cd3d11_rasterizer_desc1)) к значениям z, используемым системой при отрисовке наборов копланар многоугольников. Многоугольники с большим значением z будут отображаться перед многоугольниками с меньшим значением z.

Существует два варианта вычисления смещения глубины.

1.  Если буфер глубины, привязанный в настоящее время к этапу слияния вывода, имеет формат **UNORM** или не привязан буфер глубины, значение смещения вычисляется следующим образом:
    ```
    Bias = (float)DepthBias * r + SlopeScaledDepthBias * MaxDepthSlope;
    ```

    

    где *r* — минимальное представимое значение > 0 в формате буфера глубины, преобразованном в **float32**. Значения **депсбиас** и **слопескаледдепсбиас** — [**D3D11 средство \_ прорисовки \_ DESC1**](/windows/desktop/api/D3D11_1/ns-d3d11_1-cd3d11_rasterizer_desc1) члены структуры. Значение **максдепсслопе** является максимальным значением горизонтального и вертикального наклоненной значения глубины в пикселе.
2.  Если буфер глубины с плавающей точкой привязан к этапу слияния вывода, значение смещения вычисляется следующим образом:
    ```
    Bias = (float)DepthBias * 2**(exponent(max z in primitive) - r) +
                SlopeScaledDepthBias * MaxDepthSlope;
    ```

    

    где *r* — число битов мантисса в представлении с плавающей запятой (за исключением скрытого бита); Например, 23 для **float32**.

Затем значение смещения будет заменяться следующим образом:


```
if(DepthBiasClamp > 0)
    Bias = min(DepthBiasClamp, Bias)
else if(DepthBiasClamp < 0)
    Bias = max(DepthBiasClamp, Bias)
```



Затем значение смещения используется для вычисления глубины пикселя.


```
if ( (DepthBias != 0) || (SlopeScaledDepthBias != 0) )
    z = z + Bias
```



Операции смещения глубины выполняются на вершинах после обрезки, поэтому смещение глубины не влияет на геометрическую отсечение. Значение смещения является константой для данного примитива и добавляется к значению z для каждой вершины перед настройкой интерполяции. При использовании [уровней компонентов](overviews-direct3d-11-devices-downlevel-intro.md) 10,0 и выше все вычисления смещения выполняются с использованием 32-разрядных арифметических вычислений с плавающей запятой. Смещение не применяется к примитивным или строкам, за исключением линий, нарисованных в режиме каркаса.

Одним из артефактов с тенями на основе теневого буфера является теневая акнека или затенение поверхности из-за незначительного различия между вычислениями глубины в шейдере и глубиной той же поверхности в теневом буфере. Одним из способов решения этой этой проблему является использование **депсбиас** и **слопескаледдепсбиас** при подготовке буфера теневого отображения. Идея заключается в том, чтобы отправить поверхности достаточно при отрисовке теневого буфера, чтобы результат сравнения (между теневым буфером z и шейдером z) был согласованным по поверхности, и не использовать локальную самотень.

Однако использование **депсбиас** и **слопескаледдепсбиас** может привести к новым проблемам отрисовки, если многоугольник, просматривает очень острый угол, приводит к тому, что уравнение смещения создает очень большое значение z. Это, в свою сторону, помещает многоугольник крайне далеко из исходной области на теневой карте. Одним из способов помочь обойти эту проблему является использование **депсбиаскламп**, который предоставляет верхнюю границу (положительное или отрицательное) на величину вычисляемого смещения z.

> [!Note]  
> Для [уровней компонентов](overviews-direct3d-11-devices-downlevel-intro.md) 9,1, 9,2, 9,3, **депсбиаскламп** не поддерживается.

 

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Стадия средства слияния вывода](d3d10-graphics-programming-guide-output-merger-stage.md)
</dt> </dl>

 

 




