---
title: Рекомендации для приложений расширения схемы
description: Этот раздел содержит рекомендации для приложений расширения схемы.
ms.assetid: 615e927e-a113-4557-b354-55a208a649eb
ms.tgt_platform: multiple
keywords:
- Рекомендации для приложений расширения схемы AD
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2393211eb910ce4bc490667398da7f38d212ddcf
ms.sourcegitcommit: 803f3ccd65bdefe36bd851b9c6e7280be9489016
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/17/2020
ms.locfileid: "104133663"
---
# <a name="recommendations-for-schema-extension-applications"></a>Рекомендации для приложений расширения схемы

В дополнение к предварительным требованиям для приложений расширения схемы рекомендуется использовать следующие рекомендации.

-   Найдите хозяин схемы. Выполните привязку к схеме на контроллере домена, который является хозяином схемы. Избегайте необязательного изменения роли хозяина схемы между контроллерами домена. Для привязки к контейнеру схемы на хозяине схемы. Дополнительные сведения см. в разделе [Предварительные требования для установки расширения схемы](prerequisites-for-installing-a-schema-extension.md).
-   Перед выполнением какого-либо действия проверьте свойство **алловедчилдклассесеффективе** контейнера схемы, чтобы убедиться, что можно создавать атрибуты и (или) классы. Если **attributeSchema** и **classSchema** не являются значениями в этом свойстве, у вас недостаточно прав для добавления атрибутов или классов в схему. Дополнительные сведения см. [в разделе пример кода для проверки прав на создание объектов схемы](example-code-for-checking-for-rights-to-create-schema-objects.md).
-   Убедитесь, что в реестре хозяина схемы правильно задано обновление схемы. Чтобы создать или задать это значение, восстановите его исходное состояние в рамках подпрограммы очистки приложения. Дополнительные сведения о проверке и установке этого значения см. [в разделе Включение изменений схемы в хозяине схемы](enabling-schema-changes-at-the-schema-master.md).
-   Перед добавлением атрибутов или классов убедитесь, что они еще не существуют. Если они существуют, убедитесь, что они являются теми же атрибутами или классами, которые вы добавляете, а не атрибутом или классом, созданным пользователем с другим синтаксисом и свойствами, несовместимыми с атрибутами или классами.

    Для атрибутов, запросите **CN**, **attributeID**, **governsID**, **lDAPDisplayName** и **schemaIDGUID** , чтобы убедиться, что они еще не используются. Если добавить набор связанных атрибутов (один канал прямой связи, одна обратная ссылка), убедитесь, что они еще не используются. Запрос для **governsID** , так как идентификатор объекта (OID) должен быть уникальным в атрибутах и классах.

    Для классов запросите **CN**, **governsID**, **attributeID**, **lDAPDisplayName** и **schemaIDGUID** , чтобы убедиться, что они еще не используются. Запрос **attributeID** , так как OID должен быть уникальным в классах и атрибутах.

    Дополнительные сведения о проверке конфликтов именования см. в разделе [пример кода для обнаружения конфликтов именования схемы](example-code-for-detecting-schema-naming-collisions.md).

    Если существуют атрибуты или классы, конфликтующие с новыми атрибутами или классами, приложение не должно применять изменения схемы.

-   Если такой конфликт существует, приложение не должно применять изменения схемы. Администратору схемы может потребоваться устранить конфликт, а затем снова запустить приложение. Кроме того, можно использовать другой **lDAPDisplayName** . Однако все приложения, использующие атрибут или объект, должны знать об этом изменении. Чтобы избежать конфликтов OID, получите идентификатор объекта из центра регистрации имен ISO.
-   Если приложение зависит от атрибутов или классов, которые были добавлены, обновите кэш схемы, прежде чем добавлять новые атрибуты или классы, зависящие от этих атрибутов или классов. Имейте в виду, что атрибут **счемаупдатенов** работает синхронно. То есть вызов метода [**iAds::P UT**](/windows/desktop/api/iads/nf-iads-iads-put) будет заблокирован до тех пор, пока не будет обновлен кэш схемы. При возвращении вызова кэш схемы был обновлен, а новые атрибуты и (или) классы становятся доступными.

    Дополнительные сведения об обновлении кэша схемы см. [в разделе пример кода для обновления кэша схемы](example-code-for-updating-the-schema-cache.md).

 

 