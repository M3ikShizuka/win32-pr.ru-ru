---
title: Опрос изменений с помощью USNChanged
description: Изменения из Active Directory также могут быть получены путем запроса атрибута uSNChanged, что позволяет избежать ограничений, касающихся элемента управления DirSync.
ms.assetid: 83bda359-09e5-4abf-8f60-9c63bccfcdd1
ms.tgt_platform: multiple
keywords:
- Опрос изменений с помощью USNChanged AD
- USNChanged AD
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a8e062c84fae575f837f45d78be7c92e5e284c1e
ms.sourcegitcommit: 803f3ccd65bdefe36bd851b9c6e7280be9489016
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/17/2020
ms.locfileid: "103890396"
---
# <a name="polling-for-changes-using-usnchanged"></a>Опрос изменений с помощью USNChanged

Элемент управления DirSync является мощным и эффективным, но имеет два существенных ограничения:

-   Только для приложений с высоким уровнем привилегий. для использования элемента управления DirSync приложение должно запускаться под учетной записью с правами доступа к **\_ \_ \_ имени агента синхронизации SE** на контроллере домена. Некоторые учетные записи имеют высокий уровень привилегий, поэтому приложение, использующее элемент управления DirSync, не может быть запущено обычными пользователями.
-   Без поддерева области: элемент управления DirSync возвращает все изменения, которые происходят в контексте именования. Приложение, заинтересованное только в случае изменений, происходящих в небольшом поддереве контекста именования, должно Уэйд с помощью множества несущественных изменений, которые неэффективны как для приложения, так и для контроллера домена.

Изменения из Active Directory также могут быть получены путем запроса атрибута [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) , что позволяет избежать ограничений, касающихся элемента управления DirSync. Этот вариант не лучше, чем элемент управления DirSync, так как он включает передачу всех атрибутов при изменении любого атрибута и требует больше работы от разработчика приложения, чтобы правильно обрабатывал определенные сценарии сбоя. В настоящее время это лучший способ написания определенных приложений для отслеживания изменений.

Когда контроллер домена изменяет объект, он устанавливает атрибут [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) этого объекта в значение, превышающее предыдущее значение атрибута **uSNChanged** для этого объекта, и больше текущего значения атрибута **uSNChanged** для всех остальных объектов, хранящихся на этом контроллере домена. Как следствие, приложение может найти недавно измененный объект на контроллере домена, находя объект с наибольшим значением **uSNChanged** . Во втором последнем измененном объекте на контроллере домена будет иметься второе наибольшее значение **uSNChanged** и т. д.

Атрибут [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) не реплицируется, поэтому считывание атрибута **uSNChanged** объекта на двух разных контроллерах домена обычно приводит к различным значениям.

Например, атрибут [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) можно использовать для наблюдения за изменениями в поддереве S. Во-первых, выполните полную синхронизацию поддерева. Предположим, что максимальное значение **uSNChanged** для любого объекта в S равно U. периодически запрашивает все объекты в поддеревьях, значение **USNChanged** которых больше U. Запрос возвратит все объекты, которые были изменены с момента полной синхронизации. Задайте для вас самый крупный **uSNChanged** из этих измененных объектов, и вы сможете снова опросить.

Ниже перечислены тонкости реализации приложения синхронизации [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) .

-   Используйте атрибут **Хигхесткоммиттедусн** RootDSE, чтобы привязать фильтры [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) . Это значит, что перед началом полной синхронизации прочтите **хигхесткоммиттедусн** подключенного контроллера домена. Затем выполните запрос полной синхронизации (с использованием страничных результатов) для инициализации базы данных. По завершении сохраните значение **хигхесткоммиттедусн** , считанное до полного запроса синхронизации. значение, чтобы использовать в качестве нижней границы атрибута **uSNChanged** для следующей синхронизации. Позже, чтобы выполнить добавочную синхронизацию, повторно считайте атрибут **хигхесткоммиттедусн** RootDSE. Затем запросите соответствующие объекты, используя страничные результаты, у которых **uSNChanged** больше нижних границ значения атрибута **uSNChanged** , сохраненного из предыдущей синхронизации. Обновите базу данных, используя эти сведения. По завершении обновите нижние границы атрибута **uSNChanged** из значения **хигхесткоммиттедусн** , считанного перед добавочным запросом синхронизации. Всегда храните нижние границы значения атрибута **uSNChanged** в том же хранилище, которое приложение синхронизирует с содержимым контроллера домена.

    При выполнении этой процедуры, а не на основе значений [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) в извлеченных объектах, не нужно, чтобы сервер повторно просматривает обновленные объекты, находящиеся за пределами набора, применимого к приложению.

-   Так как [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) является нереплицируемым атрибутом, приложение должно быть привязано к тому же контроллеру домена при каждом его запуске. Если не удается выполнить привязку к этому контроллеру домена, он должен либо подождать, пока он не сможет это сделать, либо привязать его к новому контроллеру домена и выполнить полную синхронизацию с этим контроллером домена. Когда приложение будет находиться в аффилированной организации с контроллером домена, оно записывает DNS-имя этого контроллера домена в стабильное хранилище, которое является тем же хранилищем, которое оно согласуется с содержимым контроллера домена. Затем он использует сохраненное имя DNS для привязки к тому же контроллеру домена для последующих синхронизаций.
-   Приложение должно обнаружить, когда контроллер домена, с которым он связан в данный момент, был восстановлен из резервной копии, так как это может привести к несогласованности. Если приложение имеет аффилированные лица с контроллером домена, он кэширует "идентификатор вызова" этого контроллера домена в стабильном хранилище, то есть то же хранилище, которое оно согласуется с содержимым контроллера домена. "Идентификатор вызова" контроллера домена — это идентификатор GUID, хранящийся в атрибуте **invocationID** объекта службы контроллера домена. Чтобы получить различающееся имя объекта службы контроллера домена, прочитайте атрибут **дссервиценаме** для RootDSE.

    Имейте в виду, что при восстановлении стабильного хранилища приложения из резервной копии проблемы с согласованностью не возникают, так как имя контроллера домена, идентификатор вызова и Нижняя граница значения атрибута [**uSNChanged**](/windows/desktop/ADSchema/a-usnchanged) хранятся вместе с данными, синхронизированными с содержимым контроллера домена.

-   Используйте разбиение по страницам при запросе к серверу как полной, так и добавочной синхронизации, чтобы избежать возможности одновременного извлечения больших результирующих наборов. Дополнительные сведения см. в разделе [Указание других параметров поиска](specifying-other-search-options.md).
-   Выполнение запросов на основе индекса во избежание принудительного хранения больших промежуточных результатов на сервере при использовании страничных результатов. Дополнительные сведения см. в разделе [индексированные атрибуты](indexed-attributes.md).
-   В общем случае не используйте сортировку результатов поиска на стороне сервера, что может привести к принудительному хранению и сортировке больших промежуточных результатов на сервере. Это относится как к полной, так и к добавочной синхронизации. Дополнительные сведения см. в разделе [Указание других параметров поиска](specifying-other-search-options.md).
-   Не обрабатывайте родительские условия надлежащим образом. Приложение может распознать объект до того, как он распознает его родительский элемент. В зависимости от приложения это может быть проблемой или не может быть. Приложение всегда может считывать текущее состояние родителя из каталога.
-   Чтобы выполнить обработку перемещенных или удаленных объектов, сохраните атрибут [**objectGUID**](/windows/desktop/ADSchema/a-objectguid) каждого отслеживающего объекта. Атрибут **objectGUID** объекта остается неизменным независимо от того, где он перемещен в пределах леса.
-   Чтобы выполнить обработку перемещенных объектов, выполните периодическую полную синхронизацию или увеличьте область поиска и отфильтровывайте неинтересные изменения на стороне клиента.
-   Чтобы обрабатывал удаленные объекты, выполните периодическую полную синхронизацию или выполните отдельный Поиск удаленных объектов при выполнении добавочной синхронизации. При запросе удаленных объектов Извлеките [**objectGUID**](/windows/desktop/ADSchema/a-objectguid) удаленных объектов, чтобы определить объекты, которые нужно удалить из базы данных. Дополнительные сведения см. в разделе [получение удаленных объектов](retrieving-deleted-objects.md).
-   Имейте в виду, что результаты поиска включают только те объекты и атрибуты, которые у вызывающего объекта есть разрешение на чтение (на основе дескрипторов безопасности и списков DACL для различных объектов). Дополнительные сведения см. [в разделе влияние безопасности на запросы](effects-of-security-on-queries.md).

Дополнительные сведения и пример кода, демонстрирующий основные сведения о приложении синхронизации USNChanged, см. в разделе [пример кода для получения изменений с помощью USNChanged](example-code-to-retrieve-changes-using-usnchanged.md).

 

 