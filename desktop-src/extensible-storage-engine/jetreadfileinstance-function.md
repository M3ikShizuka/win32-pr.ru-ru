---
description: Дополнительные сведения о функции Жетреадфилеинстанце
title: Функция JetReadFileInstance
TOCTitle: JetReadFileInstance Function
ms:assetid: b17b4b43-86e5-4507-8a85-bbd5eac0aa3c
ms:mtpsurl: https://msdn.microsoft.com/library/Gg294060(v=EXCHG.10)
ms:contentKeyID: 32765675
ms.date: 04/11/2016
ms.topic: reference
api_name:
- JetReadFileInstance
topic_type:
- apiref
- kbArticle
api_type:
- COM
- DLLExport
api_location:
- ESENT.DLL
ROBOTS: INDEX,FOLLOW
ms.openlocfilehash: ec5c83bb78528a61bbe7af9bafa59567100ee9da669915b96230bfb97b8bf390
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "117891120"
---
# <a name="jetreadfileinstance-function"></a>Функция JetReadFileInstance


_**Применимо к:** Windows | Windows Сервером_

## <a name="jetreadfileinstance-function"></a>Функция JetReadFileInstance

Функция **жетреадфилеинстанце** извлекает содержимое файла, открытого с помощью функции [жетопенфилеинстанце](./jetopenfileinstance-function.md) .

**Windows xp**: **жетреадфилеинстанце** появился в Windows XP.

```cpp
    JET_ERR JET_API JetReadFileInstance(
      __in          JET_INSTANCE instance,
      __in          JET_HANDLE hfFile,
      __out         void* pv,
      __in          unsigned long cb,
      __out_opt     unsigned long* pcb
    );
```

### <a name="parameters"></a>Параметры

*вхождение*

Экземпляр, используемый для конкретного вызова API.

обратите внимание, что для Windows 2000, вариант API, который принимает этот параметр, недоступен, так как поддерживается только один экземпляр. В этом случае подразумевается использование этого одного глобального экземпляра.

для Windows XP и более поздних выпусков можно вызвать вариант API, который не принимает этот параметр, только если ядро находится в устаревшем режиме (режим совместимости Windows 2000) в случаях, когда поддерживается только один экземпляр. В противном случае операция завершится ошибкой и возвратит ошибку JET_errRunningInMultiInstanceMode.

*хффиле*

Описатель файла для чтения.

*PV*

Выходной буфер, который будет принимать данные файла.

*CB*

Максимальный размер выходного буфера в байтах.

*пкб*

Фактический объем получаемых файловых данных.

### <a name="return-value"></a>Возвращаемое значение

эта функция упрощает возврат любых [JET_ERR](./jet-err.md) типов данных, определенных в API-интерфейсе расширяемого служба хранилища Engine (ESE). дополнительные сведения об ошибках JET см. в разделе [расширенные ошибки служба хранилища Engine](./extensible-storage-engine-errors.md) и [параметры обработки ошибок](./error-handling-parameters.md).

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th><p>Код возврата</p></th>
<th><p>Значение</p></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><p>JET_errSuccess</p></td>
<td><p>Операция выполнена успешно.</p></td>
</tr>
<tr class="even">
<td><p>JET_errBackupAbortByServer</p></td>
<td><p>Не удалось выполнить операцию, так как текущая Внешняя резервная копия была прервана вызовом функции <a href="gg269240(v=exchg.10).md">жетстопсервице</a> . эта ошибка будет возвращена только Windows XP и более поздних версий Windows.</p></td>
</tr>
<tr class="odd">
<td><p>JET_errClientRequestToStopJetService</p></td>
<td><p>Невозможно выполнить операцию, так как все действия в экземпляре, связанном с сеансом, были прекращены в результате вызова функции <a href="gg269240(v=exchg.10).md">жетстопсервице</a> .</p></td>
</tr>
<tr class="even">
<td><p>JET_errInstanceUnavailable</p></td>
<td><p>Невозможно выполнить операцию, так как в экземпляре, связанном с сеансом, произошла неустранимая ошибка, из-за которой доступ ко всем данным должен быть отозван для защиты целостности этих данных. эта ошибка будет возвращена только Windows XP и более поздних версий Windows.</p></td>
</tr>
<tr class="odd">
<td><p>JET_errInvalidParameter</p></td>
<td><p>Один из указанных параметров содержит либо непредвиденное значение, либо значение, которое не имеет смысла при объединении со значением другого параметра. Это может произойти для функции <strong>жетреадфилеинстанце</strong> при выполнении любого из следующих условий:</p>
<ul>
<li><p>Указан недопустимый обработчик экземпляра. Windows XP и более поздних версий Windows.</p></li>
<li><p>Размер выходного буфера не кратен размеру страницы базы данных (<a href="gg269337(v=exchg.10).md">JET_paramDatabasePageSize</a>). Windows XP и более поздних версий Windows.</p></li>
<li><p>Размер выходного буфера меньше трех страниц базы данных (<a href="gg269337(v=exchg.10).md">JET_paramDatabasePageSize</a>), и это первый вызов функции <strong>жетреадфилеинстанце</strong> для указанного маркера. Windows XP и более поздних версий Windows.</p></li>
</ul></td>
</tr>
<tr class="even">
<td><p>JET_errLogReadVerifyFailure</p></td>
<td><p>Не удалось выполнить операцию, так как при чтении файла журнала транзакций обнаружено неустранимое повреждение данных. эта ошибка будет возвращена только Windows XP и более поздних версий Windows.</p></td>
</tr>
<tr class="odd">
<td><p>JET_errNoBackup</p></td>
<td><p>Не удалось выполнить операцию, так как не выполняется внешняя архивация.</p></td>
</tr>
<tr class="even">
<td><p>JET_errNotInitialized</p></td>
<td><p>Невозможно выполнить операцию, так как экземпляр, связанный с этим сеансом, еще не инициализирован.</p></td>
</tr>
<tr class="odd">
<td><p>JET_errReadVerifyFailure</p></td>
<td><p>Не удалось выполнить операцию, так как при чтении страницы базы данных из файла базы данных или файла исправления в файл обнаружено неустранимое повреждение данных.</p></td>
</tr>
<tr class="even">
<td><p>JET_errRestoreInProgress</p></td>
<td><p>Невозможно выполнить операцию, так как в экземпляре, связанном с этим сеансом, выполняется операция восстановления.</p></td>
</tr>
<tr class="odd">
<td><p>JET_errRunningInMultiInstanceMode</p></td>
<td><p>не удалось выполнить операцию, так как была предпринята попытка использовать модуль в устаревшем режиме (режим совместимости Windows 2000) в случае, если поддерживается только один экземпляр, но несколько экземпляров уже существуют.</p></td>
</tr>
<tr class="even">
<td><p>JET_errTermInProgress</p></td>
<td><p>Невозможно выполнить операцию, так как работа экземпляра, связанного с этим сеансом, завершается.</p></td>
</tr>
</tbody>
</table>


При успешном выполнении следующий фрагмент данных из файла будет считан в выходной буфер. Также будет возвращено фактическое число полученных байтов. Смещение файла, на котором будет выполняться следующее считывание, будет расширено этим объемом.

В случае сбоя состояние выходного буфера не определено. Сбой приведет к отмене всего процесса резервного копирования для текущего экземпляра. в Windows XP и более поздних версиях Windows резервное копирование не будет отменено, если при чтении файла базы данных произошла ошибка. Однако резервная копия этого файла базы данных по-прежнему будет отменена, и соответствующий маркер будет автоматически закрыт.

#### <a name="remarks"></a>Remarks

Любой вызов функции **жетреадфилеинстанце** , выполненной с помощью маркера, который уже вернул все данные в базовом файле (например, если предыдущий вызов вернул меньшее число байтов, чем размер выходного буфера), всегда будет успешно выполнен, но возвратит нулевые байты данных.

Для повышения производительности резервного копирования следует использовать большой выходной буфер. Может потребоваться поэкспериментировать, чтобы найти оптимальный компромисс между потреблением ресурсов и пропускной способностью в конкретной ситуации. В любом случае размер выходного буфера не должен превышать 64 КБ. Указатель, передаваемый в **жетреадфилеинстанце** , должен быть согласован с границей страницы памяти (4 КБ или 8 КБ). Это можно сделать, вызвав функцию **VirtualAlloc** .

Несколько одновременных вызовов **жетреадфилеинстанце** , выполненных с помощью одного и того же файла, не поддерживаются. Это означает, что невозможно поставить в очередь несколько буферов для параллельного чтения в одном и том же файле для достижения высокой последовательной пропускной способности. Вместо этого следует использовать один большой буфер.

Если вы настроили определенный экземпляр таким образом, что включена очистка страниц базы данных (см. параметр [JET_paramCircularLog](./transaction-log-parameters.md) в разделе [системные параметры](./extensible-storage-engine-system-parameters.md)), удаленные данные будут удалены из базы данных как побочный результат вызова **жетреадфилеинстанце** для файла базы данных.

Очень важно понимать, как взаимодействуют резервные копии и повреждения данных. Если ядро СУБД обнаружит повреждение данных во время резервного копирования, произойдет сбой резервного копирования затронутой базы данных или всего экземпляра. Это осознанное решение по проектированию, предназначенное для защиты от потери данных. Если ядро СУБД позволило успешно выполнить резервное копирование, при котором произошло повреждение данных, возможно, что в результате может быть отклонено старое, неповрежденное резервное копирование. Это было бы неудачно, так как можно было бы исправить повреждение данных на динамическом экземпляре, восстановив эту резервную копию и воспроизводящую все файлы журнала транзакций для этой базы данных. Этот сценарий с нулевой потерей данных предполагает, что циклическое ведение журнала не включено (см. [JET_paramCircularLog](./transaction-log-parameters.md) в разделе [системные параметры](./extensible-storage-engine-system-parameters.md)).

Также важно понимать, что случаи повреждения данных обычно сначала обнаруживаются во время потоковой архивации. Это обусловлено тем, что потоковая Архивация является единственным процессом, который ежедневно сканирует каждую отдельную страницу файла базы данных. Также вполне вероятно, что потоковая Архивация будет первым процессом для обнаружения ранних нарушений аппаратного сбоя, вызванных непостоянными ошибками повреждения данных, из-за объема данных, получаемых при резервном копировании, и скорости, с которой эти данные извлекаются.

Повреждение данных обнаруживается ядром СУБД с помощью блочных контрольных сумм. Эти контрольные суммы задаются непосредственно перед записью страницы базы данных и проверяются на прочитанной странице базы данных. Эта схема позволяет ядру СУБД определить, что данные повреждены в некоторый момент, но не позволяют ядру СУБД определить источник этого повреждения. Исторически экземпляры такого повреждения данных поступили из источников, отличных от самого ядра СУБД.

#### <a name="requirements"></a>Требования

<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<tbody>
<tr class="odd">
<td><p>Клиент</p></td>
<td><p>требуется Windows Vista или Windows XP.</p></td>
</tr>
<tr class="even">
<td><p>Сервер</p></td>
<td><p>требуется Windows server 2008 или Windows server 2003.</p></td>
</tr>
<tr class="odd">
<td><p>Заголовок</p></td>
<td><p>Объявляется в ESENT. h.</p></td>
</tr>
<tr class="even">
<td><p>Библиотека</p></td>
<td><p>Использует ESENT. lib.</p></td>
</tr>
<tr class="odd">
<td><p>DLL</p></td>
<td><p>Требуется ESENT.dll.</p></td>
</tr>
</tbody>
</table>


#### <a name="see-also"></a>См. также

[JET_ERR](./jet-err.md)  
[JET_HANDLE](./jet-handle.md)  
[JET_INSTANCE](./jet-instance.md)  
[жетопенфилеинстанце](./jetopenfileinstance-function.md)  
[жетстопсервице](./jetstopservice-function.md)  
[Системные параметры](./extensible-storage-engine-system-parameters.md)
