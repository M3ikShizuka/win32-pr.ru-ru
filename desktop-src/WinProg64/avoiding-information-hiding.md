---
title: Предотвращение скрытия информации
description: Иногда программы намеренно или непреднамеренно скрывают информацию из механизма маршалирования RPC.
ms.assetid: 016b9221-092d-4c25-a396-4f41dcdfb3cf
keywords:
- Обратная совместимость 64-разрядное программирование для Windows
- проблемы совместимости с 64-разрядным программированием Windows
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2f4b9e4ba7ed5165378beb93005243af03f9e469
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104413224"
---
# <a name="avoiding-information-hiding"></a>Предотвращение скрытия информации

Иногда программы намеренно или непреднамеренно скрывают информацию из механизма маршалирования RPC. Ниже приведен ряд примеров.

-   Отправка структуры данных в виде блока байтов, не имеющего различий
-   Использование производительности с помощью побочного действия метода для передачи дополнительных данных по каналу передачи
-   Попытка маскировки маркера путем передачи его в виде **DWORD** или **ulong**

Эти приемы почти гарантируют проблемы совместимости даже перед переносом приложения на 64-разрядную версию Windows.

Вместо того чтобы отправлять контекст сервера в виде **DWORD** в стандартном вызове удаленной процедуры, используйте контекстный маркер для предоставления непрозрачного маркера контексту сервера, который удерживается от имени клиента. Контексты определяются идентификаторами GUID, определенными во время выполнения RPC, когда сервер создает контекстный обработчик для клиента. Указатель не используется по каналу передачи, и операция полностью прозрачна в пределах 32-или 64-разрядной границы. Дополнительные сведения об использовании дескрипторов контекста см. в разделе [дескрипторы контекста](/windows/desktop/Rpc/context-handles).

Интерфейсы DCOM не могут использовать дескрипторы контекста, так как COM обеспечивает собственное управление контекстом. Вместо создания маркера контекста можно передать указатель интерфейса на COM-объект. Затем можно вызвать методы непосредственно через указатель интерфейса или поместить указатель внутрь других вызовов. Чтобы освободить серверный объект, клиент вызывает метод **освобождения** интерфейса через указатель интерфейса.

Опять же, могут возникнуть ситуации, когда нельзя изменить исходный дизайн кода, который вы переносите. Если не существует способа избежать отправки указателя по каналу в виде **DWORD**, необходимо реализовать некоторую форму сопоставления на стороне сервера между значениями и указателями **DWORD** . Одним из способов сделать это является изменение указателей в клиентской части приложения на типы точности указателей, такие как **ulong \_ ptr** или **DWORD \_ ptr**. Затем используйте вызов MIDL в \[ [**\_ качестве**](/windows/desktop/Midl/call-as) \] атрибута, чтобы разместить указатели на канале как значения **DWORD** . Обертка на стороне клиента должна передавать аргументы только вместе. Оболочка на стороне сервера обрабатывает сопоставление обоих типов. Аналогичным образом можно использовать либо \[ атрибут [**передать \_ как**](/windows/desktop/Midl/transmit-as) , \] либо \[ атрибут [**представить \_ как**](/windows/desktop/Midl/represent-as) \] для преобразования данных в формат с обратной совместимостью для представления сети.

Если обратная совместимость не является проблемой или если этот обработчик не используется для удаленных вызовов и вы уверены, что удаленные вызовы между 32 и 64-разрядными процессами никогда не будут выполняться, можно переопределить аргумент как **ULONG64**. При необходимости можно изменить 32-разрядное приложение, чтобы передать пользователю **параметр DWORD** . Кроме того, можно создать отдельные заглушки из отдельных файлов IDL для каждой платформы, используя **DWORD** в 32-разрядной Windows и **ULONG64** в 64-разрядной версии Windows.

 

 