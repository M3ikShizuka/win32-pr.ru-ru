---
title: Правила использования указателей
description: перенос кода для компиляции как 32, так и 64-разрядной версии Microsoft Windows прост. Необходимо выполнить только несколько простых правил для указателей приведения и использовать новые типы данных в коде. Ниже приведены правила обработки указателей.
ms.assetid: 4c38bee2-fa1c-493f-a12d-e673df4d4895
keywords:
- правила использования указателей 64-разрядного Windows программирования
- управление указателями 64-разрядное Windows программирование
- программирование приведения указателей 64-bit Windows
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 56125c290f87747251473bde6e845e97a9e9e6c3d7b6be2d3c6bb144d7199c7a
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "117927984"
---
# <a name="rules-for-using-pointers"></a>Правила использования указателей

перенос кода для компиляции как 32, так и 64-разрядной версии Microsoft Windows прост. Необходимо выполнить только несколько простых правил для указателей приведения и использовать новые типы данных в коде. Ниже приведены правила обработки указателей.

1.  Не выведите указатели на **int**, **Long**, **ulong** или **DWORD**.

    Если необходимо привести указатель для проверки некоторых битов, задать или очистить биты или иным образом манипулировать его содержимым, используйте тип данных **uint \_ ptr** или **int \_** PTR. эти типы являются целочисленными типами, которые масштабируются до размера указателя для 32-и 64-разрядных Windows (например, **ULONG** для 32-bit Windows и \_ int64 для 64-bit Windows). Например, предположим, что выполняется перенос следующего кода:

    `ImageBase = (PVOID)((ULONG)ImageBase | 1);`

    В рамках процесса переноса вы измените код следующим образом:

    `ImageBase = (PVOID)((ULONG_PTR)ImageBase | 1);`

    Используйте **uint \_ ptr** и **int \_ ptr** там, где это необходимо (и если вы не уверены, являются ли они обязательными, их использование будет невозможным в случае). Не приведите указатели к типам **ulong**, **Long**, **int**, **uint** или **DWORD**.

    Обратите внимание, что **Handle** определяется как **void \* *_, поэтому*** при приведении значения _ Handle к значению типа **ulong** для проверки, установки или очистки младших разрядов с низким приоритетом 2 возникает ошибка 64-bit Windows.

2.  Используйте функцию **птртолонг** или **птртаулонг** для усечения указателей.

    Если необходимо усечь указатель до 32-разрядного значения, используйте функцию **птртолонг** или **птртаулонг** (определенную в басетсд. h). Эти функции отключают предупреждение об усечении указателя на время вызова.

    Используйте эти функции внимательно. После преобразования переменной указателя с помощью одной из этих функций никогда не используйте ее в качестве указателя. Эти функции усекаются верхние 32 бит адреса, которые обычно требуются для доступа к памяти, на которую ссылается указатель. Использование этих функций без тщательного рассмотрения приводит к ненадежному коду.

3.  Будьте внимательны при использовании \_ значений указателя 32 в коде, который может быть скомпилирован в виде 64-разрядного кода. Компилятор будет расширять указатель, когда он назначается собственному указателю в 64-разрядном коде, а указатель не расширяется без нуля.
4.  Будьте внимательны при использовании \_ значений указателя 64 в коде, который может быть скомпилирован в виде 32-разрядного кода. Компилятор будет расширять указатель в 32-разрядном коде, не расширяя указатель на ноль.
5.  Будьте внимательны при использовании параметров OUT.

    Например, предположим, что имеется функция, определенная следующим образом:

    `void func( OUT PULONG *PointerToUlong );`

    Не вызывайте эту функцию, как показано ниже.

    ``` syntax
    ULONG ul;
    PULONG lp;
    func((PULONG *)&ul);
    lp = (PULONG)ul;
    ```

    Вместо этого используйте следующий вызов.

    ``` syntax
    PULONG lp;
    func(&lp);
    ```

    Приведение &UL к **пулонг \*** предотвращает ошибку компилятора, но функция будет записывать 64-битное значение указателя в память в &UL. этот код работает на 32-разрядном Windows, но это приведет к повреждению данных в 64-разрядной Windows и будет иметь незаметное, сложное для поиска повреждение. Нижняя строка: не воспроизводить взятия с помощью кода C — простой и простой — лучше.

6.  Будьте внимательны с использованием интерфейсов с полиморфизмом.

    Не создавайте функции, которые принимают параметры **DWORD** для данных с преформациюми. Если данные могут быть указателями или целочисленными значениями, используйте \_ Тип uint PTR или **PVOID** .

    Например, не следует создавать функцию, которая принимает массив параметров исключений, типизированных как значения **типа DWORD** . Массив должен быть массивом значений типа **DWORD \_** . Таким образом, элементы массива могут содержать адреса или 32-разрядные целочисленные значения. (Общее правило состоит в том, что если исходный тип — **DWORD** , и он должен быть шириной указателя, преобразуйте его в значение **типа DWORD \_** . Именно поэтому существуют соответствующие типы точности указателей.) Если у вас есть код, который использует **DWORD**, **ULONG** или другие 32-разрядные типы в полиморфизме (то есть необходимо, чтобы параметр или член структуры содержал адрес), используйте **uint \_ ptr** вместо текущего типа.

7.  Используйте новые функции класса Window.

    Если у вас есть закрытые данные окон или классов, содержащие указатели, в коде потребуется использовать следующие новые функции:

    -   [**жеткласслонгптр**](/windows/win32/api/winuser/nf-winuser-getclasslongptra)
    -   [**жетвиндовлонгптр**](/windows/win32/api/winuser/nf-winuser-getwindowlongptra)
    -   [**сеткласслонгптр**](/windows/win32/api/winuser/nf-winuser-setclasslongptra)
    -   [**сетвиндовлонгптр**](/windows/win32/api/winuser/nf-winuser-setwindowlongptra)

    эти функции можно использовать как в 32, так и в 64-бит Windows, но они требуются для 64-разрядных Windows. Подготовьтесь к переходу, используя эти функции сейчас.

    Кроме того, необходимо получить доступ к указателям или дескрипторам в закрытых данных класса с помощью новых функций в 64-разрядном Windows. Чтобы помочь вам найти эти случаи, следующие индексы не определяются в файле WinUser. h во время компиляции 64-bit:

    -   ГВЛ \_ WndProc
    -   ГВЛ \_ HINSTANCE
    -   ГВЛ \_ хвдпарент
    -   ГВЛый \_ USERDATA

    Вместо этого Winuser. h определяет следующие новые индексы:

    -   ГВЛП \_ WndProc
    -   ГВЛП \_ HINSTANCE
    -   ГВЛП \_ хвндпарент
    -   ГВЛПый \_ USERDATA
    -   \_идентификатор гвлп

    Например, следующий код не компилирует:

    `SetWindowLong(hWnd, GWL_WNDPROC, (LONG)MyWndProc);`

    Его следует изменить следующим образом:

    `SetWindowLongPtr(hWnd, GWLP_WNDPROC, (LONG_PTR)MyWndProc);`

    При задании элемента **кбвндекстра** структуры [**вндкласс**](/windows/win32/api/winuser/ns-winuser-wndclassa) необходимо зарезервировать достаточно места для указателей. Например, если в настоящее время выполняется резервирование значения параметра sizeof (DWORD) для указателя, то Зарезервируйте значение в \_ байтах sizeof (DWORD PTR).

8.  Доступ ко всем данным окон и классов с помощью **\_ смещения поля**.

    Обычно доступ к данным окна осуществляется с помощью жестко заданных смещений. Этот метод не является переносимым на 64-разрядный Windows. Чтобы сделать код переносимым, получите доступ к данным окна и класса с помощью макроса **\_ смещения поля** . Не считайте, что второй указатель имеет смещение 4.

9.  Типы **lParam**, **wParam** и **lResult** изменяют размер вместе с платформой.

    При компиляции 64-разрядного кода эти типы расширяются до 64 бит, так как они обычно содержат указатели или целочисленные типы. Не следует смешивать эти значения с **DWORD**, **ulong**, **uint**, **int**, **int** или **Long** . Изучите использование этих типов и убедитесь, что значения не были случайно усечены.

 

 