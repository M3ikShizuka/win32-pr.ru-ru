---
title: Дополнительные сведения
description: При переносе кода учитывайте следующие моменты.
ms.assetid: 2d649a09-b593-477a-9b4f-d2404784f4b0
keywords:
- советы по переносу 64-разрядного Windowsного программирования
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 199f522bebf0d6d5552aa81d99aab12f77685dea35eb329b9e7d11d46b4f1500
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118561540"
---
# <a name="additional-considerations"></a>Дополнительные сведения

При переносе кода учитывайте следующие моменты.

- Следующее допущение больше не является допустимым:

   ```syntax
   #ifdef _WIN32 // Win32 code
      ...
   #else         // Win16 code
      ...
   #endif
   ```

   Однако 64-разрядный компилятор определяет \_ Win32 для обратной совместимости.

- Следующее допущение больше не является допустимым:

   ```syntax
   #ifdef _WIN16 // Win16 code
      ...
   #else         // Win32 code
      ...
   #endif
   ```

   В этом случае предложение else может представлять \_ Win32 или \_ Win64.

- Будьте внимательны при выравнивании типов данных. Макрос **\_ выравнивания типа** возвращает требования к выравниванию для типа данных. Например: `TYPE_ALIGNMENT( KFLOATING_SAVE )` = = 4 на x86, 8 для процессора Intel Itanium `TYPE_ALIGNMENT( UCHAR )` = = 1 везде

    Например, код ядра, который в настоящее время выглядит следующим образом:

    ```syntax
    ProbeForRead( UserBuffer, UserBufferLength, sizeof(ULONG) );
    ```

    возможно, следует изменить на:

    ```syntax
    ProbeForRead( UserBuffer, UserBufferLength, TYPE_ALIGNMENT(IOCTL_STRUC) );
    ```

    Автоматические исправления исключений выравнивания в режиме ядра отключены для систем Intel Itanium.

- Будьте внимательны при отсутствии операций. Рассмотрим следующий пример.

    ```syntax
    UINT_PTR a; 
    ULONG b;
    a = a & ~(b - 1);
    ```

    Проблема заключается в том, что ~ (b – 1) создает "Символ 0x0000 0000 XXXX XXXX", а не "0xFFFF FFFF XXXX XXXX". Компилятор не определит это. Чтобы устранить эту проблему, измените код следующим образом:

    ```syntax
    a = a & ~((UINT_PTR)b - 1);
    ```

- Будьте внимательны при выполнении неподписанных и подписанных операций. Рассмотрим следующий пример.

    ```syntax
    LONG a;
    ULONG b;
    LONG c;

    a = -10;
    b = 2;
    c = a / b;
    ```

    Результат неожиданно большой. Правило заключается в том, что если любой из операндов не имеет знака, результат будет неподписанным. В предыдущем примере выражение преобразуется в значение без знака, разделенное на b, и результат, хранящийся в c. Преобразование не требует числовой обработки.

    В качестве другого примера рассмотрим следующее.

    ```syntax
    ULONG x;
    LONG y;
    LONG *pVar1;
    LONG *pVar2;

    pVar2 = pVar1 + y * (x - 1);
    ```

    Проблема возникает, поскольку x не подписан, что делает все выражение неподписанным. Это подходит, если y не является отрицательным. В этом случае y преобразуется в значение без знака, выражение вычисляется с использованием 32-разрядной точности, масштабируется и добавляется в pVar1. 32-разрядное отрицательное число без знака преобразуется в большое 64-разрядное положительное число, которое дает неверный результат. Чтобы устранить эту проблему, объявите x как значение со знаком или явно присвоить его **Long** в выражении.

- Будьте внимательны при выделении распределения размера поэтапного выполнения. Пример.

    ```syntax
    struct xx {
       DWORD NumberOfPointers;
       PVOID Pointers[100];
    };
    ```

    Следующий код является неправильным, так как компилятор будет размещает структуру с дополнительными 4 байтами для создания 8-байтового выравнивания:

    ```syntax
    malloc(sizeof(DWORD) + 100*sizeof(PVOID));
    ```

    Следующий код правильный:

    ```syntax
    malloc(offsetof(struct xx, Pointers) + 100*sizeof(PVOID));
    ```

- Не передавайте `(HANDLE)0xFFFFFFFF` в такие функции, как [**CreateFileMapping**](/windows/desktop/api/winbase/nf-winbase-createfilemappinga). Вместо этого используйте **недопустимое \_ \_ значение Handle**.
- При печати строки используйте правильные описатели формата. Используйте% p для печати указателей в шестнадцатеричном формате. Это лучший вариант для печати указателей. Microsoft Visual C++ поддерживает% I для печати данных полиморфизма. Visual C++ также поддерживает% I64 для печати значений 64 бит.

 

 