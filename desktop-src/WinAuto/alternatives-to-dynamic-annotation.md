---
title: Альтернативы динамической аннотации
description: Альтернативы динамической аннотации
ms.assetid: d8019c65-620b-4aa2-a631-cc32f34e5510
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4af7582ec0fa3f317a0fabbdde0474c6a2e4d0b361062243d7518edf317477ff
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "120122434"
---
# <a name="alternatives-to-dynamic-annotation"></a>Альтернативы динамической аннотации

Существуют и другие способы предоставления настраиваемой поддержки [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) для элементов пользовательского интерфейса, и в некоторых случаях они являются правильным решением. До динамической аннотации эти альтернативные методы были единственными вариантами, доступными для разработчиков. Они включают реализацию всех интерфейсов **IAccessible** и программных методов.

## <a name="implementing-all-of-the-iaccessible-interface"></a>Реализация всех интерфейсов IAccessible

Одним из альтернативных способов является реализация всего интерфейса [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) . Этот подход часто требуется для пользовательских элементов управления или совершенно различных элементов пользовательского интерфейса. Однако затраты на разработку и тестирование настолько важны, что их следует избегать, если не действительно требуется. Если целью является изменение одного свойства, затраты трудно выровнять.

## <a name="programmatic-techniques"></a>Программные методы

Другой вариант — использовать подклассы и методы упаковки для изменения информации, предоставляемой для конкретного свойства. Это методика, которую должна заменить динамическая Аннотация. Чтобы переопределить одно свойство с помощью подкласса и упаковки, разработчик должен выполнить следующие действия:

1.  Подкласс HWND объекта [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) .
2.  Перехватите сообщение [**WM \_ GetObject**](wm-getobject.md) для правильного значения ипарам/OBJID.
3.  Перешлите сообщение [**WM \_ GetObject**](wm-getobject.md) в базовый класс с помощью функции [*каллвндпрок*](/previous-versions/windows/desktop/legacy/ms644975(v=vs.85)) . Если возвращается ноль, вызовите [**креатестдакцессиблеобжект**](/windows/desktop/api/Oleacc/nf-oleacc-createstdaccessibleobject); в противном случае вызовите [**функции lresultfromobject**](/windows/desktop/api/Oleacc/nf-oleacc-lresultfromobject) для возвращаемого значения, чтобы получить указатель на собственный интерфейс [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) элемента управления.
4.  Создайте класс-оболочку, который реализует [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) и заключает в оболочку указатель интерфейса **IAccessible** , возвращенный на предыдущем шаге. Этот класс-оболочка отправляет все методы и свойства в исходный указатель на интерфейс **IAccessible** , за исключением тех, которые должны быть переопределены. Это включает написание кода переадресации для всех 21 свойств и методов интерфейса **IAccessible** независимо от того, сколько фактически переопределено.

Кроме того, разработчики должны проверить следующие условия:

-   Переопределенный метод или свойство должны работать только с требуемыми дочерними идентификаторами и пересылать все остальные в исходный указатель на интерфейс [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) .
-   Оболочка также должна пересылать интерфейсы [**IEnumVARIANT**](/previous-versions/windows/desktop/api/oaidl/nn-oaidl-ienumvariant) и [**иолевиндов**](/windows/desktop/api/oleidl/nn-oleidl-iolewindow) только в том случае, если исходный объект поддерживает их.
-   Подсчет ссылок должен обрабатываться правильно, особенно если поддерживаются другие интерфейсы.
-   Возвращаемые значения [**IDispatch**](idispatch-interface.md) должны обрабатываться правильно, особенно с методом [**ITypeInfo:: Invoke**](/previous-versions/windows/desktop/api/oaidl/nf-oaidl-itypeinfo-invoke) , который должен вызываться с помощью указателя интерфейса на интерфейс оболочки, а не указателя на исходный интерфейс [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) .

Эти методы требуют значительного объема работы, даже если необходимо переопределить только одно или два свойства. Большая часть результирующего кода связана с подклассом и оболочкой, и только небольшая часть фактически предоставляет переопределенную информацию.

Однако существуют сценарии, в которых требуются эти методы. Например, если вы вносите структурные изменения для создания элемента пользовательского интерфейса заполнителя, следует использовать эти методы, а не динамические заметки.

## <a name="fixing-names-derived-from-labels"></a>Исправление имен, полученных из меток

Некоторые общие элементы управления Microsoft Win32, такие как элемент управления "поле ввода", почти всегда используются с меткой (запись ЛТЕКСТ в файле ресурсов) или в поле группы (GROUPBOX в файле ресурсов). Microsoft Active Accessibility автоматически извлекает свойство Name элемента управления из его метки. для таких элементов управления текст окна (отображаемый в Microsoft Visual Studio как свойство "имя" или "идентификатор") игнорируется, так как обычно создается автоматически и редко очень описательно. Например, "IDC \_ EDIT1".

Если пользовательский интерфейс приложения не спроектирован должным образом, Microsoft Active Accessibility может не иметь возможности правильно задать имя. Для связывания с элементом управления поле метки или группы должно располагаться непосредственно перед динамическим элементом управления в последовательности табуляции.

порядок табуляции можно изменить с помощью средства в Visual Studio (в меню **формат** , если открыт редактор ресурсов) или путем непосредственного редактирования файла ресурсов.

В следующем примере показано описание файла ресурсов для диалогового окна, содержащего два поля ввода с метками.


```C++
IDD_INPUTNAME DIALOGEX 22, 17, 312, 118
STYLE DS_SETFONT | DS_MODALFRAME | WS_CAPTION | WS_SYSMENU
CAPTION "Enter your name"
FONT 8, "System", 0, 0, 0x0
BEGIN
    DEFPUSHBUTTON   "OK",IDOK,179,35,30,11,WS_GROUP
    LTEXT           "First Name:",IDC_STATIC,8,16,43,8
    LTEXT           "Last Name:",IDC_STATIC,8,33,43,8
    EDITTEXT        IDC_EDITFIRSTNAME,53,15,120,12,ES_AUTOHSCROLL
    EDITTEXT        IDC_EDITLASTNAME,53,34,120,12,ES_AUTOHSCROLL
END
```



В этом примере метки и элементы управления не перечисляются в правильном порядке табуляции. В результате Microsoft Active Accessibility присваивает имя «Last Name» текстовому полю «имя» и не имеет имени в поле «Last-Name».

В следующем примере показан правильный список ресурсов. Обратите внимание также, что в метках назначены сочетания клавиш.


```C++
IDD_INPUTNAME DIALOGEX 22, 17, 312, 118
STYLE DS_SETFONT | DS_MODALFRAME | WS_CAPTION | WS_SYSMENU
CAPTION "Enter your name"
FONT 8, "System", 0, 0, 0x0
BEGIN
    LTEXT           "&First Name:",IDC_STATIC,8,16,43,8
    EDITTEXT        IDC_EDITFIRSTNAME,53,15,120,12,ES_AUTOHSCROLL
    LTEXT           "&Last Name:",IDC_STATIC,8,33,43,8
    EDITTEXT        IDC_EDITLASTNAME,53,34,120,12,ES_AUTOHSCROLL
    DEFPUSHBUTTON   "OK",IDOK,179,35,30,11,WS_GROUP
END
```



Если элементы управления имеют дополнительные метки, например для минимальных и максимальных значений на TrackBar, эти метки должны располагаться после элемента управления в последовательности табуляции. Основная метка элемента управления должна располагаться непосредственно перед самим элементом управления.

## <a name="naming-controls-without-labels"></a>Именование элементов управления без меток

Не всегда возможно или нежелательно иметь видимую метку для каждого элемента управления. Однако вы по-прежнему можете предоставить имя для элемента управления, добавив невидимую метку. Как всегда, невидимая метка должна находиться непосредственно перед элементом управления в последовательности табуляции.

если вы используете редактор ресурсов в Microsoft Visual Studio .net, можно задать для свойства Visible значение False. Чтобы сделать метку невидимой при редактировании файла ресурсов (. RC), добавьте параметр NOT- \_ Visible или в часть Style элемента управления Label, как показано в следующем примере.


```C++
    LTEXT           "&FullName:",IDC_STATIC,111,23,44,8,NOT WS_VISIBLE
```



Обратите внимание, что все назначенные сочетания клавиш работают даже несмотря на то, что метка невидима.

 

 