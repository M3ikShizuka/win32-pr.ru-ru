---
title: Соображения по поводу программирования без использования блокировок для Xbox 360 и Microsoft Windows
description: В этой статье приводятся общие сведения о некоторых проблемах, которые следует учитывать при попытке использования методов программирования, не связанных с блокировкой.
ms.assetid: 44700352-a791-7ef7-0858-146214b0e3da
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4ee9ad19fa15d9f0dc2671e77c7fb2408c96362420ddd70d6e6ad7795ba5b5f0
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "120042564"
---
# <a name="lockless-programming-considerations-for-xbox-360-and-microsoft-windows"></a>Соображения по поводу программирования без использования блокировок для Xbox 360 и Microsoft Windows

Программирование без блокировок — это способ безопасного обмена данными между несколькими потоками, не требуя затрат на получение и освобождение блокировок. Это звучит, как панацея, но программирование без блокировки является сложным и незаметным, и иногда не дает никаких преимуществ, которые он обещает. Программирование с неблокировкой особенно сложно на Xbox 360.

Программирование без блокировок является допустимым методом для многопоточного программирования, но его не следует использовать в качестве источника. Прежде чем использовать его, необходимо понимать сложность, и необходимо тщательно оценить, чтобы убедиться в том, что на самом деле это дает вам желаемый выигрыш. Во многих случаях существуют простые и быстрые решения, такие как обмен данными реже, которые следует использовать вместо них.

Неправильное использование программирования без блокировки требует значительных знаний о вашем оборудовании и компиляторе. В этой статье приводятся общие сведения о некоторых проблемах, которые следует учитывать при попытке использования методов программирования, не связанных с блокировкой.

## <a name="programming-with-locks"></a>Программирование с помощью блокировок

При написании многопоточного кода часто бывает необходимо обмениваться данными между потоками. Если несколько потоков одновременно считывают и записывают общие структуры данных, может произойти повреждение памяти. Самый простой способ решения этой проблемы — использовать блокировки. Например, если Манипулатешареддата должен выполняться только одним потоком за раз, \_ для этого можно использовать критическую секцию, как показано в следующем коде:

``` syntax
// Initialize
CRITICAL_SECTION cs;
InitializeCriticalSection(&cs);

// Use
void ManipulateSharedData()
{
    EnterCriticalSection(&cs);
    // Manipulate stuff...
    LeaveCriticalSection(&cs);
}

// Destroy
DeleteCriticalSection(&cs);
```

Этот код довольно прост и прост, и легко понять, что он правильно. Однако программирование с блокировкой имеет несколько потенциальных недостатков. Например, если два потока пытаются получить те же две блокировки, но запрашивают их в другом порядке, можно получить взаимоблокировку. Если программа удерживает блокировку слишком долго, из-за плохого проектирования или из-за того, что поток был переключен в поток более высокого приоритета, другие потоки могут быть заблокированы в течение длительного времени. Этот риск особенно хорош на Xbox 360, так как программным потокам назначен аппаратный поток, который разработчик, и операционная система не переместит их в другой аппаратный поток, даже если он бездействует. Xbox 360 также не имеет защиты от инверсии приоритета, где поток с высоким приоритетом циклически вращается в цикле, ожидая освобождения потока потоком с низким приоритетом. Наконец, если вызов отложенной процедуры или процедура службы прерываний пытается получить блокировку, то может возникнуть взаимоблокировка.

Несмотря на эти проблемы, примитивы синхронизации, такие как критические разделы, обычно являются лучшим способом координирования нескольких потоков. Если примитивы синхронизации слишком медленные, лучшее решение обычно использует их реже. Однако для тех, кто может предоставить дополнительную сложность, другой вариант — это программирование с блокировкой.

## <a name="lockless-programming"></a>Программирование с неблокировкой

Незаблокированное программирование, как и предполагает название, является семейством методик для безопасного управления общими данными без использования блокировок. Существуют бесблокировки алгоритмы, доступные для передачи сообщений, совместного использования списков и очередей данных и других задач.

При программировании без блокировки существует две проблемы, с которыми необходимо работать: неатомарные операции и переупорядочение.

## <a name="non-atomic-operations"></a>Операции, не являющиеся атомарными

Атомарная операция — это одна из неделимых — одна, где другие потоки гарантированно не видят операцию, когда она выполняется. Атомарные операции важны для программирования без блокировки, так как в противном случае другие потоки могут видеть полуширинные значения или непротиворечивое состояние.

На всех современных процессорах можно предположить, что операции чтения и записи для естественного согласованного машинного типа являются атомарными. Пока размер шины памяти не меньше, чем тип, который считывается или записывается, ЦП считывает и записывает эти типы в одну транзакцию шины, делая так, что другие потоки не смогут видеть их в состоянии "половина завершено". В архитектуре x86 и x64 нет гарантии, что операции чтения и записи размером более восьми байт являются атомарными. Это означает, что 16-байтовые операции чтения и записи регистров расширения Streaming SIMD (SSE) и строковых операций могут быть не атомарными.

Операции чтения и записи типов, которые не выровнены естественным образом (например, написание DWORD, которые пересекают границы из четырех байтов), не гарантированно будут атомарными. ПРОЦЕССОР может выполнять эти операции чтения и записи как несколько транзакций шины, что позволяет другому потоку изменять или просматривать данные в середине чтения или записи.

Составные операции, такие как чтение и изменение — запись, выполняемая при увеличении общей переменной, не являются атомарными. На Xbox 360 эти операции реализуются в виде нескольких инструкций (ЛВЗ, Адди и СТВ), и поток можно переключать попадете с помощью последовательности. На платформах x86 и x64 имеется одна инструкция (Inc.), которую можно использовать для увеличения переменной в памяти. При использовании этой инструкции увеличение переменной происходит атомарно на однопроцессорных системах, но по-прежнему не является атомарным для многопроцессорных систем. Чтобы сделать Inc атомарным многопроцессорным системам на базе x86 и x64, необходимо использовать префикс блокировки, который не позволяет другому процессору выполнить собственную последовательность чтения-изменения и записи между чтением и записью инструкции Inc.

В коде ниже приведено несколько примеров:

``` syntax
// This write is not atomic because it is not natively aligned.
DWORD* pData = (DWORD*)(pChar + 1);
*pData = 0;

// This is not atomic because it is three separate operations.
++g_globalCounter;

// This write is atomic.
g_alignedGlobal = 0;

// This read is atomic.
DWORD local = g_alignedGlobal;
```

## <a name="guaranteeing-atomicity"></a>Обеспечение атомарности

Вы можете убедиться, что вы используете атомарные операции, используя сочетание следующих параметров:

-   Естественным образом атомарные операции
-   Блокировки для составных операций
-   Функции операционной системы, реализующие атомарные версии популярных составных операций

Увеличение переменной не является атомарной операцией, а увеличение может привести к повреждению данных, если оно выполняется в нескольких потоках.

``` syntax
// This will be atomic.
g_globalCounter = 0;

// This is not atomic and gives undefined behavior
// if executed on multiple threads
++g_globalCounter;
```

Win32 поставляется с семейством функций, которые обеспечивают атомарные операции чтения и изменения для записи нескольких распространенных операций. Это семейство функций Интерлоккедкскскс. Если все изменения в общей переменной используют эти функции, изменения будут потокобезопасными.

``` syntax
// Incrementing our variable in a safe lockless way.
InterlockedIncrement(&g_globalCounter);
```

## <a name="reordering"></a>Переупорядочение

Более сложная проблема заключается в переупорядочении. Операции чтения и записи не всегда происходят в том порядке, в котором они были написаны в коде, и это может привести к очень запутанным проблемам. Во многих многопоточных алгоритмах поток записывает некоторые данные, а затем записывает их в флаг, сообщающий другим потокам, что данные готовы. Это называется записью выпуска. Если операции записи переупорядочиваются, другие потоки могут увидеть, что флаг установлен, прежде чем они смогут увидеть записанные данные.

Аналогичным образом, во многих случаях поток считывает данные из флага, а затем считывает часть общих данных, если флаг говорит, что поток получил доступ к общим данным. Это называется получением для чтения. Если операции чтения переупорядочиваются, то данные могут быть считаны из общего хранилища до флага, и отображаемые значения могут оказаться неактуальными.

Изменение порядка операций чтения и записи может выполняться компилятором и процессором. Компиляторы и процессоры выполнили это изменение порядка в течение нескольких лет, но на однопроцессорных компьютерах это было меньше. Это связано с тем, что изменение количества операций чтения и записи ЦП на однопроцессорных компьютерах невидимо (для кода драйвера не устройства, который не является частью драйвера устройства), и изменение порядка операций чтения и записи в компиляторе снижает вероятность возникновения проблем на компьютерах с одним процессором.

Если компилятор или ЦП переупорядочивает записи, показанные в следующем коде, другой поток может увидеть, что флаг Alive установлен, а старые значения для x или y не видны. Аналогичное изменение может произойти при чтении.

В этом коде один поток добавляет новую запись в массив Sprite:

``` syntax
// Create a new sprite by writing its position into an empty
// entry and then setting the ‘alive' flag. If ‘alive' is
// written before x or y then errors may occur.
g_sprites[nextSprite].x = x;
g_sprites[nextSprite].y = y;
g_sprites[nextSprite].alive = true;
```

В следующем блоке кода другой поток считывает из массива спрайта:

``` syntax
// Draw all sprites. If the reads of x and y are moved ahead of
// the read of ‘alive' then errors may occur.
for( int i = 0; i < numSprites; ++i )
{
    if( g_sprites[nextSprite].alive )
    {
        DrawSprite( g_sprites[nextSprite].x,
                g_sprites[nextSprite].y );
    }
}
```

Чтобы обеспечить безопасность системы спрайта, необходимо предотвратить Переупорядочение операций чтения и записи для компилятора и ЦП.

### <a name="understanding-cpu-rearrangement-of-writes"></a>Основные сведения о перекомпоновке операций записи ЦП

Некоторые ЦП переупорядочивают записи, чтобы они были видны другим процессорам или устройствам в порядке, отличном от программы. Это изменение никогда не является видимым для однопотокового кода, не относящегося к драйверу, но может вызвать проблемы в многопоточном коде.

### <a name="xbox-360"></a>Xbox 360

Хотя процессор Xbox 360 не упорядочивает инструкции, он переупорядочивает операции записи, что завершается после выполнения инструкций. такое изменение порядка операций записи разрешено в модели PowerPCной памяти.

Операции записи на Xbox 360 не переходят непосредственно в кэш L2. Вместо этого, чтобы улучшить пропускную способность записи в кэш L2, они проходят через очереди хранилища, а затем — для хранения буферов. Буферы сбора данных хранилища позволяют записывать блоки 64 байт в кэш L2 за одну операцию. Существует восемь буферов для сбора данных о хранении, которые обеспечивают эффективную запись в несколько различных областей памяти.

Буферы сбора данных хранения обычно записываются в кэш L2 в порядке "первым вошел — первым обслужен" (FIFO). Однако если целевой кэш-адрес записи не находится в кэше L2, запись может быть отложена, пока строка кэша извлекается из памяти.

Даже если буферы сбора данных хранилища записываются в кэш L2 в определенном порядке FIFO, это не гарантирует, что отдельные операции записи записываются в кэш L2 по порядку. Например, представьте, что ЦП записывает в расположение 0x1000, затем на Location 0x2000, а затем в Location 0x1004. Первая запись выделяет буфер сбора данных о хранилище и помещает его в начало очереди. Вторая запись выделяет другой буфер сбора данных о хранении и помещает его в очередь далее. Третья запись добавляет свои данные в первый буфер хранилища данных, который остается в начале очереди. Таким же третью запись будет находиться в кэше L2 до второй записи.

Переупорядочение, вызванное буферами сбора данных о хранении, является фундаментальным непредсказуемым, особенно потому, что оба потока в ядре совместно используют буферы для сбора данных хранилища, что делает выделение и очистку буферов с высокой степенью переменными.

Это один из примеров того, как можно изменить порядок записей. Возможны и другие возможности.

### <a name="x86-and-x64"></a>x86 и x64

Несмотря на то, что процессоры x86 и x64 выполняют инструкции по изменению порядка, они обычно не переупорядочивают операции записи относительно других операций записи. Существуют некоторые исключения для общей памяти с записью. Кроме того, операции со строковыми операциями (МОВС и СТОС) и 16-байтовые записи SSE могут быть упорядочены внутри, но в противном случае операции записи не переупорядочиваются по отношению друг к другу.

### <a name="understanding-cpu-rearrangement-of-reads"></a>Общие сведения о перестановке операций чтения ЦП

Некоторые ЦП переупорядочивают операции чтения, чтобы они эффективно поступали из общего хранилища в порядке, отличном от программы. Это изменение никогда не является видимым для однопотокового кода, не относящегося к драйверу, но может вызвать проблемы в многопоточном коде.

### <a name="xbox-360"></a>Xbox 360

Промахи в кэше могут привести к задержке операций чтения, что эффективно приводит к тому, что операции чтения поступают из общей памяти в неправильном порядке, а время этих промахов кэша является фундаментальным непредсказуемым. Предварительная выборка и прогнозирование ветвей также могут привести к неупорядоченному получению данных из общей памяти. Это лишь несколько примеров того, как можно изменить порядок операций чтения. Возможны и другие возможности. такое изменение порядка операций чтения выполняется специально для модели PowerPCной памяти.

### <a name="x86-and-x64"></a>x86 и x64

Несмотря на то, что процессоры x86 и x64 выполняют инструкции по изменению порядка, они обычно не переупорядочивают операции чтения относительно других операций чтения. Операции со строковыми операциями (МОВС и СТОС) и 16-битные операции чтения SSE могут быть упорядочены по внутреннему индексу, но в противном случае операции чтения не переупорядочиваются по отношению друг к другу.

### <a name="other-reordering"></a>Другие изменения порядка

Хотя процессоры x86 и x64 не переупорядочивают операции записи относительно других операций записи или переупорядочивают операции чтения относительно других операций чтения, они могут переупорядочивать операции чтения относительно операций записи. В частности, если программа выполняет запись в одно расположение, а затем считывает из другого расположения, то данные для чтения могут поступать из общей памяти, прежде чем записанные данные станут там. Изменение порядка может привести к нарушению работы некоторых алгоритмов, таких как алгоритмы взаимного исключения Деккер. В алгоритме Деккер каждый поток задает флаг, указывающий, что требуется ввести критическую область, а затем проверяет флаг другого потока, чтобы определить, находится ли другой поток в критическом регионе или пытаетесь его ввести. Исходный код приведен ниже.

``` syntax
volatile bool f0 = false;
volatile bool f1 = false;

void P0Acquire()
{
    // Indicate intention to enter critical region
    f0 = true;
    // Check for other thread in or entering critical region
    while (f1)
    {
        // Handle contention.
    }
    // critical region
    ...
}


void P1Acquire()
{
    // Indicate intention to enter critical region
    f1 = true;
    // Check for other thread in or entering critical region
    while (f0)
    {
        // Handle contention.
    }
    // critical region
    ...
}
```

Проблема заключается в том, что чтение данных F1 в P0Acquire может считаться из общего хранилища, прежде чем запись в F0 сделает его общим хранилищем. В то же время чтение F0 в P1Acquire может считаться из общего хранилища, прежде чем запись в F1 сделает его общим хранилищем. Результатом является то, что оба потока устанавливают флаги равными TRUE, и оба потока видят флаг другого потока как FALSE, поэтому они одновременно указывают на критическую область. Поэтому, хотя проблемы с изменением порядка в системах на базе x86 и x64 менее распространены, чем в Xbox 360, они, конечно же, могут по-прежнему выполняться. Алгоритм Деккер не будет работать без барьеров аппаратной памяти на любой из этих платформ.

Процессоры x86 и x64 не будут переупорядочивать записи перед предыдущим чтением. Процессоры x86 и x64 переупорядочивают только операции чтения перед предыдущими операциями записи, если они предназначены для разных расположений.

PowerPC Процессоры могут переупорядочивать операции чтения перед записью, а также переупорядочивать записи перед чтением, если они относятся к разным адресам.

### <a name="reordering-summary"></a>Сводка по переупорядочиванию

ЦП Xbox 360 переупорядочивает операции с памятью гораздо более агрессивно, чем процессоры x86 и x64, как показано в следующей таблице. Дополнительные сведения см. в документации к процессору.



| Действие изменения порядка           | x86 и x64 | Xbox 360 |
|-------------------------------|-------------|----------|
| Чтение с опережением чтения   | Нет          | Да      |
| Операций записи, предшествующих записи | Нет          | Да      |
| Операций записи, перемещенных вперед  | Нет          | Да      |
| Считывания за преупреждающим числом операций записи  | Да         | Да      |



 

## <a name="read-acquire-and-write-release-barriers"></a>Барьеры Read-Acquire и Write-Release

Основные конструкции, используемые для предотвращения переупорядочения операций чтения и записи, называются барьерами чтения и записи. Запрос на чтение — это чтение флага или другой переменной для получения владения ресурсом в сочетании с барьером в переупорядочении. Аналогичным образом, запись в эксплуатацию — это запись флага или другой переменной для предоставления владения ресурсом в сочетании с барьером для переупорядочения.

Формальные определения с помощью Герб Саттер:

-   Чтение и запись выполняется до всех операций чтения и записи в том же потоке, который находится за ним в порядке программ.
-   Запись-выпуск выполняется после всех операций чтения и записи в том же потоке, который предшествует ему в порядке программ.

Когда код получает владение некоторой памятью либо путем получения блокировки, либо путем извлечения элемента из общего связанного списка (без блокировки), используется постоянное чтение — тестирование флага или указателя, чтобы проверить, была ли получена принадлежность к памяти. Эта операция чтения может быть частью операции **интерлоккедкскскс** . в этом случае она включает как чтение, так и запись, но является чтением, указывающим, получен ли владелец. После получения владения памятью значения обычно считываются из этой памяти или записываются в нее, и очень важно, чтобы эти операции чтения и записи выполнялись после получения владения. Это гарантирует барьер для чтения и получения.

Когда освобождается владение какой-либо памятью путем снятия блокировки или путем отправки элемента в общий связанный список, всегда существует запись, которая сообщает другим потокам о том, что память теперь доступна для них. Несмотря на то, что код владеет памятью, он, вероятно, считывает данные из нее или пишет его, и очень важно, чтобы эти операции чтения и записи выполнялись до освобождения владения. Это гарантируется с помощью барьера выпуска для записи.

Проще всего подумать о барьерах чтения и записи в качестве отдельных операций. Однако иногда их необходимо создавать из двух частей: чтение или запись, а также барьер, который не допускает операции чтения или записи для перемещения по нему. В этом случае размещение барьера является критически важным. Для барьера, читающего запросы на чтение, сначала выполняется чтение флага, затем барьер, а затем считываются и записываются общие данные. Для барьера выпуска с возможностью записи сначала поступают операции чтения и записи общих данных, затем барьер, а затем запись флага.

``` syntax
// Read that acquires the data.
if( g_flag )
{
    // Guarantee that the read of the flag executes before
    // all reads and writes that follow in program order.
    BarrierOfSomeSort();

    // Now we can read and write the shared data.
    int localVariable = sharedData.y;
    sharedData.x = 0;

    // Guarantee that the write to the flag executes after all
    // reads and writes that precede it in program order.
    BarrierOfSomeSort();
    
    // Write that releases the data.
    g_flag = false;
}
```

Единственное различие между чтением и записью в эксплуатацию заключается в расположении барьера памяти. При получении запроса на чтение закладывается барьер после операции блокировки, а у записи выпуска есть барьер. В обоих случаях барьер находится между ссылками на Заблокированную память и ссылками на блокировку.

Чтобы понять, почему барьеры необходимы как при получении, так и при освобождении данных, лучше всего (и наиболее точным) считать эти барьеры как гарантируют синхронизацию с общей памятью, а не с другими процессорами. Если один процессор использует запись-выпуск для освобождения структуры данных в общей памяти, а другой процессор использует для получения доступа к этой структуре данных из общей памяти, то этот код будет работать правильно. Если какой либо процессор не использует соответствующее препятствие, совместное использование данных может завершиться ошибкой.

Использование правильного барьера для предотвращения переупорядочивания компилятора и ЦП для вашей платформы является критически важным.

Одним из преимуществ использования примитивов синхронизации, предоставляемых операционной системой, является то, что все они включают соответствующие барьеры памяти.

## <a name="preventing-compiler-reordering"></a>Запрет переупорядочения компилятора

Задание компилятора — агрессивно оптимизировать код для повышения производительности. Сюда входит изменение порядка инструкций везде, где это полезно, и в любом месте, где она не изменит поведение. Поскольку стандарт C++ никогда не упоминает многопоточность, и, поскольку компилятор не знает, какой код должен быть потокобезопасным, компилятор предполагает, что код является однопотоковым при принятии решения о том, какие именно изменения можно безопасно выполнить. Поэтому необходимо сообщить компилятору, что он не может переупорядочивать операции чтения и записи.

С Visual C++ можно запретить Переупорядочение компилятора с помощью встроенных [**\_ реадвритебарриер**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx)компилятора. Когда вы вставляете **\_ реадвритебарриер** в код, компилятор не будет перемещать операции чтения и записи по нему.

``` syntax
#if _MSC_VER < 1400
    // With VC++ 2003 you need to declare _ReadWriteBarrier
    extern "C" void _ReadWriteBarrier();
#else
    // With VC++ 2005 you can get the declaration from intrin.h
#include <intrin.h>
#endif
// Tell the compiler that this is an intrinsic, not a function.
#pragma intrinsic(_ReadWriteBarrier)

// Create a new sprite by filling in a previously empty entry.
g_sprites[nextSprite].x = x;
g_sprites[nextSprite].y = y;
// Write-release, barrier followed by write.
// Guarantee that the compiler leaves the write to the flag
// after all reads and writes that precede it in program order.
_ReadWriteBarrier();
g_sprites[nextSprite].alive = true;
```

В следующем коде другой поток считывает из массива спрайта:

``` syntax
// Draw all sprites.
for( int i = 0; i < numSprites; ++i )
{

    // Read-acquire, read followed by barrier.
    if( g_sprites[nextSprite].alive )
    {
    
        // Guarantee that the compiler leaves the read of the flag
        // before all reads and writes that follow in program order.
        _ReadWriteBarrier();
        DrawSprite( g_sprites[nextSprite].x,
                g_sprites[nextSprite].y );
    }
}
```

Важно понимать, что [**\_ реадвритебарриер**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) не вставляет никаких дополнительных инструкций и не мешает процессору переупорядочить операции чтения и записи — он только не позволяет компилятору переупорядочить их. Таким словами, **\_ реадвритебарриер** достаточно при реализации барьера для записи на платформах x86 и x64 (поскольку x86 и x64 не переупорядочивают записи, а обычная запись достаточна для освобождения блокировки), но в большинстве других случаев также необходимо предотвратить Переупорядочение операций чтения и записи ЦП.

[**\_ Реадвритебарриер**](https://msdn.microsoft.com/library/f20w0x5e(v=VS.71).aspx) также можно использовать при записи в память, не поддерживающую кэширование, для предотвращения изменения порядка операций записи. В этом случае **\_ реадвритебарриер** помогает повысить производительность, гарантируя, что операции записи происходят в предпочтительном линейном порядке процессора.

Также можно использовать встроенные функции [**\_ реадбарриер**](https://msdn.microsoft.com/library/z055s48f(v=VS.80).aspx) и [**\_ вритебарриер**](https://msdn.microsoft.com/library/65tt87y8(v=VS.80).aspx) для более точного управления переупорядочением компилятора. Компилятор не будет перемещать операции чтения в **\_ реадбарриер** и не будет перемещать операции записи по **\_ вритебарриер**.

## <a name="preventing-cpu-reordering"></a>Предотвращение изменения порядка ЦП

Изменение порядка ЦП является более незаметным, чем Переупорядочение компилятора. Пока вы не видите его напрямую, вы просто видите ошибки инекспликабле. Чтобы предотвратить изменение порядка операций чтения и записи ЦП, необходимо использовать инструкции по барьеру памяти на некоторых процессорах. универсальное имя для инструкции барьера памяти на Xbox 360 и Windows [**меморибарриер**](/windows/win32/api/winnt/nf-winnt-memorybarrier). Этот макрос реализуется соответствующим образом для каждой платформы.

В Xbox 360 [**меморибарриер**](/windows/win32/api/winnt/nf-winnt-memorybarrier) определен как **лвсинк** (облегченная синхронизация), также доступный через встроенную **\_ \_ лвсинк** , которая определена в ппЦинтринсикс. h. **\_ \_ лвсинк** также выступает в качестве барьера памяти компилятора, предотвращая перераспределение операций чтения и записи компилятором.

Инструкция **лвсинк** — это барьер памяти на Xbox 360, который синхронизирует одно ядро процессора с кэшем L2. Он гарантирует, что все операции записи перед **лвсинк** передают его в кэш L2, прежде чем выполнять операции записи. Также гарантируется, что все операции чтения, следующие за **лвсинк** , не будут получать более старые данные из L2, чем предыдущие операции чтения. Один из типов переупорядочения, который он не препятствует, — это чтение с переносом на другой адрес. Таким же **лвсинк** обеспечивает упорядочение памяти, совпадающее с порядком памяти процессоров x86 и x64 по умолчанию. Для получения полного порядка памяти требуется более дорогостоящая Инструкция по синхронизации (также известная как бумага высокой плотности), но в большинстве случаев это не является обязательным. Параметры изменения порядка памяти в Xbox 360 показаны в следующей таблице.



| Переупорядочение Xbox 360           | Без синхронизации | лвсинк | sync |
|-------------------------------|---------|--------|------|
| Чтение с опережением чтения   | Да     | Нет     | Нет   |
| Операций записи, предшествующих записи | Да     | Нет     | Нет   |
| Операций записи, перемещенных вперед  | Да     | Нет     | Нет   |
| Считывания за преупреждающим числом операций записи  | Да     | Да    | Нет   |



 

PowerPC также содержит инструкции по синхронизации **исинк** и **еиеио** (которые используются для управления переупорядочением памяти, запрещенной для кэширования). Эти инструкции по синхронизации не требуются для нормальной синхронизации.

в Windows [**меморибарриер**](/windows/win32/api/winnt/nf-winnt-memorybarrier) определяется в Winnt. h и предоставляет другую инструкцию барьера памяти в зависимости от того, выполняется ли компиляция для x86 или x64. Инструкция барьера памяти служит полным барьером, предотвращая Переупорядочение операций чтения и записи в барьере. таким образом, **меморибарриер** на Windows обеспечивает более надежную гарантию, чем на Xbox 360.

На Xbox 360 и во многих других ЦП существует еще один дополнительный способ, который может быть предотвращен на чтение и изменение порядка ЦП. Если вы прочитаете указатель и затем используете этот указатель для загрузки других данных, ЦП гарантирует, что считывания с указателя не старше, чем чтение указателя. Если флаг блокировки является указателем, и если все операции чтения общих данных находятся за пределами указателя, [**меморибарриер**](/windows/win32/api/winnt/nf-winnt-memorybarrier) можно опустить, чтобы снизить экономию производительности.

``` syntax
Data* localPointer = g_sharedPointer;
if( localPointer )
{
    // No import barrier is needed--all reads off of localPointer
    // are guaranteed to not be reordered past the read of
    // localPointer.
    int localVariable = localPointer->y;
    // A memory barrier is needed to stop the read of g_global
    // from being speculatively moved ahead of the read of
    // g_sharedPointer.
    int localVariable2 = g_global;
}
```

Инструкция [**меморибарриер**](/windows/win32/api/winnt/nf-winnt-memorybarrier) предотвращает изменение порядка операций чтения и записи в кэшированную память. Если выделить память в качестве нестраничного \_ кэша страницы или \_ вритекомбине страницы, Общий прием для авторов драйверов устройств и для разработчиков игр на Xbox 360, **меморибарриер** не влияет на доступ к этой памяти. Большинству разработчиков не требуется синхронизация некэшированной памяти. Это выходит за рамки данной статьи.

## <a name="interlocked-functions-and-cpu-reordering"></a>Блокируемые функции и изменение порядка ЦП

Иногда операции чтения или записи, которые запрашивают или освобождают ресурс, выполняются с помощью одной из функций **интерлоккедкскскс** . на Windows это упрощает работу. поскольку на Windows функции **интерлоккедкскскс** — это все барьеры для полной памяти. Они эффективно используют барьер памяти ЦП как до, так и после них. Это означает, что они являются полным барьером для чтения и записи.

В Xbox 360 функции **интерлоккедкскскс** не содержат барьеров памяти ЦП. Они предотвращают изменение порядка операций чтения и записи в компиляторе, но не переупорядочивают ЦП. Таким образом, в большинстве случаев при использовании функций **интерлоккедкскскс** на Xbox 360 необходимо перед ними или следовать ему с помощью **\_ \_ лвсинк**, чтобы сделать их барьером для чтения и записи. Для удобства и **более удобного** читаемости доступны и **выпуски** версий многих функций **интерлоккедкскскс** . Они поставляются с встроенным барьером памяти. Например, [**интерлоккединкрементаккуире**](/previous-versions/windows/desktop/legacy/ms683618(v=vs.85)) выполняет блокируемое приращение, за которым следует барьер памяти **\_ \_ лвсинк** , чтобы обеспечить полную функциональность чтения и считывания.

рекомендуется использовать версии для **получения** и **выпуска** функций **интерлоккедкскскс** (большинство из которых доступны в Windows, без снижения производительности), чтобы сделать цель более очевидной и упростить получение инструкций по барьеру памяти в нужном месте. Любое использование **интерлоккедкскскс** на Xbox 360 без барьера памяти должно быть тщательно проверено, так как часто это ошибка.

В этом примере показано, как один поток может передавать задачи или другие данные в другой поток, используя версии **получения** и **выпуска** функций **интерлоккедксксксслист** . Функции **интерлоккедксксксслист** — это семейство функций для поддержания общего однонаправленного списка без блокировки. обратите внимание, что варианты **получения** и **освобождения** этих функций недоступны на Windows, но обычные версии этих функций являются полным барьером памяти для Windows.

``` syntax
// Declarations for the Task class go here.

// Add a new task to the list using lockless programming.
void AddTask( DWORD ID, DWORD data )
{
    Task* newItem = new Task( ID, data );
    InterlockedPushEntrySListRelease( g_taskList, newItem );
}

// Remove a task from the list, using lockless programming.
// This will return NULL if there are no items in the list.
Task* GetTask()
{
    Task* result = (Task*)
        InterlockedPopEntrySListAcquire( g_taskList );
    return result;
}
```

## <a name="volatile-variables-and-reordering"></a>Переменные переменных и изменение порядка

Стандарт C++ говорит, что чтение переменных с переменными переменными не может быть кэшировано, временные операции записи не могут быть отложены, а временные операции чтения и записи нельзя перемещать друг за другом. Это достаточно для связи с аппаратными устройствами, что является назначением ключевого слова volatile в стандарте C++.

Однако гарантии уровня "Стандартный" недостаточно для использования переменных для многопоточности. Стандарт C++ не останавливает Переупорядочение неизменяемых операций чтения и записи относительно временных операций чтения и записи, и ничего не говорит о предотвращении переупорядочения ЦП.

Visual C++ 2005 выходит за пределы стандартного языка C++, чтобы определить понятную многопотоковую семантику для временного доступа к переменным. Начиная с Visual C++ 2005, операции чтения из переменных volatile определяют семантику чтения и записи в переменные переменных, для которых определена семантика записи в эксплуатацию. Это означает, что компилятор не будет изменять порядок операций чтения и записи, а на Windows это гарантирует, что процессор не будет делать это.

Важно понимать, что эти новые гарантии применимы только к Visual C++ 2005 и будущим версиям Visual C++. Компиляторы от других поставщиков обычно реализуют другую семантику без дополнительных гарантий Visual C++ 2005. Кроме того, в Xbox 360 компилятор не вставляет никаких инструкций для предотвращения переупорядочения операций чтения и записи ЦП.

## <a name="example-of-a-lock-free-data-pipe"></a>Пример канала данных Lock-Free

Канал — это конструкция, которая позволяет одному или нескольким потокам записывать данные, которые затем считываются другими потоками. Незаблокированная версия канала может быть элегантным и эффективным способом передачи работы от потоков к потоку. Пакет SDK для DirectX предоставляет **локкфрипипе**, одномодульный и однозаписывающий канал безблокировок, доступный в дксутлоккфрипипе. h. Один и тот же **локкфрипипе** доступен в пакете SDK для Xbox 360 в атглоккфрипипе. h.

**Локкфрипипе** можно использовать, когда у двух потоков есть связь "производитель-получатель". Поток-производитель может записывать данные в канал, чтобы поток-потребитель мог обработать его позже, без каких-либо блокировок. Если канал заполняется, происходит сбой записи, и потоку-производителю придется повторить попытку позже, но это произойдет только в случае, если поток-производитель впереди. Если канал очищается, происходит сбой операций чтения, и потребительский поток придется повторить попытку позже, но это произойдет, только если нет никакой работы для выполнения потока-потребителя. Если два потока хорошо сбалансированы, и канал достаточно велик, канал позволит им без проблем передавать данные без задержек или блоков.

## <a name="xbox-360-performance"></a>Производительность Xbox 360

Производительность инструкций по синхронизации и функций в Xbox 360 будет зависеть от того, какой код работает. Получение блокировок займет больше времени, если другой поток в настоящее время владеет блокировкой. Операции [**интерлоккединкремент**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) и критического раздела будут выполняться намного дольше, если другие потоки записываются в одну строку кэша. Содержимое очередей хранилища также может негативно сказаться на производительности. Таким образом, все эти числа являются приблизительными, что формируется из очень простых тестов:

-   **лвсинк** измеряется в 33-48 циклов.
-   [**Интерлоккединкремент**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) измеряется в 225-260 циклов.
-   Получение или освобождение критической секции измеряется примерно 345 циклов.
-   Получение или освобождение мьютекса заняло примерно 2350 циклов.

## <a name="windows-performance"></a>Производительность Windows

производительность инструкций по синхронизации и функций на Windows зависит от типа и конфигурации процессора, а также от того, какой код работает. Многоядерные и многосокетные системы часто занимают больше времени для выполнения инструкций по синхронизации, и получение блокировок занимает больше времени, если другой поток в настоящее время владеет блокировкой.

Тем не менее, даже некоторые измерения, созданные на основе очень простых тестов, полезны:

-   [**Меморибарриер**](/windows/win32/api/winnt/nf-winnt-memorybarrier) измеряется в 20-90 циклов.
-   [**Интерлоккединкремент**](/windows/win32/api/winnt/nf-winnt-interlockedincrement) измеряется в 36-90 циклов.
-   Получение или освобождение критической секции измеряется в 40-100 циклов.
-   Получение или освобождение мьютекса заняло примерно 750-2500 циклов.

эти тесты выполнялись в Windows XP на различных процессорах. Короткие времена находились на однопроцессорном компьютере, и более длительные времена находились на многопроцессорном компьютере.

Хотя получение и освобождение блокировок является более дорогим, чем использование программирования без блокировки, лучше обмениваться данными реже, тем самым избегая затрат.

## <a name="performance-thoughts"></a>Соображения по производительности

Получение или освобождение критической секции состоит из барьера памяти, операции **интерлоккедкскскс** и некоторой дополнительной проверки на обработку рекурсии и возвращения к мьютексу при необходимости. Вы должны быть осторожными при реализации собственного критического раздела, так как цикличный цикл, ожидающий снятия блокировки, не прибегает к мьютексу, может извлекать значительный объем производительности. Для критически важных разделов, которые сильно обрабатываются, но не удерживаются в течение длительного времени, следует рассмотреть возможность использования [**инитиализекритикалсектионандспинкаунт**](/windows/win32/api/synchapi/nf-synchapi-initializecriticalsectionandspincount) , чтобы операционная система проходила на некоторое время, ожидая доступности критического раздела, а не сразу же откладывая на мьютекс, если при попытке получить критический раздел вы являетесь владельцем критической секции. Для определения критических секций, которые могут использовать преимущества счетчика, необходимо измерять длину типичного ожидания для определенной блокировки.

Если для выделения памяти используется общая куча, поведение по умолчанию — каждое выделение памяти и освобождение ресурсов требуют блокировки. По мере увеличения числа потоков и числа выделений, уровни производительности отключаются, а в конечном итоге начинает уменьшаться. Использование куч для каждого потока или уменьшение числа выделений может избежать возникновения узкого места блокировки.

Если один поток создает данные, а другой поток использует данные, они могут часто предоставлять общий доступ к данным. Это может произойти, если один поток загружает ресурсы, а другой поток — визуализацию сцены. Если поток отрисовки ссылается на общие данные при каждом вызове Draw, затраты на блокировку будут высокими. Гораздо более высокая производительность может быть реализована, если каждый поток имеет закрытые структуры данных, которые затем синхронизируются один раз для каждого кадра или меньше.

Не гарантируется, что алгоритмы без блокировки будут работать быстрее, чем алгоритмы, использующие блокировки. Следует проверить, действительно ли блокировки вызывают проблемы, прежде чем пытаться избежать их, и следует оценить, чтобы узнать, действительно ли код без блокировки повышает производительность.

## <a name="platform-differences-summary"></a>Обзор различий платформы

-   функции **интерлоккедкскскс** не позволяют изменять порядок чтения и записи цп на Windows, но не на Xbox 360.
-   чтение и запись переменных с временными переменными с помощью Visual Studio C++ 2005 предотвращает изменение порядка чтения и записи цп в Windows, но на Xbox 360 она только не допускают изменения порядка чтения и записи компилятора.
-   Операции записи переупорядочиваются на Xbox 360, но не на x86 или x64.
-   Операции чтения переупорядочиваются на Xbox 360, но на x86 или x64 они переупорядочиваются только относительно операций записи и только в том случае, если операции чтения и записи предназначены для разных расположений.

## <a name="recommendations"></a>Рекомендации

-   Используйте блокировки, если это возможно, так как они проще правильно использовать.
-   Избегайте слишком частой блокировки, чтобы затраты на блокировку не стали значительными.
-   Старайтесь не удерживать блокировки слишком долго, чтобы избежать длительных ожиданий.
-   Используйте программирование без блокировки, если это уместно, но не забывайте, что рост будет оправдан.
-   Используйте программирование или блокировки с неблокировкой в ситуациях, когда запрещены другие блокировки, например при совместном использовании данных между отложенными вызовами процедур и обычным кодом.
-   Используйте только стандартные алгоритмы программирования с неблокировкой, которые были проверены правильно.
-   При программировании независимо от блокировок при необходимости обязательно используйте переменные флагов и инструкции по барьеру памяти.
-   При использовании **интерлоккедкскскс** на Xbox 360 используйте варианты " **получить** " и " **выпуск** ".

## <a name="references"></a>Ссылки

-   библиотека MSDN. "[**volatile (C++)**](https://msdn.microsoft.com/library/12a04hfd(v=VS.71).aspx)". Справочник по языку C++.
-   Вэнс Моррисон. "[Понимание влияния методов Low-Lock в многопоточных приложениях](/archive/msdn-magazine/2005/october/understanding-low-lock-techniques-in-multithreaded-apps)". Журнал MSDN Magazine, Октябрь 2005.
-   Лйонс, Майкл. «[PowerPC служба хранилища модель и программирование AIX](https://www-128.ibm.com/developerworks/eserver/articles/powerpc.mdl)». IBM Девелоперворкс, 16 ноября 2005.
-   Мккеннэй, Пол E. "[порядок памяти в современных микропроцессорах, часть II](https://www.linuxjournal.com/article/8212)". Журнал Linux, 2005 сентября. \[В этой статье содержатся сведения об архитектуре x86.\]
-   Корпорация Intel. "[Упорядочение памяти в архитектуре Intel® 64](https://www.cs.cmu.edu/~410-f10/doc/Intel_Reordering_318147.pdf)". 2007 августа. \[Применяется к процессорам IA-32 и Intel 64.\]
-   Ниеблер, то есть "[Отчет о командировках: прямое совещание в потоках на C++](https://www.artima.com/cppsource/threads_meeting.html)". Исходный код C++, 17 октября 2006.
-   Харт, Томас E. 2006. "[Быстрое выполнение синхронизации блокировок: влияние восстановления памяти на производительность](https://www.cs.toronto.edu/~tomhart/papers/hart_ipdps06.pdf)". Материалы 2006 Международная параллельная и распределенная обработка Symposium (ИПДПС 2006), остров Роудз, Греция, Апрель 2006.

 

 