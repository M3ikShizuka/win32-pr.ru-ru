---
title: Часто задаваемые вопросы о DirectX
description: Эта статья содержит набор часто задаваемых вопросов о Microsoft DirectX.
ms.assetid: 58d9fe45-a2c7-8280-2826-e2e14ecea983
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2cd5fd70f1a651121b8d977dbb9479cef6edd024
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104070285"
---
# <a name="directx-frequently-asked-questions"></a>Часто задаваемые вопросы о DirectX

Эта статья содержит набор часто задаваемых вопросов о Microsoft DirectX.

-   [Общие вопросы разработки DirectX](#general-directx-development-issues)
-   [Вопросы по Direct3D](#direct3d-questions)
    -   [Общие вопросы по Direct3D](#general-direct3d-questions)
    -   [Обработка геометрии (вершина)](#geometry-vertex-processing)
    -   [Настройка производительности](#performance-tuning)
    -   [Библиотека служебной программы D3DX](#d3dx-utility-library)
-   [Вопросы о DirectSound](#directsound-questions)
-   [Расширения DirectX для псевдонима Maya](#directx-extensions-for-alias-maya)
-   [Ксинпут вопросы](#xinput-questions)

## <a name="general-directx-development-issues"></a>Общие вопросы разработки DirectX

<dl> <dt>

<span id="Should_game_developers_really_care_about_supporting_x64_editions_"></span><span id="should_game_developers_really_care_about_supporting_x64_editions_"></span><span id="SHOULD_GAME_DEVELOPERS_REALLY_CARE_ABOUT_SUPPORTING_X64_EDITIONS_"></span>**Должны ли разработчики игр, в действительности, позаботиться о поддержке 64-разрядных версий?**
</dt> <dd>

Конечно. Технология x64 широко доступна на рынке. Большинство новых процессоров, проданных за последние несколько лет, и почти все процессорные линии в разработке с помощью процессоров AMD и Intel, поддерживают 64-разрядную архитектуру. В выпуске Windows XP Professional x64 Edition появилась технология поддержки ОС для x64, выпущенная в апреле 2005. Поскольку для версий x64 требуется новое поколение 64-разрядных драйверов машинного кода, первый выпуск был ограничен дистрибутивом OEM.

Благодаря Windows Vista клиенты могут выбрать один из 32-разрядных или 64-разрядных выпусков при покупке компьютеров под управлением Windows, а лицензии для Windows Vista действительны как для 32-разрядных, так и для 64-разрядных выпусков операционной системы. Кроме того, в окне доступны многие 64-разрядные драйверы, а изготовители устройств должны предоставить как можно более 32-разрядный и 64-разрядный драйвер в рамках программы сертификации Windows.

Все эти факторы значительно увеличивают число развертываний 64-разрядных выпусков Windows. По мере того как новые компьютеры начинают поставляться с объемом физической памяти более 2 ГБ, стимул использования 32-разрядной операционной системы значительно уменьшается в пользу 64-разрядных выпусков. 64-разрядная технология полностью поддерживает 32-разрядный машинный код, хотя 64-разрядные машинные реализации необходимы для использования всех преимуществ нового пространства в памяти 64-bit. Каждое 32-разрядное приложение должно иметь совместимость с 64-разрядной версией в соответствии с минимальным требованием к доставке, и это требование является базовым требованием для совместимости с Windows Vista. Несовместимость обычно возникает из-за использования 16-разрядного кода, предназначенного для операционной системы Windows 3,1, или установки драйверов, которые не предоставляются в собственных формах с 32 и 64.

Дополнительные сведения о 64-разрядной технологии см. в разделе [64-разрядное программирование для разработчиков игр](/windows/desktop/DxTechArts/sixty-four-bit-programming-for-game-developers).

</dd> <dt>

<span id="Should_game_developers_still_be_publishing_games_for_Windows_95__Windows_98_or_Windows_ME_"></span><span id="should_game_developers_still_be_publishing_games_for_windows_95__windows_98_or_windows_me_"></span><span id="SHOULD_GAME_DEVELOPERS_STILL_BE_PUBLISHING_GAMES_FOR_WINDOWS_95__WINDOWS_98_OR_WINDOWS_ME_"></span>**Должны ли разработчики игр по-прежнему публиковать игры для Windows 95, Windows 98 или Windows ME?**
</dt> <dd>

Больше не существует по двум причинам: производительности и набору функций.

Если минимальная скорость ЦП, необходимая для игры, составляет 1,2 ГГц или выше (что чаще всего используется для наименований с высоким уровнем производительности), то большинство соответствующих компьютеров будет работать под управлением Windows XP. По мере продажи компьютеров с тактовой частотой выше 1,2 ГГц, Windows XP была установлена как операционная система по умолчанию практически всеми производителями. Это означает, что в Windows XP существует множество функций, которые современные разработчики игр должны использовать:

-   Улучшенная многозадачность, которая обеспечивает более гладкую и удобную работу с видео, аудио и играми.
-   Более стабильная модель видеодрайверов, которая позволяет упростить отладку, воспроизводить более гладкую игру и повысить производительность.
-   Упрощенная настройка для работы в сети, которая обеспечивает более простой доступ к играм с несколькими игроками.
-   Поддержка передачи по каналу DMA по умолчанию с жестких дисков, что приводит к более гладкому и ускоренному загрузке приложений.
-   Отчеты об ошибках Windows, которые приводят к более стабильной операционной системе, драйверам и приложениям.
-   Поддержка Юникода. Это значительно упрощает локализацию.
-   Улучшенная безопасность и стабильность, что приводит к повышению эффективности работы потребителей.
-   Улучшенная поддержка современного оборудования, большинство из которых больше не использует драйверы Windows 98.
-   Улучшенное управление памятью, что приводит к повышению стабильности и безопасности.
-   Улучшена файловая система NTFS, которая более устойчива к сбоям и обеспечивает лучшую производительность с помощью функций безопасности.

</dd> <dt>

<span id="Should_game_developers_still_be_publishing_games_for_Windows_2000_"></span><span id="should_game_developers_still_be_publishing_games_for_windows_2000_"></span><span id="SHOULD_GAME_DEVELOPERS_STILL_BE_PUBLISHING_GAMES_FOR_WINDOWS_2000_"></span>**Должны ли разработчики игр по-прежнему публиковать игры для Windows 2000?**
</dt> <dd>

Только не это. В дополнение к причинам, перечисленным в разделе, **разработчики игр по-прежнему публикуют игры для windows 95, windows 98 или Windows Me?** Windows 2000 не имеет следующих возможностей:

-   Windows XP поддерживает дополнительные функции процессора, такие как технология Hyper-Threading, многоядерная архитектура и архитектура x64.
-   Windows XP поддерживает параллельные компоненты, что значительно сокращает число конфликтов при управлении версиями приложений.
-   Windows XP поддерживает невыполнение защиты памяти, что помогает предотвратить вредоносные программы и может помочь в отладке.
-   В Windows XP улучшена поддержка видеоадаптеров с поддержкой AGP и PCI Express.
-   Windows XP поддерживает быстрое переключение пользователей, удаленный рабочий стол и удаленный помощник, что может помочь снизить затраты на поддержку продукта.
-   Средства производительности, такие как PIX (в пакете SDK для разработчиков DirectX), больше не поддерживают Windows 2000.

Вкратце, Windows 2000 не разрабатывалась или не является потребительской операционной системой.

</dd> <dt>

<span id="What_are_the_differences_between_the_various_editions_of_Windows_Vista__How_do_they_impact_my_DirectX_application_"></span><span id="what_are_the_differences_between_the_various_editions_of_windows_vista__how_do_they_impact_my_directx_application_"></span><span id="WHAT_ARE_THE_DIFFERENCES_BETWEEN_THE_VARIOUS_EDITIONS_OF_WINDOWS_VISTA__HOW_DO_THEY_IMPACT_MY_DIRECTX_APPLICATION_"></span>**Каковы различия между различными выпусками Windows Vista? Как они влияют на приложение DirectX?**
</dt> <dd>

Семейство Windows Vista включает в себя пять выпусков:

-   Windows Vista Home Basic
-   Windows Vista Home Premium
-   Windows Vista Business
-   Windows Vista Enterprise
-   Windows Vista Ultimate

Домашняя базовая и Домашняя расширенная — ориентированные на потребителей версии с такими функциями, как семейная безопасность (прежнее название — родительский контроль), а Домашняя расширенная — Media Center. Business и Enterprise — это ориентированные на предприятия выпуски с такими функциями, как присоединение к домену и удаленный рабочий стол/службы терминалов. В выпуске Ultimate в одну версию объединяются все функции потребительской и корпоративной выпусков. Все выпуски входят в выпуски 32-bit (x86) и 64-bit (x64), и пользователи могут использовать один и тот же идентификатор продукта для обеих платформ.

Технология, лежащая в основе различных выпусков, идентична, и все они имеют одинаковую версию среды выполнения DirectX и других компонентов. Однако у выпусков есть несколько незначительных отличий относительно игр:

-   Обозреватель игр существует во всех выпусках, но ярлык "игры" в меню "Пуск" доступен только в Домашняя базовая, Домашняя расширенная и максимальная. Обозреватель игр по-прежнему можно найти во всех выпусках (нажмите кнопку Пуск, укажите пункт Все программы, а затем выберите пункт игры), а затем функции интерфейса Игамиксплорер во всех выпусках.
-   Игры, включенные в Windows, по умолчанию недоступны для бизнеса и предприятия, но могут быть включены администратором.
-   Семейная безопасность и рейтинги игр не отображают и не влияют на поведение бизнеса или предприятия и отключены в режиме "в сети" при присоединении к домену.

Параметры управления учетными записями пользователей имеют одинаковые значения по умолчанию во всех выпусках, но их можно переопределить с помощью параметров групповая политика для домена в Business, Enterprise и Ultimate. Например, параметр политики Контроль учетных записей: поведение запроса на повышение прав для стандартных пользователей может быть настроено на автоматическое отклонение запросов на повышение прав во многих бизнес-параметрах для повышения безопасности, и многие пользователи в этих средах всегда будут работать как обычные пользователи без возможности даже запуска от имени администратора. Любая программа (например, установщик), которая требует прав администратора из-за обнаружения устаревших настроек или наличия манифеста, указывающего требуемый уровень выполнения, как "requireAdministrator", всегда не запускается в таких ситуациях. Другие параметры политики, такие как управление учетными записями пользователей: повышать права только для подписанных и проверенных исполняемых файлов, также могут препятствовать работе установщика, если вы не подписываете исполняемый файл с помощью Authenticode.

Эти типы изменений политик могут применяться к любому выпуску Windows Vista, но скорее всего, на компьютерах, присоединенных к домену.

</dd> <dt>

<span id="What_are_the_differences_between_the_various_editions_of_Windows_7__How_do_they_impact_my_DirectX_application__"></span><span id="what_are_the_differences_between_the_various_editions_of_windows_7__how_do_they_impact_my_directx_application__"></span><span id="WHAT_ARE_THE_DIFFERENCES_BETWEEN_THE_VARIOUS_EDITIONS_OF_WINDOWS_7__HOW_DO_THEY_IMPACT_MY_DIRECTX_APPLICATION__"></span>**Каковы различия между различными выпусками Windows 7? Как они влияют на приложение DirectX?** 
</dt> <dd>

Большинство пользователей Windows 7, скорее всего, будут иметь один из двух выпусков: Windows 7 Домашняя расширенная, для домашних пользователей или Windows 7 Профессиональная для бизнес-пользователей и разработчиков. Для крупных организаций существует Windows 7 Enterprise Edition с корпоративной лицензией, которая включает все функции Windows 7. Windows 7 Ultimate — это розничный аналог этого выпуска.

Windows 7 Starter Edition доступна по всему миру, и предполагается, что она будет развернута примарли на нетбуках, а также на портативных компьютерах с Ultra-низким энергопотреблением. Windows 7 Домашняя базовая доступна только на новых рынках.

Обратите внимание, что все выпуски Windows 7 (кроме выпуска Starter Edition) доступны как для 32-разрядных (x86), так и для 64-разрядных (x64) версий, а все розничные пакеты Windows 7 включают носители для обеих версий. Как и в Windows Vista, пользователи могут использовать один и тот же идентификатор розничного продукта на любой платформе.

Базовая технология в различных выпусках идентична, и все выпуски имеют одну и ту же версию среды выполнения DirectX и других компонентов. У них есть несколько отличий относительно игр.

-   Обозреватель игр доступен во всех выпусках, но ярлык "игры" в меню "Пуск" по умолчанию скрыт в Windows 7 Профессиональная и Корпоративная. Обозреватель игр по-прежнему можно найти в меню «Пуск» (щелкнув все программы, затем дважды щелкнув «игры»), и пользователь может включить ярлык «прямые игры».
-   Игры, включенные в Windows, недоступны по умолчанию в Windows 7 Профессиональная и Корпоративная, но они могут быть включены администратором.
-   Семейная безопасность и рейтинги игр доступны во всех выпусках, но они отключены в Windows 7 Профессиональная, Корпоративная и максимальная, когда операционная система присоединяется к домену. Как и в Windows Vista Ultimate, эту функцию можно включить повторно на компьютере, который присоединился к домену.

Параметры управления учетными записями пользователей (UAC) могут зависеть от параметров групповая политика в выпусках Windows 7 Профессиональная, Enterprise и Ultimate, подобно Windows Vista. Дополнительные сведения см **. в разделе различия между различными выпусками Windows Vista. Как они влияют на приложение DirectX?**

</dd> <dt>

<span id="Will_DirectX_10_be_available_for_Windows_XP__"></span><span id="will_directx_10_be_available_for_windows_xp__"></span><span id="WILL_DIRECTX_10_BE_AVAILABLE_FOR_WINDOWS_XP__"></span>**Будет ли DirectX 10 доступен для Windows XP?** 
</dt> <dd>

Нет. Windows Vista с DirectX 10 включает обновленную среду выполнения DirectX на основе среды выполнения в пакете обновления 2 (SP2) для Windows XP (DirectX 9.0 c) с изменениями для работы с новой моделью драйвера экрана Windows (WDDM) и новым стеком драйверов аудио, а также с другими обновлениями в операционной системе. Помимо Direct3D 9, Windows Vista поддерживает два новых интерфейса при наличии правильного оборудования и драйверов для видео: Direct3D9Ex и Direct3D10.

Поскольку эти новые интерфейсы полагаются на технологию WDDM, они никогда не будут доступны в более ранних версиях Windows. Все остальные изменения, вносимые в технологии DirectX для Windows Vista, также относятся к новой версии Windows. Имя DirectX 10 является ошибочным в том, что многие технологии, поставляемые в пакете SDK DirectX (КСИНПУТ, D3DX), не охватываются этим номером версии. Таким образом, обращение к номеру версии среды выполнения DirectX в целом потеряет значительную часть его значения, даже для 9.0 c. Средство диагностики DirectX (DXdiag.exe) в Windows Vista сообщает о DirectX 10, но в действительности это относится только к Direct3D 10.

</dd> <dt>

<span id="Will_DirectX_11_be_available_for_Windows_Vista_or_Windows_XP__"></span><span id="will_directx_11_be_available_for_windows_vista_or_windows_xp__"></span><span id="WILL_DIRECTX_11_BE_AVAILABLE_FOR_WINDOWS_VISTA_OR_WINDOWS_XP__"></span>**Будет ли выпущен DirectX 11 для Windows Vista или Windows XP?** 
</dt> <dd>

DirectX 11 встроен в Windows 7 и доступен в виде обновления для Windows Vista (см <https://go.microsoft.com/fwlink/p/?linkid=160189> .). Сюда входит API Direct3D 11, графическая инфраструктура DirectX (DXGI) 1,1, 10Level9 уровни компонентов, платформа Windows Advanced растеризации (ДЕФОРМАЦИЯ) 10 устройство отрисовки программного обеспечения, Direct2D, DirectWrite и обновление API Direct3D 10,1 для поддержки 10Level9 и деформации 10.

По тем же причинам, которые были указаны в предыдущем вопросе (**DirectX 10 будет доступен для Windows XP?** ), Direct3D 11 и связанные API недоступны в Windows XP.

</dd> <dt>

<span id="What_Happened_to_DirectShow__I_can_t_find_it_in_the_DirectX_SDK._"></span><span id="what_happened_to_directshow__i_can_t_find_it_in_the_directx_sdk._"></span><span id="WHAT_HAPPENED_TO_DIRECTSHOW__I_CAN_T_FIND_IT_IN_THE_DIRECTX_SDK._"></span>**Что случилось с DirectShow? Я не могу найти его в пакете SDK для DirectX.** 
</dt> <dd>

DirectShow была удалена из пакета SDK DirectX по состоянию на апрель 2005. Вы можете получить заголовки, библиотеки, инструменты и примеры для DirectShow в пакете средств разработки программного обеспечения Windows (прежнее название — Platform SDK). Директсетуп в пакете SDK для DirectX поддерживает перераспределение системных компонентов DirectShow, а последние компоненты уже установлены в следующих операционных системах: Microsoft Windows XP с пакетом обновления 2, Windows XP Professional x64 Edition, Windows Server 2003 с пакетом обновления 1 (SP1) и Windows Vista.

</dd> <dt>

<span id="What_changes_were_made_to_the_DirectX_runtime_for_Windows_Vista__"></span><span id="what_changes_were_made_to_the_directx_runtime_for_windows_vista__"></span><span id="WHAT_CHANGES_WERE_MADE_TO_THE_DIRECTX_RUNTIME_FOR_WINDOWS_VISTA__"></span>**Какие изменения были внесены в среду выполнения DirectX для Windows Vista?** 
</dt> <dd>

Для поддержки новой модели WDDM были внесены основные изменения. Дополнительные сведения о новой модели драйверов, о влиянии на Direct3D 9 и двух новых графических интерфейсах: Direct3D 9Ex и Direct3D 10, см. [в подразделах API графики в Windows](/windows/desktop/direct3darticles/graphics-apis-in-windows-vista). Новые графические API для Windows 7 — Direct3D 11, Direct2D, DirectWrite, DXGI 1,1 и обновленный Direct3D 10.1 — доступны в виде обновления для Windows Vista (см <https://go.microsoft.com/fwlink/p/?linkid=160189> .).

Пакет обновления 1 (SP1) для Windows Vista содержит обновленную версию среды выполнения DirectX. Это обновление дополняет поддержку Windows Vista для включения Direct3D 10,1, предоставляя новые дополнительные аппаратные функции. (Все оборудование, поддерживающее Direct3D 10,1, также полностью поддерживает все функции Direct3D 10.)

DirectSound был обновлен для предоставления возможностей нового стека Windows Vista Audio Driver, который поддерживает буферы программного обеспечения с несколькими каналами. Интерфейс API сохраненного режима Direct3D полностью удален из Windows Vista. Кроме того, служба DirectPlay Voice также была удалена, а также вспомогательной функции NAT для Директинпут и пользовательского интерфейса сопоставителя действий. Поддержка интерфейсов DirectX 7 и DirectX 8 для Visual Basic 6,0 недоступна в Windows Vista.

</dd> <dt>

<span id="What_changes_were_made_to_the_DirectX_runtime_for_Windows_7__"></span><span id="what_changes_were_made_to_the_directx_runtime_for_windows_7__"></span><span id="WHAT_CHANGES_WERE_MADE_TO_THE_DIRECTX_RUNTIME_FOR_WINDOWS_7__"></span>**Какие изменения были внесены в среду выполнения DirectX для Windows 7?** 
</dt> <dd>

В состав Windows 7 входят все компоненты среды выполнения DirectX, имеющиеся в Windows Vista, и добавлены функции Direct3D 11, DXGI 1,1, 10Level9, WARP10 Software, Direct2D, DirectWrite и обновление для Direct3D 10,1 для поддержки 10Level9 и WARP10. Дополнительные сведения см. [в статье графические API в Windows](/windows/desktop/direct3darticles/graphics-apis-in-windows-vista).

Все остальные компоненты идентичны Windows Vista, с 64 добавлением 64-разрядной (x64) собственной поддержки основного API DirectMusic, связанного с меткой времени MIDI. Уровень производительности DirectMusic остается устаревшим и доступен только для 32-разрядных приложений в Windows 7 для обеспечения совместимости приложений. Обратите внимание, что 64-разрядная собственная поддержка DirectMusic недоступна в Windows Vista.

</dd> <dt>

<span id="I_think_I_have_found_a_driver_bug__what_do_I_do__"></span><span id="i_think_i_have_found_a_driver_bug__what_do_i_do__"></span><span id="I_THINK_I_HAVE_FOUND_A_DRIVER_BUG__WHAT_DO_I_DO__"></span>**Я думаю, что обнаружена ошибка драйвера, что я делаю?** 
</dt> <dd>

Сначала убедитесь, что результаты проверены с помощью средства программной прорисовки. Затем проверьте результаты с помощью последней сертифицированной версии WHQL драйвера IHV. Вы можете программно проверить состояние WHQL с помощью метода Жетадаптеридентифиер () в интерфейсе IDirect3D9, передав \_ \_ флаг уровня лаборатории D3DENUM.

</dd> <dt>

<span id="Why_do_I_get_so_many_error_messages_when_I_try_to_compile_the_samples__"></span><span id="why_do_i_get_so_many_error_messages_when_i_try_to_compile_the_samples__"></span><span id="WHY_DO_I_GET_SO_MANY_ERROR_MESSAGES_WHEN_I_TRY_TO_COMPILE_THE_SAMPLES__"></span>**Почему при попытке компиляции образцов появляется много сообщений об ошибках?** 
</dt> <dd>

Возможно, неправильно задан путь к включаемым файлам. Многие компиляторы, в том числе Microsoft Visual C++, включают более раннюю версию пакета SDK, поэтому если во время поиска включаемых файлов в стандартном компиляторе выполняется поиск каталогов в первую очередь, будут получены неверные версии файлов заголовков. Чтобы устранить эту проблему, убедитесь в том, что для пути к включаемым файлам и библиотекам задано предварительное поиск путей к файлам и библиотекам Microsoft DirectX. См. также файл dxreadme.txt в пакете SDK. Если вы устанавливаете пакет SDK для DirectX и используете Visual C++, установщик может дополнительно настроить пути включения.

</dd> <dt>

<span id="I_get_linker_errors_about_multiple_or_missing_symbols_for_globally_unique_identifiers__GUIDs___what_do_I_do__"></span><span id="i_get_linker_errors_about_multiple_or_missing_symbols_for_globally_unique_identifiers__guids___what_do_i_do__"></span><span id="I_GET_LINKER_ERRORS_ABOUT_MULTIPLE_OR_MISSING_SYMBOLS_FOR_GLOBALLY_UNIQUE_IDENTIFIERS__GUIDS___WHAT_DO_I_DO__"></span>**Я получаю ошибки компоновщика о нескольких или отсутствующих символах для глобальных уникальных идентификаторов (GUID), что я делаю?** 
</dt> <dd>

Различные используемые идентификаторы GUID должны быть определены один раз и только один раз. Определение идентификатора GUID будет вставлено, если вы \# определили символ инитгуид перед включением файлов заголовков DirectX. Поэтому следует убедиться, что это происходит только в одной единице компиляции. Альтернативой этому методу является связывание с библиотекой дксгуид. lib, которая содержит определения всех идентификаторов GUID DirectX. При использовании этого метода (рекомендуется) никогда не следует \# определять символ инитгуид.

</dd> <dt>

<span id="Can_I_cast_a_pointer_to_a_DirectX_interface_to_a_lower_version_number__"></span><span id="can_i_cast_a_pointer_to_a_directx_interface_to_a_lower_version_number__"></span><span id="CAN_I_CAST_A_POINTER_TO_A_DIRECTX_INTERFACE_TO_A_LOWER_VERSION_NUMBER__"></span>**Можно ли привести указатель к интерфейсу DirectX к более низкому номеру версии?** 
</dt> <dd>

Нет. Интерфейсы DirectX являются COM-интерфейсами. Это означает, что для более высоких пронумерованных интерфейсов нет необходимости в порождении соответствующих более низких пронумерованных. Таким образом, единственным надежным способом получения другого интерфейса для объекта DirectX является использование метода QueryInterface интерфейса. Этот метод является частью стандартного интерфейса IUnknown, от которого должны наследоваться все COM-интерфейсы.

</dd> <dt>

<span id="Can_I_mix_the_use_of_DirectX_9_components_and_DirectX_8_or_earlier_components_within_the_same_application__"></span><span id="can_i_mix_the_use_of_directx_9_components_and_directx_8_or_earlier_components_within_the_same_application__"></span><span id="CAN_I_MIX_THE_USE_OF_DIRECTX_9_COMPONENTS_AND_DIRECTX_8_OR_EARLIER_COMPONENTS_WITHIN_THE_SAME_APPLICATION__"></span>**Можно ли смешивать компоненты DirectX 9 и DirectX 8 или более ранних версий в рамках одного приложения?** 
</dt> <dd>

Можно свободно смешивать разные компоненты разной версии. Например, можно использовать Директинпут 8 с Direct3D 9 в одном приложении. Однако обычно нельзя смешивать разные версии одного компонента в одном приложении. Например, вы не можете смешивать DirectDraw 7 с Direct3D 9 (так как они фактически являются одним и тем же компонентом, когда DirectDraw был относящиеся в Direct3D на DirectX 8). Однако существуют исключения, такие как использование Direct3D 9 и Direct3D 10 вместе в одном приложении, которое разрешено.

</dd> <dt>

<span id="Can_I_mix_the_use_of_Direct3D_9_and_Direct3D_10_within_the_same_application__"></span><span id="can_i_mix_the_use_of_direct3d_9_and_direct3d_10_within_the_same_application__"></span><span id="CAN_I_MIX_THE_USE_OF_DIRECT3D_9_AND_DIRECT3D_10_WITHIN_THE_SAME_APPLICATION__"></span>**Можно ли сочетать использование Direct3D 9 и Direct3D 10 в одном приложении?** 
</dt> <dd>

Да, вы можете использовать эти версии Direct3D вместе в одном приложении.

</dd> <dt>

<span id="What_do_the_return_values_from_the_Release_or_AddRef_methods_mean__"></span><span id="what_do_the_return_values_from_the_release_or_addref_methods_mean__"></span><span id="WHAT_DO_THE_RETURN_VALUES_FROM_THE_RELEASE_OR_ADDREF_METHODS_MEAN__"></span>**Что означают возвращаемые значения из методов выпуска или AddRef?** 
</dt> <dd>

Возвращаемое значение будет текущим счетчиком ссылок объекта. Однако спецификация COM указывает, что не следует полагаться на это, и значение обычно доступно только для целей отладки. Наблюдаемые значения могут быть неожиданными, так как другие системные объекты могут хранить ссылки на создаваемые объекты DirectX. По этой причине не следует писать код, который вызывает повторный вызов метода Release до тех пор, пока значение счетчика ссылок не будет равно нулю, так как объект может быть освобожден даже несмотря на то, что другой компонент по-прежнему может ссылаться на него.

</dd> <dt>

<span id="Does_it_matter_in_which_order_I_release_DirectX_interfaces__"></span><span id="does_it_matter_in_which_order_i_release_directx_interfaces__"></span><span id="DOES_IT_MATTER_IN_WHICH_ORDER_I_RELEASE_DIRECTX_INTERFACES__"></span>**Имеет ли дело порядок выпуска интерфейсов DirectX?** 
</dt> <dd>

Не имеет значения, так как COM-интерфейсы подсчитываются. Однако существуют некоторые известные ошибки с порядком выпуска интерфейсов в некоторых версиях DirectX. В целях безопасности рекомендуется освобождать интерфейсы в порядке создания обратных заказов, когда это возможно.

</dd> <dt>

<span id="What_is_a_smart_pointer_and_should_I_use_it__"></span><span id="what_is_a_smart_pointer_and_should_i_use_it__"></span><span id="WHAT_IS_A_SMART_POINTER_AND_SHOULD_I_USE_IT__"></span>**Что такое интеллектуальный указатель и следует ли его использовать?** 
</dt> <dd>

Интеллектуальный указатель — это класс шаблона C++, предназначенный для инкапсуляции функций указателя. В частности, существуют стандартные классы интеллектуальных указателей, предназначенные для инкапсуляции указателей на интерфейсы COM. Эти указатели автоматически выполняют QueryInterface вместо приведения и обрабатывали AddRef и Release. Следует ли использовать их, в основном это вопрос. Если код содержит большое количество копирований указателей интерфейса с несколькими AddRef и выпусками, то интеллектуальные указатели, вероятно, сделают ваш код менее подверженным ошибкам. В противном случае это можно сделать без них. Visual C++ включает стандартный интеллектуальный указатель Microsoft COM, определенный в файле заголовков "comdef. h" (поиск \_ \_ в справке com PTR t).

</dd> <dt>

<span id="I_have_trouble_debugging_my_DirectX_application__any_tips__"></span><span id="i_have_trouble_debugging_my_directx_application__any_tips__"></span><span id="I_HAVE_TROUBLE_DEBUGGING_MY_DIRECTX_APPLICATION__ANY_TIPS__"></span>**У меня возникли проблемы при отладке моего приложения DirectX?** 
</dt> <dd>

Наиболее распространенной проблемой при отладке приложений DirectX является попытка отладки, когда поверхность DirectDraw заблокирована. Такая ситуация может вызвать блокировку Win16 на системах Microsoft Windows 9x, которая не позволяет закрасить окно отладчика. Указание \_ флага НОСИСЛОКК D3DLOCK при блокировке поверхности обычно может устранить эту необходимость. Windows 2000 не страдает от этой проблемы. При разработке приложения полезно работать с отладочной версией среды выполнения DirectX (выбирается при установке пакета SDK), которая выполняет некоторые проверки параметров и выводит полезные сообщения в выходные данные отладчика.

</dd> <dt>

<span id="What_s_the_correct_way_to_check_return_codes__"></span><span id="what_s_the_correct_way_to_check_return_codes__"></span><span id="WHAT_S_THE_CORRECT_WAY_TO_CHECK_RETURN_CODES__"></span>**Каков правильный способ проверки кодов возврата?** 
</dt> <dd>

Используйте макросы "успешно" и "сбой". Методы DirectX могут возвращать несколько кодов успешного завершения и ошибок, поэтому просту:

``` syntax
== D3D_OK
```

или аналогичный тест не всегда будет достаточным.

</dd> <dt>

<span id="How_do_I_disable_ALT_TAB_and_other_task_switching__"></span><span id="how_do_i_disable_alt_tab_and_other_task_switching__"></span><span id="HOW_DO_I_DISABLE_ALT_TAB_AND_OTHER_TASK_SWITCHING__"></span>**Разделы справки отключить клавиши ALT + TAB и другие переключения задач?** 
</dt> <dd>

Не так. Игры должны иметь возможность корректного управления задачами, так как многие из них приводят к возникновению этой проблемы: ALT + TAB, подключения к удаленному рабочему столу, быстрое переключение пользователей, права на использование родительского контроля и многие другие события.

В то же время два стандартных источника случайного переключения задач в играх с схемами элементов управления, ориентированными на клавиатуры, находят нажатием клавиши Windows и активируйте залипание специальных возможностей с помощью клавиши SHIFT. Чтобы устранить эти случаи путем отключения функциональности, см. методы, описанные в разделе [Отключение сочетаний клавиш в играх](/windows/desktop/DxTechArts/disabling-shortcut-keys-in-games).

</dd> <dt>

<span id="Is_there_a_recommended_book_explaining_COM__"></span><span id="is_there_a_recommended_book_explaining_com__"></span><span id="IS_THERE_A_RECOMMENDED_BOOK_EXPLAINING_COM__"></span>**Есть ли рекомендуемая книга, объясняющая COM?** 
</dt> <dd>

*В COM-* приложении Дэйл rogerson's, опубликованное Microsoft Press, является отличным ВВЕДЕНИЕМ в com. Для более подробного взгляда на модели COM также настоятельно рекомендуется использовать для книги *Ключевые com* , опубликованные в долгосрочной перспективе.

</dd> <dt>

<span id="What_is_managed_code__"></span><span id="what_is_managed_code__"></span><span id="WHAT_IS_MANAGED_CODE__"></span>**Что такое управляемый код?** 
</dt> <dd>

Управляемый код — это код, выполнение которого осуществляется с помощью платформа .NET Framework среды CLR. Он относится к контракту взаимодействия, выполняемого в собственном коде, и в среде выполнения. Этот контракт указывает, что в любой точке выполнения среда выполнения может прерывать выполнение ЦП и получать сведения, относящиеся к текущему адресу инструкции ЦП. Сведения, которые должны быть доступны для запросов, обычно относятся к состоянию среды выполнения, например регистру или содержимому стековой памяти.

Перед выполнением кода IL компилируется в машинный исполняемый код. И, поскольку эта компиляция происходит управляемой средой выполнения (или, что более верно, компилятором с поддержкой среды выполнения, который знает, как ориентироваться на управляемую среду выполнения), среда управляемого выполнения может гарантировать то, что будет делать код. Он может вставлять ловушки и соответствующие обработчики сборки мусора, обработку исключений, безопасность типов, границы массивов и проверку индексов и т. д. Например, такой компилятор обеспечивает размещение кадров стека и всего лишь прямо так, чтобы сборщик мусора мог работать в фоновом режиме в отдельном потоке, постоянно проходея активного стека вызовов, находя все корни, прослеживания все активные объекты. Кроме того, поскольку IL имеет понятие о безопасности типа, подсистема выполнения обеспечит гарантию безопасности, исключая целый класс программных ошибок, которые часто приводят к бреши в системе безопасности.

В отличие от неуправляемого мира: неуправляемые исполняемые файлы — это, по сути, двоичный образ, код x86, загруженный в память. В счетчик программы помещается, и это последнее известное ОС. Существуют такие средства защиты, как управление памятью и ввод-вывод на порт и т. д., но система не знает, что делает приложение. Таким образом, он не может гарантировать, что происходит при запуске приложения.

</dd> <dt>

<span id="What_books_are_there_about_general_Windows_programming__"></span><span id="what_books_are_there_about_general_windows_programming__"></span><span id="WHAT_BOOKS_ARE_THERE_ABOUT_GENERAL_WINDOWS_PROGRAMMING__"></span>**Какие книги посвящены общему программированию Windows?** 
</dt> <dd>

Многое. Однако настоятельно рекомендуется использовать следующие два.

-   Программирование окон с помощью Чарльз Петцольд (Microsoft Press)
-   Программирование приложений для Windows с помощью Джеффри Рихтер (Microsoft Press)

</dd> <dt>

<span id="How_do_I_debug_using_the_Windows_symbol_files__"></span><span id="how_do_i_debug_using_the_windows_symbol_files__"></span><span id="HOW_DO_I_DEBUG_USING_THE_WINDOWS_SYMBOL_FILES__"></span>**Разделы справки отлаживать с помощью файлов символов Windows?** 
</dt> <dd>

Корпорация Майкрософт отменяет публикацию неограниченных символов для всех системных библиотек DLL (а также нескольких других). Чтобы получить доступ к ним, добавьте следующий адрес в путь к символам в параметрах проекта в Visual Studio:

``` syntax
srv*https://msdl.microsoft.com/download/symbols
```

для локального кэширования символов используйте следующий синтаксис:

``` syntax
srv*c:\cache*https://msdl.microsoft.com/download/symbols
```

Где c: \\ Cache — локальный каталог для кэширования файлов символов.

</dd> </dl>

## <a name="direct3d-questions"></a>Вопросы по Direct3D

### <a name="general-direct3d-questions"></a>Общие вопросы по Direct3D

<dl> <dt>

<span id="Where_can_I_find_information_about_3D_graphics_techniques__"></span><span id="where_can_i_find_information_about_3d_graphics_techniques__"></span><span id="WHERE_CAN_I_FIND_INFORMATION_ABOUT_3D_GRAPHICS_TECHNIQUES__"></span>**Где можно найти сведения о приемах трехмерной графики?** 
</dt> <dd>

Стандартной книгой по теме является компьютерная графика: принципы и практика, Фоли, Van Dam et. Это ценный ресурс для всех пользователей, желающих разобраться в математических принципах геометрических, растровых и аппаратных методов освещения. Часто задаваемые вопросы о группе comp. Graphics. алгоритмов также содержат полезные материалы.

</dd> <dt>

<span id="Does_Direct3D_emulate_functionality_not_provided_by_hardware__"></span><span id="does_direct3d_emulate_functionality_not_provided_by_hardware__"></span><span id="DOES_DIRECT3D_EMULATE_FUNCTIONALITY_NOT_PROVIDED_BY_HARDWARE__"></span>**Функции эмуляции Direct3D не предоставляются оборудованием?** 
</dt> <dd>

Это зависит от нескольких условий. В Direct3D имеется полнофункциональный конвейер обработки вершин (включая поддержку пользовательских шейдеров вершин). Однако для операций на уровне точек эмуляция не предоставляется; приложения должны проверять соответствующие биты и использовать API Валидатедевице для определения поддержки.

</dd> <dt>

<span id="Is_there_a_software_rasterizer_included_with_Direct3D__"></span><span id="is_there_a_software_rasterizer_included_with_direct3d__"></span><span id="IS_THERE_A_SOFTWARE_RASTERIZER_INCLUDED_WITH_DIRECT3D__"></span>**Входит ли программное средство прорисовки в Direct3D?** 
</dt> <dd>

Не для приложений производительности. Для проверки драйверов предоставляется справочный средство программной прорисовки, но реализация рассчитана на точность, а не на производительность. Direct3D поддерживает модули программной прорисовки подключаемых модулей.

</dd> <dt>

<span id="How_can_I_perform_color_keying_with_DirectX_graphics__"></span><span id="how_can_i_perform_color_keying_with_directx_graphics__"></span><span id="HOW_CAN_I_PERFORM_COLOR_KEYING_WITH_DIRECTX_GRAPHICS__"></span>**Как можно выполнять цветовую раскладку с помощью графики DirectX?** 
</dt> <dd>

Ключ цвета не поддерживается напрямую, вместо этого необходимо использовать альфа-смешение для эмуляции цветовой декраски. Для упрощения этой процедуры можно использовать функцию D3DXCreateTextureFromFileEx (). Эта функция принимает параметр цвета ключа и заменит все пиксели из исходного изображения, содержащего заданный цвет, прозрачными черными пикселями в созданной текстуре.

</dd> <dt>

<span id="Does_the_Direct3D_geometry_code_utilize_3DNow__and_or_Pentium_III_SIMD_instructions__"></span><span id="does_the_direct3d_geometry_code_utilize_3dnow__and_or_pentium_iii_simd_instructions__"></span><span id="DOES_THE_DIRECT3D_GEOMETRY_CODE_UTILIZE_3DNOW__AND_OR_PENTIUM_III_SIMD_INSTRUCTIONS__"></span>**Использует ли код геометрии Direct3D инструкции 3DNow! и/или Pentium III SIMD?** 
</dt> <dd>

Да. В конвейере обработки геометрии Direct3D есть несколько различных путей кода в зависимости от типа процессора и будут использоваться специальные операции с плавающей запятой, предоставляемые 3DNow! или Pentium III SIMD, где доступны эти инструкции. Это включает обработку пользовательских шейдеров вершин.

</dd> <dt>

<span id="How_do_I_prevent_transparent_pixels_being_written_to_the_z-buffer__"></span><span id="how_do_i_prevent_transparent_pixels_being_written_to_the_z-buffer__"></span><span id="HOW_DO_I_PREVENT_TRANSPARENT_PIXELS_BEING_WRITTEN_TO_THE_Z-BUFFER__"></span>**Разделы справки предотвратить запись прозрачных пикселей в z-буфер?** 
</dt> <dd>

Можно отфильтровать пикселы с помощью альфа-значения выше или ниже заданного порогового значения. Это поведение управляется с помощью рендерстатес АЛФАТЕСТЕНАБЛЕ, АЛФАРЕФ и АЛФАФУНК.

</dd> <dt>

<span id="What_is_a_stencil_buffer__"></span><span id="what_is_a_stencil_buffer__"></span><span id="WHAT_IS_A_STENCIL_BUFFER__"></span>**Что такое буфер трафарета?** 
</dt> <dd>

Буфер набора элементов — это дополнительный буфер данных на пиксель, подобно z-буферу. Фактически он находится в некоторых битах z-буфера. Формат общего трафарета/z-буфера — 15-разрядный z и 1-разрядный набор элементов, а также 24-разрядный z и 8-разрядный набор элементов. Можно выполнять простые арифметические операции над содержимым буфера шаблона на пиксельном уровне при отрисовке многоугольников. Например, буфер шаблона можно увеличить или уменьшить, или пиксель можно отклонить, если значение шаблона не проходит простой тест сравнения. Это полезно для эффектов, которые охватывают область буфера кадров, а затем выполняя визуализацию только отмеченного (или непомеченного) региона. Хорошим примером являются объемные такие эффекты, как теневые тома.

</dd> <dt>

<span id="How_do_I_use_a_stencil_buffer_to_render_shadow_volumes__"></span><span id="how_do_i_use_a_stencil_buffer_to_render_shadow_volumes__"></span><span id="HOW_DO_I_USE_A_STENCIL_BUFFER_TO_RENDER_SHADOW_VOLUMES__"></span>**Разделы справки использовать буфер шаблона для отображения теневых томов?** 
</dt> <dd>

Ключом к этому и другим эффектам буфера набора элементов объемные является взаимодействие между буфером трафарета и z-буфером. Сцена с теневым томом отображается в три этапа. Во-первых, сцена без тени визуализируется обычным образом с помощью z-буфера. Затем тень помечается в буфере шаблона следующим образом. Лицевые стороны теневого тома рисуются с помощью невидимых многоугольников с включенным z-тестированием, но при этом отключается z-запись, а размер буфера шаблона увеличивается на каждом пикселе, передавая z-тест. Задние грани теневого тома отображаются аналогичным образом, но вместо этого уменьшается значение набора элементов.

Теперь рассмотрим один пиксель. Если камера не находится в теневом томе, то для соответствующей точки сцены существует четыре варианта. Если луч от камеры к точке не пересекается с теневым томом, то теневые многоугольники не будут отображаться там, а буфер шаблона остается нулевым. В противном случае, если точка находится перед теневым томом, теневые многоугольники будут относиться к z-буферизации, а набор элементов снова останется неизменным. Если точки находятся за теневым томом, то будет отображено то же количество внешних лицевых сторон, что и для задних граней, а набор элементов будет равен нулю, что увеличится столько раз, сколько было уменьшено.

Последняя возможность заключается в том, что точка находится внутри теневого тома. В этом случае на обратной стороне теневого тома будет использоваться z-буферизация, но не лицевая сторона, поэтому буфер шаблона будет иметь ненулевое значение. Результат заключается в том, что части буфера фрейма, появляющиеся в теневой копии, имеют ненулевое значение трафарета. Наконец, для фактической прорисовки тени вся сцена накладывается на многоугольник с альфа-смешением, который задается только на пикселах с ненулевым значением трафарета. Пример этой методики можно увидеть в примере "теневой том", который поставляется с пакетом SDK DirectX.

</dd> <dt>

<span id="What_are_the_texel_alignment_rules__How_do_I_get_a_one-to-one_mapping__"></span><span id="what_are_the_texel_alignment_rules__how_do_i_get_a_one-to-one_mapping__"></span><span id="WHAT_ARE_THE_TEXEL_ALIGNMENT_RULES__HOW_DO_I_GET_A_ONE-TO-ONE_MAPPING__"></span>**Что такое правила выравнивания шаг текселя? Разделы справки получить сопоставление "один к одному"?** 
</dt> <dd>

Эти сведения полностью описаны в документации по Direct3D 9. Однако для правильной согласованности с пикселей текстуры необходимо заменять координаты экрана на-0,5 пикселей. Большинство карт теперь правильно соответствуют правилам выравнивания шаг текселя, однако некоторые старые карты или драйверы не поддерживаются. Чтобы справиться с этими случаями, лучше обратиться к поставщику оборудования и запросить обновленные драйверы или предлагаемое решение. Обратите внимание, что в Direct3D 10 это правило больше не хранится.

</dd> <dt>

<span id="What_is_the_purpose_of_the_D3DCREATE_PUREDEVICE_flag__"></span><span id="what_is_the_purpose_of_the_d3dcreate_puredevice_flag__"></span><span id="WHAT_IS_THE_PURPOSE_OF_THE_D3DCREATE_PUREDEVICE_FLAG__"></span>**Для чего предназначен \_ флаг D3DCREATE пуредевице?** 
</dt> <dd>

Используйте флаг D3DCREATE \_ пуредевице во время создания устройства, чтобы создать чистое устройство. Чистое устройство не сохраняет текущее состояние (во время изменений состояния), что часто повышает производительность; для этого устройства также требуется аппаратная обработка вершин. Чистое устройство обычно используется при завершении разработки и отладки, и вы хотите добиться лучшей производительности.

Недостаток чистого устройства заключается в том, что он не поддерживает все \* вызовы API Get. Это означает, что нельзя использовать чистое устройство для запроса состояния конвейера. Это усложняет отладку во время выполнения приложения. Ниже приведен список всех методов, отключенных чистым устройством.

-   [**IDirect3DDevice9:: Жетклипплане**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-getclipplane)
-   [**IDirect3DDevice9:: Жетклипстатус**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-getclipstatus)
-   [**IDirect3DDevice9:: light**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-getlight)
-   [**IDirect3DDevice9:: осветлить**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-getlightenable)
-   [**IDirect3DDevice9:: о.**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-getmaterial)
-   [**IDirect3DDevice9:: Жетпикселшадерконстантф**](/windows/desktop/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-getpixelshaderconstantf)
-   [**IDirect3DDevice9:: Жетпикселшадерконстанти**](/windows/desktop/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-getpixelshaderconstanti)
-   [**IDirect3DDevice9:: Жетпикселшадерконстантб**](/windows/desktop/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-getpixelshaderconstantb)
-   [**IDirect3DDevice9:: Жетрендерстате**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-getrenderstate)
-   [**IDirect3DDevice9:: Жетсамплерстате**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-getsamplerstate)
-   [**IDirect3DDevice9:: Жеттекстурестажестате**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-gettexturestagestate)
-   [**IDirect3DDevice9:: Transform**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-gettransform)
-   [**IDirect3DDevice9:: Жетвертексшадерконстантф**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-getvertexshaderconstantf)
-   [**IDirect3DDevice9:: Жетвертексшадерконстанти**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-getvertexshaderconstanti)
-   [**IDirect3DDevice9:: Жетвертексшадерконстантб**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-getvertexshaderconstantb)

Вторым недостатком чистого устройства является то, что он не фильтрует изменения в избыточном состоянии. При использовании чистого устройства приложение должно уменьшить количество изменений состояния в цикле визуализации до минимума; Это может включать изменения состояния фильтрации, чтобы гарантировать, что состояния не будут установлены несколько раз. Это компромиссно зависит от приложения; При использовании более 1000 вызовов set на кадр следует рассмотреть возможность использования фильтрации избыточности, которая выполняется автоматически нечистым устройством.

Как и в случае всех проблем с производительностью, единственный способ определить, будет ли приложение работать лучше с чистого устройства, — сравнить производительность приложения с чистым и нечистым устройством. Чистое устройство может ускорить работу приложения, уменьшая нагрузку на ЦП API. Но будьте внимательны! В некоторых сценариях чистое устройство будет замедлять работу приложения (из-за дополнительных операций ЦП, вызванных изменением избыточного состояния). Если вы не знаете, какой тип устройства лучше подходит для вашего приложения, и вы не фильтруете избыточные изменения в приложении, используйте нечистое устройство.

</dd> <dt>

<span id="How_do_I_enumerate_the_display_devices_in_a_multi-monitor_system__"></span><span id="how_do_i_enumerate_the_display_devices_in_a_multi-monitor_system__"></span><span id="HOW_DO_I_ENUMERATE_THE_DISPLAY_DEVICES_IN_A_MULTI-MONITOR_SYSTEM__"></span>**Разделы справки перечислить устройства отображения в системе с несколькими мониторами?** 
</dt> <dd>

Перечисление можно выполнить с помощью простой итерации приложения с помощью методов интерфейса IDirect3D9. Вызовите Жетадаптеркаунт, чтобы определить количество адаптеров дисплея в системе. Вызовите Жетадаптермонитор, чтобы определить, к какому физическому монитору подключен адаптер (этот метод возвращает ХМОНИТОР, который затем можно использовать в Жетмониторинфо API Win32 для определения сведений о физическом мониторе). Определение характеристик конкретного видеоадаптера или создание устройства Direct3D на этом адаптере сводится к передаче соответствующего номера адаптера вместо D3DADAPTER \_ по умолчанию при вызове жетдевицекапс, креатедевице или других методов.

</dd> <dt>

<span id="What_happened_to_Fixed_Function_Bumpmapping_in_D3D9__"></span><span id="what_happened_to_fixed_function_bumpmapping_in_d3d9__"></span><span id="WHAT_HAPPENED_TO_FIXED_FUNCTION_BUMPMAPPING_IN_D3D9__"></span>**Что случилось с исправленной функцией Бумпмаппинг в D3D9?** 
</dt> <dd>

Начиная с Direct3D 9 мы проверку на картах, которые поддерживали только > 2 одновременные текстуры. При использовании определенной операции альфа-модуляции для некоторых старых карт доступно 3 этапа текстуры. Наиболее распространенный способ использования, в котором люди используют три этапа, — Приподнятие бумпмаппинг, и вы все равно можете сделать это с помощью D3D9.

Поле Height должно храниться в альфа-канале и использоваться для модуляции вклада в свет, то есть:

``` syntax
// Stage 0 is the base texture, with the height map in the alpha channel
m_pd3dDevice->SetTexture(0, m_pEmbossTexture );
m_pd3dDevice->SetTextureStageState(0, D3DTSS_TEXCOORDINDEX, 0 );
m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLOROP,   D3DTOP_MODULATE );
m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG1, D3DTA_TEXTURE );
m_pd3dDevice->SetTextureStageState(0, D3DTSS_COLORARG2, D3DTA_DIFFUSE );
m_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAOP,   D3DTOP_SELECTARG1 );
m_pd3dDevice->SetTextureStageState(0, D3DTSS_ALPHAARG1, D3DTA_TEXTURE );
if( m_bShowEmbossMethod )
{
 // Stage 1 passes through the RGB channels (SELECTARG2 = CURRENT), and 
 // does a signed add with the inverted alpha channel. 
 // The texture coords associated with Stage 1 are the shifted ones, so 
 // the result is:
 //    (height - shifted_height) * tex.RGB * diffuse.RGB
   m_pd3dDevice->SetTexture( 1, m_pEmbossTexture );
   m_pd3dDevice->SetTextureStageState( 1, D3DTSS_TEXCOORDINDEX, 1 );
   m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLOROP, D3DTOP_SELECTARG2 );
   m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG1, D3DTA_TEXTURE );
   m_pd3dDevice->SetTextureStageState( 1, D3DTSS_COLORARG2, D3DTA_CURRENT );
   m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAOP, D3DTOP_ADDSIGNED );
   m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG1, D3DTA_TEXTURE|D3DTA_COMPLEMENT );
   m_pd3dDevice->SetTextureStageState( 1, D3DTSS_ALPHAARG2, D3DTA_CURRENT );

   // Set up the alpha blender to multiply the alpha channel 
   // (monochrome emboss) with the src color (lighted texture)
   m_pd3dDevice->SetRenderState( D3DRS_ALPHABLENDENABLE, TRUE );
   m_pd3dDevice->SetRenderState( D3DRS_SRCBLEND,  D3DBLEND_SRCALPHA );
   m_pd3dDevice->SetRenderState( D3DRS_DESTBLEND, D3DBLEND_ZERO );
}
```

Этот пример вместе с другими более старыми примерами больше не поставляются в текущем выпуске пакета SDK и не будет поставляться в будущих выпусках пакета SDK.

</dd> </dl>

### <a name="geometry-vertex-processing"></a>Обработка геометрии (вершина)

<dl> <dt>

<span id="Vertex_streams_confuse_me_how_do_they_work__"></span><span id="vertex_streams_confuse_me_how_do_they_work__"></span><span id="VERTEX_STREAMS_CONFUSE_ME_HOW_DO_THEY_WORK__"></span>**Потоки вершин путают мне, как они работают?** 
</dt> <dd>

Direct3D собирает каждую вершину, которая передается в обрабатывающую часть конвейера, из одного или нескольких потоков вершин. Наличие только одного потока вершин соответствует старой модели, предшествующей DirectX 8, в которой вершины берутся из одного источника. С помощью DirectX 8 различные компоненты вершины могут поступать из разных источников. Например, один буфер вершин может содержать позиции и нормали, в то время как второй сохраненный цвет и координаты текстуры.

</dd> <dt>

<span id="What_is_a_vertex_shader__"></span><span id="what_is_a_vertex_shader__"></span><span id="WHAT_IS_A_VERTEX_SHADER__"></span>**Что такое шейдер вершин?** 
</dt> <dd>

Шейдер вершин — это процедура обработки одной вершины. Он определяется с помощью простого языка, аналогичного сборке, который собирается библиотекой служебной программы D3DX в поток маркеров, принимаемый Direct3D. Шейдер вершин принимает в качестве входных данных одну вершину и набор постоянных значений; Он выводит расположение вершины (в пространстве клипов) и, при необходимости, набор цветов и координат текстуры, которые используются при растрировании. Обратите внимание, что при наличии пользовательского шейдера вершин компоненты вершины больше не имеют никакой семантики, применяемой в Direct3D, а вершины — это просто произвольные данные, интерпретируемые создаваемым шейдером вершин.

</dd> <dt>

<span id="Does_a_vertex_shader_perform_perspective_division_or_clipping__"></span><span id="does_a_vertex_shader_perform_perspective_division_or_clipping__"></span><span id="DOES_A_VERTEX_SHADER_PERFORM_PERSPECTIVE_DIVISION_OR_CLIPPING__"></span>**Выполняет ли шейдер вершин деление перспективы или обрезает?** 
</dt> <dd>

Нет. Шейдер вершин выводит однородную координату в пространстве обрезки для преобразованной координаты вершины. Подразделение перспективы и обрезка выполняются автоматически после шейдера.

</dd> <dt>

<span id="Can_I_generate_geometry_with_a_vertex_shader__"></span><span id="can_i_generate_geometry_with_a_vertex_shader__"></span><span id="CAN_I_GENERATE_GEOMETRY_WITH_A_VERTEX_SHADER__"></span>**Можно ли создать геометрию с помощью шейдера вершин?** 
</dt> <dd>

Шейдер вершин не может создавать или удалять вершины; Он работает с одной вершиной за раз, принимая одну необработанную вершину в качестве входных данных и выводите одну обработанную вершину. Таким образом, его можно использовать для работы с существующей геометрией (применением или выполнением операций с обложками), но на самом деле не может создать новую геометрию на уровне SE.

</dd> <dt>

<span id="Can_I_apply_a_custom_vertex_shader_to_the_results_of_the_fixed-function_geometry_pipeline__or_vice-versa___"></span><span id="can_i_apply_a_custom_vertex_shader_to_the_results_of_the_fixed-function_geometry_pipeline__or_vice-versa___"></span><span id="CAN_I_APPLY_A_CUSTOM_VERTEX_SHADER_TO_THE_RESULTS_OF_THE_FIXED-FUNCTION_GEOMETRY_PIPELINE__OR_VICE-VERSA___"></span>**Можно ли применить пользовательский шейдер вершин к результатам конвейера геометрии с фиксированной функцией (или наоборот)?** 
</dt> <dd>

Нет. Необходимо выбрать один или другой. Если вы используете пользовательский шейдер вершин, вы несете ответственность за выполнение всего преобразования вершин.

</dd> <dt>

<span id="Can_I_use_a_custom_vertex_shader_if_my_hardware_does_not_support_it__"></span><span id="can_i_use_a_custom_vertex_shader_if_my_hardware_does_not_support_it__"></span><span id="CAN_I_USE_A_CUSTOM_VERTEX_SHADER_IF_MY_HARDWARE_DOES_NOT_SUPPORT_IT__"></span>**Можно ли использовать пользовательский шейдер вершин, если его оборудование не поддерживает?** 
</dt> <dd>

Да. Модуль обработки вершин программного обеспечения Direct3D полностью поддерживает пользовательские шейдеры вершин с удивительно высоким уровнем производительности.

</dd> <dt>

<span id="How_do_I_determine_if_the_hardware_supports_my_custom_vertex_shader__"></span><span id="how_do_i_determine_if_the_hardware_supports_my_custom_vertex_shader__"></span><span id="HOW_DO_I_DETERMINE_IF_THE_HARDWARE_SUPPORTS_MY_CUSTOM_VERTEX_SHADER__"></span>**Разделы справки определить, поддерживает ли оборудование пользовательский шейдер вершин?** 
</dt> <dd>

Устройства, поддерживающие поддержку шейдеров вершин в оборудовании, необходимы для заполнения поля D3DCAPS9:: Вертексшадерверсион, указывающего на уровень версии шейдера вершин, который они поддерживают. Все устройства, поддерживающие определенный уровень шейдера вершин, должны поддерживать все допустимые построители текстур вершин, соответствующие спецификации этого уровня или ниже.

</dd> <dt>

<span id="How_many_constant_registers_are_available_for_vertex_shaders__"></span><span id="how_many_constant_registers_are_available_for_vertex_shaders__"></span><span id="HOW_MANY_CONSTANT_REGISTERS_ARE_AVAILABLE_FOR_VERTEX_SHADERS__"></span>**Сколько регистров констант доступно для шейдеров вершин?** 
</dt> <dd>

Устройства, поддерживающие шейдер вершин VS 1,0, должны поддерживать не менее 96 постоянных регистров. Устройства могут поддерживать больше этого минимального числа и могут сообщить об этом через поле D3DCAPS9:: Максвертексшадерконст.

</dd> <dt>

<span id="Can_I_share_position_data_between_vertices_with_different_texture_coordinates__"></span><span id="can_i_share_position_data_between_vertices_with_different_texture_coordinates__"></span><span id="CAN_I_SHARE_POSITION_DATA_BETWEEN_VERTICES_WITH_DIFFERENT_TEXTURE_COORDINATES__"></span>**Можно ли совместно использовать данные о положении между вершинами с разными координатами текстуры?** 
</dt> <dd>

Обычным примером этой ситуации является куб, в котором необходимо использовать другую текстуру для каждой грани. Увы, ответ — «нет», сейчас невозможно индексировать компоненты вершин по отдельности. Даже с несколькими потоками вершин индексируются все потоки.

</dd> <dt>

<span id="When_I_submit_an_indexed_list_of_primitives__does_Direct3D_process_all_of_the_vertices_in_the_buffer__or_just_the_ones_I_indexed__"></span><span id="when_i_submit_an_indexed_list_of_primitives__does_direct3d_process_all_of_the_vertices_in_the_buffer__or_just_the_ones_i_indexed__"></span><span id="WHEN_I_SUBMIT_AN_INDEXED_LIST_OF_PRIMITIVES__DOES_DIRECT3D_PROCESS_ALL_OF_THE_VERTICES_IN_THE_BUFFER__OR_JUST_THE_ONES_I_INDEXED__"></span>**При отправке индексированного списка примитивов Direct3D обрабатывает все вершины в буфере или только индексируемые?** 
</dt> <dd>

При использовании конвейера по геометрии программного обеспечения Direct3D сначала преобразует все вершины в отправленном диапазоне, а не преобразует их по запросу, когда они индексируются. Для плотных упакованных данных (то есть, где используются большинство вершин) это более эффективно, особенно если доступны инструкции SIMD. Если данные находятся в разреженном виде (т. е. многие вершины не используются), то, возможно, потребуется переупорядочить данные, чтобы избежать слишком большого количества избыточных преобразований. При использовании аппаратного ускорения геометрии вершины обычно преобразуются по запросу по мере необходимости.

</dd> <dt>

<span id="What_is_an_index_buffer__"></span><span id="what_is_an_index_buffer__"></span><span id="WHAT_IS_AN_INDEX_BUFFER__"></span>**Что такое буфер индексов?** 
</dt> <dd>

Буфер индексов точно аналогичен буферу вершин, но он содержит индексы для использования в вызовах Дравиндекседпримитиве. Настоятельно рекомендуется использовать буферы индексов вместо необработанной памяти, выделенной приложением по возможности, по тем же причинам, что и буферы вершин.

</dd> <dt>

<span id="I_notice_that_32-bit_indices_are_a_supported_type__can_I_use_them_on_all_devices__"></span><span id="i_notice_that_32-bit_indices_are_a_supported_type__can_i_use_them_on_all_devices__"></span><span id="I_NOTICE_THAT_32-BIT_INDICES_ARE_A_SUPPORTED_TYPE__CAN_I_USE_THEM_ON_ALL_DEVICES__"></span>**Обратите внимание, что 32-разрядные индексы поддерживают тип; можно ли использовать их на всех устройствах?** 
</dt> <dd>

Нет. Чтобы определить максимальное значение индекса, поддерживаемое устройством, необходимо проверить поле D3DCAPS9:: Максвертексиндекс. Это значение должно быть больше 2 в 16-й час (0xFFFF), чтобы буферы индексов типа D3DFMT \_ INDEX32 поддерживались. Кроме того, обратите внимание, что некоторые устройства могут поддерживать 32-разрядные индексы, но поддерживают максимальное значение индекса, меньшее 2, в 32-го Power-1 (0xFFFFFFFF). в этом случае приложение должно учитывать лимит, сообщаемый устройством.

</dd> <dt>

<span id="Does_S_W_vertex_processing_support_64_bit__"></span><span id="does_s_w_vertex_processing_support_64_bit__"></span><span id="DOES_S_W_VERTEX_PROCESSING_SUPPORT_64_BIT__"></span>**Поддерживает ли обработка вершин (S/W) 64 бит?** 
</dt> <dd>

Для x64 существует оптимизированный конвейер s/w, но он не существует для IA64.

</dd> </dl>

### <a name="performance-tuning"></a>Настройка производительности

<dl> <dt>

<span id="How_can_I_improve_the_performance_of_my_Direct3D_application__"></span><span id="how_can_i_improve_the_performance_of_my_direct3d_application__"></span><span id="HOW_CAN_I_IMPROVE_THE_PERFORMANCE_OF_MY_DIRECT3D_APPLICATION__"></span>**Как можно повысить производительность приложения Direct3D?** 
</dt> <dd>

Ниже приведены основные аспекты, которые следует рассмотреть при оптимизации производительности.

<dl> <dt>

<span id="Batch_size_"></span><span id="batch_size_"></span><span id="BATCH_SIZE_"></span>**Размер пакета** 
</dt> <dd>

Direct3D оптимизирован для больших пакетов примитивов. Чем больше многоугольников можно отправить в одном вызове, тем лучше. Хорошим правилом для параметра Thumb является среднее 1000 вершин на вызов примитива. Ниже этот уровень, вероятно, не является оптимальной производительностью, чем выше, и вы получаете снижение количества возвратов и потенциальных конфликтов с соображениями параллелизма (см. ниже).

</dd> <dt>

<span id="State_changes_"></span><span id="state_changes_"></span><span id="STATE_CHANGES_"></span>**Изменения состояния** 
</dt> <dd>

Изменение состояния рендеринга может быть дорогостоящей операцией, особенно при изменении текстуры. По этой причине важно максимально увеличить количество изменений состояния в кадре. Кроме того, постарайтесь не изменять буфер вершин или индекс.

> [!Note]  
> Начиная с DirectX 8 стоимость изменения буфера вершин больше не так высока, как и в предыдущих версиях, но рекомендуется избегать изменений в буфере вершин, если это возможно.

 

</dd> <dt>

<span id="Concurrency"></span><span id="concurrency"></span><span id="CONCURRENCY"></span>**Параллелизма**
</dt> <dd>

Если вы можете организовать параллельную отрисовку с другой обработкой, вы получите все преимущества производительности системы. Эта цель может конфликтовать с целью сокращения рендерстате изменений. Необходимо установить баланс между пакетной обработкой, чтобы сократить изменения состояния и принудительно отправить данные в драйвер, чтобы помочь достигнуть параллелизма. Использование нескольких буферов вершин с циклическим перебором может помочь при одновременном использовании.

</dd> <dt>

<span id="Texture_uploads_"></span><span id="texture_uploads_"></span><span id="TEXTURE_UPLOADS_"></span>**Передачи текстур** 
</dt> <dd>

Передача текстур на устройство потребляет пропускную способность и вызывает конкуренцию с пропускной способностью с данными вершин. Поэтому важно не перегружать память текстуры, что приведет к принудительной нагрузке схемы кэширования для передачи чрезмерного количества текстур каждого кадра.

</dd> <dt>

<span id="Vertex_and_index_buffers_"></span><span id="vertex_and_index_buffers_"></span><span id="VERTEX_AND_INDEX_BUFFERS_"></span>**Буферы вершин и индексов** 
</dt> <dd>

Всегда следует использовать буферы вершин и индексов, а не обычные блоки выделенной памяти приложения. Как минимум семантика блокировки буферов вершин и индексов может не допустить избыточной операции копирования. С некоторыми драйверами можно разместить буфер вершин или индекс в более оптимальном объеме памяти (например, в видеопамяти или AGP) для доступа к оборудованию.

</dd> <dt>

<span id="State_macro_blocks_"></span><span id="state_macro_blocks_"></span><span id="STATE_MACRO_BLOCKS_"></span>**Блоки макросов состояния** 
</dt> <dd>

Они появились в DirectX 7,0. Они предоставляют механизм для записи ряда изменений состояния (в том числе изменений освещения, материала и матрицы) в макрос, который затем можно воспроизвести с помощью одного вызова. Это принесет два преимущества:

-   Вы уменьшаете затраты на вызов, вызвав один вызов вместо множества.
-   Драйвер с поддержкой драйвера может предварительно анализировать и предварительно компилировать изменения состояния, что значительно ускоряет их отправку на графическое оборудование.

Изменения состояния по-прежнему могут быть дорогостоящими, но использование макросов состояния помогает сократить по крайней мере некоторые затраты. Используйте только одно устройство Direct3D. Если необходимо выполнить отрисовку в несколько целевых объектов, используйте Сетрендертаржет. Если вы создаете оконное приложение с несколькими трехмерными окнами, используйте API Креатеаддитионалсвапчаин. Среда выполнения оптимизирована для одного устройства, и при использовании нескольких устройств возникает существенное снижение скорости.

</dd> </dl> </dd> <dt>

<span id="Which_primitive_types__strips__fans__lists_and_so_on__should_I_use__"></span><span id="which_primitive_types__strips__fans__lists_and_so_on__should_i_use__"></span><span id="WHICH_PRIMITIVE_TYPES__STRIPS__FANS__LISTS_AND_SO_ON__SHOULD_I_USE__"></span>**Какие типы-примитивы (полосы, вентиляторы, списки и т. д.) следует использовать?** 
</dt> <dd>

Многие сетки, обнаруженные в реальных вершинах данных, совместно используются несколькими многоугольниками. Чтобы повысить производительность, желательно уменьшить дублирование в вершинах, преобразованных и передаваемых через шину на устройство отрисовки. Очевидно, что использование простых списков треугольников не дает общего доступа к вершинам, делая его наименее оптимальным методом. Затем можно выбрать между полосами и вентиляторами, которые подразумевают определенное отношение соединения между многоугольниками и использование индексированных списков. Если данные естественным образом попадают в полосы и вентиляторы, это наиболее подходящий вариант, так как они уменьшают объем данных, отправляемых в драйвер. Однако разложение сеток на полосы и вентиляторы часто приводит к большому количеству отдельных частей, что подразумевает наличие большого числа вызовов Дравпримитиве. По этой причине наиболее эффективным методом обычно является использование одного вызова Дравиндекседпримитиве со списком треугольников. Дополнительное преимущество использования индексированного списка заключается в том, что преимущество может быть получено даже в том случае, если последовательные треугольники совместно используют только одну вершину. В сводке, если данные естественным образом попадают в большие полосы или вентиляторы, используйте полосы или вентиляторы. в противном случае используйте индексированные списки.

</dd> <dt>

<span id="How_do_you_determine_the_total_texture_memory_a_card_has__excluding_AGP_memory__"></span><span id="how_do_you_determine_the_total_texture_memory_a_card_has__excluding_agp_memory__"></span><span id="HOW_DO_YOU_DETERMINE_THE_TOTAL_TEXTURE_MEMORY_A_CARD_HAS__EXCLUDING_AGP_MEMORY__"></span>**Как определить общую память текстуры, имеющую карту, за исключением памяти AGP?** 
</dt> <dd>

[**IDirect3DDevice9:: жетаваилаблетекстуремем**](/windows/desktop/api/d3d9/nf-d3d9-idirect3ddevice9-getavailabletexturemem) возвращает общий объем доступной памяти, включая AGP. Выделение ресурсов на основе предположения о том, какой объем видеопамяти не является великолепной идеей. Например, что делать, если карта работает с архитектурой единой памяти или может сжимать текстуры? Может быть больше свободного места, чем вы могли подумать. Следует создать ресурсы и проверить наличие ошибок "недостаточно памяти", а затем выполнить масштабирование на текстурах. Например, можно удалить верхние уровни MIP текстур.

</dd> <dt>

<span id="What_s_a_good_usage_pattern_for_vertex_buffers_if_I_m_generating_dynamic_data__"></span><span id="what_s_a_good_usage_pattern_for_vertex_buffers_if_i_m_generating_dynamic_data__"></span><span id="WHAT_S_A_GOOD_USAGE_PATTERN_FOR_VERTEX_BUFFERS_IF_I_M_GENERATING_DYNAMIC_DATA__"></span>**Какова хорошая схема использования буферов вершин при создании динамических данных?** 
</dt> <dd>

1.  Создайте буфер вершин, используя \_ Флаги D3DUSAGE Dynamic и D3DUSAGE \_ WRITEONLY, а также \_ флаг D3DPOOL пула по умолчанию. (Также укажите D3DUSAGE \_ СОФТВАРЕПРОЦЕССИНГ, если используется программная обработка вершин.)
2.  I = 0.
3.  Задайте состояние (текстуры, рендерстатес и т. д.).
4.  Проверьте, есть ли в буфере место, например, "I + M <= N?" (Где M — число новых вершин).
5.  Если да, то заблокируйте VB с помощью D3DLOCK \_ нуверврите. Это означает, что Direct3D и драйвер, в который будут добавляться вершины, не будут изменять ранее Пакетированные. Таким образом, если выполняется операция DMA, она не прерывается. Если нет, goto 11.
6.  Заполните вершины M в I.
7.  Блокирован.
8.  Вызов метода рисования \[ индексированного \] примитива. Для неиндексированных примитивов в качестве параметра Стартвертекс используется I. Для индексированных примитивов убедитесь, что индексы указывают на правильную часть буфера вершин (для достижения этого может быть проще использовать параметр Басевертексиндекс в вызове Сетиндицес).
9.  I + = M.
10. GOTO 3.
11. Итак, у нас нет свободного пространства, поэтому начнем с нового VB. Мы не будем использовать тот же самый, так как возможно, выполняется операция DMA. Мы переносимся к нему на Direct3D и драйвер, заключив тот же VB с \_ флагом D3DLOCK Discard. Это означает: "вы можете дать мне новый указатель, так как я делаю старый, и не волнует о старом содержимом".
12. I = 0.
13. GOTO 4 (или 6).

</dd> <dt>

<span id="Why_do_I_have_to_specify_more_information_in_the_D3DVERTEXELEMENT9_structure__"></span><span id="why_do_i_have_to_specify_more_information_in_the_d3dvertexelement9_structure__"></span><span id="WHY_DO_I_HAVE_TO_SPECIFY_MORE_INFORMATION_IN_THE_D3DVERTEXELEMENT9_STRUCTURE__"></span>**Зачем нужно указывать дополнительные сведения в структуре D3DVERTEXELEMENT9?** 
</dt> <dd>

Начиная с Direct3D 9, объявление потока вершин больше не является просто массивом типа DWORD, а теперь является массивом структур D3DVERTEXELEMENT9. Среда выполнения использует дополнительные сведения о семантике и использовании для привязки содержимого потоков вершин к входным регистрам и переменным шейдеров вершин. Для Direct3D 9 объявления вершин отделены от шейдеров вершин, что упрощает использование шейдеров с геометрией различных форматов, так как среда выполнения привязывает только те данные, которые необходимы шейдеру.

Новые объявления вершин можно использовать с фиксированным конвейером функций или с шейдерами. Для конвейера фиксированной функции нет необходимости вызывать Сетвертексшадер. Если же вы хотите переключиться на конвейер фиксированной функции и ранее использовала шейдер вершин, вызовите Сетвертексшадер (NULL). Когда это будет сделано, вам все равно потребуется вызвать Сетфвф для объявления кода ФВФ.

При использовании шейдеров вершин вызовите Сетвертексшадер с объектом шейдера вершин. Кроме того, вызовите Сетфвф, чтобы настроить объявление вершины. При этом используются сведения, неявные в ФВФ. Сетвертексдекларатион можно вызвать вместо Сетфвф, так как он поддерживает объявления вершин, которые не могут быть выражены с помощью ФВФ.

</dd> </dl>

### <a name="d3dx-utility-library"></a>Библиотека служебной программы D3DX

<dl> <dt>

<span id="What_file_formats_are_supported_by_the_D3DX_image_file_loader_functions__"></span><span id="what_file_formats_are_supported_by_the_d3dx_image_file_loader_functions__"></span><span id="WHAT_FILE_FORMATS_ARE_SUPPORTED_BY_THE_D3DX_IMAGE_FILE_LOADER_FUNCTIONS__"></span>**Какие форматы файлов поддерживаются функциями загрузчика файлов изображений D3DX?** 
</dt> <dd>

Функции загрузчика файлов образа D3DX поддерживают файлы BMP, TGA, JPG, DIB, PPM и DDS.

</dd> <dt>

<span id="The_text_rendering_functions_in_D3DX_don_t_seem_to_work__what_am_I_doing_wrong__"></span><span id="the_text_rendering_functions_in_d3dx_don_t_seem_to_work__what_am_i_doing_wrong__"></span><span id="THE_TEXT_RENDERING_FUNCTIONS_IN_D3DX_DON_T_SEEM_TO_WORK__WHAT_AM_I_DOING_WRONG__"></span>**Функции отрисовки текста в D3DX не работают, что я делаю неправильным?** 
</dt> <dd>

Распространенной ошибкой при использовании функций ID3DXFont::D Равтекст является указание нулевого альфа-компонента для параметра Color. в результате получается полностью прозрачный (невидимый) текст. Для полностью непрозрачного текста убедитесь, что альфа-компонент параметра Color полностью насыщен (255).

</dd> <dt>

<span id="How_can_I_save_the_contents_of_a_surface_or_texture_to_a_file__"></span><span id="how_can_i_save_the_contents_of_a_surface_or_texture_to_a_file__"></span><span id="HOW_CAN_I_SAVE_THE_CONTENTS_OF_A_SURFACE_OR_TEXTURE_TO_A_FILE__"></span>**Как сохранить содержимое поверхности или текстуры в файл?** 
</dt> <dd>

Пакет SDK DirectX 8,1 добавил две функции в библиотеку D3DX специально для этой цели: D3DXSaveSurfaceToFile () и D3DXSaveTextureToFile (). Эти функции поддерживают сохранение изображения в файл в формате BMP или DDS. В предыдущих версиях необходимо заблокировать поверхность и прочитать данные образа, а затем записать их в файл точечного рисунка. Сведения о записи функции для хранения точечных рисунков см. в разделе [Сохранение изображения](/windows/desktop/gdi/storing-an-image).

Кроме того, GDI+ можно использовать для сохранения изображения в самых разных форматах, хотя для этого требуются дополнительные файлы поддержки, распространяемые вместе с приложением.

</dd> <dt>

<span id="How_can_I_make_use_of_the_High_Level_Shader_Language__HLSL__in_my_game__"></span><span id="how_can_i_make_use_of_the_high_level_shader_language__hlsl__in_my_game__"></span><span id="HOW_CAN_I_MAKE_USE_OF_THE_HIGH_LEVEL_SHADER_LANGUAGE__HLSL__IN_MY_GAME__"></span>**Как можно использовать язык шейдеров высокого уровня (HLSL) в моей игре?** 
</dt> <dd>

Существует три способа включения языка шейдеров высокого уровня Microsoft (HLSL) в модуль игры:

-   Скомпилируйте источник шейдера в сборку заливки вершин или пикселей (с помощью служебной программы командной строки fxc.exe) и используйте D3DXAssembleShader () во время выполнения. Таким образом, даже игра DirectX 8 может даже воспользоваться преимуществами HLSL.
-   Используйте D3DXCompileShader () для компиляции источника шейдера в поток маркеров и форму таблицы констант. Во время выполнения Загрузите поток маркера и таблицу констант и вызовите Креатевертексшадер () или Креатепикселшадер () на устройстве, чтобы создать шейдеры.
-   Самый простой способ начать работу — воспользоваться преимуществами системы D3DX Effects, вызвав D3DXCreateEffectFromFile () или D3DXCreateEffectFromResource () с файлом действия.

</dd> <dt>

<span id="What_is_the_purpose_of_the_new_shader_compiler_flag__"></span><span id="what_is_the_purpose_of_the_new_shader_compiler_flag__"></span><span id="WHAT_IS_THE_PURPOSE_OF_THE_NEW_SHADER_COMPILER_FLAG__"></span>**Каково назначение нового флага компилятора шейдеров?** 
</dt> <dd>

Начиная с декабря 2006 DirectX SDK, новый компилятор HLSL, разработанный для Direct3D 10, включен для целевых объектов Direct3D 9. Новый компилятор не поддерживает \_ \_ целевые объекты PS 1 x и теперь является компилятором по умолчанию для всех шейдеров Direct3D HLSL. Флаг для обратной совместимости можно использовать для принудительной \_ \_ компиляции целевых объектов PS 1 x в качестве \_ \_ целевых объектов PS 2 0.

Приложения, которые хотят использовать устаревший компилятор, могут продолжать это сделать, указав флаг во время выполнения (см. раздел [**флаги компилятора**](/windows/desktop/direct3d9/d3dxshader-flags)) или указав параметр при использовании fxc.

</dd> <dt>

<span id="What_is_the_correct_way_to_get_shaders_from_an_Effect__"></span><span id="what_is_the_correct_way_to_get_shaders_from_an_effect__"></span><span id="WHAT_IS_THE_CORRECT_WAY_TO_GET_SHADERS_FROM_AN_EFFECT__"></span>**Что такое правильный способ получения шейдеров?** 
</dt> <dd>

Используйте D3DXCreateEffect, чтобы создать ID3DXEffect, а затем используйте Жетпассдеск для получения D3DXPASS \_ DESC. Эта структура содержит указатели на шейдеры вершин и пикселей.

Не используйте ID3DXEffectCompiler:: Жетпассдеск. Дескрипторы шейдеров вершин и точек, возвращенные этим методом, имеют значение NULL.

</dd> <dt>

<span id="What_is_the_HLSL_noise___intrinsic_for__"></span><span id="what_is_the_hlsl_noise___intrinsic_for__"></span><span id="WHAT_IS_THE_HLSL_NOISE___INTRINSIC_FOR__"></span>**Что представляет собой встроенный шум HLSL ()?** 
</dt> <dd>

Встроенная функция Noise создает шум Perl, как определено в Алексей Perl. В настоящее время функцию HLSL можно использовать только для заливки текстур в шейдерах текстур, так как текущая функция h/w не поддерживает собственный метод. Шейдер текстуры используются в сочетании с \* функциями текстур D3DXFill (), которые являются полезными вспомогательными функциями для создания определенных в процессе загрузки текстур, определяемых процедурой.

</dd> <dt>

<span id="How_do_I_detect_whether_to_use_pixel_shader_model_2.0_or_2.a__"></span><span id="how_do_i_detect_whether_to_use_pixel_shader_model_2.0_or_2.a__"></span><span id="HOW_DO_I_DETECT_WHETHER_TO_USE_PIXEL_SHADER_MODEL_2.0_OR_2.A__"></span>**Разделы справки определить, следует ли использовать модель шейдера пикселей 2,0 или 2. a?** 
</dt> <dd>

Вы можете использовать функции D3DXGetPixelShaderProfile () и D3DXGetPixelShaderProfile (), которые возвращают строку, определяющую, какой профиль HLSL лучше всего подходит для запуска устройства.

</dd> <dt>

<span id="How_do_I_access_the_Parameters_in_my_Precompiled_Effects_Shaders__"></span><span id="how_do_i_access_the_parameters_in_my_precompiled_effects_shaders__"></span><span id="HOW_DO_I_ACCESS_THE_PARAMETERS_IN_MY_PRECOMPILED_EFFECTS_SHADERS__"></span>**Разделы справки получить доступ к параметрам в шейдере предкомпилированных эффектов?** 
</dt> <dd>

Через интерфейс ID3DXConstantTable, который используется для доступа к таблице констант. Эта таблица содержит переменные, используемые в высокоуровневой шейдере и эффектах языка.

</dd> <dt>

<span id="Is_there_a_way_to_add_user_data_to_an_effect_or_other_resource__"></span><span id="is_there_a_way_to_add_user_data_to_an_effect_or_other_resource__"></span><span id="IS_THERE_A_WAY_TO_ADD_USER_DATA_TO_AN_EFFECT_OR_OTHER_RESOURCE__"></span>**Есть ли способ добавить данные пользователя в воздействие или другой ресурс?** 
</dt> <dd>

Да, чтобы задать закрытые данные, вы вызываете Сетприватедата (Преал — это объект текстуры D3D, Пспуф — объект текстуры с оболочкой).

``` syntax
hr = pReal->SetPrivateData(IID_Spoof, &pSpoof, 
            sizeof(IDirect3DResource9*), 0)));
```

Поиск указателя в оболочке:

``` syntax
    IDirect3DResource9* pSpoof;
    DWORD dwSize = sizeof(pSpoof);
    hr = pReal->GetPrivateData(IID_Spoof, (void*) &pSpoof, &dwSize);
```

</dd> <dt>

<span id="Why_does_rendering_of_an_ID3DXMesh_object_slow_down_significantly_after_I_define_subsets__"></span><span id="why_does_rendering_of_an_id3dxmesh_object_slow_down_significantly_after_i_define_subsets__"></span><span id="WHY_DOES_RENDERING_OF_AN_ID3DXMESH_OBJECT_SLOW_DOWN_SIGNIFICANTLY_AFTER_I_DEFINE_SUBSETS__"></span>**Почему отрисовка объекта ID3DXMesh значительно замедляется после определения подмножества?** 
</dt> <dd>

Вероятно, вы не оптимизируем сетку после определения атрибутов лица. Если указать атрибуты и затем вызвать ID3DXMesh::D Равсубсет (), этот метод должен выполнить поиск по сетке для всех лиц, содержащих запрошенные атрибуты. Кроме того, отображаемые лица, скорее всего, имеют шаблон произвольного доступа, поэтому не используют кэш вершин. Определив атрибуты лица для поднаборов, вызовите методы ID3DXMesh:: optimize или ID3DXMesh:: Оптимизеинплаце и укажите метод оптимизации D3DXMESHOPT \_ аттрсорт или более надежных. Обратите внимание, что для оптимальной производительности следует оптимизировать с помощью \_ флага D3DXMESHOPT вертекскаче, который также будет переупорядочивать вершины для оптимального использования кэша вершин. Массив соседей, созданный для сетки D3DX, имеет три записи для каждого лица, но некоторые стороны могут не иметь смежных граней на всех трех краях. Как это кодируется? Записи, в которых нет смежных сторон, кодируются как 0xFFFFFFFF.

</dd> <dt>

<span id="I_ve_heard_a_lot_about_Pre-computed_Radiance_Transfer__PRT___where_can_I_learn_more__"></span><span id="i_ve_heard_a_lot_about_pre-computed_radiance_transfer__prt___where_can_i_learn_more__"></span><span id="I_VE_HEARD_A_LOT_ABOUT_PRE-COMPUTED_RADIANCE_TRANSFER__PRT___WHERE_CAN_I_LEARN_MORE__"></span>**Я слышал многое о предварительно вычисленном Радианце переносе (PRT), где можно узнать больше?** 
</dt> <dd>

PRT — это новая функция D3DX, добавленная в обновление пакета SDK для летнего 2003. Он обеспечивает визуализацию сложных сценариев освещения, таких как Global-ллуминатион, мягкое затемнение и подсветка в режиме реального времени. Пакет SDK содержит документацию и примеры интеграции технологии в игру. Примеры демонстрационных образцов PRT и Локалдеформаблепрт демонстрируют использование симулятора для каждой вершины и сценариев освещения в пикселах соответственно. Дополнительные сведения об этом и других статьях можно найти на веб-странице Питер Пайк братья.

</dd> <dt>

<span id="How_can_I_render_to_a_texture_and_make_use_of_Anti_Aliasing__"></span><span id="how_can_i_render_to_a_texture_and_make_use_of_anti_aliasing__"></span><span id="HOW_CAN_I_RENDER_TO_A_TEXTURE_AND_MAKE_USE_OF_ANTI_ALIASING__"></span>**Как выполнить рендеринг на текстуру и использовать сглаживание?** 
</dt> <dd>

Создайте целевой объект рендеринга с помощью Direct3DDevice9:: Креатерендертаржет. После подготовки сцены к этой цели рендеринга Стретчрект от нее к текстуре целевого объекта прорисовки. Если вы внесете изменения в текстре (например, размытие или цветут), скопируйте его обратно в задний буфер, прежде чем приступить к представлению ().

</dd> </dl>

## <a name="directsound-questions"></a>Вопросы о DirectSound

<dl> <dt>

<span id="Why_do_I_get_a_burst_of_static_when_my_application_starts_up__I_notice_this_problem_with_other_applications_too._"></span><span id="why_do_i_get_a_burst_of_static_when_my_application_starts_up__i_notice_this_problem_with_other_applications_too._"></span><span id="WHY_DO_I_GET_A_BURST_OF_STATIC_WHEN_MY_APPLICATION_STARTS_UP__I_NOTICE_THIS_PROBLEM_WITH_OTHER_APPLICATIONS_TOO._"></span>**Почему при запуске приложения я могу получить пакет со статической статичностью? Я также вижу эту проблему с другими приложениями.** 
</dt> <dd>

Возможно, вы установили отладочную среду выполнения DirectX. Отладочная версия среды выполнения заполняет буферы статическими, чтобы помочь разработчикам перехватывать ошибки с неинициализированными буферами. Невозможно гарантировать содержимое буфера DirectSound после создания; в частности, нельзя предположить, что буфер с нулевым значением.

</dd> <dt>

<span id="Why_I_am_experiencing_a_delay_in_between_changing_an_effects_parameters_and_hearing_the_results__"></span><span id="why_i_am_experiencing_a_delay_in_between_changing_an_effects_parameters_and_hearing_the_results__"></span><span id="WHY_I_AM_EXPERIENCING_A_DELAY_IN_BETWEEN_CHANGING_AN_EFFECTS_PARAMETERS_AND_HEARING_THE_RESULTS__"></span>**Почему возникают задержки между изменением параметров эффектов и слуха результатов?** 
</dt> <dd>

Изменения параметров влияния не всегда выполняются немедленно в DirectX 8. Для повышения эффективности DirectSound обрабатывает звуковые данные в буфере 100 миллисекунд, начиная с курсора Play, до воспроизведения буфера. Такая предварительная обработка происходит после всех следующих вызовов:

``` syntax
IDirectSoundBuffer8::SetCurrentPosition
IDirectSoundBuffer8::SetFX
IDirectSoundBuffer8::Stop
IDirectSoundBuffer8::Unlock
```

Начиная с версии DirectX 9, новый алгоритм обработки FX, который обрабатывает эффекты по времени, решает эту проблему и сокращает задержку. Алгоритм был добавлен в вызов IDirectSoundBuffer8::P компоновки () вместе с дополнительным потоком, обрабатывающим все действия, предшествующие курсору Write. Поэтому вы можете задать параметры в любое время, и они будут работать должным образом. Однако обратите внимание, что в воспроизводимом буфере будет небольшая задержка (обычно 100 мс) перед тем, как вы услышите изменение параметра, так как звук между курсорами воспроизведения и записи (и более немного дополнительных полей) уже обработан в это время.

</dd> <dt>

<span id="How_do_I_detect_if_DSound_is_installed__"></span><span id="how_do_i_detect_if_dsound_is_installed__"></span><span id="HOW_DO_I_DETECT_IF_DSOUND_IS_INSTALLED__"></span>**Разделы справки определить, установлен ли Дсаунд?** 
</dt> <dd>

Если не нужно использовать Директсаунденумерате () для перечисления доступных устройств Дсаунд, не следует связывать приложение с дсаунд. lib и использовать его через идет CoCreateInstance (CLSID \_ DirectSound...), а затем инициализировать объект дсаунд с помощью функции Initialize (null). Если необходимо использовать Директсаунденумерате (), можно динамически загружать dsound.dll с помощью LoadLibrary ("dsound.dll"). и получить доступ к его методам с помощью GetProcAddress ("Директсаунденумератеа/W") и GetProcAddress ("Директсаундкреатеа/W") и т. д.

</dd> <dt>

<span id="How_do_I_create_multichannel_audio_with_WAVEFORMATEXTENSIBLE__"></span><span id="how_do_i_create_multichannel_audio_with_waveformatextensible__"></span><span id="HOW_DO_I_CREATE_MULTICHANNEL_AUDIO_WITH_WAVEFORMATEXTENSIBLE__"></span>**Разделы справки создать многоканальный звук с помощью ВАВЕФОРМАТЕКСТЕНСИБЛЕ?** 
</dt> <dd>

Если вы не можете найти ответ на свой вопрос в файлах справки DirectSound, то есть хорошая статья, в которой содержатся дополнительные сведения о звуковых данных и звуковых файлах для нескольких каналов.

</dd> <dt>

<span id="How_can_I_use_the_DirectSound_Voice_Manager_with_property_sets_like_EAX__"></span><span id="how_can_i_use_the_directsound_voice_manager_with_property_sets_like_eax__"></span><span id="HOW_CAN_I_USE_THE_DIRECTSOUND_VOICE_MANAGER_WITH_PROPERTY_SETS_LIKE_EAX__"></span>**Как можно использовать диспетчер DirectSound с наборами свойств, например EAX?** 
</dt> <dd>

В DirectSound 9,0 при дублировании буфера теперь можно получить интерфейс IDirectSoundBuffer8 для повторяющегося буфера, который предоставит доступ к методу AcquireResources. Это позволит связать буфер с \_ флагом дсбкапс локдефер с аппаратным ресурсом. Затем можно задать параметры EAX в этом буфере перед вызовом Play ().

</dd> <dt>

<span id="I_am_having_problems_with_unreliable_behavior_when_using_cursor_position_notifications._How_can_I_get_more_accurate_information__"></span><span id="i_am_having_problems_with_unreliable_behavior_when_using_cursor_position_notifications._how_can_i_get_more_accurate_information__"></span><span id="I_AM_HAVING_PROBLEMS_WITH_UNRELIABLE_BEHAVIOR_WHEN_USING_CURSOR_POSITION_NOTIFICATIONS._HOW_CAN_I_GET_MORE_ACCURATE_INFORMATION__"></span>**При использовании уведомлений о положении курсора возникают проблемы с ненадежным поведением. Как можно получить более точную информацию?** 
</dt> <dd>

В различных версиях DirectSound присутствуют некоторые небольшие ошибки: основной стек Windows и аудио драйверы, которые делают уведомления о расположениях курсоров ненадежными. Если вы не нацелены на известную конфигурацию оборудования или программного обеспечения, на которой вы знаете, что уведомления хорошо настроены, не используйте уведомления о положении курсора. Для отслеживания позиций Жеткуррентпоситион () является более безопасной методикой.

</dd> <dt>

<span id="I_am_suffering_from_performance_degradation_when_using_GetCurrentPosition__._What_can_I_do_to_improve_performance__"></span><span id="i_am_suffering_from_performance_degradation_when_using_getcurrentposition__._what_can_i_do_to_improve_performance__"></span><span id="I_AM_SUFFERING_FROM_PERFORMANCE_DEGRADATION_WHEN_USING_GETCURRENTPOSITION__._WHAT_CAN_I_DO_TO_IMPROVE_PERFORMANCE__"></span>**Я низкий от снижения производительности при использовании Жеткуррентпоситион (). Что можно сделать для повышения производительности?** 
</dt> <dd>

Каждый вызов Жеткуррентпоситион () для каждого буфера вызывает системный вызов, и системные вызовы должны быть минимальными, так как они являются большим компонентом ресурсов ЦП Дсаунд. В NT (Win2K и XP) курсоры в буферах SW (и АППАРАТных буферах на некоторых устройствах) перемещаются в 10 мс приращения, поэтому вызов Жеткуррентпоситион () для каждого 10 МС является идеальным. Обращение к нему чаще, чем при каждом 5 мс, приведет к снижению производительности.

</dd> <dt>

<span id="My_DirectSound_application_is_taking_up_too_much_CPU_time_or_is_performing_slowly._Is_there_anything_I_can_do_to_optimize_my_code__"></span><span id="my_directsound_application_is_taking_up_too_much_cpu_time_or_is_performing_slowly._is_there_anything_i_can_do_to_optimize_my_code__"></span><span id="MY_DIRECTSOUND_APPLICATION_IS_TAKING_UP_TOO_MUCH_CPU_TIME_OR_IS_PERFORMING_SLOWLY._IS_THERE_ANYTHING_I_CAN_DO_TO_OPTIMIZE_MY_CODE__"></span>**Приложение DirectSound занимает слишком много времени ЦП или медленно выполняется. Можно ли что-нибудь сделать для оптимизации моего кода?** 
</dt> <dd>

Для повышения производительности звукового кода можно сделать несколько вещей:

-   Не вызывайте Жеткуррентпоситион слишком часто. Каждый вызов Жеткуррентпоситион () для каждого буфера вызывает системный вызов, и системные вызовы должны быть минимальными, так как они являются большим компонентом ресурсов ЦП Дсаунд. В NT (Win2K и XP) курсоры в буферах SW (и АППАРАТных буферах на некоторых устройствах) перемещаются в 10 мс приращения, поэтому вызов Жеткуррентпоситион () для каждого 10 МС является идеальным. Обращение к нему чаще, чем при каждом 5 мс, приведет к снижению производительности.
-   Используйте отдельную, более низкую частоту кадров для звука. Настоящее время многих игр Windows может превышать 100 кадров в секунду, и в большинстве случаев не требуется обновлять трехмерные звуковые параметры с той же частотой кадров. Обработка звука каждую секунду или в третьем графическом фрейме, а также каждый 30ms или т. д. может значительно сократить количество звуковых вызовов в приложении, не снижая качества звучания.
-   \_Для трехмерных объектов используйте DS3D. Большинство звуковых карт немедленно реагируют на изменения параметров, и в одном кадре может измениться, особенно при изменении положения или ориентации прослушивателя. Это заставляет саундкард или ЦП выполнять множество ненужных вычислений, поэтому другая быстрая и универсальная оптимизация — отложить некоторые изменения параметров и зафиксировать их в конце кадра.

    или, по крайней мере, используйте Сеталлпараметерс, а не отдельные вызовы Set3DParamX для буферов.

    Аналогичным образом следует использовать как минимум вызовы Сеталлпараментерс в трехмерных буферах, а не отдельные вызовы Set3DParamX. Просто постарайтесь по возможности максимально сокращать системные вызовы.

-   Не делайте избыточных вызовов; Хранение и сортировка списка вызовов Play. Часто в одном кадре обновления звука есть 2 запроса на воспроизведение новых звуков. Если запросы обрабатываются по мере их поступления, можно запустить первый новый звук, а затем сразу же заменить второй запрошенный звук. Это приводит к избыточным вычислениям, ненужному вызову Play и ненужному вызову метода завершения. Лучше хранить список запросов на воспроизведение новых звуков, чтобы список можно было отсортировать, и только те из них, которые должны начать играть, всегда воспроизводятся.

    Кроме того, следует хранить локальные копии параметров объемного и EAXного объема для каждого источника звука. Если выполняется запрос на присвоение параметру определенного значения, можно проверить, отличается ли значение от последнего набора значений. Если это не так, вызов не нужно делать.

    Несмотря на то, что драйвер звуковой карты, вероятно, обнаружит этот сценарий и не выполнит (то же самое) вычисление, звуку будет необходимо связаться с аудио-драйвером (через смену звонка), и это действие уже выполняется.

</dd> <dt>

<span id="When_I_stream_a_buffer_it_tends_to_glitch_and_perform_poorly._What_s_the_best_way_to_stream_a_buffer__"></span><span id="when_i_stream_a_buffer_it_tends_to_glitch_and_perform_poorly._what_s_the_best_way_to_stream_a_buffer__"></span><span id="WHEN_I_STREAM_A_BUFFER_IT_TENDS_TO_GLITCH_AND_PERFORM_POORLY._WHAT_S_THE_BEST_WAY_TO_STREAM_A_BUFFER__"></span>**При потоковой передаче в буфер происходит сбой и он плохо выполняется. Каков лучший способ потоковой передачи буфера?** 
</dt> <dd>

Потоковая передача звука в буфер включает два основных алгоритма: после-Write-Cursor (АВК) и до-Play-Cursor (бит/с). АВК сокращает задержку за счет сбоя, в то время как канал передачи данных является противоположным. Так как обычно нет интерактивных изменений в потоковой громкости, такая ситуация редко бывает проблемой для игр и аналогичных приложений, поэтому канал передачи данных является более подходящим алгоритмом. В АВК каждый раз, когда поток потоковой передачи работает, данные в цикле перемещаются в буфер до N МС за пределами курсоров записи (обычно N = 40 или т. д.). В бит на канале всегда записывает как можно больше данных в буферы, заполняя их вправо до их курсоров (или, возможно, 32 байт раньше, чтобы разрешить драйверы, которые неправильно сообщают о ходе выполнения курсора на воспроизведение).

Используйте бит/канал, чтобы мимимизе сбой и использовать буферы 100 мс или больше, даже если игры не возникают на вашем тестовом оборудовании.

</dd> <dt>

<span id="I_am_playing_the_same_sounds_over_and_over_very_often_and_very_quickly_and_sometimes_they_don_t_play_properly__or_the_Play___call_takes_a_long_time._What_should_I_do__"></span><span id="i_am_playing_the_same_sounds_over_and_over_very_often_and_very_quickly_and_sometimes_they_don_t_play_properly__or_the_play___call_takes_a_long_time._what_should_i_do__"></span><span id="I_AM_PLAYING_THE_SAME_SOUNDS_OVER_AND_OVER_VERY_OFTEN_AND_VERY_QUICKLY_AND_SOMETIMES_THEY_DON_T_PLAY_PROPERLY__OR_THE_PLAY___CALL_TAKES_A_LONG_TIME._WHAT_SHOULD_I_DO__"></span>**Я воспроизводить одни и те же звуки очень часто и очень быстро, иногда они не воспроизводятся должным образом, или вызов Play () занимает много времени. Что мне делать?** 
</dt> <dd>

Задержка запуска (которая отличается от задержки потоковой передачи, упомянутой выше) может быть проблемой в случае некоторого оборудования (вызов Play () просто занимает много времени на определенных звуковых картах). Если вы действительно хотите уменьшить эту задержку, для твитч звуков (обойм, примеру и т. д.) очень удобно, чтобы некоторые буферы всегда были циклическими и воспроизводили тишину. Если необходимо воспроизвести твитч звук, выберите свободный буфер, посмотрите, где находится курсор записи, и вставьте звук в буфер сразу за пределами курсора Write. Некоторые саундкардс сбой Куерисуппорт для отложенных свойств, которые они поддерживают. Есть ли обходной путь? Вы могли бы просто Куерисуппорт для неотложенных версий свойств и все равно использовать отложенные параметры. Последние драйверы саундкард также могут устранить эту проблему.

</dd> <dt>

<span id="How_do_I_encode_WAV_files_into_WMA__"></span><span id="how_do_i_encode_wav_files_into_wma__"></span><span id="HOW_DO_I_ENCODE_WAV_FILES_INTO_WMA__"></span>**Разделы справки кодировать WAV файлы в WMA?** 
</dt> <dd>

Обратитесь к документации по кодировщику Windows Media по адресу: Серия Windows Media Encoder 9.

</dd> <dt>

<span id="How_do_I_decode_MP3_files_with_DirectSound__"></span><span id="how_do_i_decode_mp3_files_with_directsound__"></span><span id="HOW_DO_I_DECODE_MP3_FILES_WITH_DIRECTSOUND__"></span>**Разделы справки декодировать MP3-файлы с помощью DirectSound?** 
</dt> <dd>

DirectSound изначально не поддерживает декодирование MP3. Вы можете самостоятельно декодировать файлы (используя кодек ACM в фильтре DirectShow) или просто использовать саму DirectShow, которая может выполнить декодирование. Затем можно скопировать результирующие аудиоданные PCM в буферы DirectSound.

</dd> </dl>

## <a name="directx-extensions-for-alias-maya"></a>Расширения DirectX для псевдонима Maya

<dl> <dt>

<span id="Why_aren_t_my_NURBS_showing_up__"></span><span id="why_aren_t_my_nurbs_showing_up__"></span><span id="WHY_AREN_T_MY_NURBS_SHOWING_UP__"></span>**Почему мое НУРБС не отображается?** 
</dt> <dd>

НУРБС не поддерживаются. Их можно преобразовать в сетки многоугольников.

</dd> <dt>

<span id="Why_aren_t_my_SUBDs_showing_up_"></span><span id="why_aren_t_my_subds_showing_up_"></span><span id="WHY_AREN_T_MY_SUBDS_SHOWING_UP_"></span>**Почему мое Субдс не отображается?**
</dt> <dd>

Субдс не поддерживаются. Их можно преобразовать в сетки многоугольников.

</dd> <dt>

<span id="Why_does_my_animation_in_the_X_file_look_different_than_the_animation_in_the_preview_window__"></span><span id="why_does_my_animation_in_the_x_file_look_different_than_the_animation_in_the_preview_window__"></span><span id="WHY_DOES_MY_ANIMATION_IN_THE_X_FILE_LOOK_DIFFERENT_THAN_THE_ANIMATION_IN_THE_PREVIEW_WINDOW__"></span>**Почему анимация в файле X выглядит иначе, чем анимация в окне предварительного просмотра?** 
</dt> <dd>

Окно предварительного просмотра не является анимацией в строгом смысле важности. Он не воспроизводит анимацию, а синхронизируется с самым актуальным состоянием сцены Maya. При экспорте анимации матрицы в каждом преобразовании разбиваются на масштабирование, вращение (кватернион) и компоненты перевода (часто называются СРТС). СРТС являются более предпочтительными, чем матрицы, так как они прекрасно подходят, предоставляют более компактную форму данных и могут сжиматься независимо друг от друга. Не все матрицы могут разбиваться на СРТС. Если они не могут разбиваться, результирующий СРТС будет неизвестен, поэтому могут быть обнаружены небольшие ошибки в анимации. Эти две функции в Maya, которые чаще всего вызывают проблемы во время декомпозиции, обрабатываются, а также вращения и шкалы по центру. Если вы столкнулись с этой проблемой, так как вы используете вращение или масштабирование по центру, рассмотрите возможность добавления дополнительных преобразований, повышающих уровень иерархии.

Где D3DX Animation поддерживает СРТС, он выглядит следующим образом:

``` syntax
[S]x[R]x[T]
```

Матрицы Maya гораздо сложнее, и для них требуется значительный объем дополнительного процесса, который выглядит следующим образом:

``` syntax
[SpInv]x[S]x[Sh]x[Sp]x[St]x[RpInv]x[Ro]x[R]x[Rp]x[Rt]x[T]
```

</dd> <dt>

<span id="I_skinned_my_mesh_with_RigidSkin_but_the_mesh__or_portion__isn_t_moving._Why__"></span><span id="i_skinned_my_mesh_with_rigidskin_but_the_mesh__or_portion__isn_t_moving._why__"></span><span id="I_SKINNED_MY_MESH_WITH_RIGIDSKIN_BUT_THE_MESH__OR_PORTION__ISN_T_MOVING._WHY__"></span>**Я выберу мою сетку с Ригидскин, но сетка (или часть) не перемещается. Важно?** 
</dt> <dd>

Жесткая обложка Maya в настоящее время не поддерживается. Используйте плавную обложку.

</dd> <dt>

<span id="Where_has_all_of_my_IK_gone_in_the_X-file__"></span><span id="where_has_all_of_my_ik_gone_in_the_x-file__"></span><span id="WHERE_HAS_ALL_OF_MY_IK_GONE_IN_THE_X-FILE__"></span>**Где все ОК исчезло в файле X?** 
</dt> <dd>

X-файлы не поддерживают ОК. Вместо этого решения ОК помогутся в кадры, хранящиеся в файле X.

</dd> <dt>

<span id="Why_do_none_of_my_materials_colors_show_up_except_DirectXShaders__"></span><span id="why_do_none_of_my_materials_colors_show_up_except_directxshaders__"></span><span id="WHY_DO_NONE_OF_MY_MATERIALS_COLORS_SHOW_UP_EXCEPT_DIRECTXSHADERS__"></span>**Почему не отображается ни один из цветов материалов, кроме Директксшадерс?** 
</dt> <dd>

Расширения DirectX для Maya в настоящее время поддерживают только материалы Директксшадер для предварительного просмотра и экспорта. В будущих версиях могут поддерживаться другие материалы.

</dd> </dl>

## <a name="xinput-questions"></a>Ксинпут вопросы

<dl> <dt>

<span id="Can_I_use_DirectInput_to_read_the_triggers__"></span><span id="can_i_use_directinput_to_read_the_triggers__"></span><span id="CAN_I_USE_DIRECTINPUT_TO_READ_THE_TRIGGERS__"></span>**Можно ли использовать Директинпут для чтения триггеров?** 
</dt> <dd>

Да, но они действуют как одна и та же ось. Поэтому вы не можете читать триггеры независимо с помощью Директинпут. С помощью Ксинпут триггеры возвращают отдельные значения.

Дополнительные сведения о том, почему Директинпут интерпретирует триггеры как одну ось, см. в разделе [Использование контроллера Xbox 360 с директинпут](/windows/desktop/xinput/xinput-and-directinput).

</dd> <dt>

<span id="How_many_controllers_does_XInput_support__"></span><span id="how_many_controllers_does_xinput_support__"></span><span id="HOW_MANY_CONTROLLERS_DOES_XINPUT_SUPPORT__"></span>**Сколько контроллеров поддерживает Ксинпут?** 
</dt> <dd>

Ксинпут поддерживает 4 контроллера, подключенных за раз.

</dd> <dt>

<span id="Does_XInput_support_non-common_controllers__"></span><span id="does_xinput_support_non-common_controllers__"></span><span id="DOES_XINPUT_SUPPORT_NON-COMMON_CONTROLLERS__"></span>**Поддерживает ли Ксинпут нестандартные контроллеры?** 
</dt> <dd>

Нет, это не так.

</dd> <dt>

<span id="Are_common_controllers_available_through_DirectInput__"></span><span id="are_common_controllers_available_through_directinput__"></span><span id="ARE_COMMON_CONTROLLERS_AVAILABLE_THROUGH_DIRECTINPUT__"></span>**Доступны ли общие контроллеры через Директинпут?** 
</dt> <dd>

Да, вы можете получить доступ к общим контроллерам с помощью Директинпут.

</dd> <dt>

<span id="How_do_I_get_force_feedback_on_the_common_controllers__"></span><span id="how_do_i_get_force_feedback_on_the_common_controllers__"></span><span id="HOW_DO_I_GET_FORCE_FEEDBACK_ON_THE_COMMON_CONTROLLERS__"></span>**Разделы справки получить отзыв о стандартных контроллерах?** 
</dt> <dd>

Используйте функцию [**ксинпутсетстате**](/windows/desktop/api/xinput/nf-xinput-xinputsetstate) .

</dd> <dt>

<span id="Why_does_my_default_audio_device_change__"></span><span id="why_does_my_default_audio_device_change__"></span><span id="WHY_DOES_MY_DEFAULT_AUDIO_DEVICE_CHANGE__"></span>**Почему изменилось звуковое устройство по умолчанию?** 
</dt> <dd>

При подключении гарнитуры Гарнитура контроллера выступает в качестве стандартного звукового устройства USB, поэтому при его подключении Windows автоматически изменится на использование этого USB-устройства аудио в качестве значения по умолчанию. Так как пользователь, скорее всего, не хочет, чтобы все аудио продвигаться по гарнитуре, ему придется вручную скорректировать его до первоначальной настройки.

</dd> <dt>

<span id="How_do_I_control_the_lights_on_the_controller__"></span><span id="how_do_i_control_the_lights_on_the_controller__"></span><span id="HOW_DO_I_CONTROL_THE_LIGHTS_ON_THE_CONTROLLER__"></span>**Разделы справки управлять индикаторами на контроллере?** 
</dt> <dd>

Индикаторы контроллера определяются операционной системой и не могут быть изменены.

</dd> <dt>

<span id="How_do_I_access_the_Xbox_360_button_in_my_applications__"></span><span id="how_do_i_access_the_xbox_360_button_in_my_applications__"></span><span id="HOW_DO_I_ACCESS_THE_XBOX_360_BUTTON_IN_MY_APPLICATIONS__"></span>**Разделы справки получить доступ к кнопке Xbox 360 в разделе "Мои приложения"?** 
</dt> <dd>

К сожалению, эта кнопка зарезервирована для будущего использования.

</dd> <dt>

<span id="Where_do_I_get_drivers__"></span><span id="where_do_i_get_drivers__"></span><span id="WHERE_DO_I_GET_DRIVERS__"></span>**Где можно получить драйверы?** 
</dt> <dd>

Драйверы будут доступны через Центр обновления Windows.

</dd> <dt>

<span id="How_is_controller_ID_determined__"></span><span id="how_is_controller_id_determined__"></span><span id="HOW_IS_CONTROLLER_ID_DETERMINED__"></span>**Как определяется идентификатор контроллера?** 
</dt> <dd>

При запуске Ксинпут идентификатор определяется недетерминированным подсистемой Ксинпут и контроллерами, подключенными к. Если контроллеры подключены во время работы приложения Ксинпут, система присвоит новому контроллеру наименьшее доступное число. Если контроллер отключен, его число снова становится доступным.

</dd> <dt>

<span id="How_do_I_get_the_audio_devices_for_the_controller__"></span><span id="how_do_i_get_the_audio_devices_for_the_controller__"></span><span id="HOW_DO_I_GET_THE_AUDIO_DEVICES_FOR_THE_CONTROLLER__"></span>**Разделы справки получить звуковые устройства для контроллера?** 
</dt> <dd>

Используйте функцию [**ксинпутжетдсаундаудиодевицегуидс**](/windows/desktop/api/xinput/nf-xinput-xinputgetdsoundaudiodeviceguids) . Дополнительные сведения см. в примере аудиоконтроллер.

</dd> <dt>

<span id="What_should_I_do_when_a_controller_is_unplugged__"></span><span id="what_should_i_do_when_a_controller_is_unplugged__"></span><span id="WHAT_SHOULD_I_DO_WHEN_A_CONTROLLER_IS_UNPLUGGED__"></span>**Что делать, если контроллер не подключен?** 
</dt> <dd>

Если контроллер использовался проигрывателем, следует приостановить игру, пока контроллер не будет снова подключен, и игрок нажмет кнопку, чтобы сообщить о том, что они готовы к отправке.

</dd> </dl>

 

 