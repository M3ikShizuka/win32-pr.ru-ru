---
title: Основные проблемы с заголовками Windows
description: В этой статье описываются многие из распространенных проблем, которые мы видели в компьютерных играх, посвященных поколениям.
ms.assetid: 89b83473-1aa9-9a2d-8778-15cfb91cdea4
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 547c977f7d8e4895ef73ba229a9012854a7c6d27
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "105661767"
---
# <a name="top-issues-for-windows-titles"></a>Основные проблемы с заголовками Windows

Группа "связи для разработчиков игровых и графических технологий Microsoft Windows" выполняет анализ производительности для многих игр Windows каждый год. Во время этих сеансов мы получаем практический опыт в отношении отзывов разработчиков и запросов, которые мы получаем ежедневно. Иногда мы можем отmysterious сбой или другую проблему в названии, что дает нам дополнительные сведения о проблемах, возникающих у разработчиков.

В этой статье описываются многие из распространенных проблем, которые мы видели в компьютерных играх, посвященных поколениям.

-   [Производительность, ограниченная ЦП](#cpu-limited-performance)
-   [Плохое управление пакетами](#poor-batch-management)
-   [Чрезмерное копирование памяти](#excessive-memory-copying)
-   [Чрезмерное использование динамической отправки Draw](#excessive-use-of-dynamic-draw-submission)
-   [Большие издержки при обработке файлов](#high-overhead-in-file-processing)
-   [Снижение производительности и неприятной установки](#slow-and-frustrating-installation)
-   [Отсутствие внимания физической памяти](#lack-of-consideration-of-physical-memory)
-   [Чрезмерная зависимость от Real-Time преобразование частоты дискретизации образца звука](#over-reliance-on-real-time-audio-sample-rate-conversion)
-   [Фрагментация виртуальной памяти](#fragmention-of-virtual-memory)
-   [Управление Floating-Pointным словом](#manipulation-of-the-floating-point-control-word)
-   [Необязательная установка среды выполнения DirectX](#optional-installation-of-the-directx-runtime)
-   [Чрезмерное использование синхронизации потоков](#excessive-use-of-thread-synchronization)
-   [Использование RDTSC](#use-of-rdtsc)

## <a name="cpu-limited-performance"></a>Производительность CPU-Limited

Подавляющее большинство игр ограничивается производительностью ЦП в системах с высокопроизводительными графическими процессорами (GPU). Иногда это обусловлено плохим использованием пакетной обработки для прорисовки отправок, но, как правило, это обусловлено тем, что другие игровые системы потребляют большую часть доступных циклов ЦП. В некоторых случаях, в которых мы видели GPU как ограничение, причина в том, что это очень высокая скорость заполнения или потребность шейдера пикселей, в параметрах с высоким разрешением или с низкой производительностью вершинного шейдера видеоадаптером.

Так как большинство заголовков заключаются в ограниченном объеме ЦП, крупнейший уровень производительности, полученный в результате оптимизации игровых компьютерных систем. Как правило, ИСКУССТВЕНные и физические системы, а также связанная логика обнаружения конфликтов являются основными потребителями циклов ЦП в хорошо работающих приложениях Microsoft Direct3D. Любая работа по улучшению этих систем может повысить общую производительность игры.

## <a name="poor-batch-management"></a>Плохое управление пакетами

Для достижения хорошего параллелизма при использовании GPU необходимо, чтобы пакеты Draw содержали достаточное геометрическую форму, а шейдеры имеют правильную сложность — для того, чтобы видеокарта была занята, в то время как не используется настолько много пакетов, что буфер команд будет переполнен. На оборудовании с текущим поколением рекомендуется приблизительно 300 или меньшее количество отправок пакетов на кадр (меньшее количество на ЦП с более низким уровнем производительности), чтобы предотвратить обработку драйвера буфером командной строки из-за узкого места в производительности. Некоторые другие вызовы состояния API и сочетания драйверов могут привести к дорогостоящей обработке ЦП (например, компиляции драйвера шейдеров), поэтому мы настоятельно рекомендуем выполнять регулярный анализ производительности.

## <a name="excessive-memory-copying"></a>Чрезмерное копирование памяти

Во время разработки большинства заголовков компьютеров разработчики используют удобные структуры данных и строки для управления содержимым. Работа ЦП, необходимая для сравнения строк, копирования и других манипуляций, часто имеет измеряемую нагрузку, особенно при отсчете результатов производительности, связанных с кэшем и подсистемой памяти. Планы следует создавать при разработке этих систем для удаления или минимизации зависимости от обработки строк после того, как продукт переходит на основной этап тестирования и выпуска.

## <a name="excessive-use-of-dynamic-draw-submission"></a>Чрезмерное использование динамической отправки Draw

Современное видеооборудование хорошо работает при работе со статическими данными. Высокопроизводительные адаптеры часто имеют очень большой объем видеопамяти, но эта память не может эффективно использоваться динамическими данными.

Хотя для динамического содержимого можно реализовать достаточно эффективное использование динамических буферов вершин и буферов индексов, многие заголовки изменяют эту идиому для того, что в противном случае является статическим содержимым. Мы чаще всего увидим это с помощью двоичных деревьев секционирования (BSP) и систем на портале, которые хранят геометрию в структуре данных, которая не сопоставлена с оборудованием и должна обрабатываться в буферах для каждого кадра. Помещение как можно большого содержимого в статические ресурсы может значительно снизить затраты на пропускную способность передачи данных на видеоадаптер, улучшить использование встроенного видеоконтроллера и снизить нагрузку на ЦП и кэш, связанные с обработкой этого содержимого.

## <a name="high-overhead-in-file-processing"></a>Большие издержки при обработке файлов

Компьютерные игры получили репутацию для длительных загрузок, особенно при сравнении с названиями консолей с строгими требованиями к времени загрузки. Наш анализ того, как многие заголовки используют файловую систему, показывает некоторые распространенные проблемы.

Затраты на открытие файла обычно значительно выше, чем у разработчиков. При использовании антивирусных сканеров по запросу, а также дополнительных функциональных возможностей NTFS открытие файла является довольно дорогостоящей операцией. Одновременное открытие нескольких файлов или открытие и закрытие одного и того же файла является неудачным методом работы с управлением файлами. Некоторые игры предпринимали попытку снизить затраты на производительность, проверяя наличие файла перед его открытием. В реальности тестирование существования файла в файловой системе NTFS требует открытия файла, поэтому тестирование перед открытием приведет к оплате стоимости дважды.

Игры, которые позволяют вносить изменения в надстройки или МОДС или которые по-прежнему включают в себя формирование шаблонов разработки для проверки файлов данных переопределения, могут иметь значительные задержки при загрузке игры из-за проверки этих файлов, даже если эти файлы отсутствуют. Рекомендуется проверять наличие этих файлов только при запуске с помощью специального параметра командной строки или другого индикатора режима, чтобы только те пользователи, которые используют эту функцию, фактически платят за производительность этих (часто обширных) проверок.

Дополнительные показатели производительности можно получить в файловой системе следующим образом:

-   Правильное использование флага файла подсказок в файловой системе для \_ \_ \_ \_ последовательного доступа и флага файла \_ последовательный \_ Просмотр
-   Изменение размера буферов во избежание большого количества вызовов API-интерфейсов чтения и записи операционной системы
-   Асинхронный доступ к файлам
-   Загрузка потоков в фоновом режиме

Мы также настоятельно рекомендуем преобразовать данные в автономном режиме (во время сборки или установки) вместо того, чтобы полагаться на преобразование при первом запуске игры, так как это накладывает значительный налог на производительность для каждого пользователя.

## <a name="slow-and-frustrating-installation"></a>Снижение производительности и неприятной установки

Другой распространенной проблемой, которую мы видели, является очень длительное время установки, необходимое для многих современных компьютерных игр. Установщики запрашивают пользователя много раз, иногда просто сообщают пользователю, например «вам не нужно устанавливать DirectX». Как правило, для этих установщиков требуется, чтобы пользователь выберет " **Далее** " или " **ОК** " несколько раз перед началом установки игры. После этого мы видели, что некоторые заголовки занимают от часа до того, как пользователь получит возможность играть в игру. Мы настоятельно рекомендуем, чтобы первый час воспроизведения игры не был установлен.

Мы рекомендуем использовать ряд подходов к работе с установкой. Во-первых, необходимо, чтобы запросы были простыми и минимальными. Во-вторых, разработайте данные игры, чтобы некоторые или все файлы данных можно было использовать непосредственно с установочного диска, где это возможно — современные диски DVD имеют очень высокую пропускную способность. В-третьих, рекомендуется реализовать в ваших заголовках установку по запросу, чтобы сократить или исключить процесс установки и позволить пользователям быстро перейти в игру как можно быстрее. (Дополнительные сведения об установке по запросу см. [в статье Установка по запросу для игр](/windows/desktop/DxTechArts/install-on-demand-for-games).)

Дополнительные рекомендации по установке игр см. в разделе [Упрощение установки игр](/windows/desktop/DxTechArts/simplifying-game-installation).

## <a name="lack-of-consideration-of-physical-memory"></a>Отсутствие внимания физической памяти

Из-за широкой вариативности оборудования ПК на рынке заголовки обычно используют нерегламентированные тесты конфигурации для выбора параметров по умолчанию для уровня графических деталей. Некоторые из названий, которые мы видели, используют размер памяти видео в этих тестах, но при этом не удается сопоставить это с объемом физической памяти. Для работы с потерянными устройствами большая часть видеопамяти (как местного, так и нелокального апертуры памяти AGP) должна поддерживаться физической памятью либо с помощью управляемых ресурсов, либо из пользовательских структур данных. Некоторые высококачественные видеоадаптеры имеют размеры видеопамяти, которые приводят к размеру процессора низкого уровня. В ситуациях, когда в системе ограничена физическая память по сравнению с видеоадаптером, большая часть этой видеопамяти не может эффективно использоваться, а также должны быть настроены более низкие параметры.

## <a name="over-reliance-on-real-time-audio-sample-rate-conversion"></a>Over-Reliance преобразования частоты дискретизации Real-Time Audio

Другой распространенный источник цикла ЦП, который мы наблюдали, возникает, когда для преобразования скорости воспроизведения во время смешивания в аппаратном буфере требуется звуковая система. При использовании драйверов WDM (WDM) формат буфера оборудования не находится под прямым управлением приложениями, так как это ресурс уровня ядра. Вместо этого формат выбирается на основе формата наивысшего качества всех источников и возможностей оборудования. По умолчанию в Windows XP используется высококачественное преобразование частоты дискретизации для этого процесса, и если для большинства примеров звука требуется преобразование курсов, будет потреблена значительная часть циклов ЦП.

Рекомендуется создавать все буферы DirectSound с одинаковой частотой выборки. Если вы используете функции **звуковых** функций Microsoft Win32, вы также должны использовать одинаковую частоту выборки. При использовании драйверов WDM все буферы будут смешиваться ядром, и если в некоторых из них используется более высокая частота дискретизации, то частота дискретизации всех остальных элементов будет преобразована в соответствие. Обратите внимание, что это подразумевает использование одинакового темпа воспроизведения для всех образцов звука, включая любые буферы потокового сжатия звука. Настройка основной буферной ставки не действует, если вы не используете Windows 98 или Windows Millennium Edition.

> [!Note]  
> В Windows Vista и более поздних версиях операционной системы DirectSound и **звуковые** данные используют [API-интерфейс Windows Audio (васапи)](/windows/desktop/CoreAudio/wasapi) для всех выходных данных звука.

 

## <a name="fragmention-of-virtual-memory"></a>Фрагментация виртуальной памяти

Мы рассмотрели ряд последних проблем, связанных с 32-разрядным ограничением на объем памяти процесса. Несмотря на то, что 2 ГБ виртуального адресного пространства для процессов пользовательского режима были более точными, увеличение использования больших размещенных в памяти файлов, пользовательских распределительов памяти и увеличения размера видеопамяти (который должен быть сопоставлен с пространством процесса) приступило к ситуациям, когда выделение пространства виртуальной памяти завершается неудачей. Некоторые библиотеки DLL сторонних производителей используют расположения с фиксированным запуском в середине виртуального адресного пространства, что вызывает фрагментацию, приводящую к неудачному выделению.

Чаще всего эти проблемы возникают, когда игра использует пользовательскую схему выделения памяти, которая пытается выделить большой непрерывный блок виртуальной памяти. Наша рекомендация заключается в написании распределительов таким образом, что они запрашивают более разумное количество частей виртуального адресного пространства по мере необходимости. Например, запрашивает 64 или 256 МБ за раз, но не 1 ГБ. Однако следует соблюдать осторожность, чтобы не приводилось к дальнейшей фрагментации. Появление 64-разрядных операционных систем и оборудования значительно поможет устранить эти проблемы в будущем, но необходимо соблюдать осторожность при работе с 32-разрядными системами текущего поколения.

## <a name="manipulation-of-the-floating-point-control-word"></a>Управление Floating-Pointным словом

В качестве вспомогательного средства отладки некоторые разработчики могли включить исключения в блоке с плавающей запятой (FPU), используя манипуляции с управляющим словом с плавающей запятой. Это очень проблематично и, скорее всего, приведет к сбою процесса. Так же, как и в соглашении о вызовах, необходимо сохранить регистр EBX, большинство из них предполагает, что FPU находится в состоянии по умолчанию, выдаст разумные результаты и не создаст исключения. Драйверы и другие системные компоненты часто вычисляют результаты на основе предположения о том, что стандартные значения ошибок будут отображаться в регистрах для неверных условий, но если исключения включены, они будут необработанными и приведут к сбоям.

При инициализации вызывающего потока Direct3D задаст единицу с плавающей запятой с одинарной точностью и округлением до ближайшего значения, если не \_ \_ используется флаг D3DCREATE FPU PRESERVE, в этом случае управляющее слово с плавающей запятой не затрагивается. Так как управляющее слово — это параметр для каждого потока, гарантируя, что все потоки приложения будут иметь режим одиночной точности, может оптимизировать производительность. Помните, что вызов [**\_ control87**](https://msdn.microsoft.com/library/e9b52ceh(v=VS.71).aspx) не является допустимым для кодирования машинного кода x64, который использует исключительно хранимую функцию SSE. это чрезвычайно дорого в архитектуре на основе PowerPC для ЦП Xbox 360.

> [!Note]  
> При изменении управляющего слова используйте [**\_ контролфп \_ s**](https://msdn.microsoft.com/library/c9676k6h(v=VS.80).aspx) и имейте в виду, что для платформ x64 невозможно изменить точность с плавающей запятой с помощью управляющего слова.

 

В любых библиотеках, где нам нужны различные правила округления или другое поведение (например, работа с шейдерами или компиляцией вершин программного обеспечения), мы сохраняем и восстанавливаем управляющее слово. Если в игре необходимо использовать нестандартные исключения округления или FPU, он должен сохранить и восстановить управляющее слово с плавающей запятой, и следует убедиться, что он не вызывает какой-либо внешний код, который не был проверен на наличие защиты от этих проблем, включая системные API.

## <a name="optional-installation-of-the-directx-runtime"></a>Необязательная установка среды выполнения DirectX

Несколько игр запрашивают у пользователя, следует ли устанавливать DirectX. Это может вызвать проблемы, если пользователь предполагает, что в системе установлен последний распространяемый пакет DirectX, и пропустит установку, и установка продолжится успешно. Если для игры требуется определенная версия D3DX или другие обновленные функции, которые не были установлены, то игра не будет работать, и пользователь будет очень разочарован.

Настоятельно рекомендуется, чтобы установщик игры автоматически устанавливал распространяемый пакет DirectX, для которого была создана игра. Процесс установки DirectX разработан таким образом, что он проверяет, нужно ли обновлять и быстро возвращать, если это не так. Поэтому нет необходимости спрашивать пользователя об установке DirectX.

Автоматическая установка DirectX можно выполнить, выполнив следующую команду из установочного пакета: **dxsetup.exe/Silent**

Кроме того, фактический размер повторно распространяемой папки можно настроить так, чтобы она включала только те CAB-файлы (CAB), которые действительно необходимы для целевых платформ и использования игр.

> [!Note]  
> Прежде чем использовать **дкссетуп**, прочтите эту [прямую установку](https://walbourn.github.io/).

 

## <a name="excessive-use-of-thread-synchronization"></a>Чрезмерное использование синхронизации потоков

При профилировании игр часто обнаруживаются основные точки доступа, которые связаны с вводом и отнесением критических разделов. Благодаря распространению многоядерных ЦП использование многопоточности в играх значительно увеличилось, и многие реализации используют интенсивное использование синхронизации потоков. Время ЦП для получения критической секции даже без конкуренции весьма существенным, и все остальные формы синхронизации потоков еще более дороги. Поэтому необходимо соблюдать осторожность, чтобы не использовать эти примитивы.

Распространенным источником чрезмерной синхронизации в играх является использование [D3DCREATE \_ многопоточности](/windows/desktop/direct3d9/d3dcreate). Этот флаг, в то же время обеспечивая потокобезопасность Direct3D для отрисовки из нескольких потоков, принимает очень консервативный подход, что приводит к высокой нагрузке на синхронизацию. Игры не следует использовать этот флаг. Вместо этого необходимо спроектировать ядро так, чтобы все взаимодействие с Direct3D выполнялось из одного потока и обмен данными между потоками осуществляется напрямую. Дополнительные сведения о проектировании многопоточных игр см. в статье [написание кода для нескольких ядер на Xbox 360 и Microsoft Windows](/windows/desktop/DxTechArts/coding-for-multiple-cores).

## <a name="use-of-rdtsc"></a>Использование RDTSC

Использование инструкции x86 **RDTSC** не рекомендуется. **RDTSC** не может правильно вычислить время для некоторых схем управления питанием, которые изменяют частоту ЦП динамически и на многих многоядерных ЦП, для которых счетчик циклов не синхронизируется между ядрами. Вместо этого в играх следует использовать API [**QueryPerformanceCounter**](/windows/desktop/api/profileapi/nf-profileapi-queryperformancecounter) . Дополнительные сведения о проблемах с **RDTSC** и реализации времени высокого разрешения с помощью **QueryPerformanceCounter** см. в статье [время игры и многоядерные процессоры](/windows/desktop/DxTechArts/game-timing-and-multicore-processors).

 

 