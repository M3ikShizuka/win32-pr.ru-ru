---
title: Каскадные карты теней
description: Каскадные теневые карты (Ксмс) — это лучший способ противостоять одной из самых распространенных ошибок с помощью псевдонимов перспективы.
ms.assetid: d3570d0a-74e0-5b9c-6586-c933f630c4ee
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 29498dc882133215c910f3bd6caa5966aa0e141aaf4f7a68051834d33f2a3b16
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118649720"
---
# <a name="cascaded-shadow-maps"></a>Каскадные карты теней

Каскадные теневые карты (Ксмс) — это лучший способ противостоять одной из самых распространенных ошибок с тенью: «псевдонимы перспективы». Эта Техническая статья, в которой предполагается, что читатель знаком с теневым отображением, рассматривается раздел Ксмс. В частности, код:

-   объясняет сложность Ксмс;
-   содержит подробные сведения о возможных разновидностях алгоритмов CSM.
-   Описание двух наиболее распространенных методов фильтрации: процент более детальной фильтрации (PCF) и фильтрация с помощью теневых карт дисперсии (ВСМС).
-   определяет и устраняет некоторые распространенные ошибки, связанные с добавлением фильтрации в Ксмс; перетаскивани
-   показывает, как сопоставлять Ксмс с Direct3D 10 до Direct3D 11 Hardware.

Код, используемый в этой статье, можно найти в разделе CascadedShadowMaps11 and VarianceShadows11 Samples SDK (пакет средств разработки программного обеспечения DirectX). эта статья будет наиболее полезной после реализации методик, описанных в технической статье, и реализовать [распространенные методы улучшения глубины тени Карты](/windows/desktop/DxTechArts/common-techniques-to-improve-shadow-depth-maps).

## <a name="cascaded-shadow-maps-and-perspective-aliasing"></a>каскадные Карты тени и псевдонимы перспективы

Псевдоним перспективы в теневой карте — одна из самых сложных проблем, которую следует преодолеть. в технической статье описываются распространенные методики улучшения Карты глубины тени, а также рассматриваются некоторые подходы к устранению проблемы. На практике Ксмс, как правило, является лучшим решением и обычно используются в современных играх.

Базовое понятие Ксмс легко понять. Для разных областей камеры фрустум требуются теневые карты с разными разрешениями. Для объектов, ближайших к глазу, требуется более высокое разрешение, чем более отдаленные объекты. На самом деле, когда глаз очень близко к геометрической области, Пиксели, близкие к этому глазу, могут потребовать настолько большого разрешения, что даже на теневой карте 4096 × 4096 недостаточно.

Основная идея Ксмс состоит в том, чтобы секционировать фрустум в несколько Фруста. Для каждого субфрустум отображается теневая схема; построитель текстуры затем выбирается из схемы, которая наиболее точно соответствует требуемому разрешению (рис. 2).

**Рис. 1. Покрытие теневой схемы**

![покрытие теневой схемы](images/shadow-map-coverage.png)

На рис. 1 качество отображается (слева направо) от самого высокого до самого низкого. Ряд сеток, представляющих теневые карты с представлением фрустум (инвертированный конус в красном фоне), показывает, как покрытие на уровне пикселей влияет на различные теневые карты разрешения. Тени имеют наивысшее качество (белые пиксели) при наличии пикселов сопоставления соотношения 1:1 в пространстве, пикселей текстуры на теневой карте. Псевдоним перспективы имеет форму больших, блочных текстурных карт (левое изображение), если слишком много пикселей сопоставлены с одним и тем же теневым шаг текселя. Если теневая схема слишком велика, она находится в разделе выборка. В этом случае пикселей текстуры пропускаются, отображаются артефакты Шиммеринг, а производительность затронется.

**Рис. 2. Качество тени CSM**

![качество тени CSM](images/csm-shadow-quality.png)

На рис. 2 показаны отрезки от раздела наивысшего качества на каждой теневой карте на рис. 1. Теневая схема с наиболее близко расположенными пикселами (в вершине) является ближайшей глазой. Технически это карты одного и того же размера с белым и серым цветом, используемыми для проиллюстрировать успеха каскадной теневой карты. Белый вариант идеален, так как он показывает хорошее покрытие — коэффициент 1:1 для пикселов глаза и пикселей текстуры теневой схемы.

Ксмс для каждого кадра необходимо выполнить следующие действия.

1.  Разбейте фрустум на субфруста.
2.  Вычислите ортогональную проекцию для каждого субфрустум.
3.  Выводите теневую карту для каждого субфрустум.
4.  Отрисовка сцены.

    1.  Привяжите теневые карты и визуализацию.
    2.  Шейдер вершин выполняет следующие действия:

        -   Вычисляет координаты текстуры для каждого светлого субфрустум (если в шейдере пикселей не вычисляется нужная Координата текстуры).
        -   Преобразует и подсвечивает вершину и т. д.

    3.  Шейдер пикселей выполняет следующие действия:

        -   Определяет правильную теневую карту.
        -   При необходимости преобразует координаты текстуры.
        -   Выборка каскадом.
        -   Освещение пикселя.

## <a name="partitioning-the-frustum"></a>Секционирование Фрустум

Секционирование фрустум — это процесс создания субфруста. Одним из способов разделения фрустум является вычисление интервалов от нуля до 100 процентов в направлении по оси Z. Затем каждый интервал представляет близкую плоскость и дальнее плоскость в процентах от оси Z.

**Рис. 3. Произвольное представление секционирования фрустумс**

![Произвольное представление секционирования фрустумс](images/view-frustums-partitioned-arbitrarily.png)

На практике повторное вычисление разбиений фрустум на кадр приводит к шиммерию теней. Обычно принято использовать статический набор каскадных интервалов для каждого сценария. В этом сценарии интервал по оси Z используется для описания субфрустум, возникающего при секционировании фрустум. Определение правильных интервалов для заданной сцены зависит от нескольких факторов.

### <a name="orientation-of-the-scene-geometry"></a>Ориентация геометрии сцены

По отношению к геометрии сцены ориентация на камеру влияет на выбор каскадного интервала. Например, Камера, почти близкая к заземлению, например, Камера в футболе, имеет другой статический набор интервалов Cascade, чем камера в перевозки.

На рис. 4 показаны некоторые различные камеры и их соответствующие секции. Если Z-диапазон сцены очень большой, требуется больше разделенных плоскостей. Например, когда глаз почти находится рядом с плоскостью земли, но удаленные объекты по-прежнему видны, может потребоваться несколько каскадных переходов. Деление фрустум таким образом, чтобы более разбиваются рядом с глазом (где изменение псевдонимов перспективы меняется быстрее) также является ценным. Если большая часть геометрического объекта клумпед в небольшой раздел (например, на представление "затраты на накладные расходы" или симулятор рейсов) представления фрустум, необходимо меньше каскадных элементов.

**Рис. 4. Для различных конфигураций требуются разные фрустум разбиения**

![для различных конфигураций требуются разные фрустум разбиения](images/different-configurations-require-different-frustum-splits.png)

Слева Если геометрический объект имеет большой динамический диапазон в Z, требуется много каскадных. Center Если геометрический объект имеет низкий динамический диапазон в Z, существует небольшое преимущество нескольких фрустумс. Справа Если динамический диапазон является средним, необходимы только три секции.

### <a name="orientation-of-the-light-and-the-camera"></a>Ориентация освещения и камеры

Каждая матрица проекции каскадом тесно связана с соответствующей субфрустум. В конфигурациях, в которых Камера и лампочка представления являются ортогональными, каскадные расположения могут быть тесно связаны с небольшим перекрытием. Перекрытие увеличивается по мере того, как лампочка и вид камеры переходят в параллельное выравнивание (рис. 5). Если лампочка и вид камеры почти параллельны, она называется «дуелинг Фруста» и является очень сложной ситуацией для большинства алгоритмов теневого копирования. Нередко можно ограничить освещение и камеру, чтобы этот сценарий не наблюдались. Однако в этом сценарии Ксмс работают гораздо лучше, чем многие другие алгоритмы.

**Рис. 5. Каскадное перекрытие увеличивается, так как направление освещения становится параллельным с направлением камеры**

![каскадное перекрытие увеличивается, так как направление освещения становится параллельным с направлением камеры](images/cascade-overlap-increases-as-light-direction-becomes.jpg)

Многие реализации CSM используют Фруста фиксированного размера. Шейдер пикселей может использовать Z-глубину для индексации массива каскадных значений, когда фрустум разбивается в интервалах фиксированного размера.

## <a name="calculating-a-view-frustum-bound"></a>Вычисление привязанного к View-Frustumу

После выбора интервалов фрустум субфруста создаются с помощью одного из двух: по размеру сцены и по размеру каскада.

### <a name="fit-to-scene"></a>Вписать в сцену

Все Фруста можно создать с одной и той же ближней плоскостью. Это приводит к перекрытию каскадных переходов. Пример CascadedShadowMaps11 вызывает этот метод по размеру сцены.

### <a name="fit-to-cascade"></a>Вписать в каскадную

Кроме того, Фруста можно создать с фактическим интервалом секций, который используется в качестве ближайших и дальнех плоскостей. Это приводит к более тесному подаче, но вырождению для использования сцены в случае дуелинг Фруста. Примеры CascadedShadowMaps11 вызывают этот метод для размещения каскадом.

Эти два метода показаны на рис. 6. Подгонка к каскадным расходам с меньшим разрешением. Проблема по размеру каскада заключается в том, что ортогональная проекция растет и сжимается в зависимости от ориентации представления фрустум. Методика "вписать в сцену" размещает ортогональную проекцию на максимальный размер представления фрустум удаление артефактов, отображаемых при перемещении представления камерой. [распространенные методы улучшения глубины тени Карты](/windows/desktop/DxTechArts/common-techniques-to-improve-shadow-depth-maps) адреса артефактов, которые появляются, когда источник перемещается в разделе «перемещение освещения в шаг текселя с увеличением размера».

**Рис. 6. По размеру сцены и по размеру каскадом**

![вписать в сцену и разместить в каскаде](images/fit-to-scene-vs-fit-to-cascade.png)

## <a name="render-the-shadow-map"></a>Визуализация теневой схемы

Образец CascadedShadowMaps11 визуализирует теневые карты в один большой буфер. Это обусловлено тем, что PCF на массивах текстур — это функция Direct3D 10,1. Для каждого каскадного представления создается окно просмотра, охватывающее раздел буфера глубины, соответствующий этому каскаду. Привязка шейдера пикселей NULL выполнена, так как требуется только глубина. Наконец, правильная область просмотра и матрица Shadow задаются для каждого каскада, так как карты глубины подготавливаются к просмотру по одной за раз в основном буфере теневого копирования.

## <a name="render-the-scene"></a>Отрисовка сцены

Буфер, содержащий тени, теперь привязан к шейдеру пикселей. Существует два метода выбора каскада, реализованного в образце CascadedShadowMaps11. Эти два метода объясняются с помощью кода шейдера.

### <a name="interval-based-cascade-selection"></a>Interval-Based каскадный выбор

**Рис. 7. Каскадное выделение на основе интервалов**

![каскадное выделение на основе интервалов](images/interval-based-cascade-selection.jpg)

В выборе на основе интервалов (рис. 7) Вершинный шейдер вычислит расположение в мировом пространстве вершины.


```C++
Output.vDepth = mul( Input.vPosition, m_mWorldView ).z;
```



Построитель текстуры получает глубину интерполяции.


```C++
fCurrentPixelDepth = Input.vDepth;
```



При каскадном выборе на основе интервалов используется сравнение вектора и точки для определения правильного какаде. Флаг CASCADE \_ Count \_ указывает количество каскадных значений. \_Фкаскадефрустумсэйеспацедепсс данных m \_ ограничивает разделы View фрустум. После сравнения Фкомпарисон содержит значение 1, где текущий пиксель больше барьера, и значение 0, если текущий Каскад является меньшим. Элемент "точка" суммирует эти значения в индексе массива.


```C++
        float4 vCurrentPixelDepth = Input.vDepth;
        float4 fComparison = ( vCurrentPixelDepth > m_fCascadeFrustumsEyeSpaceDepths_data[0]);
        float fIndex = dot(
        float4( CASCADE_COUNT_FLAG > 0,
        CASCADE_COUNT_FLAG > 1,
        CASCADE_COUNT_FLAG > 2,
        CASCADE_COUNT_FLAG > 3)
        , fComparison );

        fIndex = min( fIndex, CASCADE_COUNT_FLAG );
        iCurrentCascadeIndex = (int)fIndex;
```



После выбора Cascade Координата текстуры должна быть преобразована в правильную каскадную.


```C++
vShadowTexCoord = mul( InterpolatedPosition, m_mShadow[iCascadeIndex] );
```



Эта Координата текстуры затем используется для выборки текстуры с помощью координаты X и координаты Y. Координата Z используется для окончательного сравнения глубины.

### <a name="map-based-cascade-selection"></a>Map-Based каскадный выбор

Выбор на основе карт (рис. 8) проверяет четыре стороны каскадных объектов, чтобы найти наиболее тесное соответствие, охватывающее конкретный пиксель. Вместо вычисления расположения в мировом пространстве шейдер вершин вычисляет расположение пространства в области просмотра для каждого каскада. Шейдер пикселей выполняет перебор каскадов, чтобы масштабировать и сдвинуть координаты текстуры таким образом, чтобы они проиндексированы текущий Каскад. Затем Координата текстуры проверяется на соответствие текстурным границам. Если значения X и Y координаты текстуры находятся внутри каскадной, они используются для выборки текстуры. Координата Z используется для окончательного сравнения глубины.

**Рис. 8. Каскадное выделение на основе карт**

![каскадное выделение на основе карт](images/map-based-cascade-selection.jpg)

### <a name="interval-based-selection-vs-map-based-selection"></a>Выбор Interval-Based и выбор Map-Based

Выбор на основе интервалов выполняется немного быстрее, чем выбор на основе карт, поскольку каскадное выделение можно выполнить напрямую. Выбор на основе карт должен пересекать координату текстуры с границами Cascade.

Выбор на основе карты более эффективно использует Каскад, если теневые карты не выровнены идеально (см. рис. 8).

## <a name="blend-between-cascades"></a>Переход между каскадными таблицами

ВСМС (см. Далее в этой статье) и методы фильтрации, такие как PCF, можно использовать с Ксмс с низким разрешением для создания мягких теней. К сожалению, это приводит к отображению стыка (рис. 9) между каскадными слоями, так как разрешение не совпадает. Решение состоит в том, чтобы создать полосу между теневыми картами, где выполняется теневая проверка обоих каскадных расположений. Затем шейдер линейно выполняет интерполяцию между двумя значениями на основе расположения пикселя в полосе смешения. Примеры CascadedShadowMaps11 и VarianceShadows11 предоставляют ползунок графического пользовательского интерфейса, который можно использовать для увеличения и уменьшения этого диапазона размытия. Шейдер выполняет динамическую ветвь, чтобы подавляющее большинство пикселей было считано только из текущего каскада.

**Рис. 9. Каскадные стыки**

![каскадные стыки](images/cascade-seams.jpg)

Слева Видимый стык можно увидеть, где каскады перекрываются. Справа При переходе между каскадными таблицами не происходит стыка.

## <a name="filtering-shadow-maps"></a>фильтрация теневых Карты

### <a name="pcf"></a>PCF

Фильтрация обычных теневых карт не приводит к созданию мягких размытий теней. Фильтрация оборудования разменяет значения глубины, а затем сравнивает эти размытые значения с шаг текселя пространством. Жесткий элемент, полученный в результате теста пройден/Fail, все еще существует. Размытие теневые карты служат только для того, чтобы ошибочно переместить жесткое ребро. PCF включает фильтрацию на теневых картах. Основная идея PCF заключается в том, чтобы вычислить процентную долю пикселя в тени на основе количества подвыборок, прошедших тест глубины по общему количеству подвыборок.

Direct3D 10 и Direct3D 11 могут выполнять PCF. Входные данные для образца PCF состоят из координаты текстуры и значения глубины сравнения. Для простоты PCF объясняется с помощью фильтра с четырьмя касаниями. Образец текстуры считывает текстуру четыре раза, аналогично стандартному фильтру. Однако возвращаемый результат представляет собой процент пикселей, которые прошли тест глубины. На рис. 10 показано, как в теневой копии пикселя, прошедшего одну из четырех тестов глубины, является 25%. Возвращаемое значение представляет собой линейную интерполяцию, основанную на субтексел координатах считывания текстур для создания плавного градиента. Без этой линейной интерполяции PCF с четырьмя tapи смогут возвращать только пять значений: {0,0, 0,25, 0,5, 0,75, 1,0}.

**Рис. 10. Отфильтрованное изображение PCF с покрыто 25% от выбранного пикселя**

![отфильтрованное изображение PCF с покрыто 25% от выбранного пикселя](images/pcf-filtered-image.png)

Также можно выполнить PCF без поддержки оборудования или расширить PCF до более крупных ядер. Некоторые приемы даже выборке с взвешенным ядром. Для этого создайте ядро (например, значение по Гауссу) для сетки N × N. Весовые коэффициенты должны быть не более 1. Затем текстура выдает значение N2 раз. Каждый пример масштабируется по соответствующим весовым коэффициентам в ядре. Этот подход используется в образце CascadedShadowMaps11.

### <a name="depth-bias"></a>Смещение глубины

Сдвиг глубины еще более важен при использовании крупных ядер PCF. Это допустимо только для сравнения глубины свободного пространства в пикселях относительно пикселя, к которому он соответствует, на карте глубины. Соседи шаг текселя карт глубины ссылаются на другую точку. Эта глубина, скорее всего, будет аналогичной, но она может сильно отличаться в зависимости от сцены. На рис. 11 показаны происходящие артефакты. Одна глубина сравнивается с тремя соседними пикселей текстуры в теневой карте. Одна из тестов глубины ошибочно завершается ошибкой, так как ее глубина не соотносится с вычисленной глубиной освещения текущего геометрического пространства. Рекомендуемое решение этой проблемы — использовать более крупное смещение. Однако слишком большое значение смещения может привести к сдвигу Питер. Вычисление тесного приближения плоскости и дальней плоскости позволяет снизить последствия использования смещения.

**Рис. 11. Ошибочное затенение**

![ошибочное затенение](images/erroneous-self-shadowing.png)

Ошибочное затенение приводит к сравнению пикселов в глубине свободного пространства с пикселей текстуры на теневой карте, которая не взаимосвязана. Глубина в светлом пространстве соответствует теневому шаг текселя 2 на карте глубины. Шаг текселя 1 больше, чем глубина свободного пространства, а 2 равно, а 3 меньше. Пикселей текстуры 2 и 3 прошли тест глубины, в то время как шаг текселя 1 завершается ошибкой.

### <a name="calculating-a-per-texel-depth-bias-with-ddx-and-ddy-for-large-pcfs"></a>Вычисление смещения глубины Per-Texel с помощью DDX и ДДИ для крупных Пкфс

Вычисление смещения глубины шаг текселя с помощью **DDX** и **ДДИ** для крупных пкфс — это метод, который вычисляет правильную глубину глубины (предполагая, что поверхность плоская) для смежной теневой схемы шаг текселя.

Этот метод соответствует глубине сравнения для плоскости, использующей производные сведения. Поскольку этот метод является сложным, его следует использовать, только если GPU имеет циклы вычислений для запасного. Если используются очень крупные ядра, это может быть единственная методика, которая позволяет удалить артефакты самотеневого копирования, не вызывая панорамирование Питер.

На рис. 12 выделяется проблема. Глубина свободного пространства известна для одного шаг текселя, который сравнивается. Глубина свободного пространства, соответствующая соседним пикселей текстуры на карте глубины, неизвестна.

**Рис. 12. Сцена и схема глубины**

![Сцена и схема глубины](images/scene-and-depth-map.png)

Визуализированная сцена показана слева, а схема глубины с примером блока шаг текселя показана справа. Шаг текселя пробела сопоставляется с пикселем, обозначенным D в центре блока. Это сравнение является точным. Правильная глубина области видимости, связанная с пикселами, неизвестными для соседа D. Сопоставление соседних пикселей текстуры с пространством глаза возможно только в том случае, если предполагается, что пиксель относится к тому же треугольнику, что и D.

Глубина известна для шаг текселя, которая соответствует положению области освещения. Глубина неизвестна для соседних пикселей текстуры на карте глубины.

На высоком уровне этот метод использует операции **DDX** и **ДДИ** HLSL для поиска производного места в пространстве. Это нетривиальный способ, поскольку производные операции возвращают градиент глубины светлого пространства относительно пространства экрана. Чтобы преобразовать это значение в градиент глубины освещения относительно пустого пространства, необходимо вычислить матрицу преобразования.

### <a name="explanation-with-shader-code"></a>Объяснение с помощью кода шейдера

Подробные сведения о остальном алгоритме приведены в пояснении к коду шейдера, который выполняет эту операцию. Этот код можно найти в примере CascadedShadowMaps11. На рис. 13 показано, как координаты текстуры освещения отображают карту глубины и как производные значения в X и Y можно использовать для создания матрицы преобразования.

**Рис. 13. Пространство на экране для матрицы с небольшими пробелами**

![пространство на экране для матрицы с небольшими пробелами](images/screen-space-to-light-space-matrix.png)

Для создания этой матрицы используются производные от расположения места в пространстве координат X и Y.

Первым шагом является вычисление производного расположения светлого пространства.


```C++
          float3 vShadowTexDDX = ddx (vShadowMapTextureCoordViewSpace);
          float3 vShadowTexDDY = ddy (vShadowMapTextureCoordViewSpace);
```



Процессоры класса Direct3D 11 вычисляют эти производные, выполняя 2 × 2 четыре пикселя параллельно и вычитая координаты текстуры из соседа в X для **DDX** и из соседа в Y для **ДДИ**. Эти два производных класса составляют строки матрицы размером 2 × 2. В текущей форме эту матрицу можно использовать для преобразования пространства экрана, соседних пикселов, в наклоненной. Однако требуется обратная часть этой матрицы. Матрица, которая преобразует наклоненной, соседние пиксели, в пространстве экрана.


```C++
          float2x2 matScreentoShadow = float2x2( vShadowTexDDX.xy, vShadowTexDDY.xy );
          float fInvDeterminant = 1.0f / fDeterminant;

          float2x2 matShadowToScreen = float2x2 (
          matScreentoShadow._22 * fInvDeterminant,
          matScreentoShadow._12 * -fInvDeterminant,
          matScreentoShadow._21 * -fInvDeterminant,
          matScreentoShadow._11 * fInvDeterminant );
```



**Рис. 14. Свободное пространство на экране**

![свободное пространство на экране](images/light-space-to-screen-space.png)

Эта матрица затем используется для преобразования двух пикселей текстуры выше и справа от текущего шаг текселя. Эти соседи представлены в виде смещения от текущего шаг текселя.


```C++
          float2 vRightShadowTexelLocation = float2( m_fTexelSize, 0.0f );
          float2 vUpShadowTexelLocation = float2( 0.0f, m_fTexelSize );
          float2 vRightTexelDepthRatio = mul( vRightShadowTexelLocation,
          matShadowToScreen );
          float2 vUpTexelDepthRatio = mul( vUpShadowTexelLocation,
          matShadowToScreen );
```



Соотношение, которое создает матрица, в итоге умножается на производные от глубины, чтобы вычислить смещения глубины для соседних пикселов.


```C++
            float fUpTexelDepthDelta =
            vUpTexelDepthRatio.x * vShadowTexDDX.z
            + vUpTexelDepthRatio.y * vShadowTexDDY.z;
            float fRightTexelDepthDelta =
            vRightTexelDepthRatio.x * vShadowTexDDX.z
            + vRightTexelDepthRatio.y * vShadowTexDDY.z;
```



Теперь эти весовые коэффициенты можно использовать в цикле PCF для добавления смещения к позиции.


```C++
    for( int x = m_iPCFBlurForLoopStart; x < m_iPCFBlurForLoopEnd; ++x ) 
    {
        for( int y = m_iPCFBlurForLoopStart; y < m_iPCFBlurForLoopEnd; ++y )
            {
            if ( USE_DERIVATIVES_FOR_DEPTH_OFFSET_FLAG )
            {
            depthcompare += fRightTexelDepthDelta * ( (float) x ) +
            fUpTexelDepthDelta * ( (float) y );
            }
            // Compare the transformed pixel depth to the depth read
            // from the map.
            fPercentLit += g_txShadow.SampleCmpLevelZero( g_samShadow,
            float2(
            vShadowTexCoord.x + ( ( (float) x ) * m_fNativeTexelSizeInX ) ,
            vShadowTexCoord.y + ( ( (float) y ) * m_fTexelSize )
            ),
            depthcompare
            );
            }
     }
```



## <a name="pcf-and-csms"></a>PCF и Ксмс

PCF не работает с массивами текстур в Direct3D 10. Чтобы использовать PCF, все каскады хранятся в одной большой текстуре Atlas.

### <a name="derivative-based-offset"></a>Смещение Derivative-Based

Добавление смещений на основе производных для Ксмс представляет некоторые трудности. Это обусловлено производным вычислением в отдельном потоке управления. Проблема возникает из-за фундаментального способа работы GPU. Direct3D11 GPU работают в 2 × 2 четырех пикселях. Чтобы выполнить производный, GPU, как правило, вычитают копию переменной текущего пикселя из копии этой же переменной на соседнем пикселе. Как это происходит от GPU до GPU. Координаты текстуры определяются каскадным выделением на основе карт или на основе интервалов. Некоторые Пиксели в пикселе имеют разную каскадную, чем остальные Пиксели. Это приводит к видимым стыкам между теневыми картами, так как производные смещения теперь являются совершенно неправильными. Решение состоит в том, чтобы выполнить производную на координатах текстуры освещения незанятого пространства. Эти координаты одинаковы для каждого каскада.

### <a name="padding-for-pcf-kernels"></a>Заполнение для ядер PCF

PCF ядра индекса за пределами секции Cascade, если теневой буфер не заполнен. Решение заключается в том, чтобы заполнить наружную rimную часть каскадом на половину размера ядра PCF. Эта возможность должна быть реализована в шейдере, который выбирает Каскад и в матрице проекции, которая должна отображать каскадную, достаточно большой для сохранения границы.

## <a name="variance-shadow-maps"></a>теневая Карты дисперсии

ВСМС (Дополнительные сведения см. в разделе [отклонение теневых карт](https://portal.acm.org/citation.cfm?doid=1111411.1111440) по Доннелли и лауритзен). включите фильтрацию прямого теневого отображения. При использовании ВСМС можно использовать все возможности оборудования, поддерживающего фильтрацию текстур. Можно использовать фильтрацию трилинейной и анизотропный (рис. 15). Кроме того, ВСМС может быть размыт напрямую через свертывание. ВСМС имеют некоторые недостатки. необходимо хранить два канала данных глубины (с глубиной и глубиной в квадрате). Когда тени перекрываются, светло-суперсовременные является наиболее распространенным. Однако они хорошо работают с более низкими разрешениями и могут сочетаться с Ксмс.

**Рис. 15. Анизотропная фильтрация**

![Анизотропная фильтрация](images/anisotropic-filtering.png)

### <a name="algorithm-details"></a>Подробные сведения об алгоритмах

ВСМС работу, выполнив визуализацию глубины и глубины в квадрате на основе схемы с двумя каналами. Затем эту схему теневой схемы с двумя каналами можно сделать размытой и отфильтровать так же, как нормальная текстура. Затем алгоритм использует неравенство Чебичев в шейдере пикселей для оценки доли области в пикселях, которая будет проходить тест глубины.

Построитель текстуры получает значения глубины и глубины в квадратах.


```C++
        float  fAvgZ  = mapDepth.x; // Filtered z
        float  fAvgZ2 = mapDepth.y; // Filtered z-squared
```



Выполняется сравнение глубины.


```C++
        if ( fDepth <= fAvgZ )
        {
        fPercentLit = 1;
        }
```



Если сравнение глубины завершается неудачно, то вычисляется процентная доля освещенного пикселя. Дисперсия вычисляется как среднее значение минус квадраты.


```C++
        float variance = ( fAvgZ2 ) − ( fAvgZ * fAvgZ );
        variance = min( 1.0f, max( 0.0f, variance + 0.00001f ) );
```



Значение Фперцентлит оценивается как неравенство Чебичев.


```C++
        float mean           = fAvgZ;
        float d              = fDepth - mean;
        float fPercentLit    = variance / ( variance + d*d );
```



## <a name="light-bleeding"></a>Светло суперсовременные

Самый большой недостаток ВСМС — светло суперсовременные (рис. 16). Легкая суперсовременные возникает, когда несколько теней окклуде друг с другом вдоль краев. ВСМС затениет края темных элементов на основе неосторожностей глубины. Когда тени перекрываются, в центре области, которая должна быть скрыта, существует несоответствие глубины. Это проблема использования алгоритма VSM.

**Рис. 16. VSM Light суперсовременные**

![VSM Light суперсовременные](images/vsm-light-bleeding.png)

Частичное решение проблемы заключается в том, чтобы подать Фперцентлит в степень. Это приводит к ослаблению размытия, что может вызвать артефакты с небольшими нарушениями в глубине. Иногда существует значение Magical, которое устраняет проблему.


```C++
fPercentLit = pow( p_max, MAGIC_NUMBER );
```



Альтернативой порождению процента освещенности мощности является избежание конфигураций, в которых тени перекрываются. Даже высоко настроенные теневые конфигурации имеют несколько ограничений на освещение, камеру и геометрию. Светло суперсовременные также уменьшается с помощью текстур с более высоким разрешением.

Многоуровневые теневые карты расхождений (Лвсмс) позволяют решить проблему за счет нарушения фрустум в слоях, перпендикулярных источнику. Количество необходимых карт будет довольно большим, если Ксмс также используются.

Кроме того, Эндрю Лауритзен, соавтор бумаги на ВСМС и автор документа на Лвсмс, обсуждая сочетание экспоненциальной теневой карты (Есмс) с ВСМС, чтобы противося нелегкому смешению на [форуме Beyond3D](https://forum.beyond3d.com/showthread.php?t=47427).

## <a name="vsms-with-csms"></a>ВСМС с Ксмс

В примере VarianceShadow11 объединяются ВСМС и Ксмс. Это сочетание довольно просто. Пример соответствует тем же действиям, что и образец CascadedShadowMaps11. Поскольку PCF не используется, тени преобразуются в отделяемыхй свертки. Не используйте PCF также позволяет образцу использовать массивы текстур вместо текстуры Atlas. PCF на массивах текстур — это функция Direct3D 10,1.

### <a name="gradients-with-csms"></a>Градиенты с Ксмс

Использование градиентов с Ксмс может создать стык вдоль границы между двумя каскадными таблицами, как показано на рис. 17. В образце инструкции используются производные между пикселями для вычисления информации, например уровня mipmap, необходимого для фильтра. Это вызывает проблему в частности для выбора mipmap или анизотропной фильтрации. Когда в построителе пикселей четыре ветви в шейдере, производные от оборудования GPU недопустимы. Это приводит к неровному стыку на теневой карте.

**Рис. 17. Стыки на каскадных границах из-за анизотропной фильтрации с использованием других элементов управления потоком**

![стыки на каскадных границах из-за анизотропной фильтрации с использованием других элементов управления потоком](images/seams-on-cascade-borders-due-to-anisotropic.jpg)

Эту проблему можно решить, вычисляя производные от места в свободном месте. Координата недостаточного пространства не зависит от выбранного каскадного представления. Вычисленные производные массивы могут масштабироваться по части шкалы матрицы проекций текстур до правильного уровня mipmap.


```C++
        float3 vShadowTexCoordDDX = ddx( vShadowMapTextureCoordViewSpace );
        vShadowTexCoordDDX *= m_vCascadeScale[iCascade].xyz;
        float3 vShadowTexCoordDDY = ddy( vShadowMapTextureCoordViewSpace );
        vShadowTexCoordDDY *= m_vCascadeScale[iCascade].xyz;

        mapDepth += g_txShadow.SampleGrad( g_samShadow, vShadowTexCoord.xyz,
        vShadowTexCoordDDX, vShadowTexCoordDDY );
```



## <a name="vsms-compared-to-standard-shadows-with-pcf"></a>ВСМС по сравнению со стандартными тенями с PCF

И ВСМС, и PCF попытаются приблизительно оценить долю пиксельной области, которая будет проходить тест глубины. ВСМС работает с фильтрацией оборудования и может быть размыт с помощью ядер отделяемых. Ядрам свертки отделяемых значительно дешевле для реализации, чем для полного ядра. Кроме того, ВСМС сравнивает одну глубину свободного пространства с одним значением на карте глубины свободного пространства. Это означает, что ВСМС не имеют тех же проблем со смещением, что и PCF. Технически, ВСМС — это глубина выборки в большей области, а также выполнение статистического анализа. Это менее точное, чем PCF. На практике ВСМС выполняет очень хорошее задание смешения, что приводит к меньшему смещению. Как описано выше, число, которое один недостаток в ВСМС, является светлой суперсовременные.

ВСМС и PCF представляют компромисс между производительностью вычислений GPU и текстурой GPU. Для вычисления дисперсии ВСМС требуется больше математических вычислений. PCF требует больше пропускной способности текстурной памяти. Большие ядра PCF могут быстро стать узким местом по пропускной способности текстуры. Так как вычислительные мощности GPU растут более быстро, чем пропускная способность GPU, ВСМС становится более практичной из двух алгоритмов. ВСМС также лучше рассмотреть теневые карты с более низким разрешением из-за смешения и фильтрации.

## <a name="summary"></a>Сводка

Ксмс предлагают решение проблемы с псевдонимом перспективы. Существует несколько возможных конфигураций для получения необходимой визуальной точности заголовка. PCF и ВСМС широко используются и должны сочетаться с Ксмс, чтобы сократить число псевдонимов.

## <a name="references"></a>Справочные материалы

Доннелли, W. и Лауритзен — [теневые карты с дисперсией](https://portal.acm.org/citation.cfm?doid=1111411.1111440). В SI3D ' 06: материалы 2006 Symposium в интерактивной трехмерной графике и играх. 2006. PP. 161 – 165. Нью Йорк, Москва, США: ACM Press.

Лауритзен, Эндрю и Мккул, Майкл. [Слоевые теневые карты расхождений](https://portal.acm.org/citation.cfm?id=1375714.1375739&coll=GUIDE&dl=GUIDE&CFID=45360327&CFTOKEN=34578992). Материалы графического интерфейса 2008, 28 мая – 30, 2008, Windsor, Онтарио, Канада.

Енжел, Вофлганг F. раздел 4. каскадная теневая Карты. ShaderX5, дополнительные методы отрисовки, Волфганг F. Енжел, ED. Чарльз River Media, Бостон, Массачусетс. 2006. PP. 197 – 206.

 

 