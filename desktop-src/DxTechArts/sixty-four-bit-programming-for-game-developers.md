---
title: 64-разрядное программирование для разработчиков игр
description: В этой статье рассматриваются проблемы совместимости и переноса и помогает разработчикам упростить переход на 64-разрядные платформы.
ms.assetid: 23a7ed41-6637-0607-327e-983b622e9104
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 439db3173e18206cb04875ab9c4422dbcedc7230508c8e98cf09b7fe27bfb9f2
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "120042434"
---
# <a name="64-bit-programming-for-game-developers"></a>64-разрядное программирование для разработчиков игр

Производители процессоров используют для настольных компьютеров только 64-разрядные процессоры, а даже наборы микросхем большинства ноутбуков поддерживают технологию x64. очень важно, чтобы разработчики игр использовали преимущества усовершенствований, предоставляемых 64-разрядными процессорами, с новыми приложениями и обеспечить правильную работу их приложений на новых процессорах и 64-разрядных выпусках Windows Vista и Windows 7. В этой статье рассматриваются проблемы совместимости и переноса и помогает разработчикам упростить переход на 64-разрядные платформы.

В настоящее время корпорация Майкрософт имеет следующие 64-разрядные операционные системы:

-   Windows Server 2003 с пакетом обновления 1
-   Windows XP Professional x64 Edition (доступно для изготовителей оборудования и для разработчиков с помощью MSDN)
-   Windows Vista
-   Windows Server 2008
-   Windows 7
-   Windows Server 2008 R2

> [!Note]  
> Windows Сервер 2008 R2 доступен только в виде 64-разрядного выпуска.

 

-   [Различия в адресации памяти](#differences-in-addressable-memory)
-   [Указание больших адресов при создании](#specifying-large-address-aware-when-building)
-   [Совместимость 32-разрядных приложений на 64-разрядных платформах](#compatibility-of-32-bit-applications-on-64-bit-platforms)
    -   [Потенциальные ошибки совместимости](#potential-compatibility-pitfalls)
-   [Перенос приложений на 64-разрядные платформы](#porting-applications-to-64-bit-platforms)
-   [Профилирование и оптимизация перенесенных приложений](#profiling-and-optimization-of-ported-applications)
-   [Управляемый код в 64-разрядной операционной системе](#managed-code-on-a-64-bit-operating-system)
-   [Влияние на производительность при выполнении 64-разрядной операционной системы](#performance-implications-of-running-a-64-bit-operating-system)
-   [Сводка](#summary)

## <a name="differences-in-addressable-memory"></a>Различия в адресации памяти

Первое, что большинство разработчиков заметит, это то, что 64-разрядные процессоры обеспечивают огромную LEAP в объеме физической и виртуальной памяти, которую можно решить.

-   32-разрядные приложения на 32-разрядных платформах могут иметь до 2 ГБ.
-   32-разрядные приложения, созданные с помощью флага компоновщика/LARGEADDRESSAWARE: YES в 32-bit Windows XP или Windows Server 2003 с помощью специальной функции загрузки/3gb, могут иметь до 3 гб. Это ограничивает ядро только 1 ГБ, что может привести к сбою некоторых драйверов и (или) служб.
-   32-разрядные приложения, созданные с помощью флага компоновщика/LARGEADDRESSAWARE: YES в 32-разрядных выпусках Windows Vista, Windows Server 2008 и Windows 7, могут обращаться к памяти вплоть до числа, указанного в элементе данных конфигурации загрузки (BCD) инкреасеусерва. инкреасеусерва может иметь значение от 2048 (по умолчанию) до 3072 (которое соответствует объему памяти, настроенному с помощью параметра/3gb boot в Windows XP). Оставшаяся часть 4 ГБ выделяется ядру и может привести к сбою конфигурации драйвера и службы.

    Дополнительные сведения о BCD см. в разделе [данные конфигурации загрузки](https://msdn.microsoft.com/library/aa362692.aspx) на сайте MSDN.

-   32-разрядные приложения на 64-разрядных платформах могут иметь до 2 ГБ или до 4 ГБ с флагом компоновщика/LARGEADDRESSAWARE: YES.
-   64-разрядные приложения используют 43 бит для адресации, что обеспечивает 8 ТБ виртуального адреса для приложений и 8 ТБ, зарезервированные для ядра.

Помимо всего памяти, в 64-разрядных приложениях, использующих операции ввода-вывода с отображением в памяти, значительно возрастает увеличение виртуального адресного пространства. 64-разрядная архитектура также улучшает производительность операций с плавающей запятой и ускоряет передачу параметров. 64-разрядные процессоры имеют удвоенное количество регистров, как для типов данных общего назначения и расширения потоковой передачи SIMD (SSE), так и для поддержки наборов инструкций SSE и SSE2. Многие 64-разрядные процессоры даже поддерживают наборы инструкций SSE3.

## <a name="specifying-large-address-aware-when-building"></a>Указание больших адресов при создании

При создании 32-разрядных приложений рекомендуется указывать большое количество адресов, используя флаг компоновщика/LARGEADDRESSAWARE, даже если приложение не предназначено для 64-разрядной платформы, из-за преимуществ, которые бесплатно предоставляются бесплатно. Как упоминалось ранее, включение этого флага для сборки позволяет 32-разрядной программе получить доступ к большему объему памяти с помощью специальных параметров загрузки в 32-разрядной ОС или в 64-разрядной ОС. Тем не менее, разработчики должны быть внимательны, чтобы предположения о указателе не были сделаны, например при условии, что в 32-разрядном указателе никогда не задана старшая разрядность. Как правило, рекомендуется включать флаг/LARGEADDRESSAWARE.

32-битовые приложения, поддерживающие большие адреса, могут определить во время выполнения, сколько всего виртуального адресного пространства доступно для них с текущей конфигурацией ОС путем вызова [**глобалмемористатусекс**](/windows/desktop/api/sysinfoapi/nf-sysinfoapi-globalmemorystatusex). Результат Уллтоталвиртуал будет в диапазоне от 2147352576 байт (2 ГБ) до 4294836224 байт (4 ГБ). Значения, превышающие 3221094400 (3 ГБ), можно получить только в 64-разрядных выпусках Windows. Например, если Инкреасеусерва имеет значение 2560, результатом будет Уллтоталвиртуал со значением 2684223488 байт.

## <a name="compatibility-of-32-bit-applications-on-64-bit-platforms"></a>Совместимость 32-разрядных приложений на 64-разрядных платформах

64-разрядные операционные системы Windows являются двоичными совместимыми с архитектурой IA32, и большинство интерфейсов api, используемых в 32-разрядных приложениях, доступны через Windows 32-bit на Windows 64-bit Emulator, WOW64. WOW64 гарантирует, что эти API будут работать должным образом.

WOW64 имеет слой выполнения, который обрабатывает маршалинг 32-разрядных данных. WOW64 перенаправляет запросы DLL-файлов, перенаправляет некоторые ветви реестра для 32-разрядных приложений и отражает некоторые ветви реестра для 32-и 64-разрядных приложений.

Дополнительные сведения о WOW64 можно найти в статье [сведения о реализации WOW64](/windows/desktop/WinProg64/wow64-implementation-details) на сайте MSDN. рекомендации по созданию приложений, работающих на платформе wow64, см. в разделе рекомендации [по использованию wow64](https://www.microsoft.com/whdc/system/platform/64bit/WoW64_bestprac.mspx) в центре разработчиков Windows оборудования.

### <a name="potential-compatibility-pitfalls"></a>Потенциальные ошибки совместимости

Большинство приложений, разработанных для 32-разрядной платформы, будут работать без проблем на 64-разрядной платформе. Некоторые приложения могут столкнуться с проблемами, которые могут включать в себя следующее:

-   все драйверы для 64-разрядных версий операционных систем Windows должны быть 64-разрядными версиями. Необходимость в новых 64-разрядных драйверах влияет на схемы защиты от копирования, основанные на старых драйверах. Обратите внимание, что для загрузки драйверов в режиме ядра необходимо, чтобы в 64-разрядных выWindows пусках были загружены подписи Authenticode.
-   64-разрядные процессы не могут загружать 32-разрядные библиотеки DLL, а 32-разрядные процессы не могут 64 загружать динамические DLL-библиотеки. Прежде чем продолжить разработку, разработчики должны убедиться, что доступны 64-разрядные версии сторонних библиотек DLL. если необходимо использовать 32-разрядную библиотеку DLL в 64-разрядном процессе, то можно использовать Windows взаимодействия между процессами (IPC). COM-компоненты также могут использовать необработанные серверы и выполнять маршалинг для взаимодействия между границами, но это может привести к снижению производительности.
-   Многие процессоры x64 также являются многоядерными процессорами, и разработчики должны протестировать, как это влияет на устаревшие приложения. Дополнительные сведения о многоядерных процессорах и последствиях для игровых приложений можно найти в области " [время игры" и в многоядерных процессорах](/windows/desktop/DxTechArts/game-timing-and-multicore-processors).
-   Приложения также должны вызывать [**шжетфолдерпас**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shgetfolderpatha) для обнаружения путей к файлам, так как некоторые имена папок изменились в некоторых случаях. Например, \_ программные файлы CSid \_ возвращают «C: \\ Program Files (x86)» для 32-разрядного приложения, работающего на 64-разрядной платформе вместо «C: \\ Program Files». Разработчики должны быть учитывать, как работают возможности перенаправления и отражения эмулятора WOW64.

Кроме того, разработчики должны быть осторожными с 16-разрядными программами, которые по-прежнему могут использоваться. Подсистема WOW64 не может работать с 16-разрядными приложениями; Сюда входят старые установщики и все программы MS-DOS.

> [!Note]  
> Наиболее распространенными проблемами совместимости являются установщики, выполняющие 16-разрядный код и не имеющие 64-разрядных драйверов для схем защиты копирования.

 

В следующем разделе обсуждаются вопросы, связанные с переносом кода в 64-разрядный машинный код для разработчиков, желающих обеспечить работу своих устаревших программ на 64-разрядных платформах. Он также предназначен для разработчиков, не знакомых с 64-разрядным программированием.

## <a name="porting-applications-to-64-bit-platforms"></a>Перенос приложений на 64-разрядные платформы

Наличие правильных средств и библиотек поможет упростить переход с 32-разр на 64-разрядную разработку. Пакет SDK для DirectX 9 содержит библиотеки для поддержки проектов на базе x86 и x64. Microsoft Visual Studio 2005 и Visual Studio 2008 поддерживают создание кода как для x86, так и для x64, и они поставляются с библиотеками, оптимизированными для создания кода x64. Тем не менее, он также понадобится разработчикам для распространения сред выполнения Visual C в своих приложениях. обратите внимание, что выпуски Express Visual Studio 2005 и Visual Studio 2008 не включают компилятор x64, но все эти выпуски Standard, Professional и Team System все делают.

Разработчики, предназначенные для 32-разрядных платформ, могут подготовиться к 64-разрядной разработке, чтобы упростить их переход на более поздние версии. При компиляции 32-разрядных проектов разработчики должны использовать флаг/Wp64, который приведет к созданию предупреждений о проблемах, влияющих на переносимость. Переключение на 64-разрядные средства и библиотеки, вероятно, повлечет за собой создание большого количества новых ошибок сборки. Поэтому рекомендуется переключить средства и библиотеки, не зависящие от разрядов, и устранить предупреждения перед переключением на 64-разрядную сборку.

Однако изменить средства, изменить библиотеки и использовать определенные флаги компилятора будет недостаточно. Предположения в стандартах кодирования должны быть переоценены, чтобы гарантировать, что текущие стандарты кодирования не допускают проблем переносимости. Проблемы переносимости могут включать усечение указателя, размер и выравнивание типов данных, зависимость от 32-разрядных библиотек DLL, использование устаревших API, код сборки и старые двоичные файлы.

> [!Note]  
> Visual C++ 2010 содержит заголовки stdint. h и cstdint C99, которые определяют стандартные типы переносимости Int32 \_ t, UInt32 \_ t, Int64 \_ t, UInt64 \_ t, IntPtr \_ t и UIntPtr \_ t. их использование вместе с \_ типами данных standard птрдифф t и size \_ t может быть рекомендуемое для типов Windows портабилти, используемых ниже для повышения переносимости кода.

 

Ниже перечислены основные проблемы, связанные с переносом.

<dl> <dt>

<span id="Pointer_Truncation"></span><span id="pointer_truncation"></span><span id="POINTER_TRUNCATION"></span>**Усечение указателя**
</dt> <dd>

Указатели — это 64 бит в 64-разрядной ОС, поэтому приведение указателей к другим типам данных может привести к усечению, а арифметические операции с указателями могут привести к повреждению. Использование флага/Wp64 обычно выдает предупреждение об этом типе проблемы, но при использовании типов с помощью полиморфизма (INT \_ ptr, DWORD \_ ptr, Size \_ T, uint \_ PTR и т. д.) при приведении типа указателей рекомендуется полностью избежать этой проблемы. Поскольку указатели являются 64-разрядными на новых платформах, разработчики должны проверить порядок указателей и типы данных в классах и структурах, чтобы уменьшить или исключить заполнение.

</dd> <dt>

<span id="Data_Types_and_Binary_Files"></span><span id="data_types_and_binary_files"></span><span id="DATA_TYPES_AND_BINARY_FILES"></span>**Типы данных и двоичные файлы**
</dt> <dd>

Хотя указатели увеличиваются с 32 бит на 64 на 64-разрядной платформе, другие типы данных нет. Типы данных с фиксированной точностью (DWORD32, DWORD64, INT32, INT64, LONG32, LONG64, UINT32 и UINT64) можно использовать в местах, где должен быть известен размер типа данных. Например, в структуре двоичного файла. Изменение размера указателя и выравнивания данных требует специальной обработки, чтобы обеспечить совместимость с 32-bit-to-64-разр. дополнительные сведения можно найти в [подготовности к 64-разрядной Windows: новые типы данных](/windows/desktop/WinProg64/the-new-data-types).

</dd> <dt>

<span id="Older_Win32_APIs_and_Data_Alignment"></span><span id="older_win32_apis_and_data_alignment"></span><span id="OLDER_WIN32_APIS_AND_DATA_ALIGNMENT"></span>**Старые API Win32 и выравнивание данных**
</dt> <dd>

Некоторые API-интерфейсы Win32 являются устаревшими и заменены более независимыми вызовами API, например Сетвиндовлонгптр вместо SetWindowLong.

Снижение производительности для неориентированных обращений больше на платформе x64, чем на платформе x86. \_ \_ Для определения сведений о выравнивании, которые могут использоваться непосредственно в коде, можно использовать тип выравнивания (t) и макросы смещения поля (t, Member). Правильное использование упомянутых выше макросов должно устранить потенциальные несогласованные штрафы в доступе.

дополнительные сведения о \_ макросе выравнивания типов, \_ макросе смещения поля и общей 64-разрядной информации о программировании можно найти в [64-бит Windows программировании: Советы миграции: дополнительные соображения](/windows/desktop/WinProg64/additional-considerations) и [подготовка к 64-bit Windows: правила использования указателей](/windows/desktop/WinProg64/rules-for-using-pointers).

</dd> <dt>

<span id="Assembly_Code"></span><span id="assembly_code"></span><span id="ASSEMBLY_CODE"></span>**Код сборки**
</dt> <dd>

Встроенный код ассемблера не поддерживается на 64-разрядных платформах и должен быть заменен. Изменения в архитектуре могли изменить узкие места приложений, а C/C++ или встроенные функции могут получить аналогичные результаты с кодом, который проще читать. Рекомендуется переключить весь код сборки на C или C++. Встроенные функции можно использовать вместо кода сборки, но их следует использовать только после полного профилирования и выполнения анализа.

X87, MMX и 3DNow! наборы инструкций не рекомендуются в 64-разрядных режимах. Наборы инструкций по-прежнему существуют для обеспечения обратной совместимости в 32-разрядном режиме. Однако, чтобы избежать проблем совместимости в будущем, не рекомендуется использовать их в текущих и будущих проектах.

</dd> <dt>

<span id="Deprecated_APIs"></span><span id="deprecated_apis"></span><span id="DEPRECATED_APIS"></span>**Устаревшие API**
</dt> <dd>

Некоторые старые API DirectX были удалены для 64-разрядных машинных приложений: DirectPlay 4 и более ранних версий, DirectDraw 6 и более ранних версий, Direct3D 8 и более ранних версий, Директинпут 7 и более ранних версий. Кроме того, основной API DirectMusic доступен для машинных 64-разрядных приложений, но уровень производительности и производитель DirectMusic являются устаревшими.

Visual Studio выдает предупреждения об устаревании, и эти изменения не являются проблемой для разработчиков, использующих новейшие api.

</dd> </dl>

## <a name="profiling-and-optimization-of-ported-applications"></a>Профилирование и оптимизация перенесенных приложений

Все разработчики должны повторно профилировать все приложения, перенесенные в новые архитектуры. Многие приложения, перенесенные на 64-разрядные платформы, имеют разные профили производительности из их 32-разрядных версий. Перед оценкой того, что необходимо оптимизировать, разработчикам необходимо выполнить 64-разрядные тесты производительности. Хорошая новость в этом заключается в том, что многие традиционные оптимизации работают на 64-разрядных платформах. Кроме того, 64-разрядные компиляторы также могут выполнять много операций оптимизации с правильным использованием флагов компилятора и подсказок кода.

Некоторые структуры могут иметь свои внутренние типы данных, переупорядоченные для экономии пространства памяти и улучшения кэширования. В некоторых случаях вместо полного 64-разрядного указателя можно использовать индексы массивов. Флаг/FP: Fast может улучшить оптимизацию и векторность с плавающей точкой. Использование \_ \_ restrict, declspec (restrict) и declspec (не псевдонима) может помочь компилятору разрешить псевдонимы и улучшить использование файла регистрации.

Дополнительные сведения о/FP: Fast можно найти в [/FP (укажите Floating-Point поведение)](/cpp/build/reference/fp-specify-floating-point-behavior).

Дополнительные сведения о \_ \_ ограничении можно найти в [модификаторах, специфичных для Майкрософт](/cpp/cpp/microsoft-specific-modifiers).

Дополнительные сведения о declspec (restrict) можно найти в статье [рекомендации по оптимизации](/cpp/build/optimization-best-practices).

Дополнительные сведения о declspec можно найти по адресу [ \_ \_ declspec (](https://msdn.microsoft.com/library/k649tyc7(VS.80).aspx)No Alias).

## <a name="managed-code-on-a-64-bit-operating-system"></a>Управляемый код в 64-разрядной операционной системе

Управляемый код используется многими разработчиками игр в цепочке инструментов, поэтому понимание того, как оно работает в 64-разрядной ОС, может быть полезным. Управляемый код — это нейтральный набор инструкций, поэтому при запуске управляемого приложения в 64-разрядной операционной системе среда CLR может запустить ее как 32-разрядный или 64-разрядный процесс. По умолчанию среда CLR запускает управляемые приложения как 64-разрядные, и они должны работать нормально, не выполняя никаких проблем. Однако если приложение зависит от библиотеки DLL, которая является собственной 32-разрядной, то при попытке вызвать эту БИБЛИОТЕКУ приложение завершится ошибкой. В 64-разрядном процессе требуется полностью 64-разрядный код, а 32-bit DLL не может быть вызван из 64-разрядного процесса. Лучшим долгосрочным решением является компиляция машинного кода как 64-bit, но вполне разумное решение краткосрочного решения — просто пометить управляемое приложение как x86 только с помощью флага сборки/Platform: x86.

## <a name="performance-implications-of-running-a-64-bit-operating-system"></a>Влияние на производительность при выполнении 64-разрядной операционной системы

Поскольку процессоры с архитектурой AMD64 и Intel 64 могут выполнять 32-разрядные инструкции изначально, они могут запускать 32-разрядные приложения на полной скорости, даже в 64-разрядной ОС. При вызове функций операционной системы существует некоторая плата за преобразование параметров между 32-разрядным и 64-битным, но эта стоимость обычно незначительна. Это означает, что при запуске 32-разрядных приложений в 64-разрядной ОС вы не сможете замедленовать.

При компиляции приложений как 64-разрядных, вычисления будут более сложными. В 64-разрядной программе используются 64-битовые указатели, и его инструкции немного увеличиваются, поэтому потребность в памяти немного увеличивается. Это может привести к незначительному снижению производительности. С другой стороны, наличие двух регистров и возможность выполнять 64-разрядные целочисленные вычисления в одной инструкции зачастую больше, чем компенсация. В итоге 64-разрядное приложение может работать немного медленнее, чем то же приложение, скомпилированное в 32-бит, но оно часто выполняется немного быстрее.

## <a name="summary"></a>Сводка

64-разрядные архитектуры позволяют разработчикам отправлять ограничения на внешний вид, звук и воспроизведение игр. Однако переход от 32-разрядного программирования к 64-разрядному программированию не является тривиальным. Понимание различий между ними и с помощью новейших средств позволяет упростить и ускорить переход на 64-разрядные платформы.

Дополнительные сведения о 64-разрядном программировании можно найти в [Visual C++ центре разработчиков: 64-разрядное программирование](https://msdn.microsoft.com/vstudio//aa336463.aspx).

 

 