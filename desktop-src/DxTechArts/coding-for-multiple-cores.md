---
title: Написание программного кода для многоядерных процессоров Xbox 360 и Windows
description: В этом разделе приводятся некоторые рекомендации по началу работы с многопоточным программированием.
ms.assetid: 661f13a6-c73d-8513-2bad-0ef9d1a361a0
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 75899dacdfba829fc1a83e9393e6aa58574c9f30
ms.sourcegitcommit: 89f99926f946dc6c5ea600fb7c41f6b19ceac516
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 10/21/2020
ms.locfileid: "104414113"
---
# <a name="coding-for-multicore-on-xbox-360-and-windows"></a>Написание программного кода для многоядерных процессоров Xbox 360 и Windows

В течение многих лет производительность процессоров увеличилась непрерывно, а игры и другие программы использовали преимущества этого увеличения мощности без необходимости делать ничего особенного.

Правила были изменены. Производительность однопроцессорных ядер теперь увеличивается очень медленно, если вообще. Однако вычислительные мощности, доступные на типичном компьютере или в консоли, продолжат расти. Разница заключается в том, что большая часть этого выигрыша в производительности теперь связана с наличием нескольких процессорных ядер на одном компьютере, часто в одной микросхеме. Процессор Xbox 360 имеет три ядра процессора на одной микросхеме, и примерно 70 процентов процессоров ПК, продаваемых в 2006, были многоядерными.

Увеличение доступной вычислительной мощности так же просто, как в прошлом, но теперь разработчикам приходится писать многопоточный код для использования этой мощности. Многопоточное программирование приносит новые задачи проектирования и программирования. В этом разделе приводятся некоторые рекомендации по началу работы с многопоточным программированием.

## <a name="the-importance-of-good-design"></a>Важность хорошего дизайна

Хорошая разработка многопоточной программы очень важна, но она может быть очень сложной. Если вы ударили переместить Основные игровые системы на разные потоки, скорее всего, вы обнаружите, что каждый поток тратит большую часть времени на работу других потоков. Этот тип проекта приводит к увеличению сложности и значительным усилиям по отладке, практически не повышая производительность.

Каждый раз, когда потоки должны синхронизировать или предоставлять общий доступ к данным, существует вероятность повреждения данных, затрат на синхронизацию, взаимоблокировок и сложности. Таким образом, многопоточной архитектуре необходимо четко документировать каждую синхронизацию и точку обмена данными, и она должна максимально сокращать такие моменты. Когда потоки должны обмениваться данными, усилия по написанию кода будут увеличиваться, что может снизить производительность, если она влияет на слишком большой объем исходного кода.

Простейшая цель проектирования многопоточности — разбить код на большие независимые части. Если вы затем сделаете эти части недоступными только несколько раз в кадре, вы увидите значительное ускорение от многопоточности, не источником значительного сложность.

## <a name="typical-threaded-tasks"></a>Типичные потоковые задачи

Некоторые типы задач проверены на податлива в отдельные потоки. Следующий список не является исчерпывающим, но должен дать некоторые идеи.

### <a name="rendering"></a>Отрисовка

Отрисовка, которая может включать в себя проход по графу сцены или, возможно, только вызов функций D3D — часто учетные записи для времени ЦП 50% или больше. Таким образом, перемещение визуализации в другой поток может иметь значительные преимущества. Поток обновления может заполнять некоторый буфер описания рендеринга, который поток отрисовки может обработать.

Поток обновления игры всегда находится в одном кадре впереди потока прорисовки, что означает, что он принимает два кадра перед отображением действий пользователя на экране. Хотя эта увеличенная задержка может быть проблемой, увеличение частоты кадров при разделении рабочей нагрузки обычно позволяет сохранить общую задержку.

В большинстве случаев все действия по отрисовке по-прежнему выполняются в одном потоке, но это другой поток из обновления игры.

\_МНОГОпотоковый флаг D3DCREATE иногда используется, чтобы разрешить отрисовку в одном потоке и создании ресурсов в других потоках. Этот флаг не учитывается на Xbox 360, и его следует избегать в Windows. В Windows указание этого флага приводит к тому, что D3D тратит значительное время на синхронизацию, что замедляет поток отрисовки.

### <a name="file-decompression"></a>Распаковка файлов

Время загрузки всегда слишком велико, и потоковая передача данных в память без влияния на частоту кадров может оказаться сложной задачей. Если все данные агрессивно сжимаются на диске, скорость передачи данных с жесткого диска или оптического диска скорее всего будет ограничивающим фактором. В однопотоковых процессорах обычно недостаточно процессорного времени для сжатия, чтобы помочь время загрузки. Однако в многопроцессорной системе распаковка файлов использует циклы ЦП, которые в противном случае были бы потеряны. Это увеличивает время загрузки и потоковую передачу. и экономит место на диске.

Не используйте распаковку файлов в качестве замены для обработки, которая должна выполняться во время рабочей среды. Например, если посвятить дополнительный поток синтаксическому анализу XML-данных во время загрузки уровня, многопоточность не используется для улучшения работы проигрывателя.

При использовании потока распаковки файлов следует по-прежнему использовать асинхронный файловый ввод-вывод и большие операции чтения, чтобы обеспечить максимальную эффективность чтения данных.

### <a name="graphics-fluff"></a>Графические проводимые самими

Существует множество графических изяществ, которые улучшают внешний вид игры, но не являются строго необходимыми. К ним относятся, например, создаваемые процедурные анимации в облаке, имитации ткани и волосы, процедурные волны, процедурные растительности, другие частицы или не игрового процесса физика.

Поскольку эти эффекты не влияют на игрового процесса, они не вызывают проблем с синхронизацией — они могут синхронизироваться с другими потоками один раз в кадре или реже. Кроме того, в играх для Windows эти эффекты могут увеличить ценность для игроков с многоядерными процессорами, в то время как на одноядерные компьютеры не указывается без предупреждения, что позволяет легко масштабироваться по широкому спектру возможностей.

### <a name="physics"></a>Физика

Физика часто не может быть помещена в отдельный поток для параллельного выполнения с обновлением игры, так как для игры обычно требуется немедленное вычисление результатов физических вычислений. Альтернативой многопоточности является запуск на нескольких процессорах. Хотя это можно сделать, это сложная задача, которая требует частого доступа к общим структурам данных. Если вы можете хранить физическую рабочую нагрузку достаточно мало, чтобы вместить основной поток, ваша работа будет более простой.

Доступны библиотеки, поддерживающие выполнение физических потоков в нескольких потоках. Однако это может привести к возникновению проблемы: Если в игре используется физика, используется много потоков, но в остальной части времени используется мало. Выполнение физикы в нескольких потоках потребует адресации таким образом, чтобы Рабочая нагрузка равномерно распределена по кадру. При написании многопоточного механизма обработки физических потоков необходимо уделить особое внимание всем структурам данных, точкам синхронизации и балансировке нагрузки.

## <a name="example-multithreaded-designs"></a>Примеры многопоточных проектов

Игры для Windows должны работать на компьютерах, имеющих разное количество ядер ЦП. Большинство игровых компьютеров по-прежнему имеют только одно ядро, хотя число 2-ядерных компьютеров быстро растет. Типичная игра для Windows может привести к нарушению рабочей нагрузки в одном потоке для обновления и отрисовки с дополнительными рабочими потоками для добавления дополнительных функциональных возможностей. Кроме того, может использоваться несколько фоновых потоков для выполнения файлового ввода-вывода и сети. На рис. 1 показаны потоки вместе с основными точками передачи данных.

**Рис. 1. Проектирование потоков в игре для Windows**

![Проектирование потоков в игре для Windows](images/coding-for-multiple-cores-1.gif)

Стандартная игра Xbox 360 может использовать дополнительные ресурсоемкие программные потоки, поэтому она может разбивать свою рабочую нагрузку на поток обновления, поток отрисовки и три рабочих потока, как показано на рис. 2.

**Рис. 2. Проектирование потоков в игре для Xbox 360**

![Проектирование потоков в игре для Xbox 360](images/coding-for-multiple-cores-2.gif)

За исключением файловых операций ввода-вывода и работы в сети, все эти задачи могут быть достаточно ресурсоемкими, чтобы использовать их в своем аппаратном потоке. Эти задачи также могут быть достаточно независимыми, чтобы их можно было выполнять для всего кадра без связи.

Поток обновления игры управляет входными данными контроллера, AI и физикой, а также подготавливает инструкции для других четырех потоков. Эти инструкции помещаются в буферы, принадлежащие потоку обновления игры, поэтому при создании инструкций не требуется синхронизация.

В конце кадра поток обновления игры передает буферы инструкций четырем другим потокам, а затем начинает работу над следующим кадром, заполняя другой набор буферов инструкций.

Так как потоки обновления и отрисовки работают в локкстеп друг с другом, их буферы обмена данными просто передаются двойным буфером: в любой момент времени поток обновления заполняет один буфер, а поток прорисовки считывается из другого.

Другие рабочие потоки не обязательно привязаны к частоте кадров. Распаковка фрагмента данных может занять гораздо меньше кадров или может занять много кадров. Даже имитация ткани и перекрестного выполнения может не требоваться в точности на частоте кадров, поскольку менее частые обновления могут быть вполне приемлемыми. Таким образом, этим трем потокам требуются разные структуры данных для взаимодействия с потоком обновления и потоком отрисовки. Каждому из них требуется очередь ввода, которая может содержать рабочие запросы, а потоку прорисовки необходима очередь данных, которая может содержать результаты, созданные потоками. В конце каждого кадра в потоке обновления будет добавлен блок рабочих запросов к очередям рабочих потоков. Добавление в список только один раз за кадр гарантирует, что поток обновления минимизирует нагрузку на синхронизацию. Каждый рабочий поток извлекает назначения из рабочей очереди так быстро, как это возможно, используя цикл, который выглядит примерно так:


```C++
for(;;)
{
    while( WorkQueueNotEmpty() )
    {
        RemoveWorkItemFromWorkQueue();
        ProcessWorkItem();
        PutResultInDataQueue();
    }
    WaitForSingleObject( hWorkSemaphore ); 
}
```



Так как данные переходят от потоков обновления к рабочим потокам, а затем к потоку прорисовки, перед выполнением некоторых действий на экране может быть задержка в трех или более кадрах. Однако при назначении задач, отчувствительных к задержке, рабочим потокам это не должно быть проблемой.

В качестве альтернативного проекта можно создать несколько рабочих потоков из одной рабочей очереди. Это обеспечит автоматическую балансировку нагрузки и сделает его более вероятной, чтобы все рабочие потоки оставались занятыми.

Поток обновления игры должен не дать слишком много усилий рабочим потокам, иначе рабочие очереди могут постоянно расти. Управление этим потоком обновлений зависит от того, какие задачи выполняет рабочий поток.

## <a name="simultaneous-multithreading-and-number-of-threads"></a>Одновременная многопоточность и количество потоков

Все потоки не создаются равными. Два аппаратных потока могут находиться на отдельных микросхемах, в одной микросхеме или даже в одном ядре. Наиболее важной конфигурацией для программистов игр является два аппаратных потока на одном ядре — Одновременная многопоточность (SMT) Hyper-Threading или технология технологии HT.

Потоки технологии SMT или HT совместно используют ресурсы ядра ЦП. Поскольку они совместно используют единицы выполнения, максимальное ускорение от выполнения двух потоков вместо одного обычно составляет 10 – 20 процентов, а не 100 процентов, которые возможны из двух независимых аппаратных потоков.

Более существенно, SMT или технологии HT используют совместное использование инструкций L1 и кэшей данных. Если шаблоны доступа к памяти несовместимы, они могут обеспечить борьба с кэшем и привести к большому количеству промахов в кэше. В худшем случае общая производительность ядра ЦП может фактически снижаться при выполнении второго потока. На Xbox 360 это довольно простая проблема. Конфигурация Xbox 360 известна — три ядра ЦП, каждый с двумя аппаратными потоками, и разработчики назначают свои программные потоки конкретным потокам ЦП и могут измерять, чтобы определить, дает ли их проектирование потоков дополнительные показатели производительности.

В Windows ситуация сложнее. Количество потоков и их конфигурация будет отличаться от компьютера к компьютеру, а определение конфигурации будет сложным. Функция [**жетлогикалпроцессоринформатион**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) предоставляет сведения о связи между различными аппаратными потоками, а эта функция доступна в Windows Vista, Windows 7 и Windows XP SP3. Таким образом, для того чтобы решить, сколько "реальных" потоков доступно, необходимо использовать инструкцию CPUID и алгоритмы, заданные корпорацией Intel и AMD. Дополнительные сведения см. в ссылках.

Пример Коредетектион в пакете SDK для DirectX содержит пример кода, который использует функцию [**жетлогикалпроцессоринформатион**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation) или CPUID для возврата ТОПОЛОГИИ ядра ЦП. Инструкция CPUID используется, если **жетлогикалпроцессоринформатион** не поддерживается на текущей платформе. Коредетектион можно найти в следующих расположениях:

<dl> <dt>

<span id="Source_"></span><span id="source_"></span><span id="SOURCE_"></span>Источника
</dt> <dd>

Корень пакета SDK для *DirectX* \\ Примеры \\ C++ \\ Разное \\ коредетектион

</dd> <dt>

<span id="Executable_"></span><span id="executable_"></span><span id="EXECUTABLE_"></span>Объектов
</dt> <dd>

Корень пакета SDK для *DirectX* \\ Примеры \\ для \\CoreDetection.exe "Прочие \\ ячейки C++ \\ "

</dd> </dl>

Самым надежным предположением является наличие только одного потока, интенсивно использующих ЦП, на ядро ЦП. Наличие большего количества потоков ЦП, чем ядер ЦП, не дает никаких преимуществ и приводит к дополнительным затратам и сложности дополнительных потоков.

## <a name="creating-threads"></a>Создание потоков

Создание потоков является довольно простой операцией, но существует множество потенциальных ошибок. В приведенном ниже коде показан правильный способ создания потока, ожидания его завершения и очистки.


```C++
const int stackSize = 65536;
HANDLE hThread = (HANDLE)_beginthreadex( 0, stackSize,
            ThreadFunction, 0, 0, 0 );
// Do work on main thread here.
// Wait for child thread to complete
WaitForSingleObject( hThread, INFINITE );
CloseHandle( hThread );

...

unsigned __stdcall ThreadFunction( void* data )
{
#if _XBOX_VER >= 200
    // On Xbox 360 you must explicitly assign
    // software threads to hardware threads.
    XSetThreadProcessor( GetCurrentThread(), 2 );
#endif
    // Do child thread work here.
    return 0;
}
```



При создании потока можно указать размер стека для дочернего потока или указать нуль, в этом случае дочерний поток будет наследовать размер стека родительского потока. В Xbox 360, где стеки полностью фиксируются при запуске потока, указание нуля может зарасходить значительный объем памяти, так как многим дочерним потокам не требуется такой же размер стека, как у родительского. На Xbox 360 также важно, чтобы размер стека был кратным 64-КБ.

Если для создания потоков используется функция [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) , то среда выполнения C/C++ (CRT) не будет правильно инициализирована в Windows. Вместо этого рекомендуется использовать функцию CRT [**\_ бегинсреадекс**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) .

Возвращаемое значение из [**CreateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createthread) или [**\_ бегинсреадекс**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx) является обработчиком потока. Этот поток можно использовать для ожидания завершения дочернего потока, что намного проще и гораздо эффективнее, чем циклический перебор в цикле проверки состояния потока. Чтобы дождаться завершения потока, просто вызовите [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) с помощью обработчика потока.

Ресурсы для потока не будут освобождены до тех пор, пока поток не завершится, а обработчик потока не будет закрыт. Поэтому важно закрыть обработчик потока с помощью [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) после завершения работы с ним. Если ожидается, что поток завершится с помощью [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), не закрывайте этот обработчик до тех пор, пока не завершится ожидание.

На Xbox 360 необходимо явным образом назначить программные потоки конкретному аппаратному потоку с помощью **кссетсреадпроцессор**. В противном случае все дочерние потоки будут оставаться в том же аппаратном потоке, что и родительский. В Windows можно использовать [**сетсреадаффинитимаск**](/windows/win32/api/winbase/nf-winbase-setthreadaffinitymask) для обеспечения строгого предложения операционной системе о том, на каких аппаратных потоках должен выполняться поток. Как правило, этот метод следует избегать в Windows, так как неизвестно, какие другие процессы могут быть запущены в системе. Обычно лучше позволить планировщику Windows назначать потоки в бездействующие аппаратные потоки.

Создание потоков является дорогостоящей операцией. Потоки должны создаваться и уничтожаться редко. Если вы не хотите часто создавать и уничтожать потоки, используйте пул потоков, ожидающих работы.

## <a name="synchronizing-threads"></a>Синхронизация потоков

Для совместной работы нескольких потоков необходимо иметь возможность синхронизировать потоки, передавать сообщения и запрашивать монопольный доступ к ресурсам. Windows и Xbox 360 поставляются с обширным набором примитивов синхронизации. Полные сведения об этих примитивах синхронизации см. в документации по платформе.

### <a name="exclusive-access"></a>Монопольный доступ

Распространенной потребностью является получение монопольного доступа к ресурсу, структуре данных или пути кода. Одним из вариантов получения монопольного доступа является мьютекс, в котором показано обычное использование.


```C++
// Initialize
HANDLE mutex = CreateMutex( 0, FALSE, 0 );

// Use
void ManipulateSharedData()
{
    WaitForSingleObject( mutex, INFINITE );
    // Manipulate stuff...
    ReleaseMutex( mutex );
}

// Destroy
CloseHandle( mutex );
The kernel guarantees that, for a particular mutex, only one thread at a time can 
acquire it.
The main disadvantage to mutexes is that they are relatively expensive to acquire 
and release. A faster alternative is a critical section.
// Initialize
CRITICAL_SECTION cs;
InitializeCriticalSection( &cs );

// Use
void ManipulateSharedData()
{
    EnterCriticalSection( &cs );
    // Manipulate stuff...
    LeaveCriticalSection( &cs );
}

// Destroy
DeleteCriticalSection( &cs );
```



Критические секции имеют схожую семантику для мьютексов, но их можно использовать для синхронизации только внутри процесса, а не между процессами. Их основное преимущество заключается в том, что они выполняются примерно в двадцать раз быстрее, чем мьютексы.

### <a name="events"></a>События

Если два потока (например, поток обновления и поток отрисовки) переходят на использование пары буферов описания рендеринга, им нужен способ указать, когда они выполняются с определенным буфером. Это можно сделать, связав событие (выделенное с помощью [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa)) с каждым буфером. Когда поток выполняется с помощью буфера, он может использовать [**выполнить SetEvent**](/windows/win32/api/synchapi/nf-synchapi-setevent) , чтобы сообщить об этом, а затем вызвать [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) для события другого буфера. Этот метод позволяет легко выполнить тройную буферизацию ресурсов.

### <a name="semaphores"></a>Семафоры

Семафор используется для управления количеством потоков, которые могут выполняться и обычно используются для реализации рабочих очередей. Один поток добавляет работу в очередь и использует [**ReleaseSemaphore**](/windows/win32/api/synchapi/nf-synchapi-releasesemaphore) каждый раз при добавлении нового элемента в очередь. Это позволяет освободить один рабочий поток из пула ожидающих потоков. Рабочие потоки просто вызывают [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject), и когда он возвращает данные о том, что в очереди есть рабочий элемент. Кроме того, для обеспечения безопасного доступа к общей рабочей очереди необходимо использовать критически важный раздел или другой метод синхронизации.

### <a name="avoid-suspendthread"></a>Избегайте Суспендсреад

Иногда, когда нужно, чтобы поток перестает работать, он может использовать [**суспендсреад**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-suspendthread) вместо правильных примитивов синхронизации. Это неплохое идея, и это может легко привести к взаимоблокировкам и другим проблемам. **Суспендсреад** также взаимодействует с отладчиком Visual Studio. Избегайте **суспендсреад**. Вместо этого используйте [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) .

### <a name="waitforsingleobject-and-waitformultipleobjects"></a>WaitForSingleObject и WaitForMultipleObjects

Функция [**WaitForSingleObject**](/windows/win32/api/synchapi/nf-synchapi-waitforsingleobject) — это наиболее часто используемая функция синхронизации. Однако иногда требуется, чтобы поток дождался одновременного выполнения нескольких условий или до тех пор, пока не будет удовлетворен один из наборов условий. В этом случае следует использовать [**WaitForMultipleObjects**](/windows/win32/api/synchapi/nf-synchapi-waitformultipleobjects).

### <a name="interlocked-functions-and-lockless-programming"></a>Блокируемые функции и программирование с блокировкой

Существует семейство функций для выполнения простых потокобезопасных операций без использования блокировок. Это семейство функций, блокируемых, например [**интерлоккединкремент**](/windows/win32/api/winnt/nf-winnt-interlockedincrement). Эти функции и другие методы, использующие тщательный выбор флагов, вместе называются программированием с поддержкой блокировок. Программирование без блокировок может быть очень сложным для правильной работы и существенно сложнее на Xbox 360, чем в Windows.

Дополнительные сведения о программировании без блокировок см. в разделе [рекомендации по программированию для Xbox 360 и Microsoft Windows](./lockless-programming.md).

### <a name="minimizing-synchronization"></a>Минимизация синхронизации

Некоторые методы синхронизации выполняются быстрее, чем другие. Однако вместо оптимизации кода путем выбора наиболее быстрых методик синхронизации обычно лучше синхронизироваться реже. Это быстрее, чем слишком частое выполнение синхронизации, и делает более простым код, который проще отлаживать.

Для правильной работы некоторых операций, таких как выделение памяти, может потребоваться использовать примитивы синхронизации. Таким образом, частое выделение памяти из общей кучи по умолчанию приведет к частым операциям синхронизации, что приведет к неэффективному снижению производительности. Предотвращение частого выделения памяти или использования куч для каждого потока (использование КУЧИ \_ без \_ сериализации при использовании хеапкреате) может избежать этой скрытой синхронизации.

Другая причина скрытой синхронизации — D3DCREATE \_ многопоточность, что приводит к тому, что D3D в Windows будет использовать синхронизацию во многих операциях. (Этот флаг игнорируется на Xbox 360.)

Данные по потокам, также известные как локальное хранилище потока, могут быть важным способом предотвращения синхронизации. Visual C++ позволяет объявлять глобальные переменные в качестве отдельных потоков с помощью синтаксиса **\_ \_ declspec (thread)** .


```C++
__declspec( thread ) int tls_i = 1;
```



Это дает каждому потоку в процессе обработки собственную копию TLS \_ i, на которую можно ссылаться безопасно и эффективно, не требуя синхронизации.

Метод **\_ \_ declspec (thread)** не работает с динамически загружаемыми библиотеками DLL. При использовании динамически загружаемых библиотек DLL необходимо использовать семейство функций TLSAlloc для реализации локального хранилища потока.

## <a name="destroying-threads"></a>Уничтожение потоков

Единственным надежным способом уничтожения потока является то, что сам поток завершается, либо путем возвращения из основной функции потока, либо путем вызова потока [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread) или [**\_ ендсреадекс**](https://msdn.microsoft.com/library/hw264s73(v=VS.71).aspx). Если поток создается с помощью [**\_ бегинсреадекс**](https://msdn.microsoft.com/library/ms397047(v=VS.70).aspx), он должен использовать **\_ ендсреадекс** или возвращаться из основной функции потока, поскольку использование **ExitThread** не приведет к неправильному освобождению ресурсов CRT. Никогда не вызывайте функцию [**TerminateThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread) , так как поток не будет корректно очищен. Потоки всегда должны зафиксировать самоубийства — они никогда не должны быть мурдеред.

## <a name="openmp"></a>OpenMP

OpenMP — это расширение языка для добавления многопоточности в программу с помощью директив pragma для указания компилятора в параллелизации циклов. OpenMP поддерживается Visual C++ 2005 в Windows и Xbox 360. их можно использовать в сочетании с ручным управлением потоками. OpenMP может быть удобным способом потоковой работы с частями кода, но вряд ли будет идеальным решением, особенно для игр. OpenMP может быть более подходящим для более длительных рабочих задач, таких как обработка изображений и другие ресурсы. Дополнительные сведения см. в документации по Visual C++ или перейдите на [веб-сайт](https://www.openmp.org/)OpenMP.

## <a name="profiling"></a>Профилирование

Многопоточное профилирование имеет большое значение. Очень легко в итоге ожидать, когда потоки ожидают друг друга. Такие ожидания трудно найти и диагностировать. Чтобы определить их, рассмотрите возможность добавления инструментирования в вызовы синхронизации. Профилировщик с выборкой может также помочь определить эти проблемы, поскольку он может записывать сведения о времени, не внося существенного изменения.

## <a name="timing"></a>Временные свойства

Инструкция RDTSC является одним из способов получения точных сведений о времени в Windows. К сожалению, у RDTSC есть несколько проблем, которые делают его неудовлетворительным выбором для названия доставки. Счетчики RDTSC не обязательно синхронизируются между процессорами, поэтому при перемещении потока между аппаратными потоками вы можете получить большие положительные или отрицательные различия. В зависимости от параметров управления питанием частота, с которой увеличивается значение счетчика RDTSC, может также меняться во время выполнения игры. Во избежание этих трудностей следует предпочесть [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) и [**куериперформанцефрекуенци**](/windows/win32/api/profileapi/nf-profileapi-queryperformancefrequency) для высокой точности времени в игре, используемой для доставки. Дополнительные сведения о времени см. в разделе [время игры и многоядерные процессоры](./game-timing-and-multicore-processors.md).

## <a name="debugging"></a>Отладка

Visual Studio полностью поддерживает многопоточное отладку для Windows и Xbox 360. Окно потоков Visual Studio позволяет переключаться между потоками, чтобы видеть различные стеки вызовов и локальные переменные. Окно потоки также позволяет заморозить и разморозить определенные потоки.

На Xbox 360 можно использовать мета-переменную **\@ хвсреад** в окне контрольных значений для отображения аппаратного потока, в котором выполняется текущий выбранный программный поток.

Окно потоки проще использовать, если вы назначите имена потоков осмысленно. Visual Studio и другие отладчики Майкрософт позволяют присвоить имена потокам. Реализуйте следующую функцию **сетсреаднаме** и вызывайте ее из каждого потока при запуске.


```C++
typedef struct tagTHREADNAME_INFO
{
    DWORD dwType;     // must be 0x1000
    LPCSTR szName;    // pointer to name (in user address space)
    DWORD dwThreadID; // thread ID (-1 = caller thread)
    DWORD dwFlags;    // reserved for future use, must be zero
} THREADNAME_INFO;

void SetThreadName( DWORD dwThreadID, LPCSTR szThreadName )
{
    THREADNAME_INFO info;
    info.dwType = 0x1000;
    info.szName = szThreadName;
    info.dwThreadID = dwThreadID;
    info.dwFlags = 0;

    __try
    {
        RaiseException( 0x406D1388, 0,
                    sizeof(info) / sizeof(DWORD),
            (DWORD*)&info );
    }
    __except( EXCEPTION_CONTINUE_EXECUTION ) {
    }
}

// Example usage:
SetThreadName(-1, "Main thread");
```



Отладчик ядра (KD) и WinDBG также поддерживают многопоточность отладки.

## <a name="testing"></a>Тестирование

Многопоточное программирование может быть непростой задачей, а некоторые многопоточные ошибки отображаются лишь редко, что затрудняет их поиск и исправление. Одним из лучших способов их очистки является тестирование на широком спектре компьютеров, особенно с четырьмя или более процессорами. Многопоточный код, который прекрасно работает на однопотоковых компьютерах, может мгновенно завершиться сбоем на компьютере с четырьмя процессорами. Характеристики производительности и времени ЦП процессоров AMD и Intel могут значительно различаться, поэтому обязательно протестируйте многопроцессорные компьютеры на основе ЦП обоих поставщиков.

## <a name="windows-vista-and-windows-7-improvements"></a>Улучшения в Windows Vista и Windows 7

Для игр, предназначенных для более новых версий Windows, существует ряд интерфейсов API, которые могут упростить создание масштабируемых многопоточных приложений. Это особенно справедливо при использовании нового API ThreadPool и некоторых дополнительных примитивов синкрхонзиатион (переменных условия, упрощенной блокировки чтения-записи и однократной инициализации). Обзор этих технологий можно найти в следующих статьях MSDN Magazine:

-   [Повышение масштабируемости с помощью новых API пула потоков](/archive/msdn-magazine/2007/october/pooled-threads-improve-scalability-with-new-thread-pool-apis)
-   [Новые примитивы синхронизации в Windows Vista](/archive/msdn-magazine/2007/june/concurrency-synchronization-primitives-new-to-windows-vista)

Приложения, использующие [функции Direct3D 11](../direct3d11/direct3d-11-features.md) в этих операционных системах, также могут воспользоваться преимуществами новой конструкции для параллельного создания объектов и списков отложенных контекстных команд для повышения масштабируемости при многопоточной отрисовке.

## <a name="summary"></a>Сводка

При тщательном проектировании, позволяющем избежать взаимодействий между потоками, можно получить значительный выигрыш в производительности от многопоточного программирования, не требуя чрезмерной сложности кода. Это позволит вашему программному коду переключить следующую партию усовершенствований процессора и предоставить вам более привлекательные игровые возможности.

## <a name="references"></a>Ссылки

-   Джим Беверидже & Роберт Веинер, *многопоточное приложение в Win32*, Addison-Wesley, 1997
-   Чак Валбаурн, [время игры и многоядерные процессоры](./game-timing-and-multicore-processors.md), корпорация майкрософт, 2005
-   Библиотека MSDN: [ **жетлогикалпроцессоринформатион**](/windows/win32/api/sysinfoapi/nf-sysinfoapi-getlogicalprocessorinformation)
-   [OpenMP](https://www.openmp.org/)

 

 