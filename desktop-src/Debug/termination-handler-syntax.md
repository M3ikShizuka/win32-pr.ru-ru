---
description: '\_ \_ \_ \_ Ключевые слова try и finally используются для создания обработчика завершения. В следующем примере показана структура обработчика завершения.'
ms.assetid: fbaf8890-2516-4b60-be57-464f91f2a38a
title: Синтаксис Termination-Handler
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bcbf2656636490738a292c274a3e3184a34c0f94
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "105655869"
---
# <a name="termination-handler-syntax"></a>Синтаксис Termination-Handler

Ключевые слова **\_ \_ try** и **\_ \_ finally** используются для создания обработчика завершения. В следующем примере показана структура обработчика завершения.


```C++
__try 
{ 
    // guarded body of code 
 
} 
__finally 
{ 
    // __finally block 
 
}
```



Примеры см. в разделе [использование обработчика завершения](using-a-termination-handler.md).

Как и в случае с обработчиком исключений, блок **\_ \_ try** и блок **\_ \_ finally** должны заключаться в фигурные скобки ( {} ), и использование оператора **goto** для перехода в любой блок не допускается.

Блок **\_ \_ try** содержит защищенный текст кода, защищенного обработчиком завершения. Функция может иметь любое количество обработчиков завершения, и эти блоки обработки завершения могут быть вложены в одну и ту же функцию или в разные функции.

Блок **\_ \_ finally** выполняется каждый раз, когда поток управления покидает блок **\_ \_ try** . Однако блок **\_ \_ finally** не выполняется при вызове любой из следующих функций в блоке **\_ \_ try** : [**ExitProcess**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitprocess), [**ExitThread**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-exitthread)или **Abort**.

Блок **\_ \_ finally** выполняется в контексте функции, в которой находится обработчик завершения. Это означает, что блок **\_ \_ finally** может обращаться к локальным переменным этой функции. Выполнение блока **\_ \_ finally** может завершиться любым из следующих способов.

-   Выполнение последнего оператора в блоке и продолжение до следующей инструкции
-   Использование оператора Control (**return**, **break**, **Continue** или **goto**)
-   Использование **longjmp** или переход к обработчику исключений

Если выполнение блока **\_ \_ try** завершается из-за исключения, вызывающего блок обработки исключений обработчика исключений на основе кадров, блок **\_ \_ finally** выполняется перед выполнением блока обработки исключений. Аналогичным образом, вызов функции библиотеки времени выполнения C **longjmp** из блока **\_ \_ try** приводит к тому, что выполнение блока **\_ \_ finally** до возобновления выполнения на целевом объекте операции **longjmp** . Если выполнение блока **\_ \_ try** завершается из-за оператора управления (**return**, **break**, **Continue** или **goto**), выполняется блок **\_ \_ finally** .

Функция [**абнормалтерминатион**](abnormaltermination.md) может использоваться в блоке **\_ \_ finally** для определения того, был ли блок **\_ \_ try** завершен последовательно, то есть вне зависимости от того, достигнут ли он закрывающей фигурной скобкой (}). Выход из блока **\_ \_ try** из-за вызова **longjmp**, перехода к обработчику исключений или оператору **return**, **break**, **Continue** или **goto** считается аномальным завершением. Обратите внимание, что неуспешное завершение последовательно приводит к тому, что система ищет все кадры стека в порядке, чтобы определить, должны ли быть вызваны какие-либо обработчики завершения. Это может привести к снижению производительности из-за выполнения сотен инструкций.

Чтобы избежать аварийного завершения обработчика завершения, выполнение продолжается до конца блока. Можно также выполнить инструкцию **\_ \_ Leave** . Оператор **\_ \_ Leave** позволяет немедленно завершить блок **\_ \_ try** , не вызывая аварийного завершения и снижения его производительности. Чтобы определить, поддерживается ли оператор **\_ \_ Leave** , проверьте документацию по компилятору.

Если выполнение блока **\_ \_ finally** завершается из-за инструкции **return** Control, то оно эквивалентно **переходу** на закрывающую фигурную скобку во включающей функции. Поэтому функция, включающая функцию, будет возвращать значение.

 

 
