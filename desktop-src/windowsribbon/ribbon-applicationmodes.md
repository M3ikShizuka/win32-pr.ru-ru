---
title: Перенастройка ленты с помощью режимов приложения
description: платформа Windows ribbon поддерживает динамическую перенастройку и предоставление основных элементов пользовательского интерфейса ribbon во время выполнения на основе состояния приложения (также называемого контекстом).
ms.assetid: 8e9d85c5-33e4-4212-b9e4-2fc3b492c273
keywords:
- Windows Лента, повторная настройка с использованием режимов приложения
- Лента, повторная настройка с использованием режимов приложения
- повторная настройка ленты Windows с режимами приложения
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 83d206c238e6fe7463562077daaa52a5522a79d9
ms.sourcegitcommit: d75fc10b9f0825bbe5ce5045c90d4045e3c53243
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/13/2021
ms.locfileid: "127247504"
---
# <a name="reconfiguring-the-ribbon-with-application-modes"></a>Перенастройка ленты с помощью режимов приложения

платформа Windows ribbon поддерживает динамическую перенастройку и предоставление основных элементов пользовательского интерфейса ribbon во время выполнения на основе состояния приложения (также называемого контекстом). Объявления и связанные с определенными элементами в разметке, различные состояния, поддерживаемые приложением, называются режимами приложения.

-   [Введение](#introduction)
-   [Контекстный пользовательский интерфейс](#contextual-user-interface)
    -   [Простой сценарий режима приложения](#a-simple-application-mode-scenario)
-   [Реализация режимов приложения](#implementing-application-modes)
    -   [Идентифицируйте режимы](#identify-the-modes)
    -   [Назначение элементов управления режимам приложений](#assign-controls-to-application-modes)
    -   [Переключение режимов во время выполнения](#switch-modes-at-runtime)
-   [Замечания](#remarks)
-   [Связанные темы](#related-topics)

## <a name="introduction"></a>Введение

Режимы приложений состоят из логических групп элементов управления, предоставляющих некоторые основные функциональные возможности приложений в пользовательском интерфейсе Ribbon. Эти режимы динамически включаются или отключаются приложением с помощью вызова метода Framework [**иуифрамеворк:: сетмодес**](/windows/desktop/api/uiribbon/nf-uiribbon-iuiframework-setmodes), который включает или выключает видимость одного или нескольких режимов приложения.

## <a name="contextual-user-interface"></a>Контекстный пользовательский интерфейс

Платформа Ribbon обеспечивает широкие возможности взаимодействия с пользователем, включая динамические элементы управления, которые легко реагируют на взаимодействие с пользователем и контекст приложения. Этот богатый контекстный пользовательский интерфейс доставляется с помощью сочетания следующих механизмов:

-   Коллекции элементов управления, которые поддерживают динамическую обработку коллекций элементов.
-   Контекстные вкладки — вкладки ленты, видимость которых определяется изменением контекста рабочей области, например выбором изображения в документе.
-   Режимы приложений — основные функциональные возможности приложения, зависящие от контекста приложения.

В некоторых отношениях режимы приложения функционально похожи на контекстные вкладки. Однако фундаментальное различие заключается в намерениях и области каждого из них.

Контекстные элементы управления активируются в ответ на изменение контекста в приложении. например, в Microsoft Paint для Windows 7 отображается контекстная вкладка, содержащая группы команд, связанных с текстом, когда пользователь вставляет текстовую область в рабочую область. Эта контекстная вкладка не содержит основных команд для приложения и предоставляется только в пользовательском интерфейсе, так как контекст *в* приложении изменился. Основные функциональные возможности приложения (команды редактирования изображений) по-прежнему связаны и доступны пользователю, даже если отображается контекстная вкладка.

Режимы приложений отличаются от контекстных элементов управления тем, что они перестраивают функциональность в ответ на изменения в контексте, в котором работает приложение. Режимы приложений располагаются на более высоком уровне абстракции; они предоставляют способ перенастройки основных функций приложения вместо временного предоставления функциональных возможностей, которые не являются основными компонентами пользовательского интерфейса. например, в Microsoft Paint для Windows 7 параметр в режиме приложения происходит при вызове команды **предварительного просмотра** . когда Microsoft Paint переключается в режим **предварительного просмотра**, контекст, в котором приложение работает, изменяется в результате редактирования. В результате основные функциональные возможности приложения меняются до тех пор, пока **Предварительный просмотр** не будет отменен и приложение снова войдет в контекст редактирования.

### <a name="a-simple-application-mode-scenario"></a>Простой сценарий режима приложения

В следующем сценарии показано использование режимов приложения в приложении с именем Риббонапп для предоставления дискретных аспектов основных функциональных возможностей.

В Риббонапп определены два режима приложений:

-   **Простой** режим предоставляет основные команды в пользовательском интерфейсе ленты. Эти команды отображаются всегда, независимо от того, какой режим приложения активен.
-   **Расширенный** режим предоставляет сложные команды, предназначенные для опытных пользователей приложения. Эти расширенные команды отображаются в пользовательском интерфейсе ленты в дополнение к простым командам.

По умолчанию Риббонапп имеет значение открыть в **простом** режиме, а команды, необходимые начинающим пользователям, отображаются в **меню приложение** и на вкладке **Главная** . На следующем снимке экрана показано **меню приложения** риббонапп и вкладка **Главная** в **простом** режиме, в которых выделяются модальные элементы управления.

![снимок экрана, на котором показана вкладка для режима простого приложения.](images/overviews/appmode-hometab.png)![снимок экрана, показывающий меню приложения для режима простого приложения.](images/overviews/appmode-simpleappmenu.png)

Хотя эти команды могут быть достаточными для начинающих пользователей, Риббонапп также поддерживает опытных пользователей в **расширенном** режиме, что при активации с помощью кнопки **переключиться на расширенный режим** в **меню приложение** отображаются дополнительные основные функциональные возможности.

Этот сценарий легко реализовать путем привязки различных элементов в разметке к дискретным режимам приложений, которые могут быть включены и отключены по мере необходимости. На следующих снимках экрана показано **меню приложения** риббонапп и вкладка **Главная** в **расширенном** режиме, в которых выделяются модальные элементы управления.

![снимок экрана, на котором показана вкладка для расширенного режима приложения.](images/overviews/appmode-advancedtab.png)![снимок экрана с меню приложения для режима расширенного приложения.](images/overviews/appmode-advancedappmenu.png)

## <a name="implementing-application-modes"></a>Реализация режимов приложения

В этом разделе описаны три действия, которые обычно необходимы для реализации режимов работы платформы ленты. Риббонапп используется для предоставления примера для каждого шага.

### <a name="identify-the-modes"></a>Идентифицируйте режимы

Каждый режим в приложении должен представлять собой логический набор функциональных возможностей, которые зависят от контекста, в котором приложение может выполнять работу. Например, если приложение отображает элементы управления, которые имеют смысл только при обнаружении сетевого подключения, эти элементы управления работают в контексте сети, который может по высоте создавать **сетевой** режим.

Риббонапп имеет два контекста, которые могут быть активными в любое заданное время: **Simple** и **Advanced**. Поэтому для Риббонапп требуется два режима: **простой** и **Расширенный**.

### <a name="assign-controls-to-application-modes"></a>Назначение элементов управления режимам приложений

После определения режимов приложения присвойте каждому элементу управления Ribbon режим, объявляя атрибут *аппликатионмодес* в разметке для элементов управления, поддерживающих режимы приложений.

Представление ленты позволяет задавать режимы для следующих элементов управления:

-   Основные элементы [**вкладки**](windowsribbon-element-tab.md) .
-   Элементы [**группы**](windowsribbon-element-group.md) , являющиеся дочерними элементами базового элемента [**вкладки**](windowsribbon-element-tab.md) .
-   Элементы [**Button**](windowsribbon-element-button.md), [**SplitButton**](windowsribbon-element-splitbutton.md)и [**DropDownButton**](windowsribbon-element-dropdownbutton.md) , назначенные элементу [**менуграуп**](windowsribbon-element-menugroup.md) в [меню приложения](windowsribbon-controls-applicationmenu.md).
    > [!Note]  
    > Элементы [**Button**](windowsribbon-element-button.md), [**SplitButton**](windowsribbon-element-splitbutton.md)и [**DropDownButton**](windowsribbon-element-dropdownbutton.md) не могут быть назначены в режиме, если они не размещены в [меню приложения](windowsribbon-controls-applicationmenu.md).

     

В платформе Ribbon эти элементы управления называются модальными элементами управления. Они отображаются, только если в пользовательском интерфейсе активен режим, к которому они привязаны.

Элементы управления, содержащиеся в модальном элементе управления, наследуют поведение режима приложения. Например, если модальный элемент управления [**группы**](windowsribbon-element-group.md) назначен **расширенному** режиму, а **Расширенный** режим неактивен, то эта **Группа** и все элементы управления в ней, модальные или другие, не будут отображаться в ленте.

При использовании атрибута *аппликатионмодес* режимы присваиваются модальным элементам управления в связи 1: N (один ко многим), где один модальный элемент управления может быть связан с несколькими режимами.

Платформа ленты относится к режимам с цифрами от 0 до 31. режим 0 считался режимом по умолчанию, который автоматически активируется при запуске приложения Ribbon. Любой модальный элемент управления, не указывающий атрибут *аппликатионмодес* , считается членом режима по умолчанию.

В Риббонапп используется режим по умолчанию с **расширенными** функциями режима **, который отображается** только в том случае, если он инициирован пользователем.

В следующем примере показана разметка, необходимая для Риббонапп.


```C++
<Application.Views>
  <Ribbon>

    <!--Application Menu-->
    <Ribbon.ApplicationMenu>
      <ApplicationMenu CommandName='cmdAppMenu'>                    
        <MenuGroup>
          <Button CommandName='cmdSave'/>                        
          <Button CommandName='cmdExportMetadata' ApplicationModes='1'/>                   
        </MenuGroup>              
        <MenuGroup>
          <Button CommandName='cmdSwitchModes' ApplicationModes ='0,1'/>
          <Button CommandName='cmdExit'/>
        </MenuGroup>
      </ApplicationMenu>
    </Ribbon.ApplicationMenu>
            
    <!--Tabs-->
    <Ribbon.Tabs>
      <!--Home Tab-->
      <Tab CommandName='cmdHomeTab'>
                    
        <!--Scaling Policy for Home tab-->
        <Tab.ScalingPolicy>
          <ScalingPolicy>
            <ScalingPolicy.IdealSizes>
              <Scale Group='cmdSimpleControlsGroup' Size='Medium'/>                                
            </ScalingPolicy.IdealSizes>                     
          </ScalingPolicy>
        </Tab.ScalingPolicy>     
                    
        <!--Simple Controls Group-->
        <Group CommandName='cmdSimpleControlsGroup' SizeDefinition='ThreeButtons-OneBigAndTwoSmall'>                        
          <Button CommandName="cmdPaste" />
          <Button CommandName='cmdCut'/>                        
          <Button CommandName='cmdCopy'/>                        
        </Group>
      </Tab>
                
      <!--Advanced Tab-->
      <Tab CommandName='cmdAdvancedTab' ApplicationModes='1'>
        <!--Advanced Controls Group-->
        <Group CommandName='cmdMetadataGroup' ApplicationModes='1' SizeDefinition='TwoButtons'>
          <Button CommandName='cmdEditMetadata' />
          <Button CommandName='cmdCheckErrors' />
        </Group>
      </Tab>
    </Ribbon.Tabs>                   
                             
  </Ribbon>         
</Application.Views>
```



В этом примере показано следующее:

-   Режим по умолчанию 0 не требуется объявлять явным образом. Поскольку модальные элементы управления, не указывающие атрибут *аппликатионмодес* , автоматически привязываются к Mode 0 (**простой** режим в примере риббонапп), нет необходимости явно объявлять атрибут для модальных элементов управления по умолчанию.
-   Элементы управления могут быть привязаны к нескольким режимам. Для Риббонапп единственной потребностью в атрибуте *аппликатионмодес* в элементе управления **простого** режима является `cmdSwitchModes` кнопка, так как она является частью как **простых** , так и **расширенных** режимов. Если один из режимов активен, этот элемент управления появится в [меню приложение](windowsribbon-controls-applicationmenu.md).
-   Модальные элементы управления не наследуются от своих родителей. Вкладка **Дополнительно** в риббонапп содержит группу **метаданных** . Оба этих модальных элемента управления назначены режиму 1 (**Расширенный** режим). При назначении вкладки " **Дополнительно** " в режиме 1 дочерние элементы управления, такие как группа **метаданных** , не присваиваются автоматически в режиме 1. Это позволяет независимо включать или отключать любую группу на вкладке во время выполнения.
-   Немодальные элементы управления по-прежнему могут полагаться на переключения режима. Кнопки **изменить метаданные** и **проверить на ошибки** в риббонапп предназначены для опытных пользователей и доступны только в том случае, если пользователь переключается в **Расширенный** режим. Элементы управления "Кнопка", которые не размещаются в [меню приложения](windowsribbon-controls-applicationmenu.md) , не являются модальными; Однако поскольку эти кнопки размещаются внутри модального элемента управления (группы **метаданных** ), они отображаются, когда группа видима. Поэтому эти кнопки появляются при активации расширенного режима, а группа **метаданных** — в пользовательском интерфейсе ленты.

### <a name="switch-modes-at-runtime"></a>Переключение режимов во время выполнения

После определения режимов в разметке их можно легко включить или отключить в ответ на контекстные события. Как упоминалось ранее, приложения ленты всегда запускаются в режиме по умолчанию 0. После того как приложение инициализировано, а режим 0 активен, набор активных режимов можно изменить, вызвав функцию [**иуифрамеворк:: сетмодес**](/windows/desktop/api/uiribbon/nf-uiribbon-iuiframework-setmodes) . Эта функция принимает 32-разрядное целое число в качестве побитового представления режимов, которые должны быть активными; Наименьший значащий бит представляет режим 0, а наиболее значимый бит — режим 31. Если бит имеет значение 0, то этот режим неактивен в ИНТЕРФЕЙСе ленты.

В Риббонапп, когда пользователь включает **Расширенный** режим, расширенные команды отображаются рядом с простыми командами. Обработчик команд для кнопки " **переключиться на расширенный режим** " вызывает [**Иуифрамеворк:: сетмодес**](/windows/desktop/api/uiribbon/nf-uiribbon-iuiframework-setmodes) , чтобы установить режимы 0 (**простой**) и 1 (**Дополнительно**) в качестве активных в пользовательском интерфейсе. Ниже приведен пример кода Риббонапп для этого вызова функции:


```C++
const int SIMPLE_MODE = 0;
const int ADVANCED_MODE = 1;
pFramework->SetModes( UI_MAKEAPPMODE(SIMPLE_MODE) | UI_MAKEAPPMODE(ADVANCED_MODE) );
```



> [!Note]  
> Макрос макеаппмоде в пользовательском интерфейсе платформы Ribbon \_ упрощает задачу настройки этих битов при подготовке к вызову [**иуифрамеворк:: сетмодес**](/windows/desktop/api/uiribbon/nf-uiribbon-iuiframework-setmodes).

 

В этом примере показано следующее:

-   Используйте \_ макрос макеаппмоде пользовательского интерфейса для создания набора режимов.
-   Режимы задаются явным образом и атомарно. Целочисленное значение, передаваемое в [**иуифрамеворк:: сетмодес**](/windows/desktop/api/uiribbon/nf-uiribbon-iuiframework-setmodes) , представляет режимы, которые будут активны после возврата функции. Хотя **простой** режим был ранее активен, **Иуифрамеворк:: сетмодес** должен указывать, что **простой** режим остается активным при активации **расширенного** режима.
-   Режим по умолчанию можно удалить. Хотя в Риббонапп режим по умолчанию (Mode 0) никогда не удаляется, его можно удалить с помощью следующего вызова: `g_pFramework->SetModes(UI_MAKEAPPMODE(ADVANCED_MODE))` , предоставляя только расширенные команды в пользовательском интерфейсе.

> [!Note]  
> При перенастройке режимов приложения лента будет пытаться сохранить ранее выбранную вкладку в пользовательском интерфейсе. Если новый набор режимов больше не содержит вкладку, выбранную перед вызовом, лента выберет вкладку в макете, которая находится ближе всего к [меню приложения](windowsribbon-controls-applicationmenu.md). Эта вкладка предназначена для того, чтобы содержать команды, наиболее важные для пользователя. Дополнительные сведения см. в разделе [руководства пользователя ленты](https://msdn.microsoft.com/library/cc872782.aspx).

 

## <a name="remarks"></a>Remarks

На ленте должен быть хотя бы один активный режим. Если приложение пытается отключить все режимы путем вызова [**иуифрамеворк:: сетмодес**](/windows/desktop/api/uiribbon/nf-uiribbon-iuiframework-setmodes) с нулевым значением режима, возвращается ошибка E, \_ а активный режим остается неизменным.

Для платформы требуется, чтобы в пользовательском интерфейсе ленты существовала хотя бы одна вкладка. В результате должна существовать хотя бы одна вкладка, предоставляемая режимом по умолчанию (Mode 0) и после каждого переключения режима.

В режимах приложения влияют не все области пользовательского интерфейса. Например, если отключение режима приводит к удалению кнопок с ленты, которые ранее были добавлены на [панель быстрого доступа](windowsribbon-controls-quickaccesstoolbar.md), эти кнопки остаются на панели быстрого доступа, что позволяет пользователям выполнять команды, привязанные к кнопкам. Как правило, если команда принадлежит одному или нескольким неактивным режимам, эту команду также следует отключить, установив свойство [UI \_ PKEY \_ Enabled](windowsribbon-reference-properties-uipkey-enabled.md) в значение 0 (вариант \_ false).

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Рекомендации по работе пользователя с лентой](https://msdn.microsoft.com/library/cc872782.aspx)
</dt> <dt>

[Отображение контекстных вкладок](ribbon-contextualtabs.md)
</dt> </dl>

 

 