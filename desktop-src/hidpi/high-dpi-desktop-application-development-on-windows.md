---
title: Разработка приложений с высоким разрешением для настольных систем в Windows
description: Это содержимое предназначено для разработчиков, желающих обновить классические приложения для обработки динамического масштабирования экрана (то есть
ms.assetid: 6C419EEF-D898-4B50-8D16-E65A594487AA
ms.topic: article
ms.date: 05/31/2018
topic_type:
- kbArticle
api_name: ''
api_type: ''
api_location: ''
ms.openlocfilehash: 7af4a7a1d65077838dfa65f7cf89dee475a0b4dc
ms.sourcegitcommit: ae73f4dd3cf5a3c6a1ea7d191ca32a5b01f6686b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/08/2020
ms.locfileid: "104134719"
---
# <a name="high-dpi-desktop-application-development-on-windows"></a>Разработка приложений с высоким разрешением для настольных систем в Windows

Это содержимое предназначено для разработчиков, желающих обновлять настольные приложения с динамическим изменением масштаба отображения (в точках на дюйм или DPI), что позволяет приложениям быть четкими на отображаемых им дисплеях.

Для начала, если вы создаете новое приложение Windows с нуля, настоятельно рекомендуется создать приложение [универсальная платформа Windows (UWP)](/windows/uwp/get-started/whats-a-uwp) . Приложения UWP автоматически &mdash; и динамически &mdash; масштабируются для каждого дисплея, на котором они выполняются.

Классические приложения, использующие старые технологии программирования Windows (необработанное программирование Win32, Windows Forms, Windows Presentation Framework (WPF) и т. д.), не могут автоматически управлять масштабированием DPI без дополнительной работы разработчика. Без такой работы приложения будут выглядеть неразмытыми или неправильными по размеру во многих распространенных сценариях использования. Этот документ содержит контекст и сведения о том, что происходит при обновлении настольного приложения для корректной визуализации.

## <a name="display-scale-factor--dpi"></a>Коэффициент масштабирования экрана & DPI

По мере продвижения технологии экранов изготовитель панели монитора упаковывает увеличивающееся число пикселей в каждую единицу физического пространства на своих панелях. Это привело к тому, что количество точек на дюйм (DPI) современных панелей отображаются намного выше, чем в прошлом. В прошлом для большинства дисплеев было 96 пикселей на линейный дюйм физического пространства (96 точек на дюйм); в 2017 отображается с почти 300 DPI или выше.

В большинстве устаревших платформ пользовательского интерфейса имеются встроенные предположения о том, что отображаемое значение DPI не изменится в течение времени существования процесса.  Это предположение больше не имеет значения true, при этом dpi дисплея часто изменяется несколько раз в течение всего времени существования процесса приложения. Ниже приведены некоторые распространенные сценарии, в которых изменяется коэффициент масштабирования экрана или масштаб DPI.

-   Несколько мониторов настройки, в которых каждый дисплей имеет разный коэффициент масштабирования, и приложение перемещается из одного экрана в другое (например, 4 КБ и 1080p).
-   Закрепление и Отстыковка ноутбука с высоким DPI и внешним дисплеем с низким разрешением (или наоборот)
-   Подключение через удаленный рабочий стол с переносным компьютером с высоким разрешением или планшетом к устройству с низким разрешением (или наоборот)
-   Изменение параметров масштабирования экрана во время выполнения приложений

В этих сценариях приложения UWP автоматически перерисуются для новых точек на дюйм. По умолчанию, и без дополнительных действий разработчика, настольные приложения не работают. Настольные приложения, которые не выполняют эту лишнюю работу для реагирования на изменения DPI, могут выглядеть неразмытыми или неправильными по размеру пользователю.

## <a name="dpi-awareness-mode"></a>Режим поддержки DPI

Классические приложения должны сообщать Windows, если они поддерживают масштабирование DPI. По умолчанию система считает системные приложения неосведомленными и точечными рисунками, растягивает их окна. Установив один из следующих доступных режимов определения DPI, приложения могут явно указать Windows, как они хотят управлять масштабированием DPI:

### <a name="dpi-unaware"></a>Неосведомленность DPI

Независимые от DPI приложения отправляются по фиксированному значению DPI, равному 96 (100%). Когда эти приложения выполняются на экране с масштабом отображения более 96 DPI, Windows растягивает точечный рисунок приложения на ожидаемый физический размер. В результате приложение поменяет размытые.

### <a name="system-dpi-awareness"></a>Осведомленность о DPI системы

Настольные приложения, для которых учитывается контроль использования систем, обычно получают DPI основного подключенного монитора на момент входа пользователя. Во время инициализации они размечают пользовательский интерфейс соответствующим образом (размеры элементов управления, выбор размера шрифтов, загрузка ресурсов и т. д.), используя значение DPI системы. Таким образом, для приложений, поддерживающих DPI, масштабирование не масштабируется (точечный рисунок растягивается) в Windows при отображении с одним DPI. При перемещении приложения на дисплей с другим коэффициентом масштабирования или при изменении коэффициента масштабирования изображения Windows будет масштабировать окна приложения, делая их нечеткими. Фактически, системные приложения, поддерживающие DPI, разрабатываются только в одном масштабе экрана, поэтому при каждом изменении DPI становится размытым.

### <a name="per-monitor-and-per-monitor-v2-dpi-awareness"></a>Поддержка Per-Monitor и Per-Monitor (v2) DPI

Рекомендуется, чтобы настольные приложения были обновлены для использования режима отслеживания DPI для каждого монитора, что позволяет им правильно визуализироваться при изменении DPI. Когда приложение сообщает Windows, что оно требуется для работы в этом режиме, Windows не будет растягивать приложение при изменении DPI, вместо этого отправляя [WM \_ DPICHANGED](wm-dpichanged.md) в окно приложения. После этого выполняется полная ответственность приложения по изменению размера для нового DPI. Большинство платформ пользовательского интерфейса, используемых для классических приложений (общие элементы управления Windows (Comctl32), Windows Forms, Windows Presentation Framework и т. д.), не поддерживают автоматическое масштабирование DPI, поэтому разработчикам нужно изменять размер и расположение содержимого своих окон.

Существует две версии Per-Monitor осведомленности о том, что приложение может зарегистрировать себя как: версии 1 и версии 2 (PMv2). Регистрация процесса, выполняемого в режиме PMv2 осведомленности, приводит к следующим результатам:

1.  Приложение получает уведомления при изменении DPI (как для верхнего уровня, так и для дочернего HWND)
2.  Приложение видит необработанные пиксели каждого дисплея
3.  Приложение не масштабируется с помощью точечного рисунка Windows
4.  Автоматическая неклиентская область (заголовок окна, полосы прокрутки и т. д.) Масштабирование DPI по Windows
5.  Диалоговые окна Win32 (от [креатедиалог](/windows/desktop/api/winuser/nf-winuser-createdialogw)) автоматически масштабируются по Windows
6.  Графические ресурсы, отображаемые темой в стандартных элементах управления (флажки, фон кнопки и т. д.), автоматически подготавливаются в соответствии с коэффициентом масштабирования DPI.

При работе в режиме поддержки Per-Monitor v2 приложения уведомляются при изменении их DPI. Если приложение не изменяет размер для нового DPI, Пользовательский интерфейс приложения будет отображаться слишком маленьким или слишком большим (в зависимости от различий в предыдущем и новом значениях DPI).

> [!Note]  
> Поддержка Per-Monitor v1 (PMv1) очень ограничена. Рекомендуется, чтобы приложения использовали PMv2.

В следующей таблице показано, как приложения будут отображаться в различных сценариях.

<table>
<colgroup>
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
<col style="width: 25%" />
</colgroup>
<thead>
<tr class="header">
<th>Режим поддержки DPI</th>
<th>Появившаяся версия Windows</th>
<th>Представление DPI приложения</th>
<th>Поведение при изменении DPI</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Связан</td>
<td>Н/Д</td>
<td>Все дисплеи имеют 96 точек на дюйм.</td>
<td>Точечный рисунок-растяжение (размытые)</td>
</tr>
<tr class="even">
<td>Система</td>
<td>Vista</td>
<td>Все дисплеи имеют одинаковое разрешение DPI (DPI основного отображения на момент запуска текущего сеанса пользователя).</td>
<td>Точечный рисунок-растяжение (размытые)</td>
</tr>
<tr class="odd">
<td>Per-Monitor</td>
<td>8.1</td>
<td>DPI дисплея, на котором в основном находится окно приложения</td>
<td><ul>
<li>HWND верхнего уровня уведомляется об изменении DPI</li>
<li>Масштабирование элементов пользовательского интерфейса без разрешения.</li>
</ul>
<br/></td>
</tr>
<tr class="even">
<td>Per-Monitor V2</td>
<td>Обновление Windows 10 для дизайнеров (1703)</td>
<td>DPI дисплея, на котором в основном находится окно приложения</td>
<td><ul>
<li>Дескрипторы HWND верхнего уровня <span class="underline">и</span> дочерние окна получают уведомления об изменении dpi</li>
</ul>
<br/> <span class="underline">Автоматическое масштабирование в масштабе:</span>
<ul>
<li>Неклиентская область</li>
<li>Отображаемые в теме точечные рисунки в общих элементах управления (Comctl32 V6)</li>
<li>Диалоговые окна (<a href="/windows/desktop/api/winuser/nf-winuser-createdialogw">креатедиалог</a>)</li>
</ul>
<br/></td>
</tr>
</tbody>
</table>

### <a name="per-monitor-v1-dpi-awareness"></a>Отслеживание количества точек на дюйм (v1)

Режим поддержки Per-Monitor v1 DPI (PMv1) появился в Windows 8.1. Этот режим поддержки DPI очень ограничен и предлагает только перечисленные ниже функции. Рекомендуется, чтобы классические приложения использовали режим поддержки Per-Monitor v2, поддерживаемый в Windows 10 1703 или более поздней версии.

Начальная поддержка, предоставляемая для каждого монитора, предоставляет только следующие приложения:

1.  HWND верхнего уровня получают уведомления об изменении DPI и предоставили новый предлагаемый размер.
2.  Windows не будет растягивать пользовательский интерфейс приложения
3.  Приложение видит все экраны в физических точках (см. виртуализацию).

В Windows 10 1607 или более поздних версиях PMv1 приложения могут также вызвать [енабленонклиентдпискалинг](/windows/desktop/api/winuser/nf-winuser-enablenonclientdpiscaling) во время \_ работы WM нккреате, чтобы запросить правильное масштабирование Windows в неклиентской области окна.

## <a name="per-monitor-dpi-scaling-support-by-ui-framework--technology"></a>Поддержка масштабирования DPI на уровне по платформам и технологиям пользовательского интерфейса

В таблице ниже показан уровень поддержки DPI для каждого монитора, предлагаемый различными платформами пользовательского интерфейса Windows на основе Windows 10 1703:

<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
<col style="width: 20%" />
</colgroup>
<thead>
<tr class="header">
<th>Платформа и технология</th>
<th>Поддержка</th>
<th>Сценарий</th>
<th>Масштабирование DPI, обрабатываемое</th>
<th>Дополнительные материалы</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>Универсальная платформа Windows (UWP)</td>
<td>Полное</td>
<td>1607</td>
<td>Платформа пользовательского интерфейса</td>
<td><a href="/windows/uwp/get-started/whats-a-uwp">Универсальная платформа Windows (UWP)</a></td>
</tr>
<tr class="even">
<td>Необработанные элементы управления Win32/Common Controls V6 (comctl32.dll)</td>
<td><ul>
<li>Уведомления об изменении DPI, отправленные всем дескрипторам HWND</li>
<li>Графические ресурсы, рисуемые темами, правильно отображаются в общих элементах управления</li>
<li>Автоматическое масштабирование точек на дюйм для диалоговых окон</li>
</ul></td>
<td>1703</td>
<td>Приложение</td>
<td><a href="https://github.com/Microsoft/Windows-classic-samples/tree/master/Samples/DPIAwarenessPerWindow">Пример GitHub</a></td>
</tr>
<tr class="odd">
<td>Windows Forms</td>
<td>Для некоторых элементов управления ограничено автоматическое масштабирование DPI для каждого монитора</td>
<td>1703</td>
<td>Платформа пользовательского интерфейса</td>
<td><a href="/dotnet/framework/winforms/high-dpi-support-in-windows-forms">Поддержка высокого DPI в Windows Forms</a></td>
</tr>
<tr class="even">
<td>Windows Presentation Foundation (WPF)</td>
<td>В собственных приложениях WPF масштабирование WPF, размещенное в других платформах, и другие платформы, размещенные в WPF, не масштабируются автоматически</td>
<td>1607</td>
<td>Платформа пользовательского интерфейса</td>
<td><a href="https://github.com/Microsoft/WPF-Samples/tree/master/PerMonitorDPI">Пример GitHub</a></td>
</tr>
<tr class="odd">
<td>GDI</td>
<td>Нет</td>
<td>Н/Д</td>
<td>Приложение</td>
<td>См. раздел <a href="https://blogs.windows.com/buildingapps/2017/05/19/improving-high-dpi-experience-gdi-based-desktop-apps/">масштабирование с высоким разрешением GDI</a></td>
</tr>
<tr class="even">
<td>GDI+</td>
<td>Нет</td>
<td>Н/Д</td>
<td>Приложение</td>
<td>См. раздел <a href="https://blogs.windows.com/buildingapps/2017/05/19/improving-high-dpi-experience-gdi-based-desktop-apps/">масштабирование с высоким разрешением GDI</a></td>
</tr>
<tr class="odd">
<td>MFC</td>
<td>Нет</td>
<td>Н/Д</td>
<td>Приложение</td>
<td>Н/Д</td>
</tr>
</tbody>
</table>



 

## <a name="updating-existing-applications"></a>Обновление существующих приложений

Чтобы обновить существующее настольное приложение для правильной обработки масштабирования DPI, необходимо обновить таким образом, что, как минимум, важные части его пользовательского интерфейса обновляются для реагирования на изменения DPI.

Большинство настольных приложений выполняются в режиме поддержки DPI системы. Приложения, поддерживающие DPI, обычно масштабируются до точек на дюйм основного дисплея (экран, на котором была размещена системная область на момент запуска сеанса Windows). При изменении DPI Windows будет растягивать пользовательский интерфейс этих приложений, что часто приводит к неразмытости. При обновлении приложения, поддерживающего разрешение на уровне системы, для того, чтобы иметь возможность учитывать разрешение на контроль DPI, код, обрабатывающий макет пользовательского интерфейса, должен быть обновлен таким, что он выполняется не только во время инициализации приложения, но и при каждом получении уведомления об изменении DPI ([WM \_ DPICHANGED](wm-dpichanged.md) в случае Win32). Обычно это подразумевает повторное посещение любых допущений в коде, которые необходимо масштабировать в пользовательском интерфейсе только один раз.

Кроме того, в случае программирования на Win32 многие API-интерфейсы Win32 не имеют разрешения на разрешение или контекст отображения, поэтому они будут возвращать только значения, относящиеся к DPI системы. Можно использовать grep в коде для поиска некоторых из этих API и замены их вариантами, поддерживающими DPI. Ниже перечислены некоторые из распространенных API-интерфейсов с поддержкой DPI.



| Версия с одним DPI   | Версия Per-Monitor        |
|----------------------|----------------------------|
| жетсистемметрикс     | жетсистемметриксфордпи     |
| аджуствиндовректекс   | аджуствиндовректексфордпи   |
| системпараметерсинфо | системпараметерсинфофордпи |
| жетдпиформонитор     | жетдпифорвиндов            |



 

Также рекомендуется искать жестко закодированные размеры в базе кода, которые предполагают постоянное разрешение DPI, заменяя их кодом, который правильно задается для масштабирования DPI. Ниже приведен пример, включающий все эти рекомендации:

### <a name="example"></a>Пример.

В примере ниже показан упрощенный вариант Win32 для создания дочернего HWND. При вызове CreateWindow предполагается, что приложение выполняется в 96 DPI, и ни размер кнопки, ни ее расположение не будут правильными на более высоком DPI:


```
case WM_CREATE: 
{ 
    // Add a button 
    HWND hWndChild = CreateWindow(L"BUTTON", L"Click Me",  
        WS_CHILD|WS_VISIBLE|BS_PUSHBUTTON,  
        50,  
        50,  
        100,  
        50,  
        hWnd, (HMENU)NULL, NULL, NULL); 
} 
```



В обновленном коде показано следующее:

1.  Значение DPI для кода при создании окна. масштабирование расположения и размера дочернего HWND для DPI родительского окна
2.  Реагирование на изменение DPI путем изменения расположения и изменения размера дочернего HWND
3.  Жестко запрограммированные размеры удалены и заменены кодом, который реагирует на изменения DPI


```
#define INITIALX_96DPI 50 
#define INITIALY_96DPI 50 
#define INITIALWIDTH_96DPI 100 
#define INITIALHEIGHT_96DPI 50 
 
 
// DPI scale the position and size of the button control 
void UpdateButtonLayoutForDpi(HWND hWnd) 
{ 
    int iDpi = GetDpiForWindow(hWnd); 
    int dpiScaledX = MulDiv(INITIALX_96DPI, iDpi, 96); 
    int dpiScaledY = MulDiv(INITIALY_96DPI, iDpi, 96); 
    int dpiScaledWidth = MulDiv(INITIALWIDTH_96DPI, iDpi, 96); 
    int dpiScaledHeight = MulDiv(INITIALHEIGHT_96DPI, iDpi, 96); 
    SetWindowPos(hWnd, hWnd, dpiScaledX, dpiScaledY, dpiScaledWidth, dpiScaledHeight, SWP_NOZORDER | SWP_NOACTIVATE); 
} 
 
... 
 
case WM_CREATE: 
{ 
    // Add a button 
    HWND hWndChild = CreateWindow(L"BUTTON", L"Click Me",  
        WS_CHILD|WS_VISIBLE|BS_PUSHBUTTON, 
        0, 
        0, 
        0, 
        0, 
        hWnd, (HMENU)NULL, NULL, NULL); 
    if (hWndChild != NULL) 
    { 
        UpdateButtonLayoutForDpi(hWndChild); 
    } 
} 
break; 
 
case WM_DPICHANGED: 
{ 
    // Find the button and resize it 
    HWND hWndButton = FindWindowEx(hWnd, NULL, NULL, NULL); 
    if (hWndButton != NULL) 
    { 
        UpdateButtonLayoutForDpi(hWndButton); 
    } 
} 
break; 
```



При обновлении приложения, поддерживающего DPI, необходимо выполнить следующие общие действия.

1.  Пометьте процесс как учитывающий DPI для каждого монитора (v2) с помощью манифеста приложения (или другого метода в зависимости от используемых платформ пользовательского интерфейса).
2.  Сделать логику макета пользовательского интерфейса повторно используемой и переместить ее из кода инициализации приложения таким, что ее можно использовать повторно при изменении DPI (WM \_ DPICHANGED в случае программирования Windows (Win32)).
3.  Делает недействительным код, который предполагает, что данные, учитывающие значение DPI (DPI/шрифты/размер и т. д.), не нуждаются в обновлении. Очень часто рекомендуется кэшировать размеры шрифтов и значения DPI при инициализации процесса. При обновлении приложения для отслеживания DPI для каждого монитора данные, учитывающие DPI, необходимо переоценивать при каждом обнаружении нового DPI.
4.  Когда происходит изменение DPI, перезагрузите (или восстановите) все ресурсы растрового изображения для нового DPI или, при необходимости, растягивание выделенных ресурсов до нужного размера.
5.  Grep для API, которые не Per-Monitor учитывать DPI и заменяют Per-Monitor API-интерфейсами, поддерживающими DPI (где применимо). Пример. Замените Жетсистемметрикс на Жетсистемметриксфордпи.
6.  Протестируйте приложение в системе с множественным отображением или с несколькими DPI.
7.  Для всех окон верхнего уровня в приложении, которые не удается обновить до масштабного масштабирования, используйте масштабирование в смешанном режиме (как описано ниже), чтобы разрешить растягивание этих окон верхнего уровня системой.

## <a name="mixed-mode-dpi-scaling-sub-process-dpi-scaling"></a>Масштабирование Mixed-Mode DPI (масштабирование для дочерних процессов)

При обновлении приложения для поддержки отслеживания DPI на уровне отдельных мониторов иногда может стать непрактичным или невозможно обновить каждое окно в приложении в течение одного пути. Это может быть просто из-за времени и усилий, необходимых для обновления и тестирования любого пользовательского интерфейса, или потому, что вы не владеете кодом пользовательского интерфейса, который необходимо запустить (если приложение может загружать сторонний пользовательский интерфейс). В таких ситуациях Windows предлагает способ для упрощения поддержки каждого монитора, позволяя запускать некоторые из окон приложений (только на верхнем уровне) в первоначальном режиме с отслеживанием DPI, в то время как вы хотите сосредоточиться на времени и энергопотреблении, обновив более важные части пользовательского интерфейса.

Ниже показано, как это может выглядеть. вы обновляете пользовательский интерфейс основного приложения ("главное окно" на рисунке), чтобы запускать с отслеживанием DPI для каждого монитора во время работы других окон в существующем режиме ("дополнительное окно").

![различия в масштабировании dpi между режимами осведомленности](images/hub-page-illustrations.png)

До наступления годовщины Windows 10 (1607) режим поддержки DPI для процесса был свойством на уровне всего процесса. Начиная с годовщины Windows 10, это свойство теперь можно установить для каждого окна **верхнего уровня** . (**Дочерние** окна должны по-прежнему соответствовать размеру масштабирования своего родителя.) Окно верхнего уровня определяется как окно без родителя. Обычно это «обычное» окно с кнопками сворачивания, развертывания и закрытия. Сценарий, для которого предназначена подсистема отслеживания DPI, предназначен для того, чтобы использовать вторичный пользовательский интерфейс, масштабируемый по Windows (растянутый точечный рисунок), чтобы сосредоточиться на времени и ресурсах по обновлению основного пользовательского интерфейса.

Чтобы включить осведомленность о МАСШТАБе подпроцессов, вызовите [**сетсреаддпиаваренессконтекст**](/windows/desktop/api/Winuser/nf-winuser-setthreaddpiawarenesscontext) до и после любых вызовов создания окна. Созданное окно будет связано с осведомленностью о DPI, заданной с помощью Сетсреаддпиаваренессконтекст. Используйте второй вызов для восстановления сведений о текущем потоке DPI.

При использовании масштабирования с масштабированием подпроцессов можно полагаться на Windows для выполнения некоторых задач масштабирования DPI в приложении, что может повысить сложность приложения. Важно понимать недостатки этого подхода и природы сложностей, которые он представляет. Дополнительные сведения о поддержке дочерних процессов см. в разделе [масштабирование DPI в смешанном режиме и API с поддержкой точек на дюйм.](high-dpi-improvements-for-desktop-applications.md)

## <a name="testing-your-changes"></a>Тестирование изменений

После обновления приложения для обеспечения отслеживания DPI для каждого монитора важно убедиться, что приложение правильно отвечает на изменения DPI в среде со смешанным разрешением. Ниже приведены некоторые особенности тестирования.

1.  Перемещение окон приложений между дисплеями различных значений DPI
2.  Запуск приложения с отображением различных значений DPI
3.  Изменение коэффициента масштабирования для монитора во время работы приложения
4.  Изменение экрана, используемого в качестве основного дисплея, _выход из Windows_ и повторное тестирование приложения после повторного входа. Это особенно полезно при поиске кода, который использует жестко запрограммированные размеры и размеры.

## <a name="common-pitfalls-win32"></a>Распространенные ошибки (Win32)

**Не используйте предлагаемый прямоугольник, предоставленный в WM \_ DPICHANGED**

Когда Windows отправляет окно приложения в виде сообщения [**WM \_ DPICHANGED**](wm-dpichanged.md) , это сообщение содержит предлагаемый прямоугольник, который следует использовать для изменения размера окна. Очень важно, чтобы приложение использовало этот прямоугольник для изменения размера, как это будет:

1.  Убедитесь, что курсор мыши остается в той же относительной позиции в окне при перетаскивании между дисплеями
2.  Запрещает окну приложения переходить в цикл рекурсивного разрешения на изменение, при котором одно изменение DPI активирует последующее изменение DPI, которое активирует еще одно изменение DPI.

Если у вас есть требования для конкретного приложения, которые не позволяют использовать предлагаемый прямоугольник, предоставляемый Windows в \_ сообщении WM DPICHANGED, см. раздел [**WM \_ жетдпискаледсизе**](wm-getdpiscaledsize.md). Это сообщение можно использовать, чтобы дать Windows желаемый размер, который вы хотите использовать после изменения DPI, при этом устраняя проблемы, описанные выше.

**Нехватка документации по виртуализации**

Если HWND или процесс выполняется как не учитывающее DPI или учитывается DPI системы, это может быть растянутым изображением Windows. В этом случае Windows масштабирует и преобразует конфиденциальную информацию из некоторых API в пространство координат вызывающего потока. Например, если поток, не поддерживающий DPI, запрашивает размер экрана при выполнении на дисплее с высоким разрешением, Windows будет виртуализировать ответ, предоставленный приложению, как если бы экран находился в единицах с 96 DPI. Кроме того, если поток с поддержкой DPI в системе взаимодействует с дисплеем с отображением на разных точках на дюйм, чем при запуске текущего пользователя, Windows проведет масштабирование некоторых вызовов API в пространстве координат, которое будет использоваться HWND, если оно было запущено в исходном коэффициенте масштабирования DPI.

При правильном обновлении настольного приложения до масштаба DPI может быть трудно определить, какие вызовы API могут возвращать виртуализированные значения на основе контекста потока. Эта информация в настоящее время не предназначена для документирования корпорацией Майкрософт. Имейте в виду, что при вызове любого системного API из контекста потока, поддерживающего DPI или DPI, возвращаемое значение может быть виртуализированным. Таким образом, убедитесь, что ваш поток выполняется в контексте DPI, который вы ждете при взаимодействии с экраном или отдельными окнами. При временном изменении контекста DPI потока с помощью [сетсреаддпиаваренессконтекст](/windows/desktop/api/Winuser/nf-winuser-setthreaddpiawarenesscontext)обязательно восстановите старый контекст, чтобы избежать возникновения неправильного поведения в других приложениях.

**Многие API Windows не имеют контекста DPI**

Многие устаревшие API Windows не включают в себя контекст DPI или HWND в составе своего интерфейса. В результате разработчики часто должны выполнить дополнительную работу по масштабированию любых данных, зависящих от DPI, таких как размеры, точки или значки. Например, разработчики, использующие [лоадикон](/windows/desktop/api/winuser/nf-winuser-loadiconw) , должны либо загружать значки растровых изображений, либо использовать альтернативные API для загрузки значков правильного размера для соответствующих точек на дюйм, например [лоадимаже](/windows/desktop/api/winuser/nf-winuser-loadimagew).

**Принудительный сброс поддержки DPI в масштабе процесса**

Как правило, режим поддержки DPI для процесса не может быть изменен после инициализации процесса. Однако Windows может принудительно изменить режим поддержки DPI для процесса, если попытаться разорвать требование, чтобы все дескрипторы HWND в дереве окон имели одинаковый режим поддержки DPI. Во всех версиях Windows, начиная с Windows 10 1703, невозможно использовать различные дескрипторы HWND в дереве HWND в разных режимах определения DPI. При попытке создать отношение дочернего родителя, которое прерывает это правило, можно сбросить сведения о DPI для всего процесса. Это можно активировать следующим образом.

1.  Вызов CreateWindow, в котором переданное родительское окно находится в режиме, отличном от DPI вызывающего потока.
2.  Вызов Сетпарент, в котором два окна связаны с различными режимами определения DPI.

В таблице ниже показано, что происходит при попытке нарушения этого правила:



| Операция                 | Windows 8.1                                  | Windows 10 (1607 и более ранние версии)                | Windows 10 (1703 и более поздние версии)                  |
|---------------------------|----------------------------------------------|----------------------------------------------|----------------------------------------------|
| CreateWindow (in-proc)    | Н/Д                                          | **Дочерние наследуемые** (смешанный режим)              | **Дочерние наследуемые** (смешанный режим)              |
| CreateWindow (Cross-proc) | **Принудительный сброс** (для процесса вызывающего объекта)       | **Дочерние наследуемые** (смешанный режим)              | **Принудительный сброс** (для процесса вызывающего объекта)       |
| Сетпарент (in-proc)       | Н/Д                                          | **Принудительный сброс** (для текущего процесса)        | **Fail** (ошибка \_ недопустимое \_ состояние)             |
| Сетпарент (Cross-proc)    | **Принудительный сброс** (для процесса дочернего окна) | **Принудительный сброс** (для процесса дочернего окна) | **Принудительный сброс** (для процесса дочернего окна) |



 

## <a name="related-topics"></a>См. также

<dl> <dt>

[Справочник по API с высоким DPI](high-dpi-reference.md)
</dt> <dt>

[Масштабирование DPI в смешанном режиме и API с поддержкой DPI.](high-dpi-improvements-for-desktop-applications.md)
</dt> </dl>

