---
title: Разработка приложений WPF для мониторов с поддержкой определения DPI
description: Примечание. на этой странице рассматривается устаревшая разработка WPF для Windows 8.1. Если вы разрабатываете приложения WPF для Windows 10, ознакомьтесь с последней документацией на сайте GitHub..
ms.assetid: 04a36dc7-684f-4846-aeba-970117070b4c
keywords:
- Пользовательский интерфейс Windows, приложения, поддерживающие DPI
- Пользовательский интерфейс Windows, высокое разрешение DPI
- Приложения, поддерживающие DPI
- высокое разрешение DPI
- Написание приложений Win32 с поддержкой DPI
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 8a32bfaf76271e61d0dc3791d5aaae9609be6d8c
ms.sourcegitcommit: ebd3ce6908ff865f1ef66f2fc96769be0aad82e1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/19/2020
ms.locfileid: "104133874"
---
# <a name="developing-a-per-monitor-dpi-aware-wpf-application"></a>Разработка приложений WPF для мониторов с поддержкой определения DPI

**Важные API**

-   [**сетпроцессдпиаваренесс**](/windows/desktop/api/ShellScalingAPI/nf-shellscalingapi-setprocessdpiawareness)
-   [**жетпроцессдпиаваренесс**](/windows/desktop/api/ShellScalingAPI/nf-shellscalingapi-getprocessdpiawareness)
-   [**жетдпиформонитор**](/windows/desktop/api/ShellScalingAPI/nf-shellscalingapi-getdpiformonitor)

> [!Note]  
> **На этой странице рассматривается устаревшая разработка WPF для Windows 8.1.** Если вы разрабатываете приложения WPF для Windows 10, ознакомьтесь с <a href="https://github.com/microsoft/WPF-Samples/blob/master/PerMonitorDPI/readme.md">последней документацией на сайте GitHub.</a>

 

Windows 8.1 предоставляет разработчикам новые функции для создания настольных приложений, учитывающих разрешение DPI для каждого монитора. Чтобы воспользоваться преимуществами этой функции, приложение с поддержкой DPI для каждого монитора должно выполнить следующие действия:

-   Изменение размеров окна для поддержания физического размера, который отображается единообразно на любом дисплее
-   Повторное создание макета и повторное отображение графики для нового размера окна
-   Выберите шрифты, которые будут масштабироваться соответствующим образом для уровня DPI
-   Выбор и загрузка ресурсов точечного рисунка, адаптированных для уровня DPI

Чтобы упростить создание приложения с поддержкой DPI для каждого монитора, Windows 8.1 предоставляет следующие возможности Microsoft Win32APIs:

-   [**Сетпроцессдпиаваренесс**](/windows/desktop/api/ShellScalingAPI/nf-shellscalingapi-setprocessdpiawareness) (или запись манифеста DPI) задает для процесса указанный уровень осведомленности относительно dpi, который затем определяет, как Windows масштабирует пользовательский интерфейс. Это заменяет [**сетпроцессдпиаваре**](/windows/desktop/api/winuser/nf-winuser-setprocessdpiaware).
-   [**Жетпроцессдпиаваренесс**](/windows/desktop/api/ShellScalingAPI/nf-shellscalingapi-getprocessdpiawareness) возвращает уровень осведомленности о dpi. Это заменяет [**испроцессдпиаваре**](/windows/desktop/api/winuser/nf-winuser-isprocessdpiaware).
-   [**Жетдпиформонитор**](/windows/desktop/api/ShellScalingAPI/nf-shellscalingapi-getdpiformonitor) ВОЗВРАЩАЕТ значение dpi для монитора.
-   Уведомление окна [**WM \_ DPICHANGED**](wm-dpichanged.md) отправляется в приложения с поддержкой dpi для каждого монитора при изменении положения окна таким, что большая часть области пересекает монитор с dpi, отличным от dpi до изменения положения, или когда пользователь перемещает ползунок отображения. Чтобы создать приложение, которое изменяет размер и отображает его при перемещении пользователя на другой экран, используйте это уведомление.

Дополнительные сведения о различных уровнях определения DPI, поддерживаемых для настольных приложений, в Windows 8.1 см. в разделе [написание DPI-Aware приложений для настольных систем и Win32](https://msdn.microsoft.com/library/windows/desktop/mt843498(v=vs.85).aspx(d=robot)).

## <a name="dpi-scaling-and-wpf"></a>Масштабирование DPI и WPF

Приложения Windows Presentation Foundation (WPF) по умолчанию отслеживаются по DPI. Определения различных уровней осведомленности относительно DPI см. в разделе [написание DPI-Aware приложений для настольных систем и Win32](https://msdn.microsoft.com/library/windows/desktop/mt843498(v=vs.85).aspx(d=robot)). Графическая система WPF использует аппаратно-независимые единицы, чтобы обеспечить независимость от разрешения и устройства. WPF масштабирует каждый независимый от устройства пиксель автоматически на основе текущего DPI системы. Это позволяет приложениям WPF масштабироваться автоматически, если значение DPI монитора, на котором находится окно, равно значению DPI системы. Однако, так как приложения WPF учитывают контроль dpi системы, приложение будет масштабироваться операционной системой при перемещении приложения на монитор с другим разрешением или при использовании ползунка на панели управления для изменения DPI. Масштабирование в операционной системе может привести к тому, что приложения WPF будут выглядеть размытыми, особенно если масштабирование не является неотъемлемой частью. Чтобы избежать масштабирования приложений WPF, их необходимо обновить, чтобы они были ориентированы на контроль DPI.

## <a name="per-monitor-aware-wpf-sample-walkthrough"></a>Пример пошагового руководства WPF на уровне мониторинга

[Пример WPF, поддерживающий мониторинг](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/PerMonitorDPIAware) , — это пример приложения WPF, который обновляется в соответствии с отслеживанием dpi. Пример состоит из двух проектов:

-   Нативехелперс. vcxproj — это собственный вспомогательный проект, реализующий основные функции для создания приложения WPF в качестве уровня DPI для каждого монитора с использованием Win32APIs выше. Проект содержит два класса:
    -   Пермондпихелперс: класс, предоставляющий вспомогательные функции для операций, связанных с DPI, таких как получение текущего значения DPI активного монитора, установка процесса в соответствии с DPI и т. д.
    -   Пермонитордпивиндов: базовый класс, производный от **System. Windows. Window** , который реализует функциональные возможности для того, чтобы окно приложения WPF было ориентировано на контроль dpi. Корректирует размер окна, размер отрисовки графики и размер шрифта на основе DPI монитора, а не DPI на уровне системы.
-   Впфаппликатион. csproj: пример приложения WPF, использующего Пермонитордпивиндов (Пермонитордпивиндов), и демонстрируется изменение размера окна приложения и его отрисовки при перемещении окна на монитор с другим DPI или при использовании ползунка на панели управления "дисплей" для изменения DPI.

Чтобы запустить пример, выполните следующие действия:

1.  Загрузка и распаковка [примера для WPF с поддержкой мониторинга](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/PerMonitorDPIAware)
2.  Запустите Microsoft Visual Studio и выберите **файл > открыть > проект или решение** .
3.  Перейдите в каталог, содержащий Распакованный пример. Перейдите в каталог с именем для примера и дважды щелкните файл решения Visual Studio (SLN).
4.  Нажмите клавишу F7 или используйте **build > Build Solution** для создания примера
5.  Нажмите клавиши CTRL + F5 или используйте **отладку > запуск без отладки** , чтобы запустить пример

Чтобы увидеть влияние изменения DPI на приложение WPF, которое обновляется с учетом DPI для каждого монитора, используя базовый класс в примере, переместите окно приложения в и из отображения, которые имеют разные dpi. При перемещении окна между мониторами размер окна и масштаб пользовательского интерфейса обновляются на основе DPI на дисплее с помощью масштабируемой графической системы WPF, а не при масштабировании операционной системой. Пользовательский интерфейс приложения отображается в собственном виде и не выглядит размытым. Если у вас нет двух дисплеев с разными DPI, измените значение DPI, изменив ползунок на панели управления экрана. Изменение ползунка и нажатие кнопки **Применить** приведет к изменению размера окна приложения и автоматическому обновлению масштаба пользовательского интерфейса.

## <a name="updating-an-existing-wpf-application-to-be-per-monitor-dpi-aware-using-helper-project-in-the-wpf-sample"></a>Обновление существующего приложения WPF с учетом уровня dpi для каждого монитора с помощью вспомогательного проекта в примере WPF

Если у вас есть существующее приложение WPF и вы хотите использовать вспомогательный проект DPI из примера, чтобы обеспечить отслеживание DPI, выполните следующие действия.

1.  Загрузка и распаковка примера для WPF с поддержкой мониторинга
2.  Запустите Visual Studio и выберите **файл > открыть > проект или решение** .
3.  Перейдите к каталогу, содержащему существующее приложение WPF, и дважды щелкните файл решения Visual Studio (SLN).
4.  Щелкните правой кнопкой мыши **решение > добавить > существующий проект** ![ — снимок экрана, иллюстрирующий выбор пункта меню Добавить: существующий проект.](images/scrvs-image1.png)
5.  В диалоговом окне выбора файлов перейдите к каталогу, содержащему пример несжатого архива. Откройте каталог с именем для примера, перейдите в папку "Нативехелперс", выберите файл проекта Visual C++ "Нативехелперс. vcxproj" и нажмите кнопку " **ОК** ".
6.  Щелкните правой кнопкой мыши проект Нативехелперс и выберите **Build (сборка**). Будет создан NativeHelpers.dll, который будет добавлен в качестве ссылки на приложение WPF на следующем шаге. ![ снимок экрана, иллюстрирующий выбор в меню "сборка"](images/scrvs-image2.png)
7.  Добавьте ссылку на NativeHelpers.dll из приложения WPF. Разверните проект приложения WPF, щелкните **ссылки** правой кнопкой мыши и выберите команду **Добавить ссылку...**
8.  В открывшемся диалоговом окне разверните раздел **решение** . В разделе **проекты** выберите нативехелперс и нажмите кнопку **ОК** ![ на снимке экрана, иллюстрирующий диалоговое окно диспетчера ресурсов.](images/scrvs-image3.png)
9.  Разверните проект приложения WPF, разверните узел **Свойства** и откройте **AssemblyInfo. CS**. Внесите следующие дополнения в AssemblyInfo. cs.
    -   Добавьте ссылку на System. Windows. Media в разделе справки (с помощью System. Windows. Media;).
    -   Добавьте атрибут Дисабледпиаваренесс ( `[assembly: DisableDpiAwareness]` ).

    ![снимок экрана, иллюстрирующий дополнительные свойства](images/scrvs-image4.png)
10. Наследовать основной класс окна WPF от базового класса Пермонитордпивиндов
    -   Обновление файла CS главного окна WPF для наследования от базового класса Пермонитордпивиндов
        -   Добавьте ссылку на Нативехелперс в разделе Reference, добавив строку `using NativeHelpers;`
        -   Наследовать класс главного окна от класса Пермонитордпивиндов

        ![снимок экрана, иллюстрирующий Справочник по c++](images/scrvs-image5.png)
    -   Обновление файла XAML главного окна WPF для наследования от базового класса Пермонитордпивиндов
        -   Добавьте ссылку на Нативехелперс в разделе Reference, добавив строку `xmlns:src="clr-namespace:NativeHelpers;assembly=NativeHelpers"`
        -   Наследовать класс главного окна от класса Пермонитордпивиндов

        ![снимок экрана, иллюстрирующий Добавление ссылки на XAML](images/scrvs-image6.png)
11. Нажмите клавишу F7 или используйте **build > Build Solution** для создания примера
12. Нажмите клавиши CTRL + F5 или используйте **отладку > запуск без отладки** , чтобы запустить пример

[Пример приложения WPF с поддержкой отслеживания](https://github.com/microsoft/Windows-classic-samples/tree/master/Samples/PerMonitorDPIAware) на уровне мониторинга показывает, как можно обновить приложение WPF, чтобы оно отвечало на контроль dpi, реагируя на уведомление окна [**WM \_ DPICHANGED**](wm-dpichanged.md) . В ответ на уведомление окна пример обновляет преобразование масштабирования, используемое WPF на основе текущего DPI монитора, на котором находится окно. Параметр *wParam* уведомления окна содержит новое значение dpi в параметре *wParam*. *LParam* содержит прямоугольник с размером и положением нового рекомендуемого окна, который масштабируется для новых точек на дюйм.

Примечание.

> [!Note]  
> Поскольку этот пример перезаписывает размер окна и преобразование масштабирования корневого узла окна WPF, разработчику приложения может потребоваться дополнительная работа, если:
>
> -   Размер окна влияет на другие части приложения, такие как это окно WPF, размещенное в другом приложении.
> -   Приложение WPF, расширяющее этот класс, задает другое преобразование в корневом визуальном элементе; образец может перезаписать другое преобразование, которое применяется самим приложением WPF.

 

## <a name="overview-of-the-helper-project-in-the-wpf-sample"></a>Общие сведения о вспомогательном проекте в примере WPF

Чтобы создать существующее приложение WPF на уровне DPI для каждого монитора, Библиотека Нативехелперс предоставляет следующие функциональные возможности:

-   **Помечает приложение WPF как понитор dpi с учетом количества точек на дюйм:** Приложение WPF помечается как ориентированное на контроль DPI путем вызова [**сетпроцессдпиаваренесс**](/windows/desktop/api/ShellScalingAPI/nf-shellscalingapi-setprocessdpiawareness) для текущего процесса. Пометка приложения как учитывающего DPI для каждого монитора обеспечит

    -   ОПЕРАЦИОННАЯ система не масштабирует приложение, если DPI системы не соответствует текущему значению DPI монитора, в котором находится окно приложения.
    -   Сообщение [**WM \_ DPICHANGED**](wm-dpichanged.md) отправляется при каждом изменении dpi окна

-   **Корректирует размер окна, перекомпоновку и повторное отображение содержимого графики и выбор шрифтов на основе начального DPI монитора, на котором находится окно:** После того как приложение помечается как ориентированное на контроль DPI, WPF по-прежнему будет масштабировать размер окна, графику и размер шрифта на основе DPI на уровне системы. Так как при запуске приложения не гарантируется, что DPI на уровне системы будет таким же, как и у монитора, на котором запускается окно, Библиотека корректирует эти значения после загрузки окна. Базовый класс **пермонитордпивиндов** обновляет эти данные в обработчике **OnLoaded ()** .

    Размер окна обновляется путем изменения свойств **Width** и **Height** окна. Макет и размер обновляются путем применения соответствующего преобразования масштаба к корневому узлу окна WPF.

    ```C++
    void PerMonitorDPIWindow::OnLoaded(Object^ , RoutedEventArgs^ ) 
    {   
    if (m_perMonitorEnabled)
        {
        m_source = (HwndSource^) PresentationSource::FromVisual((Visual^) this);
        HwndSourceHook^ hook = gcnew HwndSourceHook(this, &PerMonitorDPIWindow::HandleMessages);
        m_source->AddHook(hook); 
                
        //Calculate the DPI used by WPF.                    
        m_wpfDPI = 96.0 *  m_source->CompositionTarget->TransformToDevice.M11; 

        //Get the Current DPI of the monitor of the window. 
        m_currentDPI = NativeHelpers::PerMonitorDPIHelper::GetDpiForWindow(m_source->Handle);

        //Calculate the scale factor used to modify window size, graphics and text
        m_scaleFactor = m_currentDPI / m_wpfDPI; 
            
        //Update Width and Height based on the on the current DPI of the monitor
        Width = Width * m_scaleFactor;
        Height = Height * m_scaleFactor;

        //Update graphics and text based on the current DPI of the monitor
    UpdateLayoutTransform(m_scaleFactor);
        }
    }

    void PerMonitorDPIWindow::UpdateLayoutTransform(double scaleFactor)
    {
    // Adjust the rendering graphics and text size by applying the scale transform to the top         
    level visual node of the Window     

    if (m_perMonitorEnabled) 
        {       
            auto child = GetVisualChild(0);
            if (m_scaleFactor != 1.0) 
           {
            ScaleTransform^ dpiScale = gcnew ScaleTransform(scaleFactor, scaleFactor);
            child->SetValue(Window::LayoutTransformProperty, dpiScale);
            }
            else 
            {
            child->SetValue(Window::LayoutTransformProperty, nullptr);
            }           
        }
    }
    ```

    

-   **Реагирует на WM \_ DPICHANGED Window Notification:** обновление размера окна, графики и размера шрифта на основе значений dpi, переданных в окне уведомления. Базовый класс **пермонитордпивиндов** обрабатывает уведомление окна в методе **хандлемессажес ()** .

    Размер окна обновляется путем вызова **SetWindowPos** с использованием информации, передаваемой в параметре *lParam* сообщения окна. Размер макета и графики обновляется путем применения соответствующего преобразования масштаба к корневому узлу окна WPF. Коэффициент масштабирования вычисляется с помощью параметра DPI, переданного в параметре *wParam* окна сообщения.

    ```C++
    IntPtr PerMonitorDPIWindow::HandleMessages(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, bool% )
    {
    double oldDpi;
    switch (msg)
        {
        case WM_DPICHANGED:
        LPRECT lprNewRect = (LPRECT)lParam.ToPointer();
        SetWindowPos(static_cast<HWND>(hwnd.ToPointer()), 0, lprNewRect->left, lprNewRect-
            >top, lprNewRect->right - lprNewRect->left, lprNewRect->bottom - lprNewRect->top, 
           SWP_NOZORDER | SWP_NOOWNERZORDER | SWP_NOACTIVATE);
        oldDpi = m_currentDPI;
        m_currentDPI = static_cast<int>(LOWORD(wParam.ToPointer()));
        if (oldDpi != m_currentDPI) 
            {
            OnDPIChanged();
            }
        break;
        }
    return IntPtr::Zero;
    }

    void PerMonitorDPIWindow::OnDPIChanged() 
    {
    m_scaleFactor = m_currentDPI / m_wpfDPI;
    UpdateLayoutTransform(m_scaleFactor);
    DPIChanged(this, EventArgs::Empty);
    }

    void PerMonitorDPIWindow::UpdateLayoutTransform(double scaleFactor)
    {
    // Adjust the rendering graphics and text size by applying the scale transform to the top         
    level visual node of the Window     

    if (m_perMonitorEnabled) 
        {       
            auto child = GetVisualChild(0);
            if (m_scaleFactor != 1.0) 
           {
            ScaleTransform^ dpiScale = gcnew ScaleTransform(scaleFactor, scaleFactor);
            child->SetValue(Window::LayoutTransformProperty, dpiScale);
            }
            else 
            {
            child->SetValue(Window::LayoutTransformProperty, nullptr);
            }           
        }
    }
    ```

    

## <a name="handling-dpi-change-for-assets-like-images"></a>Обработка изменения DPI для активов, например изображений

Для обновления графического содержимого пример приложения WPF применяет преобразование масштабирования к корневому узлу приложения WPF. Хотя это хорошо подходит для содержимого, отображаемого изначально WPF (прямоугольник, текст и т. д.), это подразумевает, что ресурсы точечного рисунка, такие как изображения, масштабируются WPF.

Чтобы избежать размытых растровых изображений, вызванных масштабированием, разработчик приложения WPF может написать настраиваемый элемент управления Image, который выбирает другой ресурс на основе текущего DPI монитора, на котором находится окно. Элемент управления "изображение" может полагаться на событие **DPIChanged ()** , которое срабатывает для окна WPF, использующего **пермонитордпивиндов**, при изменении dpi.

> [!Note]  
> Элемент управления "изображение" также должен выбрать нужный элемент управления во время запуска приложения в обработчике событий окна " **загружено ()** WPF".

 

 

 