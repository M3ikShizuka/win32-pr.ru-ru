---
description: Преобразования препроцессора для декодера MPEG
ms.assetid: c7ae0137-0d02-46da-9532-738d805e327d
title: Преобразования препроцессора для декодера MPEG
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d0c05ecf25bedb2a90af239715a3becb9a0adc198ed315d2b2c4deea4b380711
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "120075814"
---
# <a name="mpeg-decoder-preprocessing-transformations"></a>Преобразования препроцессора для декодера MPEG

**Леттербокс и Панскан**

Изображение 4x3 можно формировать с помощью заполнения верхнего и нижнего края изображения (называемого изображением Леттербокс) или путем извлечения 4x3 части изображения (называемой Панскан изображением). Меню и потоки подизображений перемещаются поверх конечного изображения видео. Изображения соотношения 16x9 хранятся в формате 4x3 анаморфик. Растягивание пропорций анаморфик 4x3 с исходным видео на 16x9 пропорции образуют исходное изображение 16x9.

Ниже приведено описание того, как правильно отобразить каждый из режимов и их выделение:

-   **Широкий экран:** Исходное видео было растянуто в самой крупной области 16x9 окна вывода. Основные особенности находятся относительно внутренней области 16x9. Черные полосы следует добавлять к верхней и нижней сторонам, чтобы поддерживать 16x9 область.
-   **Просмотр панорамы:** В видео 16x9 используйте горизонтальное смещение, предоставленное в потоке MPEG2, для извлечения подокна 4x3. Поместите подокно 4x3 в самую крупную область 4x3 окна выходного клиента. Координаты выделения задаются относительно окна вывода 4x3 и не имеют связи с исходным видео 16x9. Черные полосы следует добавлять к верхней и нижней сторонам, чтобы поддерживать 4x3 область.
-   **Леттербокс:** Вычислите наиболее крупную 4x3 область окна вывода. Черные полосы следует добавлять к верхней и нижней сторонам, чтобы поддерживать 4x3 область. Исходное анаморфик 4x3 видео (представляющее образ 16x9) помещается в самый крупный подокно 16x9 в области 4x3. Черные полосы должны быть добавлены в верхнюю и нижнюю часть подокна, чтобы поддерживать 16x9 область. Координаты выделения задаются относительно области 4x3 и не имеют связи с исходным видео 16x9. Диск может определять выделение, которое находится за пределами области 16x9 (но остается в окне 4x3). Для видео 4x3 видео помещается в самую большую область вывода 4x3 в окне выходного клиента. Черные полосы следует добавлять к верхней и нижней сторонам, чтобы поддерживать 4x3 область.

**Предварительная обработка MPEG с помощью навигатора по DVD и VMR**

В настоящее время декодеру передается \_ \_ тип видеоматериала формата MPEG2 (чей блок форматирования указывает на структуру [**MPEG2VIDEOINFO**](/previous-versions/windows/desktop/api/dvdmedia/ns-dvdmedia-mpeg2videoinfo) ). На выходных закреплениях декодер создает \_ тип мультимедиа VIDEOINFO2 формата, блок формата которого указывает на структуру [**VIDEOINFOHEADER2**](/previous-versions/windows/desktop/api/dvdmedia/ns-dvdmedia-videoinfoheader2) . Поле **двресервед** структуры было переименовано в флаги **двконтролс** .

Теперь элемент **двконтролфлагс** будет содержать новые биты.



| Метка | Значение |
|--------------------------|------------|
| \_используется амконтрол          | 0x00000001 |
| АМКОНТРОЛ \_ Pad \_ на \_ 4x3  | 0x00000002 |
| АМКОНТРОЛ \_ Pad \_ на \_ 16x9 | 0x00000004 |



 

АМКОНТРОЛ используется \_ для проверки того, поддерживаются ли эти новые флаги. Фильтр источника должен установить \_ флаг амконтрол и проверить успешность куерякцепт (MediaType) в нисходящем ПИН-коде. Если он отклонен, то нельзя использовать флаги АМКОНТРОЛ, и dwReserved1 должен иметь значение 0.

АМКОНТРОЛ \_ панель \_ \_ 4x3 указывает, что изображение должно быть заполнено и отображено в области 4x3.

АМКОНТРОЛ \_ панель \_ \_ 16x9 указывает, что изображение должно быть заполнено и отображено в области 16x9.

Декодер должен либо самостоятельно копировать, либо обрабатывать биты. Если декодер самостоятельно выполняет пустых, он должен изменить пропорцию пикселя, заполнить изображение и удалить соответствующие \_ \* биты амконтрол.

MPEG2VIDEOINFO. dwFlags теперь содержит три флага для управления отображением содержимого:

-   `AMMPEG2_DoPanScan (0x00000001)`. Если этот флаг установлен, декодер видео MPEG-2 должен обрезать выходное изображение на основе векторов панорамного просмотра в расширении изображения \_ \_ и изменить пропорции рисунка на 4x3. VMR не должен получить пример 16x9 с этим флагом. Простая реализация может изменить исходный прямоугольник, чтобы указать на ширину в 540-е регионе источника с левой границей, равной смещению отображения \_ в \_ расширении изображения.
-   `AMMPEG2_LetterboxAnalogOut (0x00000020)`. Когда аппаратный декодер отображает этот поток на выходе видео (обычно это соединитель СВИДЕО на карте), он должен применить правила для отображения образца 16x9 на экране 4x3.

    Программный декодер (или аппаратный декодер, создающий данные, отправляемые в VMR) имеет два варианта обработки изображений:

    1.  Проигнорируйте этот флаг и передайте содержимое VideoInfoHeader2 в VMR (АМКОНТРОЛ \_ Pad \_ to \_ 4x3 будет уже установлен в качестве образца [DVD-навигатора](dvd-navigator-filter.md) в образце). Фильтр VMR получит пример видео 16x9 с \_ панелью амконтрол \_ в \_ набор флагов 4x3 и поток 4x3 субтитров. Приложение должно установить одинаковую ширину выходных нормализованных конечных прямоугольников для двух потоков.
    2.  Преобразуйте поток анаморфик в изображение 4x3, добавив отступы в верхнюю и нижнюю часть изображения и установив пропорции изображения в 4x3 (см. Леттербокс выше) и удалив АМКОНТРОЛ \_ Pad \_ в \_ 4X3 бит из VIDEOINFOHEADER2.

    Декодеры Директксва, которые накладывают потоки видео и субтитров, должны будут обрабатывать этот флаг. Если оборудование не может масштабировать накладываемое подизображение, то декодер должен создать отдельный поток субтитров для того, чтобы смешать с видео.

-   `AMMPEG2_WidescreenAnalogOut (0x00000200)`. Когда аппаратный декодер отображает этот поток на выходе видео (обычно это соединитель СВИДЕО на карте), он должен иметь 16x9 (анаморфик).

    Программный декодер (или аппаратный декодер, создающий данные, отправляемые на VMR) имеет два варианта обработки образа анаморфик:

    1.  Пропустите этот флаг и скопируйте содержимое VideoInfoHeader2 в VMR. Фильтр VMR будет заполнять 4x3 изображения на 16x9, если АМКОНТРОЛ \_ Pad \_ \_ 16x9 Set.
    2.  Выводите выходной образ в образ 16x9 и удаляет панель АМКОНТРОЛ \_ \_ в \_ 16x9 bit.

Большинство декодеров должны использовать **жетмедиатипе** для обнаружения изменения носителя на входном ПИН-коде и копирования содержимого **VIDEOINFOHEADER2** (содержится в **MPEG2INFOHEADER**) в выходной ПИН-код. Скорее всего, они будут обрабатывать только Панскан бит.

В следующем примере кода показано, как скопировать содержимое **VIDEOINFOHEADER2** из входного контакта в выходной ПИН-код.


```C++
#include <dvdmedia.h>
HRESULT CopyMPeg2ToVideoInfoHeader2(CMediaSample* pInSample, CMediaSample* pOutSample)
{
    HRESULT hr = S_OK;
    // Check for a media type on the input sample.
    AM_MEDIA_TYPE* pInType;
    if (pInSample->GetMediaType(&pInType) == S_OK) 
    {
        // Make sure it's an MPEG2 Video format.
        if ((pInType->formattype == FORMAT_MPEG2_VIDEO) &&
            (pInType->cbFormat >= sizeof(MPEG2VIDEOINFO)))
        {
            hr = S_OK; // Initialize hr for the CMediaType constructor.
            CMediaType outType(*pInType, &hr);
            if (FAILED(hr))
            {
                DeleteMediaType( pInType );
                return hr;
            }

            // Set the format type GUID.
            outType.SetFormatType(&FORMAT_VideoInfo2);
                
            // Truncate the format block to include just the VIDEOINFOHEADER part.
            MPEG2VIDEOINFO *pMPeg2Header = (MPEG2VIDEOINFO*)pInType->pbFormat;
            BYTE *pVIH = (BYTE*)&pMPeg2Header->hdr;
            hr = (outType.SetFormat(pVIH, sizeof(VIDEOINFOHEADER2)) ? S_OK : E_OUTOFMEMORY);
            if (SUCCEEDED(hr))
            {
                hr = pOutSample->SetMediaType(&outType);
            }
        } 
        else 
        {
            ASSERT(FALSE); // Not a MPEG2 header.
            hr = VFW_E_INVALIDMEDIATYPE;
        }
        DeleteMediaType( pInType );
    } 

    return hr;
}
```



 

 



