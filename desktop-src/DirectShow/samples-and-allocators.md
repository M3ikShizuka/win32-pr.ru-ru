---
description: Примеры и Распределительы
ms.assetid: 1fbea741-f29a-4815-9885-94ca9cf4bb95
title: Примеры и Распределительы
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6f9132ff2c70b5ade63f8853b5c03bacb7a25371
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "104562939"
---
# <a name="samples-and-allocators"></a>Примеры и Распределительы

Когда ПИН-код предоставляет данные мультимедиа другому ПИН-коду, он не передает прямой указатель на буфер памяти. Вместо этого он доставляет указатель на COM-объект, управляющий памятью. Этот объект, называемый *примером носителя*, предоставляет интерфейс [**имедиасампле**](/windows/desktop/api/Strmif/nn-strmif-imediasample) . Полученный ПИН-код обращается к буферу памяти путем вызова методов **имедиасампле** , таких как [**имедиасампле::**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getpointer), [**Имедиасампле:: resize**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getsize)и [**имедиасампле:: жетактуалдаталенгс**](/windows/win32/api/strmif/nf-strmif-imediasample-getactualdatalength).

Примеры всегда перемещаются вверх, от выходного контакта до входного ПИН-кода. В модели push-уведомлений выходным закреплением доставляется образец путем вызова [**имеминпутпин:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) во входной ПИН-коде. Входной ПИН-код будет либо обрабатывать данные синхронно (то есть полностью внутри метода **Receive** ), либо асинхронно обрабатываться в рабочем потоке. Входной ПИН-код может блокироваться в методе **Receive** , если он должен ждать ресурсов.

Другой COM-объект, называемый *распределителем*, отвечает за создание образцов носителей и управление ими. Распределительы предоставляют интерфейс [**имемаллокатор**](/windows/desktop/api/Strmif/nn-strmif-imemallocator) . Каждый раз, когда для фильтра требуется пример носителя с пустым буфером, он вызывает метод [**имемаллокатор::-buffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) , который возвращает указатель на образец. Каждое подключение к закреплениям использует один распределитель. Когда два контакта соединяются, они решают, какой фильтр будет предоставлять распределитель. ПИН-коды также задают свойства распределителя, например количество буферов и размер каждого буфера. (Дополнительные сведения см. в разделе [Фильтрация подключения](how-filters-connect.md) и [согласования распределителя](negotiating-allocators.md).)

На следующем рисунке показаны связи между распределителем, примерами мультимедиа и фильтром.

![примеры и распределительы носителей](images/mediasamples.png)

**Счетчик ссылок образца носителя**

Распределитель создает конечный пул образцов. Некоторые примеры могут быть использованы в любой момент, а другие — **с вызовами** at. Распределитель использует подсчет ссылок для наблюдения за примерами. Метод **метода** IsReference возвращает образец со значением счетчика ссылок, равным 1. Если число ссылок становится равным нулю, пример возвращается в пул распределителя, где его можно использовать **в следующем** вызове функции GetNext. Пока значение счетчика ссылок остается больше нуля, выборка недоступна для- **buffer**. Если используется любой пример, принадлежащий распределительу, метод метода WebMethod блокируется до тех **пор, пока** образец не станет доступным.

Например, предположим, что входной ПИН-код получает пример. Если он обрабатывает пример синхронно, внутри метода **Receive** он не увеличивает число ссылок. После **получения** возврата выходной ПИН-код освобождает пример, счетчик ссылок переходит к нулю, а пример возвращается в пул распределителя. С другой стороны, если входной ПИН-код обрабатывает пример в рабочем потоке, он увеличивает счетчик ссылок до выхода из метода **Receive** . Число ссылок теперь равно 2. Когда закрепление выходных данных освобождает пример, счетчик переходит к 1; образец еще не возвращается в пул. После того как рабочий поток будет выполнен в примере, он вызывает **выпуск** , чтобы освободить пример. Теперь пример возвращает в пул.

Когда ПИН-код получает пример, он может скопировать данные в другой образец или изменить исходный образец и доставить его на следующий фильтр. Потенциально пример может передавать всю длину графа, каждый из которых вызывает **AddRef** и **Release** в свою очередь. Таким образом, ПИН-код не должен повторно использовать выборку после вызова метода **Receive**, так как этот пример может использовать нисходящий фильтр. Для получения нового образца выходной ПИН-код должен всегда вызывать метод " **buffer** ".

Этот механизм уменьшает объем выделения памяти, поскольку фильтры повторно используют одни и те же буферы. Это также предотвращает случайную запись фильтров по данным, которые не были обработаны, так как распределитель поддерживает список доступных образцов.

Фильтр может использовать отдельные распределителя для ввода и вывода. Это можно сделать, если распаковать входные данные (например, путем распаковки). Если выходные данные больше, чем входные данные, фильтр может обработать данные на месте, не копируя их в новый пример. В этом случае два или более подключения ПИН-кода могут совместно использовать один распределитель.

**Фиксация и дефиксация распределителя**

Когда фильтр сначала создает распределитель, распределитель не зарезервирует буферы памяти. На этом этапе все вызовы метода «методу **buffer** » завершатся ошибкой. При запуске потоковой передачи выходной ПИН-код вызывает [**имемаллокатор:: Commit**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-commit), который фиксирует распределитель, что приводит к выделению памяти. Теперь ПИН-коды могут вызывать метод " **buffer**".

При остановке потоковой передачи ПИН-код вызывает [**имемаллокатор::D екоммит**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-decommit), который отменяет распределитель. Все последующие вызовы метода **buffer** завершаются сбоем до тех пор, пока распределитель не будет зафиксирован снова. Кроме того, если какие-либо вызовы метода **buffer** в данный момент заблокированы в ожидании образца, они немедленно возвращают код ошибки. Метод **uncommit** может освободить память в зависимости от реализации. Например, класс [**кмемаллокатор**](cmemallocator.md) ожидает, пока метод деструктора не освободит память.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Поток данных в графе фильтра](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 
