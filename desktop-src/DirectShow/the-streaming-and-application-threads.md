---
description: Потоковая передача и потоки приложений
ms.assetid: 954f7abd-fe06-430a-b6f7-d60852826bc9
title: Потоковая передача и потоки приложений
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a90916c14395a21aa5c53481c96b03fb6bbb2a8d4162cf996ef18ac15ce5e856
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119583124"
---
# <a name="the-streaming-and-application-threads"></a>Потоковая передача и потоки приложений

любое DirectShowное приложение содержит по крайней мере два важных потока: поток приложения и один или несколько потоков потоковой передачи. Образцы доставляются в потоках потоковой передачи, а изменения состояния происходят в потоке приложения. Основной поток потоковой передачи создается с помощью фильтра источника или средства синтаксического анализа. Другие фильтры могут создавать рабочие потоки, которые доставляют образцы, и они также считаются потоками потоков.

Некоторые методы вызываются в потоке приложения, а другие вызываются в потоке потоковой передачи. Пример:

-   Потоки потоковой передачи: [**имеминпутпин:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive), [**Имеминпутпин:: рецеивемултипле**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receivemultiple), [**Ипин:: EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream), [**имемаллокатор::-buffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer).
-   Поток приложения: [**имедиафилтер::P Аусе**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-pause), [**Имедиафилтер:: Run**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-run), [**имедиафилтер:: останавливаться**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-stop), [**имедиасикинг:: сетпоситионс**](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-setpositions), [**Ипин:: бегинфлуш**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush), [**IPIN:: EndFlush**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).
-   Либо: [**Ипин:: невсегмент**](/windows/desktop/api/Strmif/nf-strmif-ipin-newsegment).

Наличие отдельного потока потоковой передачи позволяет передавать данные через граф, пока поток приложения ожидает ввода данных пользователем. Опасность нескольких потоков, однако, заключается в том, что фильтр может создавать ресурсы при приостановке (в потоке приложения), использовать их внутри метода потоковой передачи и уничтожать их при остановке (также в потоке приложения). Если вы не проследите, поток потоковой передачи может попытаться использовать ресурсы после их уничтожения. Решение заключается в защите ресурсов с помощью критических разделов и синхронизации методов потоковой передачи с изменениями состояния.

Для защиты состояния фильтра фильтру требуется одна критическая секция. Класс [**кбасефилтер**](cbasefilter.md) имеет переменную-член для этого критического раздела, [**кбасефилтер:: m \_ плокк**](cbasefilter-m-plock.md). Этот критический раздел называется блокировкой фильтра. Кроме того, каждому входному ПИН-коду требуется критическая секция для защиты ресурсов, используемых потоком потоковой передачи. Эти критические разделы называются потоковой блокировкой. их необходимо объявить в производном классе закрепления. проще всего использовать класс [**ккритсек**](ccritsec.md) , который создает оболочку для объекта **критического \_ раздела** Windows и может быть заблокирован с помощью класса [**каутолокк**](cautolock.md) . Класс **ккритсек** также предоставляет некоторые полезные функции отладки. Дополнительные сведения см. в разделе [функции отладки критических секций](critical-section-debugging-functions.md).

При остановке или сбросе фильтра он должен синхронизировать поток приложения с потоком потоковой передачи. Чтобы избежать взаимоблокировки, необходимо сначала разблокировать поток потоковой передачи, который может быть заблокирован по нескольким причинам:

-   Он ожидает получения образца в методе [**имемаллокатор::-buffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) , так как все примеры распределителя используются.
-   Он ожидает возврата другим фильтром из потокового метода, например **Receive**.
-   Он ожидает внутри одного из своих методов потоковой передачи, чтобы некоторый ресурс стал доступным.
-   Это фильтр модуля подготовки отчетов, ожидающий время презентации для следующего примера
-   Это фильтр модуля подготовки отчетов, ожидающий в методе **Receive** во время приостановки.

Поэтому при остановке или сбросе фильтра необходимо выполнить следующие действия.

-   Выпустите любой из примеров, который он удерживает по какой-либо причине. Это разблокирует **метод метода** WebMethod.
-   Вернитесь из любого метода потоковой передачи как можно быстрее. Если потоковый метод ожидает ресурс, он должен немедленно закончить ожидание.
-   Начните отклонять примеры в **Receive**, чтобы поток потоковой передачи не получал доступ к большему ресурсу. (Класс [**кбасеинпутпин**](cbaseinputpin.md) обрабатывает это автоматически.)
-   Метод **останавливаться** должен отменять фиксацию всех распределителя фильтра. (Класс **кбасеинпутпин** обрабатывает это автоматически.)

В потоке приложения происходит очистка и остановка. Фильтр останавливается в ответ на метод [**имедиаконтрол:: Stop**](/windows/desktop/api/Control/nf-control-imediacontrol-stop) . диспетчер Graph Manager выдает команду "закончить" в восходящий порядок, начиная с модулей подготовки отчетов и перезапускаясь в исходные фильтры. Команда "завершить" полностью выполняется внутри метода **кбасефилтер:: останавливаться** фильтра. Когда метод возвращает значение, фильтр должен находиться в остановленном состоянии.

Очистка обычно происходит из-за команды Seek. Команда Flush начинается с исходного или из фильтра синтаксического анализатора и перемещается в нисходящий. Запись на диск происходит в два этапа: метод [**Ипин:: бегинфлуш**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) информирует фильтр о том, что все ожидающие и входящие данные отменяются; метод [**Ипин:: ендфлуш**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush) сигнализирует фильтру о необходимости повторного приема данных. Для очистки требуется два этапа, так как вызов **бегинфлуш** выполняется в потоке приложения, в течение которого потоковая передача продолжит доставлять данные. Поэтому некоторые примеры могут поступать после вызова **бегинфлуш** . Фильтр должен отбросить их. Все примеры, поступающие после вызова **ендфлуш** , будут гарантированно новыми и должны быть доставлены.

В следующих разделах содержатся примеры кода, демонстрирующие способы реализации наиболее важных методов фильтрации, таких как **Пауза**, **Получение** и т. д., чтобы избежать взаимоблокировок и конкуренции. Однако у каждого фильтра есть свои требования, поэтому вам потребуется адаптировать эти примеры к конкретному фильтру.

> [!Note]  
> Базовые классы [**ктрансформфилтер**](ctransformfilter.md) и [**ктрансинплацефилтер**](ctransinplacefilter.md) обработают многие проблемы, описанные в этой статье. Если вы создаете фильтр преобразования, и фильтр не ожидает события внутри потокового метода или удерживает выборку за пределами **Receive**, то эти базовые классы должны быть достаточными.

 

 

 



