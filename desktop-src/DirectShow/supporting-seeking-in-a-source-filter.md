---
description: в этом разделе описано, как реализовать поиск в фильтре источника Microsoft DirectShow. В качестве отправной точки в нем используется пример фильтра шарика и описывается дополнительный код, необходимый для поддержки поиска в этом фильтре.
ms.assetid: a2b4be09-2fd6-4aac-8ad6-c3d62377c1f2
title: Поддержка поиска в фильтре источника
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d92c52ff4bde3ea75b156e5521af9825b0902df38f0d0c6bc23cc7be99c37a55
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119072358"
---
# <a name="supporting-seeking-in-a-source-filter"></a>Поддержка поиска в фильтре источника

в этом разделе описано, как реализовать поиск в фильтре источника Microsoft DirectShow. В качестве отправной точки в нем используется пример [фильтра шарика](ball-filter-sample.md) и описывается дополнительный код, необходимый для поддержки поиска в этом фильтре.

Образец " [Фильтр шарика](ball-filter-sample.md) " — это фильтр источника, который создает анимированный шарик с отскоками. В этой статье описывается, как добавить функции поиска в этот фильтр. После добавления этой функции можно отобразить фильтр в Графедит и управлять шариком, перетаскивая ползунок Графедит.

Этот раздел состоит из следующих подразделов.

-   [Общие сведения о поиске в DirectShow](#overview-of-seeking-in-directshow)
-   [Краткий обзор фильтра шарика](#quick-overview-of-the-ball-filter)
-   [Изменение фильтра шарика для поиска](#modifying-the-ball-filter-for-seeking)
-   [Ограничения класса Ксаурцесикинг](#limitations-of-the-csourceseeking-class)

## <a name="overview-of-seeking-in-directshow"></a>Общие сведения о поиске в DirectShow

приложение ищет граф фильтра, вызывая метод [**имедиасикинг**](/windows/desktop/api/Strmif/nn-strmif-imediaseeking) для фильтра Graph Manager. затем фильтр Graph Manager распространяет вызов на каждый модуль подготовки отчетов в графе. Каждый модуль подготовки отчетов отправляет вышестоящее обращение через выходной ПИН-код следующего вышестоящего фильтра. Вызов перемещается в потоке до тех пор, пока не достигнет фильтра, который может выполнить команду Seek (обычно это фильтр источника или фильтр анализатора). Как правило, фильтр, исходящий отметки времени, также обрабатывает Поиск.

Фильтр реагирует на команду Seek следующим образом:

1.  Фильтр очищает диаграмму. При этом удаляются все устаревшие данные из Graph, что повышает скорость реагирования. В противном случае могут быть доставлены образцы, которые были помещены в буфер до команды Seek.
2.  Фильтр вызывает [**Ипин:: невсегмент**](/windows/desktop/api/Strmif/nf-strmif-ipin-newsegment) для информирования нисходящих фильтров о новом времени окончания, времени начала и скорости воспроизведения.
3.  Затем фильтр устанавливает флаг небесперебойности в первом примере после команды Seek.

Метки времени начинаются с нуля после любой команды поиска (включая изменения скорости).

## <a name="quick-overview-of-the-ball-filter"></a>Краткий обзор фильтра шарика

Фильтр шарика — это источник push-уведомлений. Это означает, что он использует рабочий поток для предоставления образцов в нисходящем направлении, в отличие от источника запроса, который, в своюмся состоянии, ожидает, пока подчиненный фильтр не запросит образцы. Фильтр шарика строится на основе класса [**ксаурце**](csource.md) , а его выходной ПИН-код строится на основе класса [**ксаурцестреам**](csourcestream.md) . Класс **ксаурцестреам** создает рабочий поток, который управляет потоком данных. Этот поток входит в цикл, который получает выборки из распределителя, заполняет их данными и доставляет их нисходящим.

Большая часть действия в [**ксаурцестреам**](csourcestream.md) происходит в методе [**Ксаурцестреам:: филлбуффер**](csourcestream-fillbuffer.md) , который реализуется производным классом. Аргументом для этого метода является указатель на образец для доставки. Реализация **филлбуффер** в фильтре шарика получает адрес буфера выборки и рисует непосредственно в буфере, устанавливая отдельные значения пикселей. (Рисование выполняется вспомогательным классом Кбалл, поэтому вы можете игнорировать сведения о глубине битов, палитрах и т. д.)

## <a name="modifying-the-ball-filter-for-seeking"></a>Изменение фильтра шарика для поиска

Чтобы сделать фильтр шарика пригодным для поиска, используйте класс [**ксаурцесикинг**](csourceseeking.md) , предназначенный для реализации поиска в фильтрах с одним выходным закреплением. Добавьте класс **ксаурцесикинг** в список наследования для класса кбаллстреам:


```C++
class CBallStream :  // Defines the output pin.
    public CSourceStream, public CSourceSeeking
```



Кроме того, необходимо добавить инициализатор для [**ксаурцесикинг**](csourceseeking.md) в конструктор кбаллстреам:


```C++
    CSourceSeeking(NAME("SeekBall"), (IPin*)this, phr, &m_cSharedState),
```



Эта инструкция вызывает базовый конструктор для [**ксаурцесикинг**](csourceseeking.md). Параметры — это имя, указатель на ПИН-код владельца, значение **HRESULT** и адрес объекта критической секции. Имя используется только для отладки, а макрос [**Name**](name.md) компилируется в пустую строку в розничных сборках. ПИН-код непосредственно наследует **ксаурцесикинг**, поэтому второй параметр является указателем на себя, приведенным к указателю [**Ипин**](/windows/desktop/api/Strmif/nn-strmif-ipin) . Значение **HRESULT** игнорируется в текущей версии базовых классов. он остается для совместимости с предыдущими версиями. Критическая секция защищает общие данные, такие как текущее время запуска, время окончания и скорость воспроизведения.

Добавьте следующую инструкцию в конструктор [**ксаурцесикинг**](csourceseeking.md) :


```C++
m_rtStop = 60 * UNITS;
```



Переменная *\_ ртстоп m* указывает время окончания. По умолчанию используется значение \_ I64 \_ Max/2, которое составляет примерно 14 600 лет. Предыдущая инструкция задает для него более консервативную 60 секунд.

В Кбаллстреам необходимо добавить две дополнительные переменные члена:


```C++
BOOL            m_bDiscontinuity; // If true, set the discontinuity flag.
REFERENCE_TIME  m_rtBallPosition; // Position of the ball. 
```



После каждой команды Seek фильтр должен установить флаг небесперебойности для следующей выборки путем вызова [**имедиасампле:: сетдисконтинуити**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setdiscontinuity). Переменная *m \_ бдисконтинуити* будет отследить это. Переменная *\_ ртбаллпоситион m* определяет расположение шарика в кадре видео. Фильтр исходного шарика Вычисляет положение на основе потокового времени, но время потока сбрасывается в ноль после каждой команды Seek. В потоке, доступном для поиска, абсолютное положение не зависит от времени потока.

### <a name="queryinterface"></a>QueryInterface

Класс [**ксаурцесикинг**](csourceseeking.md) реализует интерфейс [**имедиасикинг**](/windows/desktop/api/Strmif/nn-strmif-imediaseeking) . Чтобы предоставить этот интерфейс клиентам, переопределите метод [**нонделегатингкуеринтерфаце**](cunknown-nondelegatingqueryinterface.md) :


```C++
STDMETHODIMP CBallStream::NonDelegatingQueryInterface
    (REFIID riid, void **ppv)
{
    if( riid == IID_IMediaSeeking ) 
    {
        return CSourceSeeking::NonDelegatingQueryInterface( riid, ppv );
    }
    return CSourceStream::NonDelegatingQueryInterface(riid, ppv);
}
```



метод называется "неделегированным" из-за способа, которым DirectShow базовые классы поддерживают агрегирование объектной модели (COM). дополнительные сведения см. в разделе "реализация IUnknown" в DirectShow SDK.

### <a name="seeking-methods"></a>Поиск методов

Класс [**ксаурцесикинг**](csourceseeking.md) поддерживает несколько переменных членов, относящихся к поиску.



| Переменная          | Описание   | Значение по умолчанию  |
|-------------------|---------------|----------------|
| *m \_ ртстарт*      | Время начала    | Ноль           |
| *m \_ ртстоп*       | Время остановки     | \_I64 \_ Max/2 |
| *m \_ дратесикинг* | Скорость воспроизведения | 1.0            |



 

Реализация [**Ксаурцесикинг**](csourceseeking.md) [**Имедиасикинг:: сетпоситионс**](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-setpositions) обновляет время начала и окончания, а затем вызывает два чисто виртуальных метода в производном классе, [**Ксаурцесикинг:: Чанжестарт**](csourceseeking-changestart.md) и [**ксаурцесикинг:: ChangeStop**](csourceseeking-changestop.md). Реализация [**имедиасикинг:: сетрате**](/windows/desktop/api/Strmif/nf-strmif-imediaseeking-setrate) подобна: она обновляет скорость воспроизведения, а затем вызывает чистый виртуальный метод [**Ксаурцесикинг:: чанжерате**](csourceseeking-changerate.md). В каждом из этих виртуальных методов ПИН-код должен выполнять следующие действия:

1.  Чтобы начать очистку данных, вызовите [**Ипин:: бегинфлуш**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) .
2.  Остановите поток потоковой передачи.
3.  Вызовите [**Ипин:: ендфлуш**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush).
4.  Перезапустите поток потоковой передачи.
5.  Вызовите [**Ипин:: невсегмент**](/windows/desktop/api/Strmif/nf-strmif-ipin-newsegment).
6.  Установите флаг небесперебойности в следующем примере.

Порядок этих шагов является важнейшим, так как поток потоковой передачи может блокироваться, пока он ожидает доставки примера или получения нового примера. Метод [**бегинфлуш**](/windows/desktop/api/Strmif/nf-strmif-ipin-beginflush) гарантирует, что поток потоковой передачи не блокируется и, следовательно, не будет заблокирован на шаге 2. Вызов [**ендфлуш**](/windows/desktop/api/Strmif/nf-strmif-ipin-endflush) информирует нисходящие фильтры о необходимости получения новых образцов, поэтому они не отклоняют их при повторном запуске потока на шаге 4.

Следующий частный метод выполняет шаги 1 – 4:


```C++
void CBallStream::UpdateFromSeek()
{
    if (ThreadExists()) 
    {
        DeliverBeginFlush();
        // Shut down the thread and stop pushing data.
        Stop();
        DeliverEndFlush();
        // Restart the thread and start pushing data again.
        Pause();
    }
}
```



Когда поток потоковой передачи снова запускается, он вызывает метод [**ксаурцестреам:: онсреадстартплай**](csourcestream-onthreadstartplay.md) . Переопределите этот метод для выполнения шагов 5 и 6:


```C++
HRESULT CBallStream::OnThreadStartPlay()
{
    m_bDiscontinuity = TRUE;
    return DeliverNewSegment(m_rtStart, m_rtStop, m_dRateSeeking);
}
```



В методе [**чанжестарт**](csourceseeking-changestart.md) задайте в качестве времени потока нулевое значение и расположение шарика на новое время начала. Затем вызовите Кбаллстреам:: Упдатефромсик:


```C++
HRESULT CBallStream::ChangeStart( )
{
    {
        CAutoLock lock(CSourceSeeking::m_pLock);
        m_rtSampleTime = 0;
        m_rtBallPosition = m_rtStart;
    }
    UpdateFromSeek();
    return S_OK;
}
```



В методе [**чанжестоп**](csourceseeking-changestop.md) вызовите кбаллстреам:: упдатефромсик, если новое время окончания меньше текущей позиции. В противном случае время прекращения остается в будущем, поэтому нет необходимости очищать граф.


```C++
HRESULT CBallStream::ChangeStop( )
{
    {
        CAutoLock lock(CSourceSeeking::m_pLock);
        if (m_rtBallPosition < m_rtStop)
        {
            return S_OK;
        }
    }

    // We're already past the new stop time. Flush the graph.
    UpdateFromSeek();
    return S_OK;
}
```



Для изменения ставок метод [**ксаурцесикинг:: сетрате**](csourceseeking-setrate.md) устанавливает для *m \_ дратесикинг* новую ставку (отменяя старое значение) перед вызовом [**чанжерате**](csourceseeking-changerate.md). Увы, если вызывающая сторона дала недопустимую скорость (например, меньше нуля), она слишком поздно вызываемой **чанжерате** времени. Одним из решений является переопределение **сетрате** и проверка допустимых ставок:


```C++
HRESULT CBallStream::SetRate(double dRate)
{
    if (dRate <= 1.0)
    {
        return E_INVALIDARG;
    }
    {
        CAutoLock lock(CSourceSeeking::m_pLock);
        m_dRateSeeking = dRate;
    }
    UpdateFromSeek();
    return S_OK;
}
// Now ChangeRate won't ever be called, but it's pure virtual, so it needs
// a dummy implementation.
HRESULT CBallStream::ChangeRate() { return S_OK; }
```



### <a name="drawing-in-the-buffer"></a>Рисование в буфере

Ниже приведена измененная версия [**ксаурцестреам:: филлбуффер**](csourcestream-fillbuffer.md)— подпрограммы, которая рисует шарик на каждом кадре:


```C++
HRESULT CBallStream::FillBuffer(IMediaSample *pMediaSample)
{
    BYTE *pData;
    long lDataLen;
    pMediaSample->GetPointer(&pData);
    lDataLen = pMediaSample->GetSize();
    {
        CAutoLock cAutoLockShared(&m_cSharedState);
        if (m_rtBallPosition >= m_rtStop) 
        {
            // End of the stream.
            return S_FALSE;
        }
        // Draw the ball in its current position.
        ZeroMemory( pData, lDataLen );
        m_Ball->MoveBall(m_rtBallPosition);
        m_Ball->PlotBall(pData, m_BallPixel, m_iPixelSize);
        
        // The sample times are modified by the current rate.
        REFERENCE_TIME rtStart, rtStop;
        rtStart = static_cast<REFERENCE_TIME>(
                      m_rtSampleTime / m_dRateSeeking);
        rtStop  = rtStart + static_cast<int>(
                      m_iRepeatTime / m_dRateSeeking);
        pMediaSample->SetTime(&rtStart, &rtStop);

        // Increment for the next loop.
        m_rtSampleTime += m_iRepeatTime;
        m_rtBallPosition += m_iRepeatTime;
    }
    pMediaSample->SetSyncPoint(TRUE);
    if (m_bDiscontinuity) 
    {
        pMediaSample->SetDiscontinuity(TRUE);
        m_bDiscontinuity = FALSE;
    }
    return NOERROR;
}
```



Ниже приведены основные различия между этой и исходной версиями.

-   Как упоминалось ранее, переменная *m \_ ртбаллпоситион* используется для задания расположения шарика, а не потокового времени.
-   После удержания критической секции метод проверяет, превышает ли текущая позиция время окончания. Если да, то возвращается **\_ значение false**, которое сигнализирует базовому классу прекратить отправку данных и доставить уведомление о завершении потока.
-   Метки времени делятся на текущую ставку.
-   Если *m \_ Бдисконтинуити* имеет **значение true**, метод устанавливает флаг небесперебойности в образце.

Существует еще одно небольшое отличие. Поскольку исходная версия использует ровно один буфер, она заполняет весь буфер нулями один раз, когда начинается потоковая передача. После этого шарик просто удаляется из предыдущего места. Однако эта оптимизация раскрывает незначительную ошибку в фильтре шарика. Когда метод [**кбасеаутпутпин::D еЦидеаллокатор**](cbaseoutputpin-decideallocator.md) вызывает [**Имеминпутпин:: нотифяллокатор**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-notifyallocator), он устанавливает для флага только для чтения **значение false**. В результате подчиненный фильтр может записываться в буфер. Одним из решений является переопределение **деЦидеаллокатор** для установки флага "только для чтения" в **значение true**. Однако для простоты новая версия просто полностью удаляет оптимизацию. Вместо этого эта версия заполняет буфер нулями каждый раз.

### <a name="miscellaneous-changes"></a>Прочие изменения

В новой версии эти две строки удаляются из конструктора Кбалл:


```C++
    m_iRandX = rand();
    m_iRandY = rand();
```



Фильтр исходного шарика использует эти значения для добавления случайных значений в исходное расположение шарика. Для наших целей мы хотим, чтобы шарик был детерминированным. Кроме того, некоторые переменные были изменены с объектов [**крефтиме**](creftime.md) на [**переменные \_ времени ссылки**](reference-time.md) . (Класс **крефтиме** является тонкой оболочкой для значения **\_ времени ссылки** .) Наконец, реализация [**икуалитиконтрол:: notify**](/windows/desktop/api/Strmif/nf-strmif-iqualitycontrol-notify) немного изменилась; Дополнительные сведения можно найти в исходном коде.

## <a name="limitations-of-the-csourceseeking-class"></a>Ограничения класса Ксаурцесикинг

Класс [**ксаурцесикинг**](csourceseeking.md) не предназначен для фильтров с несколькими выходными контактами из-за проблем с обменом данными между контактами. Например, представьте фильтр анализатора, который получает поток аудио-видео с чередованием, разбивает поток на аудио и видео компоненты и доставляет видео из одного выходного ПИН-кода и звука из другого. Оба контакта вывода будут принимать все команды Seek, но фильтр будет искать только один раз для каждой команды Seek. Решение заключается в назначении одного из контактов для управления поиском и пропуска команд поиска, полученных другим ПИН-кодом.

Однако после команды Seek оба ПИН-кода должны сбрасывать данные. Чтобы усложнить дальнейшие операции, команда Seek выполняется в потоке приложения, а не в потоке потоковой передачи. Поэтому необходимо убедиться, что ни один из ПИН-кодов не заблокирован и не ожидает возврата вызова [**имеминпутпин:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) , либо это может привести к взаимоблокировке. Дополнительные сведения о потокобезопасный сброс в ПИН-кодах см. в разделе [потоки и критические разделы](threads-and-critical-sections.md).

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Запись фильтров источника](writing-source-filters.md)
</dt> </dl>

 

 



