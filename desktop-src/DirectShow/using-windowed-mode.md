---
description: Использование оконного режима
ms.assetid: 09ee4568-348b-4cf9-bb38-dada291cdef9
title: Использование оконного режима
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: fd5f71bfa58e46ade8c779e562278f908c8b8fd593989ed4007e6b98cb7916da
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119633094"
---
# <a name="using-windowed-mode"></a>Использование оконного режима

> [!Note]  
> Устаревший [Фильтр модуля подготовки отчетов видео](video-renderer-filter.md) всегда использует оконный режим. Фильтры VMR-7 и VMR-9 используют оконный режим по умолчанию, но также поддерживают режим без окон.

 

В оконном режиме модуль подготовки отчетов создает собственное окно, в котором он рисует кадры видео. Если не указано иное, это окно верхнего уровня с собственными границами и заголовком окна. Однако в большинстве случаев окно видео будет присоединено к окну приложения, чтобы оно было интегрировано в пользовательский интерфейс приложения. Для этого необходимо выполнить следующие действия:

1.  Запрос для **ивидеовиндов**.
2.  Задайте родительское окно.
3.  Установить новые стили окна.
4.  Расположение окна видео в окне "владелец".
5.  Уведомление окна видео о \_ перемещении сообщений WM.

**Запрос для Ивидеовиндов**

прежде чем начать воспроизведение, выполните запрос фильтра Graph Manager для интерфейса **ивидеовиндов** :


```C++
IVideoWindow *pVidWin = NULL;
pGraph->QueryInterface(IID_IVideoWindow, (void **)&pVidWin);
```



**Задание родительского окна**

Чтобы задать родительское окно, вызовите метод [**ивидеовиндов::p UT \_ owner**](/windows/desktop/api/Control/nf-control-ivideowindow-put_owner) с помощью маркера окна приложения. Этот метод принимает переменную типа [**оахвнд**](oahwnd.md), поэтому приведите этот обработчик к этому типу:


```C++
pVidWin->put_Owner((OAHWND)hwnd);
```



**Установить новые стили окна**

Измените стиль окна видео, вызвав метод [**ивидеовиндов::p UT \_ WindowStyle**](/windows/desktop/api/Control/nf-control-ivideowindow-put_windowstyle) :


```C++
pVidWin->put_WindowStyle(WS_CHILD | WS_CLIPSIBLINGS);
```



Флаг WS \_ дочернего окна устанавливает, что окно является дочерним, а \_ флаг WS клипсиблингс предотвращает Рисование окна внутри клиентской области другого дочернего окна.

**Расположение окна видео**

Чтобы задать расположение видео относительно клиентской области окна приложения, вызовите метод [**ивидеовиндов:: сетвиндовпоситион**](/windows/desktop/api/Control/nf-control-ivideowindow-setwindowposition) . Этот метод принимает прямоугольник, указывающий левую границу, верхнюю границу, ширину и высоту окна видео. Например, следующий код растягивает окно видео в соответствии со всей клиентской областью родительского окна:


```C++
RECT rc;
GetClientRect(hwnd, &rc);
pVidWin->SetWindowPosition(0, 0, rc.right, rc.bottom);
```



чтобы получить собственный размер видео, вызовите метод [**ибасиквидео:: жетвидеосизе**](/windows/desktop/api/Control/nf-control-ibasicvideo-getvideosize) в фильтре Graph Manager. Эти сведения можно использовать для масштабирования видео и сохранения правильных пропорций.

**Реагирование на \_ сообщения о перемещении WM**

Для лучшей производительности следует уведомлять модуль подготовки отчетов каждый раз, когда окно перемещается во время приостановки графа. Вызовите метод [**ивидеовиндов:: нотифйовнермессаже**](/windows/desktop/api/Control/nf-control-ivideowindow-notifyownermessage) для пересылки \_ сообщения о перемещении WM:


```C++
// (Inside your WindowProc)
case WM_MOVE:
    pVidWin->NotifyOwnerMessage((OAHWND)hWnd, msg, wParam, lParam);
    break;
```



Если модуль подготовки отчетов использует наложение оборудования, это уведомление приводит к тому, что модуль подготовки отчетов обновляет расположение оверлея. (VMR-9 не использует наложение, поэтому вам не нужно вызывать этот метод, если вы используете VMR-9.)

**Очистить**

Перед выходом из приложения остановите граф и сбросьте владельца видео на **значение NULL**. В противном случае сообщения окна могут быть отправлены в неправильное окно, что может вызвать ошибки. Кроме того, можно скрыть окно видео или на экране мгновенно заметить мерцание изображения:


```C++
pControl->Stop(); 
pVidWin->put_Visible(OAFALSE);
pVidWin->put_Owner(NULL);  
```



> [!Note]  
> если родительский элемент окна видео является дочерним по отношению к главному окну приложения (иными словами, если окно видео является дочерним для дочернего элемента), следует создать видеоокно с помощью **cocreateinstance** и добавить его в граф, не разрешая Graph Manager добавлять модуль подготовки видео во время [интеллектуальной Подключение](intelligent-connect.md). Это гарантирует, что окно видео и его дочернее окно будут перерисовываться в одно и то же время. В противном случае дочернее окно может перерисовываться через окно видео.

 

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Рендеринг видео](video-rendering.md)
</dt> </dl>

 

 



