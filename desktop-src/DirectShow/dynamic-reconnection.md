---
description: Динамическое повторное подключение
ms.assetid: 5b777f64-6b62-48dd-8eae-6603582a452a
title: Динамическое повторное подключение
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a7b558a2e00ee2577cf1d31dda7aaebb15b5bd740c6dad5689e70b950c02d4d9
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119966163"
---
# <a name="dynamic-reconnection"></a>Динамическое повторное подключение

в большинстве фильтров DirectShow пин-коды не могут быть повторно подключены, пока граф активно потоковая передача данных. Приложение должно прерывать граф перед повторной подсоединением ПИН-кодов. Однако некоторые фильтры поддерживают повторное подключение ПИН-кода во время работы графа, процесс, называемый динамическим повторным подключением. Это можно сделать либо с помощью приложения, либо с помощью фильтра в графе.

В качестве примера рассмотрим диаграмму, показанную на следующем рисунке.

![Схема создания динамических диаграмм](images/dyngraph.png)

Одним из сценариев динамического повторного подключения может быть удаление фильтра 2 из диаграммы, во время работы графа и замена его другим фильтром. Для работы этого сценария должны выполняться следующие условия.

-   Входной ПИН-код фильтра 3 (ПИН-код D) должен поддерживать интерфейс [**ипинконнектион**](/windows/desktop/api/Strmif/nn-strmif-ipinconnection) . Этот интерфейс позволяет повторно подключить ПИН-код без остановки фильтра.
-   Закрепление вывода на фильтре 1 (ПИН-код A) должно иметь возможность блокировать поток данных мультимедиа во время повторного подключения. Никакие данные не перемещаются между закреплением A и ПИН-кодом D во время повторного подключения. Как правило, это означает, что выходной ПИН-код должен поддерживать интерфейс [**ипинфловконтрол**](/windows/desktop/api/Strmif/nn-strmif-ipinflowcontrol) . Однако если фильтр 1 является фильтром, который инициирует повторное подключение, он может иметь некоторый внутренний механизм для блокировки собственного потока данных.

Динамическое повторное подключение будет состоять из следующих шагов:

1.  Блокировка потока данных от закрепления.
2.  Повторно подключите ПИН-код A к ПИН-коду D, возможно, через новый промежуточный фильтр.
3.  Разблокируйте ПИН-код A, чтобы начать потоковую передачу данных.

**Шаг 1. Блокировка потока данных**

Чтобы заблокировать поток данных, вызовите [**ипинфловконтрол:: Block**](/windows/desktop/api/Strmif/nf-strmif-ipinflowcontrol-block) при закреплении A. Этот метод может вызываться либо асинхронно, либо синхронно. Для *асинхронного* вызова метода создайте объект события Win32 и передайте его в метод **Block** . Метод будет возвращаться немедленно. Дождитесь получения сигнала о событии, используя функцию, такую как **WaitForSingleObject**. ПИН-код сигнализирует о событии, когда оно заблокировало поток данных. Например:


```C++
// Create an event
HANDLE hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
if (hEvent != NULL)
{
    // Block the data flow.
    hr = pFlowControl->Block(AM_PIN_FLOW_CONTROL_BLOCK, hEvent); 
    if (SUCCEEDED(hr))
    {
        // Wait for the pin to finish.
        DWORD dwRes = WaitForSingleObject(hEvent, dwMilliseconds);
    }
}
```



Для *синхронного* вызова метода просто передайте значение **null** вместо обработчика события. Теперь метод будет блокироваться до завершения операции. Это может произойти, пока ПИН-код не будет готов к доставке нового примера. Если фильтр приостановлен, это может занять произвольный промежуток времени. Поэтому не следует выполнять синхронный вызов из основного потока приложения. Используйте Рабочий поток или иначе вызовите метод асинхронно.

**Шаг 2. Повторное подключение ПИН-кодов**

чтобы повторно подключить пин-коды, выполните запрос фильтра Graph Manager для интерфейса **играфконфиг** и вызовите либо [**играфконфиг:: reconnect**](/windows/desktop/api/Strmif/nf-strmif-igraphconfig-reconnect) , либо [**играфконфиг:: reconnect**](/windows/desktop/api/Strmif/nf-strmif-igraphconfig-reconfigure). Метод **Reconnect** проще использовать; Он выполняет следующие действия:

-   Останавливает промежуточные фильтры (фильтр 2 в примере) и удаляет их из диаграммы.
-   При необходимости добавляет новые промежуточные фильтры.
-   Подключает все контакты.
-   Приостанавливает или запускает новые фильтры для сопоставления с состоянием графа.

Метод **Reconnect** имеет несколько необязательных параметров, которые можно использовать для указания типа носителя для соединения с ПИН-кодом и промежуточного фильтра для использования. Например:


```C++
pGraph->AddFilter(pNewFilter, L"New Filter for the Graph");
pConfig->Reconnect(
    pPinA,      // Reconnect this output pin...
    pPinD,      // ... to this input pin.
    pMediaType, // Use this media type.
    pNewFilter, // Connect them through this filter.
    NULL, 
    0);     
```



Дополнительные сведения см. на странице справки. Если метод **Reconnect** недостаточно гибок, можно использовать метод **Reconnect** , который вызывает определенный приложением метод обратного вызова для повторного подключения ПИН-кодов. Чтобы использовать этот метод, реализуйте интерфейс [**играфконфигкаллбакк**](/windows/desktop/api/Strmif/nn-strmif-igraphconfigcallback) в приложении.

Перед вызовом функции **перенастройки** заблокируйте поток данных из выходного ПИН-кода, как описано выше. Затем отправьте все данные, которые все еще ожидают, в разделе графа, к которому выполняется повторное подключение, следующим образом:

1.  Вызовите [**ипинконнектион:: нотифендофстреам**](/windows/desktop/api/Strmif/nf-strmif-ipinconnection-notifyendofstream) для входного ПИН-кода, расположенного в самом низком направлении в цепочке повторного подключения (в примере это ПИН-код D). Передайте маркер в событие Win32.
2.  Вызовите [**Ипин:: EndOfStream**](/windows/desktop/api/Strmif/nf-strmif-ipin-endofstream) для входного ПИН-кода, который непосредственно находится за выходным закреплением, в котором поток данных заблокирован. (В этом примере поток данных был заблокирован на закрепление A, поэтому вы бы вызывали **EndOfStream** для контакта B.)
3.  Дождитесь получения сигнала о событии. Входной ПИН-код (ПИН-код D) сигнализирует о событии при получении уведомления о завершении потока. Это означает, что данные не передаются между контактами и что вызывающий объект может безопасно повторно подключить ПИН-коды.

Обратите внимание, что метод **играфконфиг:: Reconnect** автоматически обрабатывает предыдущие шаги. Эти действия необходимо выполнить только при использовании метода **RECONFIGURE** .

После передачи данных через граф вызовите метод **RECONFIGURE** и передайте указатель на интерфейс обратного вызова **играфконфигкаллбакк** . диспетчер Graphа фильтра будет вызывать указанный метод [**играфконфигкаллбакк:: reconfigure**](/windows/desktop/api/Strmif/nf-strmif-igraphconfigcallback-reconfigure) .

**Шаг 3. Разблокирование Flow данных**

После повторного подключения ПИН-кода Разблокируйте поток данных, вызвав **ипинфловконтрол:: Block** со значением, равным нулю, для первого параметра.

> [!Note]  
> Если динамическое повторное подключение выполняется фильтром, необходимо знать о некоторых проблемах с потоками. если диспетчер Graph Manager пытается отключить фильтр, это может привести к взаимоблокировке, так как граф ожидает завершения фильтра, в то время как фильтр может ожидать передачи данных через граф. Чтобы предотвратить возможную взаимоблокировку, некоторые методы, описанные в этом разделе, принимают в качестве маркера событие Win32. фильтр должен сообщить о событии, если фильтр Graph Manager пытается прерывать фильтр. Дополнительные сведения см. в разделе [**играфконфиг**](/windows/desktop/api/Strmif/nn-strmif-igraphconfig) и [**ипинконнектион**](/windows/desktop/api/Strmif/nn-strmif-ipinconnection).

 

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[динамическая сборка Graph](dynamic-graph-building.md)
</dt> </dl>

 

 



