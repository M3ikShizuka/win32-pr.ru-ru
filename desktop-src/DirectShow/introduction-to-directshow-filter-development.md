---
description: общие сведения о разработке фильтров DirectShow
ms.assetid: d5162ea4-ef37-4993-a82c-782f03b08c64
title: общие сведения о разработке фильтров DirectShow
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: f2769cfe3bd4f046c117c0567104094bcad0eed730c388b551593dde6b41df25
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "120083694"
---
# <a name="introduction-to-directshow-filter-development"></a>общие сведения о разработке фильтров DirectShow

в этом разделе приводится краткий обзор задач, связанных с разработкой настраиваемого фильтра DirectShow. Здесь также приводятся ссылки на разделы, в которых более подробно рассматриваются эти задачи. перед чтением этого раздела ознакомьтесь с разделами [о DirectShow](about-directshow.md), в которых описывается общая архитектура DirectShow.

**DirectShow Библиотека базовых классов**

пакет SDK для DirectShow включает набор классов C++ для записи фильтров. Хотя это и не является обязательным, эти классы являются рекомендуемым способом записи нового фильтра. чтобы использовать базовые классы, скомпилируйте их в статическую библиотеку и свяжите lib-файл с проектом, как описано в разделе [создание фильтров DirectShow](building-directshow-filters.md).

Базовая библиотека классов определяет корневой класс для фильтров, класс [**кбасефилтер**](cbasefilter.md) . Несколько других классов являются производными от **кбасефилтер** и являются специализированными для определенных типов фильтров. Например, класс [**ктрансформфилтер**](ctransformfilter.md) предназначен для фильтров преобразований. Чтобы создать новый фильтр, Реализуйте класс, наследующий от одного из классов фильтров. Например, объявление класса может выглядеть следующим образом:


```C++
class CMyFilter : public CTransformFilter
{
private:
    /* Declare variables and methods that are specific to your filter.
public:
    /* Override various methods in CTransformFilter */
};
```



дополнительные сведения о базовых классах DirectShow см. в следующих разделах:

-   [DirectShow Базовые классы](directshow-base-classes.md)
-   [создание фильтров DirectShow](building-directshow-filters.md)

**Создание ПИН-кодов**

Фильтр должен создать один или несколько ПИН-кодов. Количество ПИН-кодов можно исправить во время разработки, или фильтр может создавать новые ПИН-коды по мере необходимости. ПИН-коды обычно являются производными от класса [**кбасепин**](cbasepin.md) или от класса, который наследует **Кбасепин**, например [**кбасеинпутпин**](cbaseinputpin.md). ПИН-коды фильтра должны объявляться как переменные-члены в классе Filter. Некоторые из классов фильтров уже определяют ПИН-коды, но если фильтр наследует непосредственно от **кбасефилтер**, необходимо объявить эти ПИН-коды в производном классе.

**Согласование соединений с ПИН-кодом**

когда диспетчер Graph фильтров пытается подключить два фильтра, пин-коды должны согласовать различные вещи. В противном случае попытка подключения завершится неудачей. Обычно ПИН-коды согласовывают следующее:

-   Transport. Транспорт — это механизм, который используется фильтрами для перемещения образцов мультимедиа из выходного крепления на входной ПИН-код. Например, они могут использовать интерфейс [**имеминпутпин**](/windows/desktop/api/Strmif/nn-strmif-imeminputpin) ("Push Model") или интерфейс [**иасинкреадер**](/windows/desktop/api/Strmif/nn-strmif-iasyncreader) ("модель извлечения").
-   Тип носителя. Почти все контакты используют типы носителей для описания формата данных, которые они будут доставлять.
-   Выделен. Распределитель — это объект, который создает буферы, в которых хранятся данные. ПИН-код должен согласиться с тем, какой PIN будет предоставлять распределитель. Они также должны согласовать размер буферов, число создаваемых буферов и другие свойства буфера.

Базовые классы реализуют платформу для этих согласований. Эти сведения необходимо выполнить путем переопределения различных методов в базовом классе. Набор методов, которые необходимо переопределить, зависит от класса и от функциональности фильтра. дополнительные сведения см. в разделе [как фильтры Подключение](how-filters-connect.md).

**Обработка и доставка данных**

Основная функция большинства фильтров — обработка и доставка данных мультимедиа. Как это происходит, зависит от типа фильтра:

-   Источник push-уведомлений содержит рабочий поток, который непрерывно заполняет образцы данными и доставляет их в нисходящий.
-   Источник извлечения ожидает, что его подчиненный сосед запрашивает пример. Он отвечает, записывая данные в пример и доставляя пример подчиненному фильтру. Нисходящий фильтр создает поток, который управляет потоком данных.
-   Фильтр преобразования содержит образцы, доставленные ему из вышестоящего соседнего узла. При получении образца он обрабатывает данные и доставляет их нисходящим.
-   Фильтр модуля подготовки отчетов получает образцы из вышестоящего представления и планирует их отрисовку на основе меток времени.

Другие задачи, связанные с потоковой передачей, включают запись данных из графа, обработку конца потока и реагирование на запросы поиска. Дополнительные сведения об этих проблемах см. в следующих разделах:

-   [Flow данных для разработчиков фильтров](data-flow-for-filter-developers.md)
-   [Управление качеством](quality-control-management.md)
-   [Потоки и критические разделы](threads-and-critical-sections.md)

**Поддержка COM**

фильтры DirectShow являются COM-объектами, обычно упакованными в библиотеки dll. Базовая библиотека классов реализует платформу для поддержки COM. он описан в разделе [DirectShow и COM](directshow-and-com.md).

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[написание фильтров DirectShow](writing-directshow-filters.md)
</dt> </dl>

 

 



