---
description: Введение в разработку фильтров DirectShow
ms.assetid: d5162ea4-ef37-4993-a82c-782f03b08c64
title: Введение в разработку фильтров DirectShow
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6a42c5d2437b32f521b0efc39775f186267d3c99
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "105682238"
---
# <a name="introduction-to-directshow-filter-development"></a>Введение в разработку фильтров DirectShow

В этом разделе приводится краткий обзор задач, связанных с разработкой пользовательского фильтра DirectShow. Здесь также приводятся ссылки на разделы, в которых более подробно рассматриваются эти задачи. Перед чтением этого раздела ознакомьтесь с подразделами [о DirectShow](about-directshow.md), в которых описывается общая архитектура DirectShow.

**Библиотека базовых классов DirectShow**

Пакет SDK для DirectShow включает набор классов C++ для записи фильтров. Хотя это и не является обязательным, эти классы являются рекомендуемым способом записи нового фильтра. Чтобы использовать базовые классы, скомпилируйте их в статическую библиотеку и свяжите LIB-файл с проектом, как описано в разделе [Создание фильтров DirectShow](building-directshow-filters.md).

Базовая библиотека классов определяет корневой класс для фильтров, класс [**кбасефилтер**](cbasefilter.md) . Несколько других классов являются производными от **кбасефилтер** и являются специализированными для определенных типов фильтров. Например, класс [**ктрансформфилтер**](ctransformfilter.md) предназначен для фильтров преобразований. Чтобы создать новый фильтр, Реализуйте класс, наследующий от одного из классов фильтров. Например, объявление класса может выглядеть следующим образом:


```C++
class CMyFilter : public CTransformFilter
{
private:
    /* Declare variables and methods that are specific to your filter.
public:
    /* Override various methods in CTransformFilter */
};
```



Дополнительные сведения о базовых классах DirectShow см. в следующих разделах:

-   [Базовые классы DirectShow](directshow-base-classes.md)
-   [Создание фильтров DirectShow](building-directshow-filters.md)

**Создание ПИН-кодов**

Фильтр должен создать один или несколько ПИН-кодов. Количество ПИН-кодов можно исправить во время разработки, или фильтр может создавать новые ПИН-коды по мере необходимости. ПИН-коды обычно являются производными от класса [**кбасепин**](cbasepin.md) или от класса, который наследует **Кбасепин**, например [**кбасеинпутпин**](cbaseinputpin.md). ПИН-коды фильтра должны объявляться как переменные-члены в классе Filter. Некоторые из классов фильтров уже определяют ПИН-коды, но если фильтр наследует непосредственно от **кбасефилтер**, необходимо объявить эти ПИН-коды в производном классе.

**Согласование соединений с ПИН-кодом**

Когда диспетчер графов фильтров пытается подключить два фильтра, ПИН-коды должны согласовать различные вещи. В противном случае попытка подключения завершится неудачей. Обычно ПИН-коды согласовывают следующее:

-   Transport. Транспорт — это механизм, который используется фильтрами для перемещения образцов мультимедиа из выходного крепления на входной ПИН-код. Например, они могут использовать интерфейс [**имеминпутпин**](/windows/desktop/api/Strmif/nn-strmif-imeminputpin) ("Push Model") или интерфейс [**иасинкреадер**](/windows/desktop/api/Strmif/nn-strmif-iasyncreader) ("модель извлечения").
-   Тип носителя. Почти все контакты используют типы носителей для описания формата данных, которые они будут доставлять.
-   Выделен. Распределитель — это объект, который создает буферы, в которых хранятся данные. ПИН-код должен согласиться с тем, какой PIN будет предоставлять распределитель. Они также должны согласовать размер буферов, число создаваемых буферов и другие свойства буфера.

Базовые классы реализуют платформу для этих согласований. Эти сведения необходимо выполнить путем переопределения различных методов в базовом классе. Набор методов, которые необходимо переопределить, зависит от класса и от функциональности фильтра. Дополнительные сведения см. в разделе [Подключение фильтров](how-filters-connect.md).

**Обработка и доставка данных**

Основная функция большинства фильтров — обработка и доставка данных мультимедиа. Как это происходит, зависит от типа фильтра:

-   Источник push-уведомлений содержит рабочий поток, который непрерывно заполняет образцы данными и доставляет их в нисходящий.
-   Источник извлечения ожидает, что его подчиненный сосед запрашивает пример. Он отвечает, записывая данные в пример и доставляя пример подчиненному фильтру. Нисходящий фильтр создает поток, который управляет потоком данных.
-   Фильтр преобразования содержит образцы, доставленные ему из вышестоящего соседнего узла. При получении образца он обрабатывает данные и доставляет их нисходящим.
-   Фильтр модуля подготовки отчетов получает образцы из вышестоящего представления и планирует их отрисовку на основе меток времени.

Другие задачи, связанные с потоковой передачей, включают запись данных из графа, обработку конца потока и реагирование на запросы поиска. Дополнительные сведения об этих проблемах см. в следующих разделах:

-   [Поток данных для разработчиков фильтров](data-flow-for-filter-developers.md)
-   [Управление качеством](quality-control-management.md)
-   [Потоки и критические разделы](threads-and-critical-sections.md)

**Поддержка COM**

Фильтры DirectShow — это COM-объекты, обычно Упакованные в библиотеки DLL. Базовая библиотека классов реализует платформу для поддержки COM. Он описан в разделе [DirectShow и com](directshow-and-com.md).

## <a name="related-topics"></a>См. также

<dl> <dt>

[Написание фильтров DirectShow](writing-directshow-filters.md)
</dt> </dl>

 

 



