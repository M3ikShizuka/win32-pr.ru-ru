---
description: Куерякцепт (вышестоящий)
ms.assetid: 3153e3a4-2227-4fdd-b2b0-218763013d2d
title: Куерякцепт (вышестоящий)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 7707c52d36c3d065c4a7277939f724aabdb73e46
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "103806472"
---
# <a name="queryaccept-upstream"></a>Куерякцепт (вышестоящий)

Этот механизм позволяет закреплять входные данные для предложения изменения формата вышестоящего однорангового узла. Нисходящий фильтр должен присоединить к образцу тип мультимедиа, который будет получать вышестоящий фильтр при следующем вызове [**имемаллокатор::-buffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer). Для этого, однако, нисходящий фильтр должен предоставить пользовательский распределитель для соединения. Этот распределитель должен реализовать частный метод, который нисходящий фильтр может использовать для задания типа мультимедиа в следующем примере.

Выполняются следующие действия.

1.  Нисходящий фильтр проверяет, использует ли соединение с закреплением пользовательский распределитель. Если вышестоящий фильтр владеет распределителем, нисходящий фильтр не может изменить его формат.
2.  Нисходящий фильтр вызывает [**Ипин:: куерякцепт**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) в качестве ПИН-кода вышестоящего вывода (см. иллюстрацию, шаг а).
3.  Если `QueryAccept` возвращается значение S \_ , нисходящий фильтр вызывает закрытый метод для своего распределителя, чтобы задать тип мультимедиа. В этом частном методе распределитель вызывает [**имедиасампле:: сетмедиатипе**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setmediatype) в следующем доступном примере (B).
4.  Вышестоящий фильтр вызывает метод **buffer** для получения нового образца (C) и [**Имедиасампле:: жетмедиатипе**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getmediatype) для получения типа мультимедиа (D).
5.  Когда вышестоящий фильтр доставляет пример, он должен оставить тип носителя, присоединенный к этому примеру. Таким образом, нисходящий фильтр может подтвердить, что тип мультимедиа изменился (E).

Если вышестоящий фильтр принимает изменение формата, он также должен иметь возможность вернуться к исходному типу носителя, как показано на следующей схеме.

![куерякцепт (вышестоящий)](images/dynformat4.png)

В основных примерах такого рода изменений формата используются модули подготовки видео DirectShow.

-   Исходный фильтр модуля [подготовки видео](video-renderer-filter.md) может переключаться между типами RGB и YUV во время потоковой передачи. При подключении фильтра требуется формат RGB, соответствующий текущим параметрам экрана. Это гарантирует, что он может вернуться на GDI, если это необходимо. После начала потоковой передачи, если доступен DirectDraw, модуль подготовки отчетов запрашивает изменение формата на YUV-тип. Позже она может вернуться к RGB, если по какой бы то ни было причине по какой бы то ни было возникать на поверхности DirectDraw.
-   Новый фильтр формирователя микширования видео (VMR) будет подключаться к любому формату, поддерживаемому графическим оборудованием, включая типы YUV. Однако графическое оборудование может изменить шаг базовой поверхности DirectDraw, чтобы оптимизировать производительность. Фильтр VMR использует `QueryAccept` для создания отчета о новом STRIDE, указанном в элементе **Бивидс** структуры **битмапинфохеадер** . Исходный и целевой прямоугольники в структуре **видеоинфохеадер** или **VIDEOINFOHEADER2** указывают область, в которой должно быть декодировано видео.

**Примечание о реализации**

Маловероятно, что вы напишете фильтр, который должен запрашивать изменения в вышестоящем формате, так как это в основном является функцией модулей подготовки видео. Однако при написании фильтра преобразования видео или видеодекодера фильтр должен правильно реагировать на запросы из модуля подготовки видео.

Фильтр на месте, расположенный между модулем подготовки видео и декодером, должен пройти все `QueryAccept` вызовы вышестоящего. Сохранять новые сведения о форматировании при поступлении.

Фильтр преобразования копий (т. е. нетранзакционный фильтр) должен реализовывать одно из следующих поведений:

-   Передает изменения формата в восходящий и сохраняет новые сведения о форматировании при поступлении. Фильтр должен использовать пользовательский распределитель, чтобы он мог присоединить формат к вышестоящему примеру.
-   Преобразование формата в фильтр. Возможно, это проще, чем передать восходящий формат изменения формата. Однако это может быть менее эффективным, чем возможность декодировать фильтр декодера в правильный формат.
-   В качестве крайней необходимости просто отклоните изменение формата. (Дополнительные сведения см. в исходном коде метода [**ктрансинплацеаутпутпин:: чеккмедиатипе**](ctransinplaceoutputpin-checkmediatype.md) в библиотеке базовых классов DirectShow.) Отклонение изменения формата может привести к снижению производительности, так как не позволяет модулю визуализации видео использовать наиболее эффективный формат.

В следующем псевдокоде показано, как можно реализовать фильтр преобразования копий (производный от **ктрансформфилтер**), который может переключаться между типами выходных данных YUV и RGB. В этом примере предполагается, что фильтр выполняет само преобразование, а не передает вышестоящее изменение формата.


```C++
HRESULT CMyTransform::CheckInputType(const CMediaType *pmt)
{
    if (pmt is a YUV type that you support) {
        return S_OK;
    }
    else {
        return VFW_E_TYPE_NOT_ACCEPTED;
    }
}

HRESULT CMyTransform::CheckTransform(
    const CMediaType *mtIn, const CMediaType *mtOut)
{
    if (mtOut is a YUV or RGB type that you support)
    {
        if ((mtIn has the same video dimensions as mtOut) &&
            (you support the mtIn-to-mtOut transform))
        {
            return S_OK;
        }
    }
    // otherwise
    return VFW_E_TYPE_NOT_ACCEPTED;
}

// GetMediaType: Return a preferred output type.
HRESULT CMyTransform::GetMediaType(int iPosition, CMediaType *pMediaType)
{
    if (iPosition < 0) {
        return E_INVALIDARG;
    }
    switch (iPosition)
    {
    case 0:
        Copy the input type (YUV) to pMediaType
        return S_OK;
    case 1:
        Construct an RGB type that matches the input type.
        return S_OK;
    default:
        return VFW_S_NO_MORE_ITEMS;
    }
}

// SetMediaType: Override from CTransformFilter. 
HRESULT CMyTransform::SetMediaType(
    PIN_DIRECTION direction, const CMediaType *pmt)
{
    // Capture this information...
    if (direction == PINDIR_OUTPUT)
    {
       m_bYuv = (pmt->subtype == MEDIASUBTYPE_UYVY);
    }
    return S_OK;
}

HRESULT CMyTransform::Transform(
    IMediaSample *pSource, IMediaSample *pDest)
{
    // Look for format changes from downstream.
    CMediaType *pMT = NULL;
    HRESULT hr = pDest->GetMediaType((AM_MEDIA_TYPE**)&pMT);
    if (hr == S_OK)
    {
        hr = m_pOutput->CheckMediaType(pMT);
        if(FAILED(hr))
        {
            DeleteMediaType(pMT);
            return E_FAIL;
        }
        // Notify our own output pin about the new type.
        m_pOutput->SetMediaType(pMT);
        DeleteMediaType(pMT);
    }
    // Process the buffers
    if (m_bYuv) {
        return ProcessFrameYUV(pSource, pDest);
    }
    else {
        return ProcessFrameRGB(pSource, pDest);
    }
}
```



 

 



