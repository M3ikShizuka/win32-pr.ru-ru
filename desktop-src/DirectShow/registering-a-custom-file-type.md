---
description: в этой статье описывается, как диспетчер Graph Manager находит фильтр источника по заданному имени файла.
ms.assetid: bc0d5719-6325-40fe-8261-ad00b91f272c
title: Регистрация пользовательского типа файла
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1e98c01555497ac628fff452f464c826475edbb8
ms.sourcegitcommit: d75fc10b9f0825bbe5ce5045c90d4045e3c53243
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/13/2021
ms.locfileid: "127246436"
---
# <a name="registering-a-custom-file-type"></a>Регистрация пользовательского типа файла

в этой статье описывается, как диспетчер Graph Manager находит фильтр источника по заданному имени файла. Этот механизм можно использовать для регистрации собственных пользовательских типов файлов. после регистрации типа файла DirectShow будет автоматически загружать правильный фильтр источника всякий раз, когда приложение вызывает [**играфбуилдер:: RenderFile**](/windows/desktop/api/Strmif/nf-strmif-igraphbuilder-renderfile) или [**играфбуилдер:: аддсаурцефилтер**](/windows/desktop/api/Strmif/nf-strmif-igraphbuilder-addsourcefilter).

-   [Обзор](#overview)
-   [Протоколы](#protocols)
-   [Расширения файлов](#file-extensions)
-   [Проверить байты](#check-bytes)
-   [Загрузка фильтра источника](#loading-the-source-filter)
-   [пользовательские типы файлов в проигрыватель Windows Media](#custom-file-types-in-windows-media-player)
-   [Связанные темы](#related-topics)

## <a name="overview"></a>Обзор

чтобы указать фильтр источника по заданному имени файла, фильтр Graph Manager пытается выполнить следующие действия в указанном порядке:

1.  Соответствует протоколу, если он есть.
2.  Соответствует расширению файла.
3.  Совпадение с шаблонами байтов в файле, называемыми *Check bytes*.

## <a name="protocols"></a>Протоколы

Такие имена протоколов, как FTP или HTTP, регистрируются в

**\_корневой узел классов hKey \_**

(ключ) со следующей структурой:


```C++
HKEY_CLASSES_ROOT
    <protocol>
        Source Filter = <Source filter CLSID>
        Extensions
            <.ext1> = <Source filter CLSID>
            <.ext2> = <Source filter CLSID>
```



если имя или URL-адрес файла содержит двоеточие (":"), фильтр Graph Manager пытается использовать часть, предшествующую ":", в качестве имени протокола. Например, если имя — "myprot://myfile.ext", выполняется поиск раздела реестра с именем **мипрот**. если этот ключ существует и содержит подраздел с именем extensions, то фильтр Graph Manager ищет в этом подразделе записи, соответствующие расширению файла. Значение ключа должно быть идентификатором GUID в строковом формате. Например, " {00000000-0000-0000-0000-000000000000} ". если фильтр Graph Manager не может сопоставить что-либо в подразделе **extensions** , он ищет подраздел с именем **Source Filter**, который также должен быть идентификатором GUID в строковом формате.

если фильтр Graph Manager находит соответствующий GUID, он использует его в качестве идентификатора CLSID фильтра источника и пытается загрузить фильтр. Если совпадение не найдено, используется фильтр [источника файлов (URL-адрес)](file-source--url--filter.md) , который считает имя файла URL-адресом.

Существует два исключения из этого алгоритма:

-   Чтобы исключить буквы драйверов, строки с одним символом не считаются протоколами.
-   Если строка имеет значение "file:" или "file://", она не рассматривается как протокол.

## <a name="file-extensions"></a>Расширения файлов

если в имени файла нет протокола, фильтр Graph Manager просматривает в реестре записи с ключевыми **\_ \_ \\ \\ расширениями \\ класса HKEY ROOT Media types**.*Ext* \\ , где.*Ext* — это расширение файла. Если этот ключ существует, **Фильтр источника** значения содержит идентификатор CLSID исходного фильтра в виде строки. При необходимости ключ может иметь значения для **типа мультимедиа** и подтип, который предоставляет основной тип и идентификатор GUID **подтипа.**

## <a name="check-bytes"></a>Проверить байты

Некоторые типы файлов могут определяться конкретными шаблонами битов, происходящими по конкретным смещениям байтов в файле. фильтр Graph Manager просматривает реестр на предмет разделов в следующем формате:

**HKey \_ \_Корневой \\ \\ элемент класса MediaType**{ *основной тип* } \\ { *подтип* }

где *основной тип* и *подтип* являются идентификаторами GUID, определяющими тип мультимедиа для потока байтов. Каждый ключ содержит один или несколько подразделов, обычно именуемых 1, 2 и т. д., которые определяют байты проверки; и подраздела с именем **Исходный фильтр** , который предоставляет CLSID исходного фильтра в виде строки. Подразделы Check-Byte — это строки, содержащие одно или несколько четырех чисел, которые называются:

*СМЕЩ*, *CB*, *Mask*, *Val*

чтобы сопоставить этот файл, диспетчер Graph Manager считывает данные о cb в байтах, начиная с смещения числа байтов. Затем он выполняет операцию побитового и относительно значения в маске. Если результат равен Val, то файл будет соответствовать этому четырем. Значения Mask и Val задаются в шестнадцатеричном формате. Пустая запись для Mask обрабатывается как строка из 1 длинного значения CB. Отрицательное значение смещения указывает смещение от конца файла. Чтобы сопоставить ключ, файл должен соответствовать всем четырем из этих четырех подразделов.

Например, предположим, что реестр содержит следующие ключи в **\\ типе носителя HKCR**:


```C++
{e436eb83-524f-11ce-9f53-0020af0ba770}
    {7364696D-0000-0010-8000-00AA00389B71}
        0                    "0,4,,52494646,8,4,,524D4944"
        1                    "0,4,,4D546864"
        Source Filter        "{E436EBB5-524F-11CE-9F53-0020AF0BA770}"
```



Первый ключ соответствует \_ потоку типа MEDIATYPE. Подраздел ниже, соответствующий подтипу MEDIATYPE \_ MIDI. Значение для подраздела фильтра источника — CLSID \_ асинкреадер, CLSID фильтра [File Source (Async)](file-source--async--filter.md) .

Каждая запись может иметь несколько четверок; Все они должны совпадать. В следующем примере первые 4 байта файла должны быть 0xAB, 0xCD, 0x12, 0x34; и последние 4 байта файла должны быть 0xAB, 0xAB, 0x00, 0xAB:


```C++
    0, 4, , ABCD1234,  -4, 4, , ABAB00AB 
```



Кроме того, в одном типе носителя может присутствовать несколько записей. Достаточно совпадений с любым из них. Эта схема обеспечивает набор альтернативных масок. Например, WAV-файлы, которые могут иметь или не иметь заголовок Metallica.

> [!Note]  
> Эта схема похожа на ту, которая используется функцией [**жетклассфиле**](/windows/win32/api/objbase/nf-objbase-getclassfile) .

 

## <a name="loading-the-source-filter"></a>Загрузка фильтра источника

предполагая, что фильтр Graph Manager находит соответствующий фильтр источника для файла, он добавляет этот фильтр к графу, запрашивает фильтр для интерфейса [**ифилесаурцефилтер**](/windows/desktop/api/Strmif/nn-strmif-ifilesourcefilter) и вызывает [**ифилесаурцефилтер:: Load**](/windows/desktop/api/Strmif/nf-strmif-ifilesourcefilter-load). Аргументы метода **Load** — это имя файла и тип носителя, как определено в реестре.

если фильтр Graph Manager не может найти что-либо из реестра, по умолчанию используется фильтр асинхронного файла. В этом случае он задает тип носителя **\_ Stream**, **медиасубтипе \_ None**.

## <a name="custom-file-types-in-windows-media-player"></a>пользовательские типы файлов в проигрыватель Windows Media

проигрыватель Windows Media использует дополнительный набор записей реестра. дополнительные сведения см. в разделе [реестр расширений имен файлов Параметры](../wmp/file-name-extension-registry-settings.md) в пакете SDK для проигрыватель Windows Media.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[написание фильтров DirectShow](writing-directshow-filters.md)
</dt> </dl>

 

 
