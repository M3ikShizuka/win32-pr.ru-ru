---
description: В этой статье описывается, как диспетчер графов фильтров находит фильтр источника по заданному имени файла.
ms.assetid: bc0d5719-6325-40fe-8261-ad00b91f272c
title: Регистрация пользовательского типа файла
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1e98c01555497ac628fff452f464c826475edbb8
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "105672998"
---
# <a name="registering-a-custom-file-type"></a>Регистрация пользовательского типа файла

В этой статье описывается, как диспетчер графов фильтров находит фильтр источника по заданному имени файла. Этот механизм можно использовать для регистрации собственных пользовательских типов файлов. После регистрации типа файла DirectShow автоматически загрузит правильный фильтр источника всякий раз, когда приложение вызывает [**играфбуилдер:: renderFile**](/windows/desktop/api/Strmif/nf-strmif-igraphbuilder-renderfile) или [**Играфбуилдер:: аддсаурцефилтер**](/windows/desktop/api/Strmif/nf-strmif-igraphbuilder-addsourcefilter).

-   [Обзор](#overview)
-   [Протоколы](#protocols)
-   [Расширения файлов](#file-extensions)
-   [Проверить байты](#check-bytes)
-   [Загрузка фильтра источника](#loading-the-source-filter)
-   [Пользовательские типы файлов в проигрывателе Windows Media](#custom-file-types-in-windows-media-player)
-   [См. также](#related-topics)

## <a name="overview"></a>Обзор

Чтобы указать фильтр источника по заданному имени файла, диспетчер графа фильтров пытается выполнить следующие действия в указанном порядке:

1.  Соответствует протоколу, если он есть.
2.  Соответствует расширению файла.
3.  Совпадение с шаблонами байтов в файле, называемыми *Check bytes*.

## <a name="protocols"></a>Протоколы

Такие имена протоколов, как FTP или HTTP, регистрируются в

**\_корневой узел классов hKey \_**

(ключ) со следующей структурой:


```C++
HKEY_CLASSES_ROOT
    <protocol>
        Source Filter = <Source filter CLSID>
        Extensions
            <.ext1> = <Source filter CLSID>
            <.ext2> = <Source filter CLSID>
```



Если имя или URL-адрес файла содержит двоеточие (":"), диспетчер графа фильтров пытается использовать часть, предшествующую ":", в качестве имени протокола. Например, если имя — "myprot://myfile.ext", выполняется поиск раздела реестра с именем **мипрот**. Если этот ключ существует и содержит подраздел с именем Extensions, диспетчер графов фильтров ищет в этом подразделе записи, соответствующие расширению файла. Значение ключа должно быть идентификатором GUID в строковом формате. Например, " {00000000-0000-0000-0000-000000000000} ". Если диспетчер графов фильтров не может сопоставить что-либо в подразделе **Extensions** , он ищет подраздел с именем **Source Filter**, который также должен быть идентификатором GUID в строковом формате.

Если диспетчер графов фильтров находит соответствующий GUID, он использует его в качестве идентификатора CLSID для фильтра источника и пытается загрузить фильтр. Если совпадение не найдено, используется фильтр [источника файлов (URL-адрес)](file-source--url--filter.md) , который считает имя файла URL-адресом.

Существует два исключения из этого алгоритма:

-   Чтобы исключить буквы драйверов, строки с одним символом не считаются протоколами.
-   Если строка имеет значение "file:" или "file://", она не рассматривается как протокол.

## <a name="file-extensions"></a>Расширения файлов

Если в имени файла нет протокола, диспетчер графа фильтров ищет в реестре записи с ключевыми **\_ \_ \\ \\ расширениями \\ класса hKey root Media Types**.*Ext* \\ , где.*Ext* — это расширение файла. Если этот ключ существует, **Фильтр источника** значения содержит идентификатор CLSID исходного фильтра в виде строки. При необходимости ключ может иметь значения для **типа мультимедиа** и подтип, который предоставляет основной тип и идентификатор GUID **подтипа.**

## <a name="check-bytes"></a>Проверить байты

Некоторые типы файлов могут определяться конкретными шаблонами битов, происходящими по конкретным смещениям байтов в файле. Диспетчер графов фильтров ищет в реестре ключи в следующем формате:

**HKey \_ \_Корневой \\ \\ элемент класса MediaType**{ *основной тип* } \\ { *подтип* }

где *основной тип* и *подтип* являются идентификаторами GUID, определяющими тип мультимедиа для потока байтов. Каждый ключ содержит один или несколько подразделов, обычно именуемых 1, 2 и т. д., которые определяют байты проверки; и подраздела с именем **Исходный фильтр** , который предоставляет CLSID исходного фильтра в виде строки. Подразделы Check-Byte — это строки, содержащие одно или несколько четырех чисел, которые называются:

*СМЕЩ*, *CB*, *Mask*, *Val*

Чтобы сопоставить этот файл, диспетчер графа фильтров считывает значения CB в байтах, начиная с смещения числа байтов. Затем он выполняет операцию побитового и относительно значения в маске. Если результат равен Val, то файл будет соответствовать этому четырем. Значения Mask и Val задаются в шестнадцатеричном формате. Пустая запись для Mask обрабатывается как строка из 1 длинного значения CB. Отрицательное значение смещения указывает смещение от конца файла. Чтобы сопоставить ключ, файл должен соответствовать всем четырем из этих четырех подразделов.

Например, предположим, что реестр содержит следующие ключи в **\\ типе носителя HKCR**:


```C++
{e436eb83-524f-11ce-9f53-0020af0ba770}
    {7364696D-0000-0010-8000-00AA00389B71}
        0                    "0,4,,52494646,8,4,,524D4944"
        1                    "0,4,,4D546864"
        Source Filter        "{E436EBB5-524F-11CE-9F53-0020AF0BA770}"
```



Первый ключ соответствует \_ потоку типа MEDIATYPE. Подраздел ниже, соответствующий подтипу MEDIATYPE \_ MIDI. Значение для подраздела фильтра источника — CLSID \_ асинкреадер, CLSID фильтра [File Source (Async)](file-source--async--filter.md) .

Каждая запись может иметь несколько четверок; Все они должны совпадать. В следующем примере первые 4 байта файла должны быть 0xAB, 0xCD, 0x12, 0x34; и последние 4 байта файла должны быть 0xAB, 0xAB, 0x00, 0xAB:


```C++
    0, 4, , ABCD1234,  -4, 4, , ABAB00AB 
```



Кроме того, в одном типе носителя может присутствовать несколько записей. Достаточно совпадений с любым из них. Эта схема обеспечивает набор альтернативных масок. Например, WAV-файлы, которые могут иметь или не иметь заголовок Metallica.

> [!Note]  
> Эта схема похожа на ту, которая используется функцией [**жетклассфиле**](/windows/win32/api/objbase/nf-objbase-getclassfile) .

 

## <a name="loading-the-source-filter"></a>Загрузка фильтра источника

Предполагая, что диспетчер графов фильтров находит соответствующий фильтр источника для файла, он добавляет этот фильтр к графу, запрашивает фильтр для интерфейса [**ифилесаурцефилтер**](/windows/desktop/api/Strmif/nn-strmif-ifilesourcefilter) и вызывает [**Ифилесаурцефилтер:: Load**](/windows/desktop/api/Strmif/nf-strmif-ifilesourcefilter-load). Аргументы метода **Load** — это имя файла и тип носителя, как определено в реестре.

Если диспетчер графов фильтров не может найти что-либо из реестра, по умолчанию используется фильтр асинхронного файла. В этом случае он задает тип носителя **\_ Stream**, **медиасубтипе \_ None**.

## <a name="custom-file-types-in-windows-media-player"></a>Пользовательские типы файлов в проигрывателе Windows Media

Проигрыватель Windows Media использует дополнительный набор записей реестра. Дополнительные сведения см. в разделе [параметры реестра для расширения имени файла](../wmp/file-name-extension-registry-settings.md) в пакете SDK проигрывателя Windows Media.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Написание фильтров DirectShow](writing-directshow-filters.md)
</dt> </dl>

 

 
