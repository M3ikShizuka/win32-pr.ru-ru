---
description: Используйте этот пример, чтобы понять, как кодировщик RLE может реализовать метод в процессе записи фильтра преобразования.
ms.assetid: b7d878ab-523f-4b52-b98d-c9d4fa18ce8a
title: Шаг 5. Преобразование изображения
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 9ac9d32e48ba438f8bde2d8d4d9aca3b827ebc0c
ms.sourcegitcommit: 5d4e99f4c8f42f5f543e52cb9beb9fb13ec56c5f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/19/2021
ms.locfileid: "112406787"
---
# <a name="step-5-transform-the-image"></a>Шаг 5. Преобразование изображения

Это шаг 5 учебника [Создание фильтров преобразования](writing-transform-filters.md).

Вышестоящий фильтр доставляет примеры носителей в фильтр преобразования, вызывая метод [**имеминпутпин:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) для входного ПИН-кода фильтра преобразования. Для обработки данных фильтр преобразования вызывает метод **Transform** , который является чистым виртуальным. Классы **ктрансформфилтер** и **ктрансинплацефилтер** используют две разные версии этого метода:

-   [**Ктрансформфилтер:: Transform**](ctransformfilter-transform.md) принимает указатель на образец входных данных и указатель на образец Output. Перед тем как фильтр вызовет метод, он копирует примеры свойств из примера входных данных в образец Output, включая отметки времени.
-   [**Ктрансинплацефилтер:: Transform**](ctransinplacefilter-transform.md) принимает указатель на входной образец. Фильтр изменяет данные на месте.

Если метод **Transform** возвращает значение S \_ , то фильтр доставляет пример нисходящий. Чтобы пропустить кадр, возвратите \_ значение false. При возникновении ошибки потоковой передачи возвращает код ошибки.

В следующем примере показано, как кодировщик RLE может реализовать этот метод. Ваша собственная реализация может значительно различаться в зависимости от того, что делает фильтр.


```C++
HRESULT CRleFilter::Transform(IMediaSample *pSource, IMediaSample *pDest)
{
    // Get pointers to the underlying buffers.
    BYTE *pBufferIn, *pBufferOut;
    hr = pSource->GetPointer(&pBufferIn);
    if (FAILED(hr))
    {
        return hr;
    }
    hr = pDest->GetPointer(&pBufferOut);
    if (FAILED(hr))
    {
        return hr;
    }
    // Process the data.
    DWORD cbDest = EncodeFrame(pBufferIn, pBufferOut);
    KASSERT((long)cbDest <= pDest->GetSize());

    pDest->SetActualDataLength(cbDest);
    pDest->SetSyncPoint(TRUE);
    return S_OK;
}
```



В этом примере предполагается, что Енкодефраме является частным методом, реализующим кодирование RLE. Сам алгоритм кодирования не описан здесь; Дополнительные сведения см. в разделе "Сжатие растрового изображения" в документации по Platform SDK.

Сначала в примере вызывается [**имедиасампле:: "**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getpointer) , чтобы получить адреса базовых буферов. Он передает их закрытому методу Енкодерфраме. Затем вызывается [**имедиасампле:: сетактуалдаталенгс**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setactualdatalength) , чтобы указать длину закодированных данных. Подчиненный фильтр требует этой информации, чтобы она могла правильно управлять буфером. Наконец, метод вызывает [**имедиасампле:: сетсинкпоинт**](/windows/desktop/api/Strmif/nf-strmif-imediasample-setsyncpoint) , чтобы установить для флага ключевого кадра **значение true**. При кодировании с длиной не используются никакие разностные кадры, поэтому каждый кадр является ключевым кадром. Для разностных кадров установите значение **false**.

Ниже приведены другие проблемы, которые необходимо учитывать.

-   Метки времени. Класс **ктрансформфилтер** отметок времени для образца Output перед вызовом метода **Transform** . Он копирует значения временной метки из образца входных данных, не изменяя их. Если фильтру необходимо изменить отметки времени, вызовите [**имедиасампле:: setTime**](/windows/desktop/api/Strmif/nf-strmif-imediasample-settime) в примере Output.
-   Изменения формата. Вышестоящий фильтр может изменять форматы среднего потока, присоединяя к образцу тип мультимедиа. Перед этим он вызывает [**Ипин:: куерякцепт**](/windows/desktop/api/Strmif/nf-strmif-ipin-queryaccept) для входного ПИН-кода фильтра. В классе **ктрансформфилтер** это приводит к вызову **чеккинпуттипе** , за которым следует **чекктрансформ**. Нисходящий фильтр также может изменять типы носителей, используя тот же механизм. В собственном фильтре необходимо обратить внимание на следующие моменты:

    -   Убедитесь, что **куерякцепт** не возвращает ложные приемы.
    -   Если фильтр принимает изменения формата, проверьте их внутри метода **Transform** , вызвав [**Имедиасампле:: жетмедиатипе**](/windows/desktop/api/Strmif/nf-strmif-imediasample-getmediatype). Если этот метод возвращает значение S \_ , то фильтр должен реагировать на изменение формата.

    Дополнительные сведения см. в разделе [динамические изменения формата](dynamic-format-changes.md).

-   Многопоточно. В **ктрансформфилтер** и **ктрансинплацефилтер** фильтр преобразования доставляет выходные примеры синхронно внутри метода **Receive** . Фильтр не создает рабочие потоки для обработки данных. Как правило, для фильтра преобразований нет причин создавать рабочие потоки.

Далее. [Шаг 6. Добавлена поддержка COM](step-6--add-support-for-com.md).

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Написание фильтров DirectShow](writing-directshow-filters.md)
</dt> </dl>

 

 



