---
description: В этой статье описывается, как реагировать на события, происходящие в графе фильтров.
ms.assetid: 1c09149b-7f34-4296-bd32-dbbae5e1d62b
title: Реагирование на события
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3a51481371501c05733e5f637885a71001c1f996
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "104537202"
---
# <a name="responding-to-events"></a>Реагирование на события

В этой статье описывается, как реагировать на события, происходящие в графе фильтров.

## <a name="how-event-notification-works"></a>Как работает уведомление о событии

Пока выполняется приложение DirectShow, в графе фильтра могут возникать события. Например, фильтр может столкнуться с ошибкой потоковой передачи. Фильтры предупреждают диспетчер диаграмм фильтров, отправляя события, состоящие из кода события и двух параметров событий. Код события указывает тип события, а параметры события предоставляют дополнительные сведения. Значение параметров зависит от кода события. Полный список кодов событий см. в разделе [коды уведомлений о событиях](event-notification-codes.md).

Некоторые события автоматически обрабатываются диспетчером графа фильтров без уведомления приложения. Другие события помещаются в очередь для приложения. В зависимости от приложения существуют различные события, которые могут потребоваться для обработки. Эта статья посвящена трем событиям, которые очень распространены:

-   Событие [**EC \_ Complete**](ec-complete.md) указывает, что воспроизведение выполнено нормально.
-   Событие [**EC \_ усераборт**](ec-userabort.md) указывает, что пользователь прервал воспроизведение. Модули обработки видео отправляют это событие, если пользователь закрывает окно видео.
-   Событие [**EC \_ еррораборт**](ec-errorabort.md) указывает, что ошибка привела к остановке воспроизведения.

## <a name="using-event-notification"></a>Использование уведомления о событии

Приложение может указать диспетчеру графа фильтров отправить сообщение Windows в указанное окно при возникновении нового события. Это позволяет приложению реагировать внутри цикла обработки сообщений окна. Сначала определите сообщение, которое будет отправлено в окно приложения. Приложения могут использовать номера сообщений в диапазоне от приложения WM \_ через 0xBFFF как частные сообщения:


```C++
#define WM_GRAPHNOTIFY  WM_APP + 1
```



Затем запросите диспетчер графа фильтров для интерфейса [**имедиаевентекс**](/windows/desktop/api/Control/nn-control-imediaeventex) и вызовите метод [**Имедиаевентекс:: сетнотифивиндов**](/windows/desktop/api/Control/nf-control-imediaeventex-setnotifywindow) :


```C++
IMediaEventEx *g_pEvent = NULL;
g_pGraph->QueryInterface(IID_IMediaEventEx, (void **)&g_pEvent);
g_pEvent->SetNotifyWindow((OAHWND)g_hwnd, WM_GRAPHNOTIFY, 0);
```



Этот метод обозначает указанное окно (g \_ HWND) в качестве получателя сообщения. Вызовите метод после создания графа фильтра, но перед запуском графа.

WM \_ графнотифи — это обычное сообщение Windows. Каждый раз, когда диспетчер графа фильтров помещает новое событие в очередь событий, оно отправляет \_ сообщение ГРАФНОТИФИ WM в указанное окно приложения. Параметр *lParam* сообщения равен третьему параметру в [**сетнотифивиндов**](/windows/desktop/api/Control/nf-control-imediaeventex-setnotifywindow). Этот параметр позволяет отправить данные экземпляра вместе с сообщением. Параметр *wParam* сообщения окна всегда равен нулю.

В функции **WindowProc** приложения добавьте инструкцию CASE для \_ сообщения WM графнотифи:


```C++
case WM_GRAPHNOTIFY:
    HandleGraphEvent();
    break;
```



В функции обработчика событий вызовите метод [**имедиаевент:: четный**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) для получения событий из очереди:


```C++
void HandleGraphEvent()
{
    // Disregard if we don't have an IMediaEventEx pointer.
    if (g_pEvent == NULL)
    {
        return;
    }
    // Get all the events
    long evCode;
    LONG_PTR param1, param2;
    HRESULT hr;
    while (SUCCEEDED(g_pEvent->GetEvent(&evCode, &param1, &param2, 0)))
    {
        g_pEvent->FreeEventParams(evCode, param1, param2);
        switch (evCode)
        {
        case EC_COMPLETE:  // Fall through.
        case EC_USERABORT: // Fall through.
        case EC_ERRORABORT:
            CleanUp();
            PostQuitMessage(0);
            return;
        }
    } 
}
```



Метод [**четный**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) извлекает код события и два параметра события. Четвертый параметр **четный** указывает продолжительность времени ожидания события в миллисекундах. Так как приложение вызывает этот метод в ответ на \_ сообщение ГРАФНОТИФИ WM, событие уже поставлено в очередь. Поэтому мы устанавливаем значение времени ожидания равным нулю.

Уведомление о событии и цикл сообщений являются асинхронными, поэтому очередь может содержать более одного события на время ответа приложения на сообщение. Кроме того, диспетчер графов фильтров может удалить определенные события из очереди, если они станут недействительными. Таким образом, следует вызывать метод with, [**пока не будет**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) возвращен код сбоя, указывающий, что очередь пуста.

В этом примере приложение реагирует на [**EC \_ Complete**](ec-complete.md), [**EC \_ усераборт**](ec-userabort.md)и [**EC \_ еррораборт**](ec-errorabort.md) , вызывая функцию очистки, определяемую приложением, что приводит к корректному завершению работы приложения. В примере игнорируются два параметра события. После получения события вызовите [**имедиаевент:: фриевентпарамс**](/windows/desktop/api/Control/nf-control-imediaevent-freeeventparams) для любых свободных ресурсов, связанных с параметрами события.

Обратите внимание, что событие [**EC \_ Complete**](ec-complete.md) не приводит к сбою графа фильтра. Приложение может либо остановить, либо приостановить граф. Если вы останавливаете граф, Фильтры освобождают все удерживаемые ими ресурсы. При приостановке графа фильтры продолжают хранить ресурсы. Кроме того, когда модуль подготовки видео приостанавливает работу, он отображает статическое изображение самого последнего кадра.

Перед освобождением указателя [**имедиаевентекс**](/windows/desktop/api/Control/nn-control-imediaeventex) отмените уведомление о событии, вызвав [**сетнотифивиндов**](/windows/desktop/api/Control/nf-control-imediaeventex-setnotifywindow) с **нулевым** маркером окна:


```C++
// Disable event notification before releasing the graph.
g_pEvent->SetNotifyWindow(NULL, 0, 0);
g_pEvent->Release();
g_pEvent = NULL;
```



В \_ обработчике сообщений WM графнотифи проверьте указатель [**имедиаевентекс**](/windows/desktop/api/Control/nn-control-imediaeventex) перед вызовом метода [](/windows/desktop/api/Control/nf-control-imediaevent-getevent):


```C++
if (g_pEvent == NULL) return;
```



Это предотвращает возможную ошибку, которая может возникнуть, если приложение получает уведомление о событии после освобождения указателя.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Основные задачи DirectShow](basic-directshow-tasks.md)
</dt> <dt>

[Уведомление о событии в DirectShow](event-notification-in-directshow.md)
</dt> </dl>

 

 



