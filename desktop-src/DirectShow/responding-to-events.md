---
description: В этой статье описывается, как реагировать на события, происходящие в графе фильтров.
ms.assetid: 1c09149b-7f34-4296-bd32-dbbae5e1d62b
title: Реагирование на события
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 8fb0325af2e216a3679d3e15a293aa6bfe1c100f2271d089e982b295df791130
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "120050564"
---
# <a name="responding-to-events"></a>Реагирование на события

В этой статье описывается, как реагировать на события, происходящие в графе фильтров.

## <a name="how-event-notification-works"></a>Как работает уведомление о событии

во время работы приложения DirectShow в графе фильтра могут возникать события. Например, фильтр может столкнуться с ошибкой потоковой передачи. фильтры предупреждают фильтр Graph Manager, отправляя события, которые состоят из кода события и двух параметров события. Код события указывает тип события, а параметры события предоставляют дополнительные сведения. Значение параметров зависит от кода события. Полный список кодов событий см. в разделе [коды уведомлений о событиях](event-notification-codes.md).

некоторые события автоматически обрабатываются фильтром Graph Manager без уведомления приложения. Другие события помещаются в очередь для приложения. В зависимости от приложения существуют различные события, которые могут потребоваться для обработки. Эта статья посвящена трем событиям, которые очень распространены:

-   Событие [**EC \_ Complete**](ec-complete.md) указывает, что воспроизведение выполнено нормально.
-   Событие [**EC \_ усераборт**](ec-userabort.md) указывает, что пользователь прервал воспроизведение. Модули обработки видео отправляют это событие, если пользователь закрывает окно видео.
-   Событие [**EC \_ еррораборт**](ec-errorabort.md) указывает, что ошибка привела к остановке воспроизведения.

## <a name="using-event-notification"></a>Использование уведомления о событии

приложение может дать Graph менеджеру фильтра отправить сообщение Windows в указанное окно при возникновении нового события. Это позволяет приложению реагировать внутри цикла обработки сообщений окна. Сначала определите сообщение, которое будет отправлено в окно приложения. Приложения могут использовать номера сообщений в диапазоне от приложения WM \_ через 0xBFFF как частные сообщения:


```C++
#define WM_GRAPHNOTIFY  WM_APP + 1
```



затем выполните запрос фильтра Graph Manager для интерфейса [**имедиаевентекс**](/windows/desktop/api/Control/nn-control-imediaeventex) и вызовите метод [**имедиаевентекс:: сетнотифивиндов**](/windows/desktop/api/Control/nf-control-imediaeventex-setnotifywindow) :


```C++
IMediaEventEx *g_pEvent = NULL;
g_pGraph->QueryInterface(IID_IMediaEventEx, (void **)&g_pEvent);
g_pEvent->SetNotifyWindow((OAHWND)g_hwnd, WM_GRAPHNOTIFY, 0);
```



Этот метод обозначает указанное окно (g \_ HWND) в качестве получателя сообщения. Вызовите метод после создания графа фильтра, но перед запуском графа.

WM \_ графнотифи — это обычное сообщение Windows. каждый раз, когда диспетчер Graph фильтра помещает новое событие в очередь событий, оно отправляет \_ сообщение WM графнотифи в указанное окно приложения. Параметр *lParam* сообщения равен третьему параметру в [**сетнотифивиндов**](/windows/desktop/api/Control/nf-control-imediaeventex-setnotifywindow). Этот параметр позволяет отправить данные экземпляра вместе с сообщением. Параметр *wParam* сообщения окна всегда равен нулю.

В функции **WindowProc** приложения добавьте инструкцию CASE для \_ сообщения WM графнотифи:


```C++
case WM_GRAPHNOTIFY:
    HandleGraphEvent();
    break;
```



В функции обработчика событий вызовите метод [**имедиаевент:: четный**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) для получения событий из очереди:


```C++
void HandleGraphEvent()
{
    // Disregard if we don't have an IMediaEventEx pointer.
    if (g_pEvent == NULL)
    {
        return;
    }
    // Get all the events
    long evCode;
    LONG_PTR param1, param2;
    HRESULT hr;
    while (SUCCEEDED(g_pEvent->GetEvent(&evCode, &param1, &param2, 0)))
    {
        g_pEvent->FreeEventParams(evCode, param1, param2);
        switch (evCode)
        {
        case EC_COMPLETE:  // Fall through.
        case EC_USERABORT: // Fall through.
        case EC_ERRORABORT:
            CleanUp();
            PostQuitMessage(0);
            return;
        }
    } 
}
```



Метод [**четный**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) извлекает код события и два параметра события. Четвертый параметр **четный** указывает продолжительность времени ожидания события в миллисекундах. Так как приложение вызывает этот метод в ответ на \_ сообщение ГРАФНОТИФИ WM, событие уже поставлено в очередь. Поэтому мы устанавливаем значение времени ожидания равным нулю.

Уведомление о событии и цикл сообщений являются асинхронными, поэтому очередь может содержать более одного события на время ответа приложения на сообщение. кроме того, фильтр Graph Manager может удалить определенные события из очереди, если они станут недействительными. Таким образом, следует вызывать метод with, [**пока не будет**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) возвращен код сбоя, указывающий, что очередь пуста.

В этом примере приложение реагирует на [**EC \_ Complete**](ec-complete.md), [**EC \_ усераборт**](ec-userabort.md)и [**EC \_ еррораборт**](ec-errorabort.md) , вызывая функцию очистки, определяемую приложением, что приводит к корректному завершению работы приложения. В примере игнорируются два параметра события. После получения события вызовите [**имедиаевент:: фриевентпарамс**](/windows/desktop/api/Control/nf-control-imediaevent-freeeventparams) для любых свободных ресурсов, связанных с параметрами события.

Обратите внимание, что событие [**EC \_ Complete**](ec-complete.md) не приводит к сбою графа фильтра. Приложение может либо остановить, либо приостановить граф. Если вы останавливаете граф, Фильтры освобождают все удерживаемые ими ресурсы. При приостановке графа фильтры продолжают хранить ресурсы. Кроме того, когда модуль подготовки видео приостанавливает работу, он отображает статическое изображение самого последнего кадра.

Перед освобождением указателя [**имедиаевентекс**](/windows/desktop/api/Control/nn-control-imediaeventex) отмените уведомление о событии, вызвав [**сетнотифивиндов**](/windows/desktop/api/Control/nf-control-imediaeventex-setnotifywindow) с **нулевым** маркером окна:


```C++
// Disable event notification before releasing the graph.
g_pEvent->SetNotifyWindow(NULL, 0, 0);
g_pEvent->Release();
g_pEvent = NULL;
```



В \_ обработчике сообщений WM графнотифи проверьте указатель [**имедиаевентекс**](/windows/desktop/api/Control/nn-control-imediaeventex) перед вызовом метода [](/windows/desktop/api/Control/nf-control-imediaevent-getevent):


```C++
if (g_pEvent == NULL) return;
```



Это предотвращает возможную ошибку, которая может возникнуть, если приложение получает уведомление о событии после освобождения указателя.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[основные задачи DirectShow](basic-directshow-tasks.md)
</dt> <dt>

[Уведомление о событии в DirectShow](event-notification-in-directshow.md)
</dt> </dl>

 

 



