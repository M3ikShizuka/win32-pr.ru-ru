---
description: Обучение при возникновении события
ms.assetid: 4e44089b-676b-4220-9721-54ddf56bf760
title: Обучение при возникновении события
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 19ed537430fd66818687b142f059399292c923e1
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "104537703"
---
# <a name="learning-when-an-event-occurs"></a>Обучение при возникновении события

Для обработки событий DirectShow приложению требуется способ выяснить, когда события ожидают в очереди. Диспетчер графов фильтров предоставляет два способа:

-   **Уведомление окна:** Диспетчер графов фильтров отправляет определяемое пользователем сообщение Windows в окно приложения при наличии нового события.
-   **Сигнализация события:** Диспетчер графов фильтров сигнализирует о событии Windows, если в очереди есть события DirectShow, и сбросить событие, если очередь пуста.

Приложение может использовать любой из этих методов. Уведомление окна обычно проще.

**Уведомление окна**

Чтобы настроить уведомление окна, вызовите метод [**имедиаевентекс:: сетнотифивиндов**](/windows/desktop/api/Control/nf-control-imediaeventex-setnotifywindow) и укажите частное сообщение. Приложения могут использовать номера сообщений в диапазоне от приложения WM \_ через 0xBFFF как частные сообщения. Каждый раз, когда диспетчер графа фильтра помещает новое уведомление о событии в очередь, оно отправляет это сообщение в указанное окно. Приложение реагирует на сообщение в цикле обработки сообщений окна.

В следующем примере кода показано, как задать окно уведомления.


```C++
#define WM_GRAPHNOTIFY WM_APP + 1   // Private message.
pEvent->SetNotifyWindow((OAHWND)g_hwnd, WM_GRAPHNOTIFY, 0);
```



Сообщение является обычным сообщением Windows и публикуется отдельно от очереди уведомлений о событиях DirectShow. Преимуществом этого подхода является то, что большинство приложений уже реализуют цикл обработки сообщений. Таким образом, можно включить обработку событий DirectShow без значительной дополнительной работы.

В следующем примере кода показано, как реагировать на сообщение уведомления. Полный пример см. в разделе [реагирование на события](responding-to-events.md).


```C++
LRESULT CALLBACK WindowProc( HWND hwnd, UINT msg, UINT wParam, LONG lParam)
{
    switch (msg)
    {
        case WM_GRAPHNOTIFY:
            HandleEvent();  // Application-defined function.
            break;
        // Handle other Windows messages here too.
    }
    return (DefWindowProc(hwnd, msg, wParam, lParam));
}
```



Так как уведомления о событиях и цикл сообщений являются асинхронными, очередь может содержать более одного события на время ответа приложения на сообщение. Кроме того, события иногда могут быть удалены из очереди, если они становятся недействительными. Поэтому в коде обработки событий вызовите [**иаммедиаевент::-четный**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) , пока не вернется код сбоя, указывающий, что очередь пуста.

Перед освобождением указателя [**имедиаевентекс**](/windows/desktop/api/Control/nn-control-imediaeventex) отмените уведомление о событии, вызвав [**сетнотифивиндов**](/windows/desktop/api/Control/nf-control-imediaeventex-setnotifywindow) с **пустым** указателем. В коде обработки событий проверьте, является ли указатель **имедиаевентекс** допустимым, прежде чем [**вызывать метод**](/windows/desktop/api/Control/nf-control-imediaevent-getevent). Эти действия препятствуют возможной ошибке, при которой приложение получает уведомление о событии после того, как оно выпустило указатель **имедиаевентекс** .

**Сигнализация о событиях**

Диспетчер графов фильтров сохраняет событие ручного сброса, которое отражает состояние очереди событий. Если очередь содержит уведомления о событиях, ожидающих выполнения, диспетчер графа фильтров сигнализирует о событии ручного сброса. Если очередь пуста, вызов метода [**имедиаевент::-четный**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) сбрасывает событие. Приложение может использовать это событие для определения состояния очереди.

> [!Note]  
> Эта терминология может быть запутанной. Событие ручного сброса — это тип события, созданного функцией [**CreateEvent**](/windows/win32/api/synchapi/nf-synchapi-createeventa) для Windows; Он не имеет никаких действий с событиями, определенными в DirectShow.

 

Вызовите метод [**имедиаевент:: жетевенсандле**](/windows/desktop/api/Control/nf-control-imediaevent-geteventhandle) , чтобы получить маркер события ручного сброса. Дождитесь получения сигнала о событии, вызвав функцию, например [**WaitForMultipleObjects**](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjects). После получения сигнала о событии вызовите [**имедиаевент::-четный**](/windows/desktop/api/Control/nf-control-imediaevent-getevent) , чтобы получить событие DirectShow.

Этот подход показан в следующем примере кода. Он получает дескриптор события, а затем ожидает в 100-миллисекундах интервала для события. Если событие является сигнальным, оно вызывает метод in и выводит код **события и параметры** события в окно консоли. Цикл завершается, когда происходит событие [**EC \_ Complete**](ec-complete.md) , что означает, что воспроизведение завершено.


```C++
HANDLE  hEvent; 
long    evCode, param1, param2;
BOOLEAN bDone = FALSE;
HRESULT hr = S_OK;
hr = pEvent->GetEventHandle((OAEVENT*)&hEvent);
if (FAILED(hr))
{
    /* Insert failure-handling code here. */
}

while(!bDone) 
{
    if (WAIT_OBJECT_0 == WaitForSingleObject(hEvent, 100))
    { 
        while (S_OK == pEvent->GetEvent(&evCode, &param1, &param2, 0)) 
        {
            printf("Event code: %#04x\n Params: %d, %d\n", evCode, param1, param2);
            pEvent->FreeEventParams(evCode, param1, param2);
            bDone = (EC_COMPLETE == evCode);
        }
    }
} 
```



Так как граф фильтра автоматически задает или сбрасывает событие, если это уместно, приложение не должно этого делать. Кроме того, при освобождении графа фильтра граф фильтра закрывает обработчик события, поэтому не следует использовать этот обработчик после этой точки.

 

 
