---
description: Фильтрация состояний
ms.assetid: 97418307-eb50-4c8e-b03b-a2cd08139bdc
title: Фильтрация состояний
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2d61f66e1446d97d289f7e489f116f747f339d9a
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "105650436"
---
# <a name="filter-states"></a>Фильтрация состояний

Фильтры имеют три возможных состояния: остановлено, приостановлено и запущено. Назначением приостановленного состояния является подсказка в графе, чтобы команда запуска немедленно отвечала на запросы. Диспетчер графов фильтров управляет всеми переходами состояний. Когда приложение вызывает [**имедиаконтрол:: Run**](/windows/desktop/api/Control/nf-control-imediacontrol-run), [**имедиаконтрол::P Аусе**](/windows/desktop/api/Control/nf-control-imediacontrol-pause)или [**Имедиаконтрол:: останавливаться**](/windows/desktop/api/Control/nf-control-imediacontrol-stop), диспетчер графа фильтров вызывает соответствующий метод [**имедиафилтер**](/windows/desktop/api/Strmif/nn-strmif-imediafilter) для всех фильтров. Переходы между остановленными и запущенными всегда проходят через приостановленное состояние, поэтому если приложение вызывает **Запуск** на остановленном графе, диспетчер графа фильтров приостанавливает граф перед его запуском.

Для большинства фильтров запущенные и приостановленные состояния идентичны. Рассмотрим следующий граф фильтра:

Модуль подготовки > преобразования источника >

Предположим, что фильтр источника не является источником динамической записи. Когда фильтр источника приостанавливается, он создает поток, который создает новые данные и записывает их в примеры носителей как можно быстрее. Поток "отправляет" образцы, вызывая [**имеминпутпин:: Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) на входном закрепление фильтра преобразования. Фильтр преобразования получает образцы в потоке исходного фильтра. Он может использовать рабочий поток для доставки образцов в модуль подготовки отчетов, но обычно он доставляет их в один и тот же поток. Пока модуль подготовки отчетов приостановлен, он ждет получения примера. После получения он блокирует и удерживает этот пример неограниченным образом. Если это модуль подготовки видео, он отображает пример в виде изображения афиши, при необходимости Перерисовывает изображение.

На этом этапе поток полностью куед и готов к отрисовке. Если граф остается приостановленным, выборка будет [**выводиться**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) на диаграмме за первый пример, пока все фильтры не будут заблокированы в Receive или [**имемаллокатор::-buffer**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer). Однако данные не теряются. После того как исходный поток разблокируется, он просто возобновляется с того места, где он был заблокирован.

Фильтр источника и фильтр преобразования игнорируют переход от приостановленного к работающему — они просто продолжают обрабатывать данные как можно быстрее. Но когда модуль подготовки отчетов запускается, он начинает отрисовку образцов. Сначала он выводит пример, удерживаемый в момент приостановки. Затем каждый раз, когда он получает новый пример, он вычисляет время презентации в примере. (Дополнительные сведения см. [в разделе время и часы в DirectShow](time-and-clocks-in-directshow.md).) Модуль подготовки отчетов хранит каждый выбор до времени презентации, после чего он отображает пример. Хотя он ждет времени презентации, он либо блокируется в методе [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) , либо получает новые примеры в рабочем потоке с очередью. Фильтрация вышестоящего модуля модуля подготовки отчетов не участвует в планировании.

Динамические источники, такие как устройства записи, являются исключением из этой общей архитектуры. В реальном источнике нет необходимости заранее полагаться на какие-либо данные. Приложение может приостановить граф, а затем подождать длительное время, прежде чем запускать его. Граф не должен визуализировать "устаревшие" образцы. Таким образом, в реальном источнике нет выборок при приостановке, только во время выполнения. Чтобы сообщить об этом факте диспетчеру графа фильтров, метод [**имедиафилтер::**](/windows/desktop/api/Strmif/nf-strmif-imediafilter-getstate) WebMethod исходного фильтра возвращает VFW \_ s не \_ удается \_ подсказку. Этот код возврата означает, что фильтр переключен на приостановленное состояние, даже если модуль подготовки отчетов не получал никаких данных.

Когда фильтр останавливается, он отклоняет любые другие выдаваемые ему образцы. Фильтры источников завершают потоки потоковой передачи, а другие фильтры завершают работу рабочих потоков, которые они могли создать. Фиксирует фиксации распределителя.

### <a name="state-transitions"></a>Переходы состояния

Диспетчер графов фильтров выполняет все переходы состояний в восходящий порядок, начиная с модуля подготовки отчетов и перезапуская исходный фильтр. Этот порядок необходимо для предотвращения удаления образцов и предотвращения взаимоблокировки графа. Самые критические переходы состояний находятся между приостановленными и остановленными.

-   Приостановлено для приостановки: по мере приостановки каждого фильтра он готов к получению примеров со следующего фильтра. Фильтр источника является последним для приостановки. Он создает поток потоковой передачи и начинает доставку образцов. Так как все нисходящие фильтры приостановлены, ни один из фильтров не отклоняет выборки. Диспетчер графов фильтров не завершает переход, пока каждый визуализатор в графе не получил выборку (за исключением динамических источников, как описано выше).
-   Приостановлено на остановлено: при остановке фильтра он освобождает все содержащиеся в нем образцы, которые разблокируют все исходящие фильтры, [**ожидающие в процессе работы с потоком.**](/windows/desktop/api/Strmif/nf-strmif-imemallocator-getbuffer) Если фильтр ожидает ресурс внутри метода [**Receive**](/windows/desktop/api/Strmif/nf-strmif-imeminputpin-receive) , он останавливает ожидание и возвращает результат **Receive**, который разблокирует вызывающий фильтр. Таким образом, когда диспетчер графа фильтров останавливает следующий вышестоящий фильтр, этот фильтр не блокируется в команде «GetNext **» или «** **получить**» и может реагировать на команду Stop. Вышестоящий фильтр может доставлять несколько дополнительных выборок перед получением команды остановки, но подчиненный фильтр просто отклоняет их, так как он уже остановлен.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Поток данных в графе фильтра](data-flow-in-the-filter-graph.md)
</dt> </dl>

 

 



