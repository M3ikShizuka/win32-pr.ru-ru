---
description: В этом обзоре обсуждаются функции Windows, такие как типы окон, состояния, размер и расположение.
ms.assetid: 8318c22f-85a2-490e-8233-ee1e234890d9
title: Характеристики окон
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 228c6b4ab59102cae38a248935fbbad32198f2e0
ms.sourcegitcommit: 8755905962e156f29203705d09d6df8b7d0e2fca
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/25/2021
ms.locfileid: "105658140"
---
# <a name="window-features"></a>Характеристики окон

В этом обзоре обсуждаются функции Windows, такие как типы окон, состояния, размер и расположение.

-   [Типы окон](#window-types)
    -   [Перекрывающиеся окна](#overlapped-windows)
    -   [Всплывающие окна](#pop-up-windows)
    -   [Дочерние окна](#child-windows)
        -   [Направляющ](#positioning)
        -   [Вырезая](#clipping)
        -   [Связь с родительским окном](#relationship-to-parent-window)
        -   [Сообщения](#size-and-position-messages)
    -   [Многослойные окна](#layered-windows)
    -   [Окна только для сообщений](#message-only-windows)
-   [Связи окон](#window-relationships)
    -   [Передний и фоновый окна](#foreground-and-background-windows)
    -   [Собственные окна](#owned-windows)
    -   [Z-порядок](#z-order)
-   [Отображение состояния окна](#window-show-state)
    -   [Активное окно](#active-window)
    -   [Отключенные окна](#disabled-windows)
    -   [Видимость окна](#window-visibility)
    -   [Сведенные, развернутые и восстановленные окна](#minimized-maximized-and-restored-windows)
-   [Размер и расположение окна](#window-size-and-position)
    -   [Размер и расположение по умолчанию](#default-size-and-position)
    -   [Размер отслеживания](#tracking-size)
    -   [Системные команды](#system-commands)
    -   [Функции размера и позиционирования](#size-and-position-functions)
    -   [Размер и расположение сообщений](#size-and-position-messages)
-   [Анимация окна](#window-animation)
-   [Макет окна и зеркальное отображение](#window-layout-and-mirroring)
    -   [Диалоговое окно зеркального отображения и окна сообщений](#mirroring-dialog-boxes-and-message-boxes)
    -   [Контексты устройств зеркального отображения, не связанные с окном](#mirroring-device-contexts-not-associated-with-a-window)
-   [Уничтожение окна](#window-destruction)

## <a name="window-types"></a>Типы окон

Этот раздел содержит следующие разделы, описывающие типы окон.

-   [Перекрывающиеся окна](#overlapped-windows)
-   [Всплывающие окна](#pop-up-windows)
-   [Дочерние окна](#child-windows)
-   [Многослойные окна](#layered-windows)
-   [Окна только для сообщений](#message-only-windows)

### <a name="overlapped-windows"></a>Перекрывающиеся окна

*Перекрытое окно* — это окно верхнего уровня (не дочернее окно) с заголовком, границей и клиентской областью. Он предназначен для использования в качестве главного окна приложения. У него также может быть меню окна, кнопки сворачивания и развертывания, полосы прокрутки. Перекрытое окно, используемое в качестве главного окна, обычно включает все эти компоненты.

При указании стиля [**WS \_ OVERLAPPED**](window-styles.md) или **WS \_ оверлаппедвиндов** в функции [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) приложение создает окно с перекрытием. Если используется стиль **WS \_ OVERLAPPED** , окно имеет строку заголовка и границу. Если используется стиль **WS \_ оверлаппедвиндов** , окно имеет заголовок окна, границы размера, меню окна, а также кнопки сворачивания и развернуть.

### <a name="pop-up-windows"></a>Всплывающие окна

*Всплывающее окно* — это специальный тип окна с перекрытием, которое используется для диалоговых окон, окон сообщений и других временных окон, отображаемых за пределами главного окна приложения. Строки заголовка необязательны для всплывающих окон; в противном случае всплывающие окна будут такими же, как перекрывающиеся окна стиля [**WS- \_ OVERLAPPED**](window-styles.md) .

Всплывающее окно создается путем указания стиля [**\_ всплывающего окна WS**](window-styles.md) в [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa). Чтобы включить заголовок, укажите стиль **\_ заголовка WS** . Используйте стиль **WS \_ POPUPWINDOW** , чтобы создать всплывающее окно с границей и меню окна. Стиль **\_ заголовка WS** должен быть объединен с стилем **WS \_ POPUPWINDOW** , чтобы сделать меню окна видимым.

### <a name="child-windows"></a>Дочерние окна

*Дочернее окно* имеет [**стиль \_ дочернего элемента WS**](window-styles.md) и ограничивается клиентской областью родительского окна. Приложение обычно использует дочерние окна, чтобы разделить клиентскую область родительского окна на функциональные области. Дочернее окно создается путем указания стиля **\_ дочернего элемента WS** в функции [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) .

Дочернее окно должно иметь родительское окно. Родительским окном может быть окно с перекрытием, всплывающее окно или даже другое дочернее окно. Вы указываете родительское окно при вызове [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa). Если указать в **CreateWindowEx** стиль [**\_ дочернего элемента WS**](window-styles.md) , но не указать родительское окно, система не создаст окно.

Дочернее окно имеет клиентскую область, но не имеет других функций, если они не запрашиваются явным образом. Приложение может запрашивать строку заголовка, меню окна, кнопки сворачивания и развернуть, границу и полосы прокрутки для дочернего окна, но дочернее окно не может иметь меню. Если приложение задает маркер меню при регистрации класса дочернего окна или при создании дочернего окна, то маркер меню игнорируется. Если стиль границы не указан, система создает безграницуное окно. Приложение может использовать дочерние окна без границ для разделения клиентской области родительского окна, сохраняя при этом невидимые для пользователя подразделения.

В этом разделе обсуждаются следующие аспекты дочерних окон:

-   [Направляющ](#positioning)
-   [Вырезая](#clipping)
-   [Связь с родительским окном](#relationship-to-parent-window)
-   [Сообщения](#size-and-position-messages)

#### <a name="positioning"></a>Направляющ

Система всегда позиционирует дочернее окно относительно левого верхнего угла клиентской области родительского окна. Ни одна часть дочернего окна не отображается вне границ родительского окна. Если приложение создает дочернее окно, размер которого больше родительского окна или размещает дочернее окно, чтобы часть или все дочернее окно выходили за границы родительского элемента, система обрезает дочернее окно. Это значит, что часть за пределами клиентской области родительского окна не отображается. Действия, влияющие на родительское окно, также могут повлиять на дочернее окно, как показано ниже.



| Родительское окно | Дочернее окно                                                                                                             |
|---------------|--------------------------------------------------------------------------------------------------------------------------|
| Уничтожаются     | Уничтожено до уничтожения родительского окна.                                                                         |
| Скрытый        | Скрывается перед тем, как родительское окно скрыто. Дочернее окно отображается только в том случае, если родительское окно является видимым.             |
| Перенести         | Перемещено с клиентской областью родительского окна. Дочернее окно отвечает за рисование области клиента после перемещения. |
| Указанного         | Отображается после отображения родительского окна.                                                                                  |



 

#### <a name="clipping"></a>Усечение

Система не выполняет автоматическое обрезку дочернего окна из клиентской области родительского окна. Это означает, что родительское окно рисуется поверх дочернего окна, если оно выполняет все прорисовки в том же расположении, что и дочернее окно. Однако система выполняет обрезку дочернего окна из клиентской области родительского окна, если родительское окно имеет стиль [**WS \_ клипчилдрен**](window-styles.md) . Если дочернее окно обрезано, оно не может нарисоваться в родительском окне.

Дочернее окно может перекрывать другие дочерние окна в той же клиентской области. Дочернее окно, которое использует то же родительское окно, что и одно или несколько дочерних окон, называется *родственным окном*. Одноуровневые окна могут рисовать в клиентской области друг друга, если только у одного из дочерних окон не установлен стиль [**WS \_ клипсиблингс**](window-styles.md) . Если дочернее окно имеет этот стиль, любая часть его родственного окна, которая находится внутри дочернего окна, обрезается.

Если окно имеет стиль [**WS \_ Клипчилдрен**](window-styles.md) или **WS \_ клипсиблингс** , возникает небольшая утрата производительности. Каждое окно занимает системные ресурсы, поэтому приложение не должно использовать дочерние окна неразличенно. Для лучшей производительности приложение, которому необходимо логически разделить главное окно, должно сделать это в процедуре окна главного окна, а не с помощью дочерних окон.

#### <a name="relationship-to-parent-window"></a>Связь с родительским окном

Приложение может изменить родительское окно существующего дочернего окна, вызвав функцию [**сетпарент**](/windows/win32/api/winuser/nf-winuser-setparent) . В этом случае система удаляет дочернее окно из клиентской области старого родительского окна и перемещает его в клиентскую область нового родительского окна. Если **сетпарент** задает маркер **null** , окно рабочего стола станет новым родительским окном. В этом случае дочернее окно отображается на рабочем столе вне границ любого другого окна. Функция- [**родитель**](/windows/win32/api/winuser/nf-winuser-getparent) получает маркер родительского окна дочернего окна.

Родительское окно освобождает часть своей клиентской области дочернему окну, а дочернее окно получает все входные данные из этой области. Класс Window не обязательно должен быть одинаковым для всех дочерних окон родительского окна. Это означает, что приложение может заполнить родительское окно дочерними окнами, которые выглядят иначе и выполнять различные задачи. Например, диалоговое окно может содержать несколько типов элементов управления, каждое из которых дочернее окно принимает различные типы данных от пользователя.

Дочернее окно имеет только одно родительское окно, но у родительского окна может быть любое количество дочерних окон. Каждое дочернее окно, в свою очередь, может иметь дочерние окна. В этой цепочке окон каждое дочернее окно называется вложенным окном исходного родительского окна. Приложение использует функцию [**Child**](/windows/win32/api/winuser/nf-winuser-ischild) для определения того, является ли данное окно дочерним окном или вложенным окном данного родительского окна.

Функция [**енумчилдвиндовс**](/windows/win32/api/winuser/nf-winuser-enumchildwindows) перечисляет дочерние окна родительского окна. Затем **енумчилдвиндовс** передает этот обработчик в каждое дочернее окно в функцию обратного вызова, определенную приложением. Также перечисляются дочерние окна данного родительского окна.

#### <a name="messages"></a>Сообщения

Система передает входные сообщения дочернего окна непосредственно в дочернее окно; сообщения не передаются через родительское окно. Единственное исключение — только в том случае, если дочернее окно было отключено функцией [**енаблевиндов**](/windows/win32/api/winuser/nf-winuser-enablewindow) . В этом случае система передает все входные сообщения, которые были бы потеряны в дочернем окне, в родительском окне. Это позволяет родительскому окну проверять входные сообщения и при необходимости включать дочернее окно.

Дочернее окно может иметь уникальный целочисленный идентификатор. При работе с окнами управления важны идентификаторы дочерних окон. Приложение направляет действие элемента управления, отправляя его сообщения. Приложение использует идентификатор дочернего окна элемента управления для направления сообщений в элемент управления. Кроме того, элемент управления отправляет сообщения уведомления родительскому окну. Сообщение уведомления содержит идентификатор дочернего окна элемента управления, который используется родительским элементом для указания того, какой элемент управления отправил сообщение. Приложение указывает идентификатор дочернего окна для других типов дочерних окон, присвоив параметру *HMENU* функции [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) значение, а не маркер меню.

### <a name="layered-windows"></a>Многослойные окна

Использование многоуровневого окна может значительно повысить производительность и визуальные эффекты для окна с сложной фигурой, анимировать ее фигуру или использовать альфа-эффекты смешения. Система автоматически создает и перерисовывает многослойные окна и окна базовых приложений. В результате этого многослойные окна отображаются плавно, без мерцания типов сложных окон. Кроме того, многоуровневые окна могут быть частично прозрачными, то есть с альфа-смешением.

Чтобы создать многоуровневый окно, укажите многоуровневый расширенный стиль окна **WS \_ ex \_** при вызове функции [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) или вызовите функцию [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) , чтобы установить **WS \_ ex \_** после создания окна. После вызова **CreateWindowEx** многоуровневое окно не станет видимым, пока для этого окна не будет вызвана функция [**SetLayeredWindowAttributes**](/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes) или [**упдателайередвиндов**](/windows/win32/api/winuser/nf-winuser-updatelayeredwindow) .

> [!Note]  
> Начиная с Windows 8, **WS \_ ex \_** можно использовать с дочерними окнами и окнами верхнего уровня. Предыдущие версии Windows поддерживают **WS \_ ex \_** только для окон верхнего уровня.

 

Чтобы задать уровень непрозрачности или ключ цвета прозрачности для данного многоуровневого окна, вызовите [**SetLayeredWindowAttributes**](/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes). После вызова система по-прежнему может запрашивать прорисовку окна при отображении окна или изменении его размера. Однако, поскольку система сохраняет изображение многоуровневого окна, система не запрашивает у окна прорисовку, если ее части выводятся в результате относительных перемещений окна на рабочем столе. Устаревшие приложения не нуждаются в реструктуризации кода рисования, если требуется добавить полупрозрачность или эффекты прозрачности для окна, поскольку система перенаправляет Рисование окон, именуемых **SetLayeredWindowAttributes** , в память за пределами экрана и перерисовывает ее для достижения желаемого эффекта.

Для ускорения и более эффективной анимации или при необходимости для альфа-составляющей необходимо вызвать [**упдателайередвиндов**](/windows/win32/api/winuser/nf-winuser-updatelayeredwindow). **Упдателайередвиндов** следует использовать в основном, когда приложение должно напрямую предоставлять форму и содержимое многоуровневого окна без использования механизма перенаправления, предоставляемого системой через [**SetLayeredWindowAttributes**](/windows/win32/api/winuser/nf-winuser-setlayeredwindowattributes). Кроме того, использование **упдателайередвиндов** напрямую использует память более эффективно, поскольку системе не требуется дополнительная память, необходимая для хранения образа перенаправленного окна. Чтобы обеспечить максимальную эффективность анимации окон, вызовите **упдателайередвиндов** , чтобы изменить расположение и размер многоуровневого окна. Обратите внимание, что после вызова **SetLayeredWindowAttributes** последующие вызовы **упдателайередвиндов** завершатся ошибкой до тех пор, пока не будет сброшен бит стиля слоя и не установится снова.

Проверка нажатия многоуровневого окна основана на фигуре и прозрачности окна. Это означает, что области окна, имеющие цветовой ключ или альфа-значение которого равно нулю, позволяют передавать сообщения с помощью мыши. Однако если в многоуровневом окне имеется прозрачный расширенный стиль **окна \_ WS \_ ex** , то форма многоуровневого окна будет проигнорирована, а события мыши передаются в другие окна под слоеным окном.

### <a name="message-only-windows"></a>Message-Only Windows

Окно, предназначенное *только для сообщений* , позволяет отправлять и получать сообщения. Он не отображается, не имеет z-порядка, не может быть перечислен и не получает широковещательные сообщения. Окно просто отправляет сообщения.

Чтобы создать окно только с сообщением, укажите константу [ \_ сообщения HWND](#message-only-windows) или дескриптор существующего окна только для сообщений в параметре *хвндпарент* функции [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) . Можно также изменить существующее окно на окно только сообщения, указав \_ сообщение HWND в параметре *Хвндневпарент* функции [**сетпарент**](/windows/win32/api/winuser/nf-winuser-setparent) .

Чтобы найти окна только для сообщений, укажите [ \_ сообщение HWND](#message-only-windows) в параметре *хвндпарент* функции [**FindWindowEx**](/windows/win32/api/winuser/nf-winuser-findwindowexa) . Кроме того, **FindWindowEx** выполняет поиск окон только для сообщений, а также окон верхнего уровня, если оба параметра *хвндпарент* и *хвндчилдафтер* имеют **значение NULL**.

## <a name="window-relationships"></a>Связи окон

Существует множество способов связи окна с пользователем или с другим окном. Окно может быть владельцем окна, передним окном или фоновым окном. Окно также имеет z-порядок относительно других окон. Дополнительные сведения см. в следующих разделах:

-   [Передний и фоновый окна](#foreground-and-background-windows)
-   [Собственные окна](#owned-windows)
-   [Z-порядок](#z-order)

### <a name="foreground-and-background-windows"></a>Передний и фоновый окна

Каждый процесс может иметь несколько потоков выполнения, и каждый поток может создавать окна. Поток, создавший окно, с помощью которого в данный момент работает пользователь, называется основным потоком, а окно называется *передним планом*. Все остальные потоки являются фоновыми потоками, а окна, созданные фоновыми потоками, называются *фоновыми окнами*.

Каждый поток имеет уровень приоритета, определяющий количество времени ЦП, получаемого потоком. Хотя приложение может устанавливать уровень приоритета своих потоков, обычно поток переднего плана имеет немного более высокий уровень приоритета, чем фоновые потоки. Так как он имеет более высокий приоритет, поток переднего плана получает больше времени ЦП, чем в фоновых потоках. Поток переднего плана имеет нормальный базовый приоритет 9; фоновый поток имеет нормальный базовый приоритет 7.

Пользователь задает окно переднего плана, щелкая окно или используя сочетание клавиш ALT + TAB или ALT + ESC. Чтобы получить маркер для окна переднего плана, используйте функцию [**жетфореграундвиндов**](/windows/win32/api/winuser/nf-winuser-getforegroundwindow) . Чтобы проверить, является ли окно приложения передним, Сравните маркер, возвращенный **жетфореграундвиндов** , с этим окном приложения.

Приложение задает окно переднего плана с помощью функции [**сетфореграундвиндов**](/windows/win32/api/winuser/nf-winuser-setforegroundwindow) .

Система позволяет определить, какие процессы могут устанавливать окно переднего плана. Процесс может задать окно переднего плана только в том случае, если:

- Справедливы все следующие условия.
  - Процесс, вызывающий **сетфореграундвиндов** , относится к классу настольных приложений, а не к приложению UWP или приложению Магазина Windows, разработанному для Windows 8 или 8,1.
  - В процессе переднего плана не отключены вызовы **сетфореграундвиндов** по предыдущему вызову функции [**локксетфореграундвиндов**](/windows/win32/api/winuser/nf-winuser-locksetforegroundwindow) .
  - Истекло время ожидания блокировки переднего плана (см. [ **SPI_GETFOREGROUNDLOCKTIMEOUT** в **системпараметерсинфо**](/windows/win32/api/winuser/nf-winuser-systemparametersinfoa#SPI_GETFOREGROUNDLOCKTIMEOUT)).
  - Нет активных меню.
- Кроме того, выполняется по крайней мере одно из следующих условий.
  - Вызывающий процесс является основным процессом.
  - Вызывающий процесс был запущен процессом переднего плана.
  - В настоящее время нет окна переднего плана, и поэтому фоновый процесс отсутствует.
  - Вызывающий процесс получил Последнее событие ввода.
  - Выполняется отладка либо процесса переднего плана, либо вызывающего процесса.

Процессу может быть запрещено устанавливать окно переднего плана, даже если оно соответствует этим условиям.

Процесс, который может задать передний план, может позволить другому процессу установить окно переднего плана путем вызова функции [**алловсетфореграундвиндов**](/windows/win32/api/winuser/nf-winuser-allowsetforegroundwindow) или путем вызова функции [**броадкастсистеммессаже**](/windows/win32/api/winuser/nf-winuser-broadcastsystemmessage) с флагом **БСФ \_ алловсфв** . Процесс переднего плана может отключить вызовы [**сетфореграундвиндов**](/windows/win32/api/winuser/nf-winuser-setforegroundwindow) , вызвав функцию [**локксетфореграундвиндов**](/windows/win32/api/winuser/nf-winuser-locksetforegroundwindow) .

### <a name="owned-windows"></a>Собственные окна

Перекрытие или всплывающее окно может принадлежать другому перекрытому или всплывающему окну. В качестве владельца накладывается несколько ограничений на окно.

-   Собственное окно всегда находится над его владельцем в z-порядке.
-   Система автоматически удаляет собственное окно, когда его владелец уничтожается.
-   Принадлежащее окно скрыто, когда его владелец сведен к минимальному.

Только перекрывающиеся или всплывающие окна могут быть окном-владельцем; дочернее окно не может быть окном-владельцем. Приложение создает собственное окно, указывая маркер окна владельца в качестве параметра *хвндпарент* объекта [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) при создании окна с стилем **\_ меню** [**WS \_ OVERLAPPED**](window-styles.md) или WS. Параметр *хвндпарент* должен обозначать перекрывающиеся или всплывающие окна. Если *хвндпарент* определяет дочернее окно, система назначает владение родительским окном верхнего уровня дочернего окна. После создания собственного окна приложение не может передать владение окном другому окну.

Диалоговые окна и окна сообщений являются собственными окнами по умолчанию. Приложение задает окно-владельца при вызове функции, которая создает диалоговое окно или поле сообщения.

Приложение может [**использовать функцию getHandler**](/windows/win32/api/winuser/nf-winuser-getwindow) с флагом **\_ владельца GW** для получения маркера для владельца окна.

### <a name="z-order"></a>Z-порядок

*Z-порядок* окна указывает на расположение окна в стеке перекрывающихся окон. Этот стек окна ориентирован на мнимую ось, ось z и расширяет наружу с экрана. Окно, расположенное в верхней части z-порядка, перекрывает все остальные окна. Окно в нижней части z-порядка перекрывается всеми остальными окнами.

В одном списке система сохраняет z-порядок. Он добавляет Windows в z-порядок в зависимости от того, являются ли они верхними окнами, окнами верхнего уровня или дочерними окнами. *Верхнее окно* перекрывает все остальные окна, не являющиеся самым верхним, независимо от того, является ли это окно активным или передним. Самое верхнее окно имеет **стиль \_ WS \_ ex** . Все самые верхние окна отображаются в z-порядке до всех окон, не являющихся самым верхними. Дочернее окно группируются с его родителем в z-порядке.

Когда приложение создает окно, система помещает его в верхнюю часть z-порядка для Windows того же типа. Функцию [**брингвиндовтотоп**](/windows/win32/api/winuser/nf-winuser-bringwindowtotop) можно использовать для перевода окна в начало z-порядка для Windows того же типа. Можно изменить z-порядок с помощью функций [**SetWindowPos**](/windows/win32/api/winuser/nf-winuser-setwindowpos) и [**дефервиндовпос**](/windows/win32/api/winuser/nf-winuser-deferwindowpos) .

Пользователь изменяет z-порядок, активируя другое окно. Система позиционирует активное окно в верхней части z-порядка для Windows того же типа. Когда окно поступает в начало z-порядка, дочерние окна должны быть. Функцию [**жеттопвиндов**](/windows/win32/api/winuser/nf-winuser-gettopwindow) можно использовать для поиска всех дочерних окон родительского окна и возврата маркера в дочернее окно, которое имеет наибольшее значение в z-порядке. Функция [**жетнекствиндов**](/windows/win32/api/winuser/nf-winuser-getnextwindow) Извлекает маркер в следующее или предыдущее окно в z-порядке.

## <a name="window-show-state"></a>Отображение состояния окна

В любой момент времени окно может быть активным или неактивным; скрытый или видимый; и сведены, развернутые или восстановленные. Эти качества называются совместно по мере *отображения состояния окна*. В следующих разделах описывается отображение состояния окна.

-   [Активное окно](#active-window)
-   [Отключенные окна](#disabled-windows)
-   [Видимость окна](#window-visibility)
-   [Сведенные, развернутые и восстановленные окна](#minimized-maximized-and-restored-windows)

### <a name="active-window"></a>Активное окно

*Активное окно* — это окно верхнего уровня приложения, с которым пользователь работает в данный момент. Чтобы позволить пользователю легко определить активное окно, система размещает его в верхней части z-порядка и изменяет цвет заголовка и границы окна на определенные системой цвета в активном окне. Только окно верхнего уровня может быть активным окном. Когда пользователь работает с дочерним окном, система активирует родительское окно верхнего уровня, связанное с дочерним окном.

Только одно окно верхнего уровня в системе активно за раз. Пользователь активирует окно верхнего уровня, щелкая его (или одно из его дочерних окон) или используя сочетание клавиш ALT + ESC или ALT + TAB. Приложение активирует окно верхнего уровня, вызывая функцию [**сетактивевиндов**](/windows/win32/api/winuser/nf-winuser-setactivewindow) . Другие функции могут вызвать активацию в системе другого окна верхнего уровня, включая [**SetWindowPos**](/windows/win32/api/winuser/nf-winuser-setwindowpos), [**дефервиндовпос**](/windows/win32/api/winuser/nf-winuser-deferwindowpos), [**сетвиндовплацемент**](/windows/win32/api/winuser/nf-winuser-setwindowplacement)и [**дестройвиндов**](/windows/win32/api/winuser/nf-winuser-destroywindow). Хотя приложение может активировать другое окно верхнего уровня в любое время, чтобы не путать пользователя, оно должно делать это только в ответ на действие пользователя. Приложение использует функцию [**жетактивевиндов**](/windows/win32/api/winuser/nf-winuser-getactivewindow) для получения маркера активного окна.

Когда активация меняется от окна верхнего уровня одного приложения к окну верхнего уровня другого, система отправляет сообщение [**WM \_ активатеапп**](wm-activateapp.md) в оба приложения, уведомляя их об изменении. Когда активация меняется на другое окно верхнего уровня в том же приложении, система отправляет как Windows, так и сообщение [**\_ активации WM**](../inputdev/wm-activate.md) .

### <a name="disabled-windows"></a>Отключенные окна

Окно можно отключить. *Отключенное окно* не получает от пользователя ввод с клавиатуры или с помощью мыши, но может получать сообщения от других окон, из других приложений и из системы. Приложение обычно отключает окно, чтобы пользователь не использовал окно. Например, приложение может отключить кнопку отправки в диалоговом окне, чтобы пользователь не мог его выбрать. Приложение может включить отключенное окно в любое время; При включении окна восстанавливаются нормальные входные данные.

По умолчанию окно активируется при создании. Однако приложение может задать стиль [**WS \_ disabled**](window-styles.md) , но для отключения нового окна. Приложение включает или отключает существующее окно с помощью функции [**енаблевиндов**](/windows/win32/api/winuser/nf-winuser-enablewindow) . Система отправляет сообщение о [**\_ включении WM**](wm-enable.md) в окно, когда его включенное состояние будет изменено. Приложение может определить, включено ли окно с помощью функции [**исвиндовенаблед**](/windows/win32/api/winuser/nf-winuser-iswindowenabled) .

Если дочернее окно отключено, система передает входные сообщения дочернего элемента мыши родительскому окну. Для определения того, следует ли включить дочернее окно, в родительском окне используются сообщения. Дополнительные сведения см. в разделе Ввод с помощью [мыши](../inputdev/mouse-input.md).

Только одно окно может принимать ввод с клавиатуры; говорят, что это окно имеет фокус клавиатуры. Если приложение использует функцию [**енаблевиндов**](/windows/win32/api/winuser/nf-winuser-enablewindow) для отключения окна фокуса клавиатуры, окно теряет фокус клавиатуры, а также отключает его. Затем **енаблевиндов** устанавливает фокус клавиатуры на **значение NULL**, означающее, что окно не имеет фокуса. Если в дочернем окне или другом подчиненном окне есть фокус клавиатуры, то при отключении родительского окна фокус теряется. Дополнительные сведения см. в разделе [Ввод с клавиатуры](../inputdev/keyboard-input.md).

### <a name="window-visibility"></a>Видимость окна

Окно может быть видимым или скрытым. Система отображает *видимое окно* на экране. Он скрывает *скрытое окно* , не рисуя его. Если окно видимое, пользователь может производить ввод в окно и видеть вывод окна. Если окно скрыто, оно эффективно отключено. Скрытое окно может обрабатывать сообщения от системы или от других окон, но не может обрабатывать ввод от пользователя или отображать вывод. Приложение задает состояние видимости окна при создании окна. Позже приложение может изменить состояние видимости.

Окно отображается, если для окна установлен стиль « [**WS \_ Visible**](window-styles.md) ». По умолчанию функция [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) создает скрытое окно, если в приложении не указан стиль, **\_ видимый для WS** . Как правило, приложение задает стиль **\_ отображения WS** после создания окна для сохранения сведений о процессе создания, скрытых от пользователя. Например, приложение может скрывать новое окно, пока оно настраивает внешний вид окна. Если в **CreateWindowEx** указан стиль **WS \_ Visible** , система отправляет сообщение [**WM \_ SHOWWINDOW**](wm-showwindow.md) в окно после создания окна, но перед его отображением.

Приложение может определить, является ли окно видимым с помощью функции [**исвиндоввисибле**](/windows/win32/api/winuser/nf-winuser-iswindowvisible) . Приложение может показать (сделать видимым) или скрыть окно с помощью функции [**ShowWindow**](/windows/win32/api/winuser/nf-winuser-showwindow), [**SetWindowPos**](/windows/win32/api/winuser/nf-winuser-setwindowpos), [**дефервиндовпос**](/windows/win32/api/winuser/nf-winuser-deferwindowpos)или [**сетвиндовплацемент**](/windows/win32/api/winuser/nf-winuser-setwindowplacement) или [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) . Эти функции отображают или скрывают окно, устанавливая или удаляя для окна стиль " [**WS \_ Visible**](window-styles.md) ". Они также перед отображением или скрытием сообщения [**WM \_ SHOWWINDOW**](wm-showwindow.md) отправляются в окно.

Когда окно-владелец свернется, система автоматически скрывает связанные с ней собственные окна. Аналогично, при восстановлении окна владельца система автоматически отображает связанные с ней окна. В обоих случаях система отправляет сообщение [**WM \_ SHOWWINDOW**](wm-showwindow.md) в собственные окна, прежде чем скрывать или отображать их. Иногда приложению может потребоваться скрыть собственные окна без необходимости сворачивания или скрытия владельца. В этом случае приложение использует функцию [**шововнедпопупс**](/windows/win32/api/winuser/nf-winuser-showownedpopups) . Эта функция задает или удаляет стиль [**\_ отображения WS**](window-styles.md) для всех собственных окон и отправляет сообщение **WM \_ SHOWWINDOW** в собственные окна перед скрытием или отображением. Скрытие окна владельца не влияет на состояние видимости принадлежащих окон.

Если родительское окно является видимым, также отображаются его связанные дочерние окна. Аналогично, когда родительское окно скрыто, его дочерние окна также скрываются. Минимизация родительского окна не влияет на состояние видимости дочерних окон. Это значит, что дочерние окна сворачиваются вместе с родительским, но стиль [**, \_ видимый WS**](window-styles.md) , не изменяется.

Даже если окно имеет стиль « [**WS \_ Visible**](window-styles.md) », пользователь может не видеть окно на экране; другие окна могут полностью перекрывать его или быть перемещены за границы экрана. Кроме того, видимое дочернее окно подчиняется правилам обрезки, установленным его связью «родители-потомки». Если родительское окно окна не отображается, оно также не будет отображаться. Если родительское окно перемещается за пределы экрана, дочернее окно также перемещается, так как дочернее окно отображается относительно левого верхнего левого угла. Например, пользователь может переместить родительское окно, содержащее дочернее окно, достаточного края экрана, что пользователь может не видеть дочернее окно, даже если его дочернее окно и его родительское окно имеют стиль **WS \_ Visible** .

### <a name="minimized-maximized-and-restored-windows"></a>Сведенные, развернутые и восстановленные окна

*Развернутое окно* — это окно с стилем [**WS- \_ Maximize**](window-styles.md) . По умолчанию система расширяет полноэкранное окно, и оно занимает весь экран или, если это дочернее окно, клиентскую область родительского окна. Хотя размер окна можно задать таким же размером, что и развернутое окно, развернутое окно немного отличается. Система автоматически перемещает строку заголовка окна в верхнюю часть экрана или в верхнюю часть клиентской области родительского окна. Кроме того, система отключает границу размера окна и возможность позиционирования окна в строке заголовка (чтобы пользователь не смог переместить окно, перетащив строку заголовка).

*Уменьшенное окно* — это окно с стилем [**WS- \_ сворачивания**](window-styles.md) . По умолчанию система уменьшает минимизированное окно до размеров кнопки панели задач и перемещает его на панель задач. *Восстановленное окно* — это окно, которое было возвращено к предыдущему размеру и положению, то есть к размеру, до которого он был уменьшен или развернут.

Если приложение задает в функции [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) стиль **\_ сворачивания** WS или WS, то окно изначально разворачивается или уменьшается. [**\_**](window-styles.md) После создания окна приложение может использовать функцию [**клосевиндов**](/windows/win32/api/winuser/nf-winuser-closewindow) для сворачивания окна. Функция [**арранжеикониквиндовс**](/windows/win32/api/winuser/nf-winuser-arrangeiconicwindows) упорядочивает значки на рабочем столе или упорядочивает в родительском окне окна с минимальными дочерними окнами родительского окна. Функция [**опеникон**](/windows/win32/api/winuser/nf-winuser-openicon) восстанавливает окно до предыдущего размера и расположения.

Функция [**ShowWindow**](/windows/win32/api/winuser/nf-winuser-showwindow) позволяет максимально увеличить, развернуть или восстановить окно. Он также может задавать состояние видимости и активации окна. Функция [**сетвиндовплацемент**](/windows/win32/api/winuser/nf-winuser-setwindowplacement) включает те же функции, что и **ShowWindow**, но может переопределять положение окна по умолчанию: сведенные, развернутые и восстановленные позиции.

Функции [**Zoom**](/windows/win32/api/winuser/nf-winuser-iszoomed) и [**Icon**](/windows/win32/api/winuser/nf-winuser-isiconic) определяют, является ли данное окно развернутым или минимальным соответственно. Функция [**жетвиндовплацемент**](/windows/win32/api/winuser/nf-winuser-getwindowplacement) извлекает уменьшенные, развернутые и восстановленные позиции для окна, а также определяет состояние отображения окна.

Когда система получает команду для развертывания или восстановления окна в режиме сворачивания, оно отправляет сообщение [**WM \_ куерйопен**](wm-queryopen.md) . Если процедура окна возвращает **значение false**, система игнорирует команду Развернуть или восстановить.

Система автоматически устанавливает размер и расположение развернутого окна в заданные системой значения по умолчанию для развернутого окна. Чтобы переопределить эти значения по умолчанию, приложение может либо вызвать функцию [**сетвиндовплацемент**](/windows/win32/api/winuser/nf-winuser-setwindowplacement) , либо обработать сообщение [**WM \_ жетминмаксинфо**](wm-getminmaxinfo.md) , полученное окном, когда система собирается развернуть окно. **WM \_ ЖЕТМИНМАКСИНФО** содержит указатель на структуру [**минмаксинфо**](/windows/win32/api/winuser/ns-winuser-minmaxinfo) , содержащую значения, которые система использует для установки максимального размера и позиции. Замена этих значений переопределяет значения по умолчанию.

## <a name="window-size-and-position"></a>Размер и расположение окна

Размер и расположение окна выражаются в виде ограничивающего прямоугольника, заданного в координатах относительно экрана или родительского окна. Координаты окна верхнего уровня задаются относительно левого верхнего угла экрана; координаты дочернего окна задаются относительно левого верхнего угла родительского окна. Приложение задает начальный размер и расположение окна при создании окна, но может изменить размер и расположение окна в любое время. Дополнительные сведения см. в разделе [заполненные фигуры](../gdi/filled-shapes.md).

В этом разделе рассматриваются следующие вопросы.

-   [Размер и расположение по умолчанию](#default-size-and-position)
-   [Размер отслеживания](#tracking-size)
-   [Системные команды](#system-commands)
-   [Функции размера и позиционирования](#size-and-position-functions)
-   [Размер и расположение сообщений](#size-and-position-messages)

### <a name="default-size-and-position"></a>Размер и расположение по умолчанию

Приложение может позволить системе вычислить исходный размер или расположение окна верхнего уровня, указав \_ УСЕДЕФАУЛТ во [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa). Если приложение устанавливает координаты окна во Вт \_ . уседефаулт и не создает никаких других окон верхнего уровня, система устанавливает расположение нового окна относительно левого верхнего угла экрана; в противном случае задается расположение относительно положения окна верхнего уровня, которое приложение создало последним. Если для параметров Width и Height задано значение уседефаулт во Вт \_ ., система вычисляет размер нового окна. Если приложение создало другие окна верхнего уровня, система применяет размер нового окна к размеру самого последнего окна верхнего уровня, созданного приложением. Указание уседефаулт во Вт \_ . при создании дочернего или всплывающего окна система устанавливает размер окна по умолчанию как минимальный размер окна.

### <a name="tracking-size"></a>Размер отслеживания

Система поддерживает минимальный и максимальный размер отслеживания для окна стиля [**WS \_ сиккфраме**](window-styles.md) ; окно с этим стилем имеет границу изменения размера. *Минимальный размер для отслеживания* — минимальный размер окна, который можно создать путем перетаскивания границы размера окна. Точно так же *максимальный размер отслеживания* — это самый крупный размер окна, который можно создать, перетащив границу изменения размера.

Минимальный и максимальный размеры окна устанавливаются в определенные системой значения по умолчанию при создании окна системой. Приложение может обнаружить значения по умолчанию и переопределить их, обрабатывая сообщение [**WM \_ жетминмаксинфо**](wm-getminmaxinfo.md) . Дополнительные сведения см. в разделе [сообщения о размере и позиционировании](#size-and-position-messages).

### <a name="system-commands"></a>Системные команды

Приложение с меню окна может изменить размер и расположение этого окна, отправив системные команды. Системные команды создаются, когда пользователь выбирает команды в меню окно. Приложение может эмулировать действие пользователя, отправляя сообщение [**WM \_ сискомманд**](../menurc/wm-syscommand.md) в окно. Следующие системные команды влияют на размер и расположение окна.



| Get-Help      | Описание                                                                                                                                                          |
|--------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| SC \_ Close    | Закрывает окно. Эта команда отправляет сообщение [**о \_ закрытии WM**](wm-close.md) в окно. Окно выполняет все действия, необходимые для очистки и уничтожения. |
| \_развернуть SC | Разворачивает окно.                                                                                                                                                |
| SC — \_ Minimize | Сворачивает окно.                                                                                                                                                |
| SC \_ Move     | Перемещает окно.                                                                                                                                                    |
| SC \_ RESTORE  | Восстанавливает уменьшенное или развернутое окно до его предыдущего размера и расположения.                                                                                          |
| \_Размер SC     | Запускает команду размера. Чтобы изменить размер окна, используйте мышь или клавиатуру.                                                                                  |



 

### <a name="size-and-position-functions"></a>Функции размера и позиционирования

После создания окна приложение может задать размер или расположение окна, вызвав одну из нескольких различных функций, включая [**сетвиндовплацемент**](/windows/win32/api/winuser/nf-winuser-setwindowplacement), [**мовевиндов**](/windows/win32/api/winuser/nf-winuser-movewindow), [**SetWindowPos**](/windows/win32/api/winuser/nf-winuser-setwindowpos)и [**дефервиндовпос**](/windows/win32/api/winuser/nf-winuser-deferwindowpos). **Сетвиндовплацемент** задает режим сворачивания окна, его развернутую точку, размер и расположение, а затем показывает состояние. Функции **мовевиндов** и **SetWindowPos** похожи; Установите размер или расположение одного окна приложения. Функция **SetWindowPos** включает набор флагов, влияющих на состояние отображения окна. **Мовевиндов** не включает эти флаги. Используйте функции [**бегиндефервиндовпос**](/windows/win32/api/winuser/nf-winuser-begindeferwindowpos), **дефервиндовпос** и [**енддефервиндовпос**](/windows/win32/api/winuser/nf-winuser-enddeferwindowpos) для одновременного задания расположения ряда окон, включая размер, расположение, расположение в z-порядке и отображение состояния.

Приложение может извлекать координаты ограничивающего прямоугольника окна с помощью функции [**жетвиндоврект**](/windows/win32/api/winuser/nf-winuser-getwindowrect) . **Жетвиндоврект** заполняет структуру [**Rect**](/previous-versions//dd162897(v=vs.85)) координатами верхнего левого и нижнего правого угла окна. Координаты задаются относительно левого верхнего угла экрана, даже для дочернего окна. Функция [**скринтоклиент**](/windows/win32/api/winuser/nf-winuser-screentoclient) или [**мапвиндовпоинтс**](/windows/win32/api/winuser/nf-winuser-mapwindowpoints) сопоставляет экранные координаты ограничивающего прямоугольника дочернего окна с координатами относительно клиентской области родительского окна.

Функция [**жетклиентрект**](/windows/win32/api/winuser/nf-winuser-getclientrect) извлекает координаты клиентской области окна. **Жетклиентрект** заполняет структуру [**Rect**](/previous-versions//dd162897(v=vs.85)) координатами верхнего левого и нижнего правого угла клиентской области, но координаты отсчитываются от самой клиентской области. Это означает, что координаты верхнего левого угла клиентской области всегда равны (0, 0), а координаты нижнего правого угла имеют ширину и высоту клиентской области.

Функция [**каскадевиндовс**](/windows/win32/api/winuser/nf-winuser-cascadewindows) размещает окна на рабочем столе или раскрывают дочерние окна указанного родительского окна. Функция [**тилевиндовс**](/windows/win32/api/winuser/nf-winuser-tilewindows) накладывает окна на Рабочий стол или плитки дочерних окон указанного родительского окна.

### <a name="size-and-position-messages"></a>Размер и расположение сообщений

Система отправляет сообщение [**WM \_ жетминмаксинфо**](wm-getminmaxinfo.md) в окно, размер или расположение которого собирается измениться. Например, сообщение отправляется, когда пользователь нажимает кнопку " **переместить** " или " **Размер** " в меню "окно" или щелкает границу изменения размера или строку заголовка. сообщение также отправляется, когда приложение вызывает [**SetWindowPos**](/windows/win32/api/winuser/nf-winuser-setwindowpos) для перемещения или изменения размера окна. **WM \_ ЖЕТМИНМАКСИНФО** содержит указатель на структуру [**минмаксинфо**](/windows/win32/api/winuser/ns-winuser-minmaxinfo) , содержащую развернутый по умолчанию размер и расположение окна, а также минимальный и максимальный размер отслеживания по умолчанию. Приложение может переопределить значения по умолчанию, обрабатывая **WM \_ жетминмаксинфо** и установив соответствующие члены **минмаксинфо**. Для получения **\_ жетминмаксинфо WM** окно должно иметь стиль **\_ заголовка** [**WS \_ сиккфраме**](window-styles.md) или WS. Окно с стилем **WS \_ сиккфраме** получает это сообщение в процессе создания окна, а также при перемещении или изменении размера.

Система отправляет сообщение [**WM \_ виндовпосчангинг**](wm-windowposchanging.md) в окно, размер, расположение, расположение в z-порядке или состояние отображения которого собирается измениться. Это сообщение содержит указатель на структуру [**WINDOWPOS**](/windows/win32/api/winuser/ns-winuser-windowpos) , указывающую новый размер, расположение и расположение окна в z-порядке, а также состояние отображения. Устанавливая элементы **WINDOWPOS**, приложение может повлиять на новый размер, расположение и внешний вид окна.

После изменения размера окна, расположения, расположения в z-порядке или отображения состояния система отправляет сообщение [**WM \_ виндовпосчанжед**](wm-windowposchanged.md) в окно. Это сообщение содержит указатель на [**WINDOWPOS**](/windows/win32/api/winuser/ns-winuser-windowpos) , который информирует окно о новом размере, положении, положении в z-порядке и показывает состояние. Установка элементов структуры **WINDOWPOS** , которая передается с помощью **WM \_ виндовпосчанжед** , не влияет на окно. Окно, которое должно обрабатывать сообщения [**WM \_ size**](wm-size.md) и [**WM \_ Move**](wm-move.md) , должно **передавать WM \_ виндовпосчанжед** функции [**Дефвиндовпрок**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) . в противном случае система не отправляет **\_ Размер WM** и **WM \_ перемещает** сообщения в окно.

Система отправляет сообщение [**WM \_ нккалксизе**](wm-nccalcsize.md) в окно при создании или изменении размера окна. Система использует сообщение для вычисления размера клиентской области окна и положения клиентской области относительно левого верхнего угла окна. Окно обычно передает это сообщение в процедуру окна по умолчанию; Однако это сообщение может быть полезно в приложениях, которые настраивают неклиентскую область окна или сохраняют части клиентской области при изменении размера окна. Дополнительные сведения см. в разделе [Рисование и рисование](../gdi/painting-and-drawing.md).

## <a name="window-animation"></a>Анимация окна

При отображении или скрытии окон с помощью функции [**аниматевиндов**](/windows/win32/api/winuser/nf-winuser-animatewindow) можно создавать специальные эффекты. Когда окно анимировано таким образом, система будет либо рулонировать, либо скольжением, либо исчезать окно в зависимости от флагов, указанных при вызове **аниматевиндов**.

По умолчанию система использует *анимацию рулона*. При таком результате окно открывается как «рулон» (с отображением окна) или «рулон» (скрытие окна). Можно использовать параметр *dwFlags* , чтобы указать, будет ли окно горизонтально, вертикально или по диагонали.

При указании флага **\_ слайда AW** система использует *анимацию слайдов*. При таком результате окно отображается для просмотра (с отображением окна) или за пределами представления (скрытие окна). Можно использовать параметр *dwFlags* , чтобы указать, как окно слайдов будет горизонтально, вертикально или по диагонали.

При указании флага **AW \_ Blend** система использует *Выцветание с альфа-смешением*.

Можно также использовать флаг **\_ центра AW** , чтобы сделать окно свернутым или развернутым по внешнему.

## <a name="window-layout-and-mirroring"></a>Макет окна и зеркальное отображение

Макет окна определяет, как текст и объекты Windows интерфейс графических устройств (GDI) размещаются в окне или в контексте устройства (DC). Для некоторых языков, таких как английский, французский и немецкий, требуется макет слева направо (LTR). Для других языков, таких как арабский и иврит, требуется макет с направлением письма справа налево. Макет окна применяется к тексту, но также влияет на другие элементы GDI окна, включая растровые изображения, значки, расположение источника, кнопки, каскадные элементы управления "дерево" и способ увеличения горизонтальной координаты при переходе влево или вправо. Например, после того, как приложение настроило макет RTL, начало координат располагается на правой границе окна или устройства, а число, представляющее горизонтальную координату, увеличивается по мере перемещения влево. Однако макет окна влияет не на все объекты. Например, макет для диалоговых окон, окон сообщений и контекстов устройств, которые не связаны с окном, например метафайлы и контроллеры домена печати, необходимо обрабатывать отдельно. Конкретные особенности для них приведены далее в этом разделе.

Функции окон позволяют задавать или изменять макет окна в версиях Windows для арабского и иврита. Обратите внимание, что переход на макет с письмом справа налево (также называемый зеркальным отображением) не поддерживается для Windows, имеющих стиль [CS \_ овндк](about-window-classes.md) или для контроллера домена с \_ расширенным графическим режимом GM.

По умолчанию макет окна размещается слева направо (LTR). Чтобы задать макет окна справа налево, вызовите [**CreateWindowEx**](/windows/win32/api/winuser/nf-winuser-createwindowexa) с помощью стиля **WS \_ ex \_ лайаутртл**. Кроме того, по умолчанию дочернее окно (то есть созданное с помощью стиля [**\_ дочернего элемента WS**](window-styles.md) и допустимый родительский параметр *HWND* в вызове [**CreateWindow**](/windows/win32/api/winuser/nf-winuser-createwindowa) или **CreateWindowEx**) имеет тот же макет, что и его родительский элемент. Чтобы отключить наследование зеркального отображения для всех дочерних окон, укажите **WS \_ ex \_ NOINHERITLAYOUT** в вызове **CreateWindowEx**. Обратите внимание, что зеркальное отображение не наследуется собственными окнами (созданными без стиля **\_ дочернего элемента WS** ) или созданными с помощью родительского параметра *HWND* в **CreateWindowEx** , для которого установлено **значение NULL**. Чтобы отключить наследование зеркального отображения для отдельного окна, обработайте сообщение [**WM \_ Нккреате**](wm-nccreate.md) с [**жетвиндовлонг**](/windows/win32/api/winuser/nf-winuser-getwindowlonga) и [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) , чтобы отключить флаг **WS \_ ex \_ лайаутртл** . Эта обработка является дополнением к любой другой обработке. В следующем фрагменте кода показано, как это сделать.


```
SetWindowLong (hWnd, 
               GWL_EXSTYLE, 
               GetWindowLong(hWnd,GWL_EXSTYLE) & ~WS_EX_LAYOUTRTL))
```



Можно задать макет по умолчанию RTL, вызвав [**сетпроцессдефаултлайаут**](/windows/win32/api/winuser/nf-winuser-setprocessdefaultlayout)(макет \_ RTL). Все окна, созданные после вызова, будут отражены, но существующие окна не затрагиваются. Чтобы отключить зеркальное отображение по умолчанию, вызовите **сетпроцессдефаултлайаут**(0).

Обратите внимание, что [**сетпроцессдефаултлайаут**](/windows/win32/api/winuser/nf-winuser-setprocessdefaultlayout) отражает только контроллеры домена с зеркальными окнами. Для зеркального отображения любого контроллера домена вызовите [**сетлайаут**](/windows/win32/api/wingdi/nf-wingdi-setlayout)(HDC, Layout \_ RTL). Дополнительные сведения см. в разделе обсуждение контекстов устройств зеркального отображения, не связанных с Windows, которые описаны далее в этой статье.

Растровые изображения и значки в зеркальном окне также отражаются по умолчанию. Однако не все из них должны быть отражены. Например, не следует создавать зеркальное отображение текста, эмблемы компании или аналоговых часов. Чтобы отключить зеркальное отображение точечных рисунков, вызовите [**сетлайаут**](/windows/win32/api/wingdi/nf-wingdi-setlayout) с разметкой \_ битмапориентатионпресервед bit, установленным в *двлайаут*. Чтобы отключить зеркальное отображение в контроллере домена, вызовите **сетлайаут**(HDC, 0).

Чтобы запросить текущий макет по умолчанию, вызовите [**жетпроцессдефаултлайаут**](/windows/win32/api/winuser/nf-winuser-getprocessdefaultlayout). После успешного возврата *пдвдефаултлайаут* содержит макет \_ RTL или 0. Чтобы запросить параметры макета контекста устройства, вызовите метод [**компоновки**](/windows/win32/api/wingdi/nf-wingdi-getlayout). При успешном возврате метод- **Layout** возвращает **DWORD** , который указывает параметры макета по параметрам макета \_ RTL и \_ битмапориентатионпресервед бит.

После создания окна измените макет с помощью функции [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga) . Например, это необходимо, когда пользователь изменяет язык пользовательского интерфейса существующего окна с арабского языка или иврита на немецкий. Однако при изменении макета существующего окна необходимо сделать недействительным и обновить окно, чтобы содержимое окна нарисовано на одном и том же макете. В следующем примере кода показан пример кода, который изменяет макет окна по мере необходимости:


```
// Using ANSI versions of GetWindowLong and SetWindowLong because Unicode
// is not needed for these calls

lExStyles = GetWindowLongA(hWnd, GWL_EXSTYLE);

// Check whether new layout is opposite the current layout
if (!!(pLState -> IsRTLLayout) != !!(lExStyles & WS_EX_LAYOUTRTL))
{
    // the following lines will update the window layout

    lExStyles ^= WS_EX_LAYOUTRTL;        // toggle layout
    SetWindowLongA(hWnd, GWL_EXSTYLE, lExStyles);
    InvalidateRect(hWnd, NULL, TRUE);    // to update layout in the client area
}
```



При зеркальном отображении следует придуматься к терминам «NEAR» и «Far» вместо «Left» и «right». В противном случае могут возникнуть проблемы. Одна из распространенных методик создания кода, вызывающая проблемы в зеркальном окне, возникает при сопоставлении координат экрана и клиентских координат. Например, приложения часто используют код, аналогичный приведенному ниже, для размещения элемента управления в окне:


```
// DO NOT USE THIS IF APPLICATION MIRRORS THE WINDOW

// get coordinates of the window in screen coordinates
GetWindowRect(hControl, (LPRECT) &rControlRect);  

// map screen coordinates to client coordinates in dialog
ScreenToClient(hDialog, (LPPOINT) &rControlRect.left); 
ScreenToClient(hDialog, (LPPOINT) &rControlRect.right);
```



Это вызывает проблемы при зеркальном отображении, поскольку левый конец прямоугольника станет правым ребром в зеркальном окне и наоборот. Чтобы избежать этой проблемы, замените вызовы [**скринтоклиент**](/windows/win32/api/winuser/nf-winuser-screentoclient) вызовом [**мапвиндовпоинтс**](/windows/win32/api/winuser/nf-winuser-mapwindowpoints) следующим образом:


```
// USE THIS FOR MIRRORING

GetWindowRect(hControl, (LPRECT) &rControlRect);
MapWindowPoints(NULL, hDialog, (LPPOINT) &rControlRect, 2)
```



Этот код работает потому, что на платформах, поддерживающих зеркальное отображение, [**мапвиндовпоинтс**](/windows/win32/api/winuser/nf-winuser-mapwindowpoints) изменяется для переключения левой и правой точек при зеркальном отображении окна клиента. Дополнительные сведения см. в подразделе "Примечания" раздела **мапвиндовпоинтс**.

Другой распространенный подход, который может вызвать проблемы в зеркальных окнах, — размещение объектов в клиентском окне с использованием смещений в экранных координатах вместо клиентских координат. Например, в следующем коде используется разница в координатах экрана в качестве положения x в координатах клиента для размещения элемента управления в диалоговом окне.


```
// OK if LTR layout and mapping mode of client is MM_TEXT,
// but WRONG for a mirrored dialog 

RECT rdDialog;
RECT rcControl;

HWND hControl = GetDlgItem(hDlg, IDD_CONTROL);
GetWindowRect(hDlg, &rcDialog);             // gets rect in screen coordinates
GetWindowRect(hControl, &rcControl);
MoveWindow(hControl,
           rcControl.left - rcDialog.left,  // uses x position in client coords
           rcControl.top - rcDialog.top,
           nWidth,
           nHeight,
           FALSE);
```



Этот код подходит, когда окно диалогового окна имеет макет слева направо (LTR), а режим сопоставления клиента — это \_ текст в формате mm, так как Новая координата x в клиентской части соответствует разнице в левых границах элемента управления и диалоговом окне в координатах экрана. Однако в зеркальном диалоговом окне левый и правый Обратны, поэтому следует использовать [**мапвиндовпоинтс**](/windows/win32/api/winuser/nf-winuser-mapwindowpoints) следующим образом:


```
RECT rcDialog;
RECT rcControl;

HWND hControl - GetDlgItem(hDlg, IDD_CONTROL);
GetWindowRect(hControl, &rcControl);

// MapWindowPoints works correctly in both mirrored and non-mirrored windows.
MapWindowPoints(NULL, hDlg, (LPPOINT) &rcControl, 2);

// Now rcControl is in client coordinates.
MoveWindow(hControl, rcControl.left, rcControl.top, nWidth, nHeight, FALSE)
```



### <a name="mirroring-dialog-boxes-and-message-boxes"></a>Диалоговое окно зеркального отображения и окна сообщений

Диалоговые окна и окна сообщений не наследуют макет, поэтому необходимо явно задать макет. Чтобы отобразить окно сообщения, вызовите [**MessageBox**](/windows/win32/api/winuser/nf-winuser-messagebox) или [**мессажебоксекс**](/windows/win32/api/winuser/nf-winuser-messageboxexa) с параметром **\_ RTLREADING МБ** . Для разметки диалогового окна справа налево используйте расширенный стиль WS \_ ex \_ лайаутртл в структуре шаблона диалогового окна [**длгтемплатикс**](../dlgbox/dlgtemplateex.md). Страницы свойств являются особым случаем диалоговых окон. Каждая вкладка рассматривается как отдельное диалоговое окно, поэтому необходимо включить \_ стиль WS ex \_ лайаутртл на каждой вкладке, которую нужно зеркально отобразить.

### <a name="mirroring-device-contexts-not-associated-with-a-window"></a>Контексты устройств зеркального отображения, не связанные с окном

Контроллеры домена, не связанные с окном, например метафайлы или контроллеры домена, не наследуют макет, поэтому необходимо явно задать макет. Чтобы изменить макет контекста устройства, используйте функцию [**сетлайаут**](/windows/win32/api/wingdi/nf-wingdi-setlayout) .

Функция [**сетлайаут**](/windows/win32/api/wingdi/nf-wingdi-setlayout) редко используется в Windows. Как правило, Windows получает связанный контроллер домена только при обработке сообщения [**WM \_ Paint**](../gdi/wm-paint.md) . Иногда программа создает контроллер домена для окна, вызывая [**GetDC**](/windows/win32/api/winuser/nf-winuser-getdc). В любом случае начальный макет контроллера домена задается параметром [**бегинпаинт**](/windows/win32/api/winuser/nf-winuser-beginpaint) или **GetDC** в соответствии с \_ флагом окна WS \_ ex лайаутртл.

На значения, возвращаемые [**жетвиндоворжекс**](/windows/win32/api/wingdi/nf-wingdi-getwindoworgex), [**жетвиндовекстекс**](/windows/win32/api/wingdi/nf-wingdi-getwindowextex), [**жетвиевпорторжекс**](/windows/win32/api/wingdi/nf-wingdi-getviewportorgex) и [**жетвиевпортекстекс**](/windows/win32/api/wingdi/nf-wingdi-getviewportextex) , не влияет вызов [**сетлайаут**](/windows/win32/api/wingdi/nf-wingdi-setlayout).

Если макет имеет вид RTL, [**жетмапмоде**](/windows/win32/api/wingdi/nf-wingdi-getmapmode) будет возвращать мм \_ анизотропную длину вместо mm \_ Text. Вызов [**сетмапмоде**](/windows/win32/api/wingdi/nf-wingdi-setmapmode) с \_ текстом mm будет работать правильно, только возвращаемое значение из **жетмапмоде** затронуто. Аналогично, вызов [**сетлайаут**](/windows/win32/api/wingdi/nf-wingdi-setlayout)(HDC, Layout \_ RTL), если режим СОПОСТАВЛЕНИЯ — текст mm, приводит к \_ изменению режима сопоставления на « \_ анизотропная».

## <a name="window-destruction"></a>Уничтожение окна

Как правило, приложение должно уничтожить все создаваемые им окна. Для этого используется функция [**дестройвиндов**](/windows/win32/api/winuser/nf-winuser-destroywindow) . При уничтожении окна система скрывает окно, если оно видимо, а затем удаляет все внутренние данные, связанные с окном. Это сделает недействительным маркер окна, который больше не может использоваться приложением.

Приложение уничтожает многие окна, создаваемые в ближайшее время после создания. Например, приложение обычно уничтожает окно диалогового окна, как только приложение будет иметь входные данные, необходимые пользователю для продолжения задачи. Приложение в конечном итоге уничтожает главное окно приложения (перед завершением работы).

Перед уничтожением окна приложение должно сохранить или удалить все данные, связанные с окном, и освободить все системные ресурсы, выделенные для окна. Если приложение не освобождает ресурсы, система освобождает все ресурсы, не освобожденные приложением.

Уничтожение окна не влияет на класс окна, из которого создается окно. Новые окна можно по-прежнему создавать с помощью этого класса, а все существующие окна этого класса продолжают работать. При уничтожении окна также уничтожаются его дочерние окна. Функция [**дестройвиндов**](/windows/win32/api/winuser/nf-winuser-destroywindow) отправляет сообщение [**WM \_ destroy**](wm-destroy.md) сначала в окно, а затем в его дочерние окна и подчиненные окна. Таким образом все дочерние окна, которые уничтожаются, также уничтожаются.

Окно с меню окна получает сообщение о [**\_ закрытии WM**](wm-close.md) , когда пользователь нажимает кнопку **Закрыть**. Обрабатывая это сообщение, приложение может запросить у пользователя подтверждение перед уничтожением окна. Если пользователь подтверждает, что окно должно быть уничтожено, приложение может вызвать функцию [**дестройвиндов**](/windows/win32/api/winuser/nf-winuser-destroywindow) для уничтожения окна.

Если окно, которое уничтожается, является активным окном, состояния активного и фокуса передаются в другое окно. Окно, которое становится активным окном, является следующим окном, как определено сочетанием клавиш ALT + ESC. Новое активное окно определяет, какое окно получает фокус клавиатуры.

 

 
