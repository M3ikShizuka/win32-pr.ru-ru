---
description: Сервер канала управляет возможностью наследования дескрипторов следующими способами.
ms.assetid: 72302f8b-f3a2-4efc-aab1-e596b8323984
title: Наследование обработчика канала
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 21cf91d4393b43011a2df632806f96da1e713b96
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "103808404"
---
# <a name="pipe-handle-inheritance"></a>Наследование обработчика канала

Сервер канала управляет возможностью наследования дескрипторов следующими способами.

-   Функция [**креатепипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-createpipe) Получает структуру [**\_ атрибутов безопасности**](/previous-versions/windows/desktop/legacy/aa379560(v=vs.85)) . Если сервер канала устанавливает для элемента **бинхерисандле** этой структуры **значение true**, дескрипторы, созданные **креатепипе** , могут быть унаследованы.
-   Сервер канала может использовать функцию [**дупликатехандле**](/windows/desktop/api/handleapi/nf-handleapi-duplicatehandle) для изменения наследования обработчика канала. Сервер канала может создать наследуемый дубликат маркера наследуемого канала или наследуемого дубликата ненаследованного обработчика канала.
-   Функция [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa) позволяет серверу канала указать, наследует ли дочерний процесс все его наследуемые дескрипторы или нет.

Когда дочерний процесс наследует маркер канала, система предоставляет процессу доступ к каналу. Однако родительский процесс должен передавать значение обработчика дочернему процессу. Родительский процесс обычно делает это путем перенаправления стандартного выходного маркера в дочерний процесс, как показано в следующих шагах:

1.  Вызовите функцию [**жетстдхандле**](/windows/console/getstdhandle) для получения текущего стандартного выходного маркера. Сохраните этот обработчик, чтобы восстановить исходный стандартный выходной обработчик после создания дочернего процесса.
2.  Вызовите функцию [**сетстдхандле**](/windows/console/setstdhandle) , чтобы задать стандартный выходной маркер для маркера записи в канал. Теперь родительский процесс может создать дочерний процесс.
3.  Вызовите функцию [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) , чтобы закрыть маркер записи в канал. После того как дочерний процесс наследует маркер записи, родительский процесс больше не нуждается в его копии.
4.  Вызовите [**сетстдхандле**](/windows/console/setstdhandle) для восстановления исходного стандартного выходного маркера.

Дочерний процесс использует функцию [**жетстдхандле**](/windows/console/getstdhandle) для получения стандартного выходного маркера, который теперь является обработчиком для конца записи канала. Затем дочерний процесс использует функцию [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) для отправки выходных данных в канал. Когда дочерний элемент завершает работу с каналом, он должен закрыть обработчик, вызвав [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) или заканчивающийся, который автоматически закрывает этот обработчик.

Родительский процесс использует функцию [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) для получения входных данных из канала. Данные записываются в анонимный канал в виде потока байтов. Это означает, что родительский процесс, считывающий из канала, не может различить байты, записанные в отдельных операциях записи, если только родительский и дочерний процессы не используют протокол для указания места завершения операции записи. Когда все дескрипторы записи в канал закрываются, функция **ReadFile** возвращает ноль. Важно, чтобы родительский процесс закрыл свой обработчик до конца записи канала перед вызовом **ReadFile**. Если это не сделано, операция **ReadFile** не может вернуть нуль, так как родительский процесс имеет открытый обработчик для конца записи канала.

Процедура перенаправления стандартного входного маркера аналогична процедуре перенаправления стандартного выходного маркера, за исключением того, что в качестве стандартного маркера ввода дочернего элемента используется маркер чтения канала. В этом случае родительский процесс должен гарантировать, что дочерний процесс не наследует маркер записи. Если это не сделано, операция [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) , выполняемая дочерним процессом, не может вернуть нуль, так как дочерний процесс имеет открытый обработчик для конца записи канала.

Пример программы, использующей анонимные каналы для перенаправления стандартных дескрипторов дочернего процесса, см. в разделе [Создание дочернего процесса с перенаправленным входом и выходом](/windows/desktop/ProcThread/creating-a-child-process-with-redirected-input-and-output).

 

 
