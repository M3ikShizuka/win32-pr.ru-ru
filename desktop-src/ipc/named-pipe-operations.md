---
description: Операции с каналами, включая клиенты и серверы канала, могут вызывать одну из нескольких функций (в дополнение к Каллнамедпипе) для чтения и записи в именованный канал.
ms.assetid: ae06455e-33bc-433d-be8f-aeb8eeb99b1d
title: Операции именованного канала
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 703189a129fc44b956ab65c2f70bbf88bfd22700
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "104143486"
---
# <a name="named-pipe-operations"></a>Операции именованного канала

В первый раз, когда сервер канала вызывает функцию [**креатенамедпипе**](/windows/desktop/api/Winbase/nf-winbase-createnamedpipea) , он использует параметр *нмаксинстанцес* , чтобы указать максимальное количество экземпляров канала, которые могут существовать одновременно. Сервер может многократно вызывать **креатенамедпипе** для создания дополнительных экземпляров канала, если он не превышает максимальное число экземпляров. Если функция завершается с ошибкой, каждый вызов возвращает маркер на серверный конец экземпляра именованного канала.

Как только сервер канала создает экземпляр канала, клиент канала может подключиться к нему, вызвав функцию [**CreateFile**](/windows/desktop/api/fileapi/nf-fileapi-createfilea) или [**каллнамедпипе**](/windows/desktop/api/Winbase/nf-winbase-callnamedpipea) . Если доступен экземпляр канала, **CreateFile** возвращает маркер для клиентской стороны экземпляра канала. Если нет доступных экземпляров канала, клиент канала может использовать функцию [**ваитнамедпипе**](/windows/desktop/api/Winbase/nf-winbase-waitnamedpipea) , чтобы подождать, пока канал не станет доступным.

Сервер канала может определить, подключен ли клиент канала к экземпляру канала, вызвав функцию [**коннектнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) . Если обработчик канала находится в режиме ожидания блокировки, **коннектнамедпипе** не возвращает значение, пока клиент не будет подключен.

Клиенты и серверы канала могут вызывать одну из нескольких функций (в дополнение к [**каллнамедпипе**](/windows/desktop/api/Winbase/nf-winbase-callnamedpipea) ) для чтения и записи в именованный канал. Поведение этих функций зависит от типа канала и режимов, действующих для указанного обработчика канала, следующим образом.

-   Функции [**ReadFile**](/windows/desktop/api/fileapi/nf-fileapi-readfile) и [**WriteFile**](/windows/desktop/api/fileapi/nf-fileapi-writefile) можно использовать с каналами типа Byte или Message-type.
-   Функции [**реадфиликс**](/windows/desktop/api/fileapi/nf-fileapi-readfileex) и [**вритефиликс**](/windows/desktop/api/fileapi/nf-fileapi-writefileex) можно использовать с каналами типа Byte или Message-type, если для перекрывающихся операций был открыт обработчик канала.
-   Функцию [**пикнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-peeknamedpipe) можно использовать для чтения без удаления содержимого канала типа Byte или канала типа сообщения. **Пикнамедпипе** также может возвращать дополнительные сведения об экземпляре канала.
-   Функцию [**трансактнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe) можно использовать с дуплексными каналами типа сообщений, если для вызывающего процесса установлен режим чтения сообщений. Функция записывает сообщение запроса и считывает ответное сообщение за одну операцию, повышая производительность сети.

Сервер канала не должен выполнять операцию блокировки чтения до запуска клиента канала. В противном случае может возникнуть состояние гонки. Обычно это происходит, когда код инициализации, такой как библиотека времени выполнения C, должен блокировать и проверять Унаследованные дескрипторы.

Когда клиент и сервер завершают работу с помощью экземпляра канала, сервер должен сначала вызвать функцию [**FlushFileBuffers**](/windows/desktop/api/fileapi/nf-fileapi-flushfilebuffers) , чтобы убедиться, что все байты или сообщения, записанные в канал, считываются клиентом. **FlushFileBuffers** не возвращает значение, пока клиент не прочитает все данные из канала. Затем сервер вызывает функцию [**дисконнектнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-disconnectnamedpipe) , чтобы закрыть подключение к клиенту канала. Эта функция делает клиентский маркер недопустимым, если он еще не был закрыт. Все непрочитанные данные в канале отбрасываются. После отключения клиента сервер вызывает функцию [**CloseHandle**](/windows/desktop/api/handleapi/nf-handleapi-closehandle) , чтобы закрыть свой маркер для экземпляра канала. Кроме того, сервер может использовать [**коннектнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe) , чтобы позволить новому клиенту подключаться к этому экземпляру канала.

Процесс может получить сведения о именованном канале, вызвав функцию [**жетнамедпипеинфо**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-getnamedpipeinfo) , которая возвращает тип канала, размер входных и выходных буферов, а также максимальное число экземпляров каналов, которые могут быть созданы. Функция [**жетнамедпипехандлестате**](/windows/desktop/api/Winbase/nf-winbase-getnamedpipehandlestatea) сообщает о режимах чтения и ожидания для обработчика канала, текущего числа экземпляров канала и дополнительных сведений о каналах, взаимодействующих по сети. Функция [**сетнамедпипехандлестате**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-setnamedpipehandlestate) задает режим чтения и режимы ожидания для маркера канала. Для клиентов канала, взаимодействующих с удаленным сервером, функция также управляет максимальным числом байтов, которое требуется получить, или максимальным временем ожидания перед передачей сообщения (предполагая, что клиентский обработчик не был открыт с включенным режимом сквозной записи).

 

 
