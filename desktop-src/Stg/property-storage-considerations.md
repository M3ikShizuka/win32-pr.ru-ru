---
title: рекомендации по служба хранилища свойств
description: Ипропертистораже Реадмултипле считывает столько свойств, сколько указано в массиве ргпспек, как и в наборе свойств.
ms.assetid: 7540966f-a3b2-46c9-9e04-b15133a517eb
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 128c5da70ae08c62660e0177187036fddee6ff27ed1d9971b6f95dea7052ecdd
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119662164"
---
# <a name="property-storage-considerations"></a>рекомендации по служба хранилища свойств

[**Ипропертистораже:: реадмултипле**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) считывает столько свойств, сколько указано в массиве *ргпспек* , как и в наборе свойств. Пока выполняется чтение любого запрошенного свойства, запрос на получение несуществующего свойства не является ошибкой. Вместо этого это должно привести к тому, \_ что VT Empty будет записан для этого свойства в массив *ргвар* \[ \] при возврате. Если ни одно из запрошенных свойств не существует, метод должен вернуть \_ значение false и установить VT \_ Empty в каждом [**пропвариант**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant). Если возвращается любая другая ошибка, значения свойств не извлекаются, и вызывающему объекту не нужно беспокоиться об их освобождении.

Параметр *ргпспек* — это массив структур [**пропспек**](/windows/win32/api/propidlbase/ns-propidlbase-propspec) , которые указывают для каждого свойства либо идентификатор его свойства, либо значение, если оно назначено, строковый идентификатор. Можно сопоставлять строку с идентификатором свойства, вызвав [**ипропертистораже:: вритепропертинамес**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writepropertynames). Однако использование идентификаторов свойств, скорее всего, будет значительно более эффективным, чем использование строк.

Свойства, запрашиваемые строковым именем (ПРСПЕК \_ LPWSTR), сопоставляются без учета регистра с идентификаторами свойств (ID), так как они указаны в текущем наборе свойств (и в соответствии с текущей национальной настройкой системы).

Если тип свойства — VT \_ LPSTR и свойство считывается из набора свойств ANSI, то есть кодовая страница для набора свойств задается не в Юникоде, а значение свойства использует ту же кодовую страницу, что и набор свойств. Если свойство VT \_ LPSTR считывается из набора свойств Юникода, то значение свойства использует текущую системную кодовую страницу ANSI по умолчанию, то есть кодовую страницу, возвращаемую функцией **жетакп** .

[**Пропвариант**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant), за исключением тех, которые являются указателями на потоки и хранилища, называется простым **пропвариант**. Эти простые **пропвариант** получают данные по значению, поэтому вызов [**Ипропертистораже:: реадмултипле**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) предоставляет копию данных, которой владеет вызывающий объект. Чтобы создать или обновить эти свойства, вызовите метод [**ипропертистораже:: вритемултипле**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple).

Напротив, типы Variant VT \_ Stream, \_ потоковый объект VT, \_ \_ хранилище VT и \_ объект VT \_ являются непростыми свойствами, поскольку вместо предоставления значения метод получает указатель на указанный интерфейс, из которого данные можно считывать. Эти типы допускают хранение больших объемов информации с помощью одного свойства. Существует несколько проблем, возникающих при использовании непростых свойств.

Чтобы создать эти свойства, как и для других свойств, вызовите [**ипропертистораже:: вритемултипле**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple). Однако, вместо вызова того же метода для обновления, более эффективно сначала вызывается метод [**ипропертистораже:: реадмултипле**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) , чтобы получить указатель интерфейса на поток или хранилище, а затем запишите данные с помощью методов [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream) или [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage) . Поток или хранилище, открытые с помощью свойства, всегда открываются в прямом режиме, поэтому дополнительный уровень вложенной транзакции не вводится. Тем не менее, в зависимости от того, как оно было открыто или создано с помощью [**IPropertySetStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertysetstorage), все еще может быть транзакцией в наборе свойств в целом. Кроме того, Теги режима доступа и совместного использования, указанные при открытии или создании набора свойств, передаются в потоки или хранилища на основе свойств.

Время существования потока на основе свойств или указателей хранилища, хотя теоретически не зависит от связанных указателей [**ипропертистораже**](/windows/desktop/api/Propidl/nn-propidl-ipropertystorage) и [**IPropertySetStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertysetstorage) , фактически зависит от них. Данные, видимые в потоке или хранилище, связаны с транзакцией в объекте хранилища свойств, откуда они извлекаются, так же как и для объекта хранилища (поддерживающего [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage)) с вложенными объектами Stream и Storage. Если транзакция в родительском объекте прервана, существующие указатели [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream) и **IStorage** , подчиненные этому объекту, становятся недоступными. Поскольку **ипропертистораже** является единственным интерфейсом в объекте хранилища свойств, полезное время существования содержащихся в них указателей **IStream** и **IStorage** ограничивается временем существования интерфейса **ипропертистораже** .

Реализация также должна иметь дело с ситуацией, когда одно и то же свойство потока или значение с хранилищем запрашивается несколько раз с помощью одного экземпляра интерфейса [**ипропертистораже**](/windows/desktop/api/Propidl/nn-propidl-ipropertystorage) . Например, в реализации составного файла COM открытие будет успешным или неудачным в зависимости от того, открыто ли это свойство.

Другой проблемой является несколько открытий в режиме транзакций. Результат зависит от уровня изоляции, который был указан с помощью вызова методов [**IPropertySetStorage**](/windows/desktop/api/Propidl/nn-propidl-ipropertysetstorage) (метод [**открытия**](/windows/desktop/api/Propidl/nf-propidl-ipropertysetstorage-open) или [**создания**](/windows/desktop/api/Propidl/nf-propidl-ipropertysetstorage-create) с помощью флагов стгм) на момент открытия хранилища свойств.

Если вызов для открытия набора свойств указывает доступ на чтение и запись, то свойства [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage) и [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream)всегда открываются с доступом на чтение и запись. Затем данные можно записать с помощью этих интерфейсов, изменив значение свойства, которое является наиболее эффективным способом обновления этих свойств. Само значение свойства не имеет дополнительного уровня вложенности транзакций, поэтому изменения зависят от транзакции (при ее наличии) в объекте хранилища свойств.

## <a name="storage-and-stream-properties"></a>свойства служба хранилища и Stream

Чтобы записать поток или объект хранилища в набор свойств, набор свойств должен быть создан как непростой. дополнительные сведения о простых и непростых наборах свойств см. в разделе [служба хранилища и объекты потока для набора свойств](storage-vs--stream-for-a-property-set.md). Следующие типы свойств, как указано в поле *VT* элементов массива *ргвар* , являются потоками или типами хранения: VT \_ Stream, VT \_ , VT, \_ потоковый \_ объект VT \_ \_ .

Чтобы записать поток или объект хранилища в качестве свойства в непростом наборе свойств, вызовите метод [**ипропертистораже:: вритемултипле**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple). Хотя этот метод также вызывается для обновления простых свойств, он не является эффективным способом обновления потоков и объектов хранения в наборе свойств. Это связано с тем, что обновление одного из этих свойств с помощью вызова **вритемултипле** в объекте хранилища свойств копирует данные переданных, а указатели [**IStorage**](/windows/desktop/api/Objidl/nn-objidl-istorage) и [**IStream**](/windows/desktop/api/Objidl/nn-objidl-istream) не сохраняются за время этого вызова. Обычно более эффективно обновлять поток или объекты хранилища напрямую, вызывая метод [**ипропертистораже:: реадмултипле**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) , чтобы получить указатель интерфейса на поток или хранилище, а затем записать данные с помощью методов **IStream** или **IStorage** .

Например, можно вызвать [**ипропертистораже:: вритемултипле**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple) для записи **пустого** потока или объекта хранилища. Реализация создаст пустой объект в наборе свойств. Затем можно получить доступ к этому объекту, вызвав [**ипропертистораже:: реадмултипле**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple). После завершения обновления этого объекта его не нужно записывать в набор свойств, так как обновления находились непосредственно в наборе свойств.

Поток или хранилище, открытые с помощью свойства, всегда открываются в прямом режиме, поэтому дополнительный уровень вложенной транзакции не вводится. По-прежнему может существовать транзакция над свойством, заданным в целом. (Например, если [**ипропертистораже**](/windows/desktop/api/Propidl/nn-propidl-ipropertystorage) был получен вызовом [**IPropertySetStorage:: Open**](/windows/desktop/api/Propidl/nf-propidl-ipropertysetstorage-open) с стгм \_ Флаг транзакций, заданный в параметре *грфмоде* .) Кроме того, поток или хранилище на основе свойств открывается в режиме чтения и записи, если это возможно, учитывая режим набора свойств. в противном случае используется режим чтения.

Как упоминалось ранее, при записи потока или объекта хранилища в свойство, заданное с помощью метода [**вритемултипле**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple) , создается копия объекта. Если такая копия выполняется в объекте потока, операция копирования начинается с текущей позиции поиска источника. Положение поиска не определено при сбое, но в случае успеха он находится в конце потока; указатель поиска не восстанавливается в исходное положение.

Если поток или свойство хранилища было считано из свойства, установленного с помощью [**реадмултипле**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple), по-прежнему удерживается открытым и последующий вызов [**вритемултипле**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple) для того же свойства, операция **вритемултипле** будет выполнена успешно. Ранее открытый поток или свойство хранилища помещается в отмененное состояние (все вызовы будут возвращать \_ ошибку STG E \_ reverted).

Если метод [**вритемултипле**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-writemultiple) возвращает ошибку при записи массива свойств или даже отдельных непростых свойств, фактически записанный объем данных не определен.

## <a name="reference-properties"></a>Свойства ссылки

Если указанная структура [**пропвариант**](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) включает флаг VT \_ ByRef в его члене **VT** , то связанное свойство является ссылочным свойством. Перед записью значения в набор свойств ссылочное свойство автоматически удаляется из ссылки. Например, если элемент **VT** в структуре **пропвариант** указывает значение типа VT \_ ByRef \| VT \_ I4, фактическое значение записано как \_ Тип VT i4. При последующем вызове метода [**ипропертистораже:: реадмултипле**](/windows/desktop/api/Propidl/nf-propidl-ipropertystorage-readmultiple) возвращается значение VT \_ i4. Использование свойств ссылок аналогично вызову функции [варианткопинд](/windows/win32/api/oleauto/nf-oleauto-variantcopyind) . [Варианткопинд](/windows/win32/api/oleauto/nf-oleauto-variantcopyind) освобождает целевой вариант и создает копию исходного VARIANTARG, выполняя необходимое косвенное обращение, если источник указан как VT \_ ByRef. Эта функция полезна, если требуется копия варианта и гарантировать, что она не является VT \_ ByRef, например при обработке аргументов в реализации [**IDispatch:: Invoke**](/windows/win32/api/oaidl/nf-oaidl-idispatch-invoke).

## <a name="notes-to-callers"></a>Примечания для тех, кто вызывает этот метод

Рекомендуется создавать наборы свойств в Юникоде, не устанавливая \_ флаг ANSI пропсетфлаг в параметре *Грффлагс* объекта [**IPropertySetStorage:: Create**](/windows/desktop/api/Propidl/nf-propidl-ipropertysetstorage-create). Также рекомендуется избегать использования \_ значений VT LPSTR и использовать \_ вместо них значения VT LPWSTR. Если кодовая страница набора свойств — Unicode, \_ строковые значения VT LPSTR преобразуются в Юникод при сохранении и возвращаются в многобайтовые строковые значения при извлечении. Если кодовая страница набора свойств не является Юникодом, имена свойств, строки VT \_ и непростые значения свойств преобразуются в многобайтовые строки при сохранении и преобразуются обратно в Юникод при извлечении, то все используют текущую системную кодовую страницу ANSI.

## <a name="notes-to-implementers"></a>Примечания для тех, кто реализует этот метод

При выделении идентификатора свойства реализация может выбрать любое значение, которое не используется в данный момент в свойстве, заданном для идентификатора свойства, если оно не равно 0 или 1 или больше 0x80000000, все из которых являются зарезервированными значениями. Параметр *пропиднамефирст* устанавливает минимальное значение для идентификаторов свойств в наборе и должно быть больше 1 и меньше 0x80000000. См. раздел "Примечания" выше.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Ипропертистораже — реализация составного файла](ipropertystorage-compound-file-implementation.md)
</dt> <dt>

[Ипропертистораже — реализация файловой системы NTFS](ipropertystorage-ntfs-file-system-implementation.md)
</dt> <dt>

[Ипропертистораже — изолированная реализация](ipropertystorage-stand-alone-implementation.md)
</dt> </dl>

 

 