---
description: Синтаксис сообщений шифрования можно использовать для кодирования сообщений, упакованных в оболочку.
ms.assetid: f35aacda-6827-42e9-b7ac-58dc007fc697
title: Кодирование запечатанных данных
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 53dc20fc7483ba1ef364d8b59824d26bd14d458d
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "104566910"
---
# <a name="encoding-enveloped-data"></a>Кодирование запечатанных данных

Запечатанные данные состоят из зашифрованного содержимого любого типа и зашифрованных ключей сеанса шифрования содержимого для одного или нескольких получателей. Сообщения с оболочкой сохраняют содержимое секрета сообщения и разрешают получение содержимого только определенным лицам или сущностям.

Синтаксис криптографического сообщения (CMS) можно использовать для кодирования сообщений, упакованных в оболочку. CMS поддерживает три метода управления ключами: транспорт ключей, соглашение о ключах и ранее распределенные симметричные ключи шифрования ключей (KEK). Ранее распределенные симметричные KEK также называются распространением ключей списка рассылки.

В каждом из этих трех методов создается один сеансовый ключ для шифрования сообщения, упакованного в оболочку. Проблемы управления ключами связаны с тем, как ключ сеанса шифруется отправителем и расшифровывается получателем. Одно зашифрованное сообщение может распространяться многим получателям с помощью сочетания методов управления ключами.

Управление ключами транспортного ключа использует для шифрования ключа сеанса открытый ключ предполагаемого получателя. Получатель расшифровывает сеансовый ключ с помощью закрытого ключа, связанного с открытым ключом, который использовался для шифрования. Затем получатель использует расшифрованный ключ сеанса для расшифровки данных, упакованных в оболочку. Когда используется транспорт ключей, получатель не подтвердил сведения об удостоверении отправителя.

В управлении согласованием ключей создается временный, эфемерный Diffie-Hellman закрытый ключ, который используется для шифрования ключа сеанса. Открытый ключ, соответствующий эфемерному закрытому ключу, включается как часть сведений о получателе сообщения. Получатель расшифровывает сеансовый ключ с помощью полученного временного ключа и использует этот расшифрованный ключ сеанса для расшифровки сообщения, упакованного в оболочку. При использовании временного ключа в сочетании с закрытым ключом получателя получатель сообщения подтвердил сведения об удостоверении отправителя.

Для управления ключами с использованием ранее распределенных [*симметричных ключей*](../secgloss/s-gly.md)каждое сообщение содержит ключ шифрования содержимого, который был зашифрован с помощью ранее распределенного ключа шифрования ключа. Получатели используют ранее распределенный ключ шифрования ключа для расшифровки ключа шифрования содержимого, а затем используют расшифрованный ключ шифрования содержимого для расшифровки запечатанного сообщения.

Типичная последовательность событий CMS для кодирования запечатанных данных показана на следующем рисунке.

![кодирование запечатанных данных](images/envelmsg.png)

-   Извлекается указатель на сообщение с [*открытым текстом*](../secgloss/p-gly.md) .
-   Создается симметричный ключ ([*сеанс*](../secgloss/s-gly.md)).
-   [*Симметричный ключ*](../secgloss/s-gly.md) и заданный алгоритм шифрования используются для шифрования данных сообщения.
-   Открыто [*хранилище сертификатов*](../secgloss/c-gly.md) .
-   Сертификат получателя извлекается из магазина.
-   [*Открытый ключ*](../secgloss/p-gly.md) извлекается из сертификата получателя.
-   При использовании открытого ключа получателя симметричный ключ шифруется.
-   Из сертификата получателя извлекается идентификатор получателя.
-   В сообщение с цифровой подписью включаются следующие сведения: алгоритм шифрования данных, зашифрованные данные, зашифрованный симметричный ключ и структура сведений о получателе.

Чтобы использовать функции обработки сообщений низкого уровня для выполнения типичных задач, которые только что перечислены, используйте следующую процедуру.

**Кодирование запечатанного сообщения**

1.  Создайте или извлеките содержимое.
2.  Получение поставщика служб шифрования.
3.  Получение сертификата получателя.
4.  Инициализируйте [**\_ \_ \_ информационную структуру КМСГ с запечатанным кодированием**](/windows/desktop/api/Wincrypt/ns-wincrypt-cmsg_enveloped_encode_info) .
5.  Вызовите [**криптмсгкалкулатинкодедленгс**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsgcalculateencodedlength) , чтобы получить размер BLOB-объекта закодированного сообщения. Выделите память для нее.
6.  Вызовите [**криптмсгопентоенкоде**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsgopentoencode), передав КМСГ в \_ конверт для *Двмсгтипе* и указатель на [**КМСГ \_ \_ \_ сведения о закодированном конверте**](/windows/desktop/api/Wincrypt/ns-wincrypt-cmsg_enveloped_encode_info) для *пвмсженкодеинфо*. В результате этого вызова вы получите маркер открытого сообщения.
7.  Вызовите [**криптмсгупдате**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsgupdate), передав маркер, полученный на шаге 6, и указатель на данные, которые должны быть зашифрованы, запечатаны и закодированы. Эту функцию можно вызывать столько раз, сколько необходимо для завершения процесса кодирования.
8.  Вызовите [**криптмсгжетпарам**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsggetparam), передав маркер, полученный на шаге 6, и соответствующие типы параметров для доступа к нужным закодированным данным. Например, передайте значение \_ параметра КМСГ Content \_ param, чтобы получить указатель на все \# сообщение PKCS 7.

    Если результат этой кодировки будет использоваться в качестве [*внутренних данных*](../secgloss/i-gly.md) для другого закодированного сообщения, например сообщения, упакованного в оболочку, \_ \_ \_ необходимо передать параметр параметра КМСГ исходного содержимого. Пример см. в разделе [альтернативный код для кодирования запечатанного сообщения](alternate-code-for-encoding-an-enveloped-message.md).

9.  Закройте сообщение, вызвав [**криптмсгклосе**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsgclose).

Результатом этой процедуры является закодированное сообщение, содержащее зашифрованные данные, [*симметричный ключ*](../secgloss/s-gly.md) , который шифруется с помощью открытых ключей получателя, и структуры данных о получателе. Сочетание зашифрованного содержимого и зашифрованного симметричного ключа получателя — это [*цифровой конверт*](../secgloss/d-gly.md) для этого получателя. Любой тип содержимого может быть запечатан для нескольких получателей.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Пример программы на языке C. кодирование подписанного сообщения с подписью](example-c-program-encoding-an-enveloped-signed-message.md)
</dt> </dl>

 

 
