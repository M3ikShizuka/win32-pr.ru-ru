---
description: Одним из преимуществ использования списков доверия сертификатов (CTL) является возможность разработки приложений, которые могут автоматически проверять подписанные сообщения от доверенных сертификатов, не требуя от пользователя диалоговых окон.
ms.assetid: e45ea3ae-52bc-49d3-8144-f3becc254f53
title: Проверка подписанных сообщений с помощью списков CTL
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a660bcd7e17a168b25048e61684aabc2d3ef3124
ms.sourcegitcommit: d75fc10b9f0825bbe5ce5045c90d4045e3c53243
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/13/2021
ms.locfileid: "127461406"
---
# <a name="verifying-signed-messages-by-using-ctls"></a>Проверка подписанных сообщений с помощью списков CTL

Одним из преимуществ использования [*списков доверия сертификатов*](../secgloss/c-gly.md) (CTL) является возможность разработки приложений, которые могут автоматически проверять подписанные сообщения от доверенных сертификатов, не требуя от пользователя диалоговых окон. Он также дает администратору сети контроль над доверенными источниками.

Следующую процедуру можно использовать для проверки подписи подписанного сообщения с помощью списка доверия сертификатов.

**Проверка подписанного сообщения с помощью списка доверия сертификатов**

1.  Декодировать сообщение следующим образом:

    1.  Получение указателя на полученное сообщение (закодированный BLOB- [*объект*](../secgloss/b-gly.md)).
    2.  Вызовите [**криптмсгопентодекоде**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsgopentodecode), передав необходимые аргументы.
    3.  Вызовите [**криптмсгупдате**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsgupdate) один раз, передав маркер, полученный на шаге b, и указатель на данные, которые необходимо декодировать. Это приводит к тому, что в зависимости от типа сообщений в сообщении будут выполняться соответствующие действия.

2.  Проверка подписи декодированного подписанного сообщения и получение указателя на [**\_ контекст сертификата**](/windows/desktop/api/Wincrypt/ns-wincrypt-cert_context)подписавшего.

    Это можно сделать, вызвав [**криптмсгжетандверифисигнер**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsggetandverifysigner), передав полученный в шаге 1C маркер сообщения в качестве параметра *хкриптмсг* . Если вызов функции возвращает **значение true**, то сигнатура была проверена, а в параметре *ппсигнер* возвращается указатель на [**\_ контекст пкцерт**](/windows/desktop/api/Wincrypt/ns-wincrypt-cert_context) подписи.

3.  Убедитесь, что подписавший является надежным источником, как показано ниже.

    1.  Откройте хранилище сертификатов, содержащее соответствующий список доверия сертификатов.
    2.  Получите указатель на [**\_ контекст CTL**](/windows/desktop/api/Wincrypt/ns-wincrypt-ctl_context) , вызвав [**цертфиндктлинсторе**](/windows/desktop/api/Wincrypt/nf-wincrypt-certfindctlinstore).
    3.  Чтобы убедиться, что подписавший является надежным источником, вызовите [**цертфиндсубжектинктл**](/windows/desktop/api/Wincrypt/nf-wincrypt-certfindsubjectinctl), передав указатель, полученный на предыдущем шаге, в параметре *пктлконтекст* , \_ \_ Тип субъекта сертификата CTL \_ в параметре *двсубжекттипе* и указатель на [**\_ контекст сертификата**](/windows/desktop/api/Wincrypt/ns-wincrypt-cert_context) , полученный на шаге 2 в параметре *пвсубжект* . Если вызов функции возвращает **значение true**, то **\_ контекст сертификата** , переданный в функцию, является надежным источником в списке доверия (CTL).

 

 
