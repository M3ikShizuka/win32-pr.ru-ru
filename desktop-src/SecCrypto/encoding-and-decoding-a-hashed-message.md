---
description: Описывает задачи, необходимые для кодирования хэшированного сообщения.
ms.assetid: c1a65452-c634-4cc6-9afe-d6bf11d999d1
title: Кодирование и декодирование хэшированного сообщения
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2bed6ffae240d9139de471f16dcaaf2ed3e29d5bc92c8d7507b981c2af67541c
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "117766749"
---
# <a name="encoding-and-decoding-a-hashed-message"></a>Кодирование и декодирование хэшированного сообщения

Хэшированные данные состоят из содержимого любого типа и [*хэша*](../secgloss/h-gly.md) содержимого. Его можно использовать, когда необходимо только подтвердить, что содержимое сообщения не было изменено с момента создания хэша.

При создании хэшированного сообщения может существовать несколько хэш-алгоритмов и несколько хэшей. На следующем рисунке показаны задачи, необходимые для кодирования хэшированного сообщения. Процедура описана в тексте, который следует за иллюстрацией.

![Создание хэшированного сообщения](images/hashmsg.png)

**Создание хэшированного сообщения**

1.  Получите указатель на данные для хэширования.
2.  Выберите хэш-алгоритм, который будет использоваться.
3.  Разместите данные с помощью функции хэширования с помощью хэш-алгоритма.
4.  Включите в закодированные исходные данные, хэш-алгоритмы и хэши в кодированном сообщении.

Чтобы использовать функции обработки сообщений низкого уровня для выполнения задач, описанных выше, используйте следующую процедуру.

**Хэширование и кодирование сообщения с помощью функций сообщений низкого уровня**

1.  Создайте или извлеките содержимое для хэширования.
2.  Получение поставщика служб шифрования.
3.  Инициализируйте [**структуру \_ \_ \_ сведений о хэшированном кодировании КМСГ**](/windows/desktop/api/Wincrypt/ns-wincrypt-cmsg_hashed_encode_info) .
4.  Вызовите [**криптмсгкалкулатинкодедленгс**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsgcalculateencodedlength) , чтобы получить размер BLOB-объекта закодированного сообщения. Выделите память для нее.
5.  Вызовите [**криптмсгопентоенкоде**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsgopentoencode), передав КМСГ \_ хэшированный для параметра *Двмсгтипе* и указатель на [**КМСГ \_ хэшированные \_ \_ сведения о кодировании**](/windows/desktop/api/Wincrypt/ns-wincrypt-cmsg_hashed_encode_info) для параметра *пвмсженкодеинфо* . В результате этого вызова вы получаете маркер открытого сообщения.
6.  Вызовите [**криптмсгупдате**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsgupdate), передав маркер, полученный на шаге 5, и указатель на данные, которые должны быть хэшированы и закодированы. Эту функцию можно вызывать столько раз, сколько необходимо для завершения процесса кодирования.
7.  Вызовите [**криптмсгжетпарам**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsggetparam), передав маркер, полученный на шаге 5, и соответствующие типы параметров для доступа к нужным закодированным данным. Например, передайте значение \_ параметра КМСГ Content \_ param, чтобы получить указатель на все сообщение [*PKCS \# 7*](../secgloss/p-gly.md) .

    Если результат этой кодировки будет использоваться в качестве [*внутренних данных*](../secgloss/i-gly.md) для другого закодированного сообщения, например сообщения, упакованного в оболочку, \_ \_ \_ необходимо передать параметр КМСГ для исходного содержимого. Пример, демонстрирующий это, см. в разделе [альтернативный код для кодирования запечатанного сообщения](alternate-code-for-encoding-an-enveloped-message.md).

8.  Закройте сообщение, вызвав [**криптмсгклосе**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsgclose).

Результатом этой процедуры является закодированное сообщение, содержащее исходные данные, алгоритмы хэширования и [*хэш*](../secgloss/h-gly.md) этих данных. Указатель на [*большой двоичный объект*](../secgloss/b-gly.md) закодированного сообщения получен на шаге 7.

Следующие две процедуры используются для декодирования и последующей проверки хэшированных данных.

**Расшифровка хэшированных данных**

1.  Получение указателя на закодированный BLOB-объект.
2.  Вызовите [**криптмсгопентодекоде**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsgopentodecode), передав необходимые аргументы.
3.  Вызовите [**криптмсгупдате**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsgupdate) один раз, передав маркер, полученный на шаге 2, и указатель на данные, которые необходимо декодировать. Это приводит к тому, что в зависимости от типа сообщений в сообщении будут выполняться соответствующие действия.
4.  Вызовите [**криптмсгжетпарам**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsggetparam), передав маркер, полученный на шаге 2, и соответствующие типы параметров для доступа к нужным декодированным данным. Например, передайте значение \_ параметра КМСГ Content \_ param, чтобы получить указатель на декодированное содержимое.

**Проверка хэша**

1.  Вызовите [**криптмсгконтрол**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsgcontrol), передав КМСГ \_ CTRL \_ , \_ чтобы проверить хэши.
2.  Вызовите [**криптмсгклосе**](/windows/desktop/api/Wincrypt/nf-wincrypt-cryptmsgclose) , чтобы закрыть сообщение.

Пример программы см. в разделе [Пример программы C: кодирование и декодирование хэшированного сообщения](example-c-program-encoding-and-decoding-a-hashed-message.md).

 

 
