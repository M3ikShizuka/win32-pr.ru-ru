---
description: Отправка и получение данных PGM аналогична отправке или приему данных на любом сокете. Существуют некоторые рекомендации по протоколу PGM, приведенные в следующих параграфах.
ms.assetid: 51b447ad-b6da-424b-91df-e5be9ce225a5
title: Отправка и получение данных PGM
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 130b38ea52e5d0679b988e55f8292b9752a4bf15d0514a8277a2e0b3b2327001
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "117740575"
---
# <a name="sending-and-receiving-pgm-data"></a>Отправка и получение данных PGM

Отправка и получение данных PGM аналогична отправке или приему данных на любом сокете. Существуют некоторые рекомендации по протоколу PGM, приведенные в следующих параграфах.

## <a name="sending-pgm-data"></a>Отправка данных PGM

после создания сеанса отправителя PGM данные отправляются с помощью различных Windows сокетов отправки: [**send**](/windows/desktop/api/Winsock2/nf-winsock2-send), [**sendto**](/windows/desktop/api/winsock/nf-winsock-sendto), [**всасенд**](/windows/desktop/api/Winsock2/nf-winsock2-wsasend)и [**всасендто**](/windows/desktop/api/Winsock2/nf-winsock2-wsasendto). так как дескрипторы сокетов Windows являются дескрипторами файловой системы, другие функции, такие как функции [**WriteFile**](/windows/win32/api/fileapi/nf-fileapi-writefile) и CRT, также могут передавать данные. В следующем фрагменте кода показана операция отправителя PGM:


```C++
LONG        error;
    //:
error = send (s, pSendBuffer, SendLength, 0);
if (error == SOCKET_ERROR)
{
    fprintf (stderr, "send() failed: Error = %d\n",
             WSAGetLastError());
}
```



При использовании режима сообщений (Сокк \_ RDM) каждый вызов функции Send приводит к появлению дискретного сообщения, которое иногда нежелательно; приложение может захотеть отправить сообщение 2 МБ с несколькими вызовами для [**отправки**](/windows/desktop/api/Winsock2/nf-winsock2-send). В таких обстоятельствах отправитель может установить параметр сокета [ \_ \_ \_ границ сообщения RM](socket-options.md) , чтобы указать размер сообщения, следующего за ним.

Если окно отправки заполнено, Новая отправка из приложения не принимается, пока окно не будет расширено. Попытка отправки на неблокирующий сокет завершается сбоем с ВСАЕВАУЛДБЛОКК; Блокирующий сокет просто блокируется до тех пор, пока окно не перейдет к точке, в которой запрошенные данные могут быть помещены в буфер и отправлены. В перекрытом вводе-выводе операция не завершается до тех пор, пока окно не будет достаточно для размещения новых данных.

## <a name="receiving-pgm-data"></a>Получение данных PGM

после создания сеанса приемника PGM данные получаются с помощью различных функций приема сокетов Windows: [**recv**](/windows/desktop/api/winsock/nf-winsock-recv), [**реквфром**](/windows/desktop/api/winsock/nf-winsock-recvfrom), [**всарекв**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv)и [**всареквфром**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecvfrom). так как дескрипторы Windows сокетов также являются дескрипторами файлов, функции [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile) и CRT также можно использовать для получения данных сеанса PGM. Транспорт пересылает данные получателю по мере поступления, если данные находятся в последовательности. Транспорт гарантирует, что возвращаемые данные являются непрерывными и освобождаются от дубликатов. В следующем фрагменте кода показана операция получения PGM:


```C++
LONG        BytesRead;
    //:
BytesRead = recv (sockR, pTestBuffer, MaxBufferSize, 0);
if (BytesRead == 0)
{
    fprintf(stdout, "Session was terminated\n");
}
else if (BytesRead == SOCKET_ERROR)
{
    fprintf(stderr, "recv() failed: Error = %d\n",
            WSAGetLastError());
}
```



При использовании режима сообщений (Сокк \_ RDM) транспорт указывает, когда получено частичное сообщение либо с ошибкой всаемсгсизе, либо путем установки \_ флага «MSG partial» при возврате из функций [**всарекв**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv) и [**всареквфром**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecvfrom) . Когда клиенту возвращается последний фрагмент полного сообщения, ошибка или флаг не указываются.

При корректном завершении сеанса операция получения завершается с ВСАЕДИСКОН. Когда происходит потеря данных в транспорте, протокол PGM временно помещает в буфер непоследовательные пакеты и пытается восстановить потерянные данные. Если потери данных невозможно восстановить, операция получения завершается с ВСАЕКОННРЕСЕТ, а сеанс завершается. Сеанс можно сбросить из-за ряда условий, включая следующие:

-   Скорость входящего и исступающего подключения слишком мала для сохранения скорости передачи данных.
-   Чрезмерная потери данных, возможно, из-за временных условий сети, таких как проблемы маршрутизации, нестабильность сети и т. д.
-   В отправителю возникает неустранимая ошибка.
-   Чрезмерное использование ресурсов происходит на локальном компьютере, например при превышении максимально допустимого внутреннего хранилища буфера или при обнаружении нехватки ресурсов.
-   Возникает ошибка проверки согласованности данных.
-   сбой в компоненте PGM зависит от, например TCP/IP или сокетов Windows.

Как первый, так и второй элементы в приведенном выше списке могут привести к чрезмерной буферизации приемника до истечения ресурсов или в конечном итоге за пределами окна отправителя.

## <a name="terminating-a-pgm-session"></a>Завершение сеанса PGM

Отправитель или получатель PGM может перемешать отправку или получение данных, вызвав [**функции closesocket**](/windows/desktop/api/winsock/nf-winsock-closesocket). Получатель должен вызвать **функции closesocket** как для прослушивания, так и для приема сокетов, чтобы предотвратить утечки в обработке. Вызов метода [**Shutdown**](/windows/desktop/api/winsock/nf-winsock-shutdown) на отправителю перед вызовом **функции closesocket** гарантирует, что все данные будут отправлены, и данные об исправлении сохраняются до тех пор, пока окно отправки не перейдет за последнюю последовательность данных, даже если само приложение завершается.

 

 
