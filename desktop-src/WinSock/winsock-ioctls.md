---
description: раздел навигации по сокетам сокетов Windows (Winsock).
ms.assetid: 6a63c2c9-4e09-4a62-b39f-3ccb26287da8
title: IOCTL Winsock (Winsock2.h)
ms.topic: reference
ms.date: 05/31/2018
ms.openlocfilehash: eadf4a0e2799d6123bf81069fe65ea16313af444
ms.sourcegitcommit: d75fc10b9f0825bbe5ce5045c90d4045e3c53243
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/13/2021
ms.locfileid: "126967258"
---
# <a name="winsock-ioctls"></a>Winsock IOCTL

в этом разделе описываются элементы управления вводом-выводом сокетов Winsock (ioctl) для различных выпусков операционных систем Windows. Используйте функцию [**всаиоктл**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) или [**вспиоктл**](/previous-versions/windows/hardware/network/ff566296(v=vs.85)) , чтобы выдать Winsock IOCTL для управления режимом сокета, транспортного протокола или подсистемы связи.

Некоторым запросам Winsock IOCTL требуется больше объяснений, чем может передать эта таблица. такие параметры содержат ссылки на дополнительные разделы.

Можно использовать схему кодирования, которая сохраняет определенные в настоящий момент коды операций [**иоктлсоккет**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) , а также предоставляет удобный способ секционирования пространства идентификаторов операций в, так как параметр *двиоконтролкоде* теперь является 32-разрядной сущностью. параметр *двиоконтролкоде* создается для обеспечения независимости от протокола и поставщика при добавлении новых управляющих кодов, сохраняя при этом обратную совместимость с Windows сокетами 1,1 и управляющими кодами Unix. Параметр *двиоконтролкоде* имеет следующую форму.

| I  | O  | V  | T  | Семейство поставщиков и адресов | Код                   |
|-|-|-|-|-|-|
| 3  | 3  | 2  | 2 2 | 2 2 2 2 2 2 2 1 1 1 1 | 1 1 1 1 1 1              |
| 1  | 0  | 9  | 8 7 | 6 5 4 3 2 1 0 9 8 7 6 | 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 |

> [!Note] 
> Биты в параметре *двиоконтролкоде* , отображаемые в таблице, должны считываться вертикально сверху вниз по столбцу. Так что самое левое значение бита 31, следующий бит — 30, а правый — бит 0.

Я настроил, является ли входной буфер допустимым для кода, как в случае с **IOC_IN**.

Параметр O устанавливается, если выходной буфер допустим для кода, как в случае с **IOC_OUT**. Управляющие коды, использующие как входной, так и выходной буферы, устанавливают и I, и O.

V задается, если для кода нет параметров, как в случае с **IOC_VOID**.

T — это 2-разрядное количество, определяющее тип IOCTL. Определены следующие значения:

0 запрос IOCTL является стандартным кодом UNIX IOCTL, как в случае с **фионреад** и **фионбио**.

1 запрос ioctl является универсальным Windowsным сокетом 2-код IOCTL. новые коды IOCTL, определенные для сокетов Windows 2, будут иметь T = = 1.

2 запрос IOCTL применяется только к определенному семейству адресов.

3 запрос IOCTL применяется только к поставщику конкретного поставщика, как в случае с **IOC_VENDOR**. Этот тип позволяет компаниям назначить номер поставщика, который отображается в параметре " **поставщик/семейство адресов** ". Затем поставщик может определить новые запросы IOCTL, относящиеся к этому поставщику, без регистрации IOCTL в расчетной палате, тем самым обеспечивая гибкость и конфиденциальность поставщика.

**Семейство поставщиков и адресов** 11-разрядное количество, определяющее поставщика, владеющего кодом (если T = = 3) или содержащего семейство адресов, к которому применяется код (если T = = 2). Если это код для UNIX IOCTL (T = = 0), то этот параметр имеет то же значение, что и код в UNIX. если это универсальный Windows сокеты 2 IOCTL (T = = 1), этот параметр можно использовать как расширение параметра кода для предоставления дополнительных значений кода.

**Код** 16-разрядное количество, содержащее конкретный код IOCTL для операции.

## <a name="unix-ioctl-codes"></a>Коды для UNIX IOCTL

Поддерживаются следующие коды (команды) IOCTL UNIX.

### <a name="fionbio"></a>фионбио

Включает или отключает режим без блокировки *на сокетах*. Параметр *лпвинбуффер* указывает на беззнаковое длинное (QoS) **без знака** (ненулевое значение), если включен режим без блокировки, и нуль, если он должен быть отключен. При создании сокета он работает в блокирующем режиме (т. е. неблокирующего режима отключен). Это согласуется с сокетами BSD.

Подпрограммы [**всаасинкселект**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) или [**всаевентселект**](/windows/desktop/api/Winsock2/nf-winsock2-wsaeventselect) автоматически устанавливают сокет в режим без блокировки. Если **всаасинкселект** или **всаевентселект** был выдан на сокете, любая попытка использовать [**всаиоктл**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) для переключения сокета в режим блокировки приведет к сбою с всаеинвал. Чтобы установить сокет обратно в режим блокировки, приложение должно сначала отключить **всаасинкселект** , вызвав **всаасинкселект** с параметром *Левент* , равным нулю, или отключить **всаевентселект** , вызвав **всаевентселект** с параметром *лнетворкевентс* , равным нулю.

### <a name="fionread"></a>фионреад

Определите объем данных, которые могут быть считаны атомарно *с сокетов*. Параметр *лпваутбуффер* указывает на **беззнаковое значение типа Long** , в котором [**всаиоктл**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) сохраняет результат.

Если сокет, переданный в параметре *s* , ориентирован на поток (например, тип Сокк \_ Stream), **фионреад** возвращает общий объем данных, которые могут быть считаны в рамках одной операции получения. обычно это то же самое, что и общий объем данных, поставленных в очередь на сокете (так как поток данных ориентирован на байты, это не гарантируется).

Если сокет, переданный в параметре *s* , является ориентированным на сообщения (например, введите Сокк \_ Дграм), **фионреад** возвращает отчет общее число доступных для чтения байтов, а не размер первой датаграммы (сообщения), поставленной в очередь на сокете.

### <a name="siocatmark"></a>сиокатмарк

Определить, были ли прочитаны все данные OOB. Это относится только к сокету в стиле потока (например, введите Сокк \_ Stream), который был настроен для встроенного приема любых данных OOB (поэтому \_ убинлине). Если данные OOB не ожидают чтения, операция возвращает значение TRUE. В противном случае возвращается **значение false**, а следующая операция Receive, выполняемая на сокете, будет извлекать некоторые или все данные, предшествующие метке. приложение должно использовать операцию **сиокатмарк** , чтобы определить, остались ли они. При наличии обычных данных, предшествующих срочным (нестандартным) данным, они будут получены по порядку. (Обратите внимание, что операции [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) никогда не будут смешивать OOB и обычные данные в одном вызове.) *лпваутбуффер* указывает на логическое значение, в котором [**всаиоктл**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) сохраняет результат.

## <a name="windows-sockets-2-commands"></a>Windows Команды сокетов 2

поддерживаются следующие команды Windows sockets 2.

### <a name="sio_acquire_port_reservation-opcode-setting-i-t3"></a>SIO_ACQUIRE_PORT_RESERVATION (параметр кода операции: I, T = = 3)

Запросите резервирование среды выполнения для блока портов TCP или UDP. Для резервирования портов во время выполнения пул портов требует, чтобы резервирования использовались в процессе, для которого было предоставлено резервирование. Количество резервирований портов среды выполнения было последним только в течение времени существования сокета, на котором был вызван [**\_ запрос IOCTL \_ \_ резервирования порта**](/previous-versions/windows/desktop/legacy/gg699720(v=vs.85)) . Напротив, постоянные резервирования портов, созданные с помощью функции [**креатеперсистентткппортресерватион**](/windows/win32/api/iphlpapi/nf-iphlpapi-createpersistenttcpportreservation) или [**креатеперсистентудппортресерватион**](/windows/win32/api/iphlpapi/nf-iphlpapi-createpersistentudpportreservation) , могут быть использованы любым процессом с возможностью получения постоянных резервирований.

Дополнительные сведения см. в справочнике [**по \_ \_ \_ резервированию порта для получения SIO**](/previous-versions/windows/desktop/legacy/gg699720(v=vs.85)) .

[**Суперконтроллер ввода/вывода \_ получение \_ \_ резервирования портов**](/previous-versions/windows/desktop/legacy/gg699720(v=vs.85)) поддерживается в Windows Vista и более поздних версиях операционной системы.

### <a name="sio_address_list_change-opcode-setting-v-t1"></a>\_ \_ Изменение списка адресов SIO \_ (параметр кода операции: V, T = = 1)

Для получения уведомлений об изменениях в списке локальных транспортных адресов семейства протоколов сокета, к которому может быть привязано приложение. При завершении этого IOCTL не будут предоставлены выходные данные. завершение просто означает, что список доступных локальных адресов изменился, и его следует запросить снова через **\_ \_ \_ запрос списка адресов SIO**.

Предполагается (хотя и не обязательно), что приложение использует перекрывающиеся операции ввода-вывода, чтобы получать уведомления об изменениях по завершении запроса на **\_ \_ \_ изменение списка адресов SIO** . Кроме того, если запрос IOCTL с **\_ \_ \_ изменением списка адресов SIO** выполняется на неблокирующем сокете и без перекрывающихся параметров (*лповерлаппед* /  *лпкомплетионраутине* имеет значение **null**), он будет немедленно завершен с ошибкой [всаеваулдблокк](windows-sockets-error-codes-2.md). Затем приложение может ожидать события изменения списка адресов с помощью вызова [**всаевентселект**](/windows/desktop/api/Winsock2/nf-winsock2-wsaeventselect) или [**всаасинкселект**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) с \_ \_ \_ установленным битом изменения списка адресов в маске сетевого события.

### <a name="sio_address_list_query-opcode-setting-o-t1"></a>\_ \_ Запрос списка адресов SIO \_ (параметр кода операции: O, T = = 1)

Получает список локальных транспортных адресов семейства протоколов сокетов, к которым может быть привязано приложение. Список адресов зависит от семейства адресов, а некоторые адреса исключаются из списка.

> [!Note] 
> в Windows средах Plug-n-Play адреса можно добавлять и удалять динамически. Поэтому приложения не могут полагаться на сведения, возвращаемые **\_ \_ \_ запросом списка адресов SIO** , как постоянные. Приложения могут регистрироваться для получения уведомлений об изменении адреса через **\_ список адресов SIO \_ \_ изменение** ioctl, который обеспечивает уведомление с помощью перекрывающихся операций ввода-вывода или \_ \_ \_ события изменения списка адресов. Чтобы гарантировать, что приложение всегда имеет текущие сведения о списке адресов, можно использовать следующую последовательность действий.

-  Выдача IOCTL с **\_ \_ \_ изменением списка адресов через SIO**
-  Выдача **\_ запроса на список адресов SIO с \_ \_ запросом** ioctl
-  Всякий раз, когда запрос IOCTL на **\_ \_ \_ изменение списка адресов SIO** уведомляет приложение об изменении списка адресов (с перекрытием операций ввода-вывода или с помощью сигнализации о \_ \_ \_ событии изменения списка адресов), должна повторяться вся последовательность действий.

Более подробные сведения см. в справочнике по [**\_ \_ \_ запросам списка адресов SIO**](/previous-versions/windows/desktop/legacy/dd877219(v=vs.85)) . **Суперконтроллер ввода/вывода \_ \_ \_ запрос списка адресов** поддерживается в Windows 2000 и более поздних версиях.

### <a name="sio_apply_transport_setting-opcode-setting-i-t3"></a>\_ \_ Параметр транспорта применения SIO \_ (параметр кода операции: I, T = = 3)

Применяет параметр транспорта к сокету. Применяемый параметр транспорта основан на [**\_ \_ идентификаторе параметра транспорта**](/windows/win32/api/transportsettingcommon/ns-transportsettingcommon-transport_setting_id) , переданном в параметре *лпвинбуффер* .

Единственным параметром транспорта, который сейчас определяет, является возможность получения **\_ \_ уведомлений \_ в режиме реального времени** на сокете TCP.

если переданный [**\_ \_ идентификатор параметра транспорта**](/windows/win32/api/transportsettingcommon/ns-transportsettingcommon-transport_setting_id) имеет значение **Guid** , установленное в **режиме реального \_ времени \_ , это \_** запрос на применение параметров уведомлений в режиме реального времени для сокета TCP, используемого с [**контролчаннелтригжер**](/uwp/api/Windows.Networking.Sockets.ControlChannelTrigger) , для получения уведомлений в фоновом режиме в приложении для магазина Windows.

Дополнительные сведения см. в статье [**\_ использование \_ \_ параметров транспорта для SIO**](/previous-versions/windows/desktop/legacy/jj553481(v=vs.85)) . **Суперконтроллер ввода/вывода \_ \_ \_ параметр "применить транспорт** " поддерживается в Windows 8, Windows Server 2012 и более поздних версиях.

### <a name="sio_associate_handle-opcode-setting-i-t1"></a>\_Маркер связи SIO \_ (параметр кода операции: I, T = = 1)

Связывает этот сокет с указанным дескриптором сопутствующего интерфейса. Входной буфер содержит целочисленное значение, соответствующее константе манифеста для сопутствующего интерфейса (например, \_ нетдев и th \_ TAPI.), за которым следует значение, которое является маркером указанного сопутствующего интерфейса вместе с любой другой обязательной информацией. Дополнительные сведения о конкретном сопутствующем интерфейсе см. в соответствующем разделе в [приложении Winsock](winsock-annexes.md) . Общий размер отражается в длине входного буфера. Выходной буфер не требуется. Код ошибки [всаенопротупт](windows-sockets-error-codes-2.md) указывается для поставщиков услуг, которые не поддерживают этот запрос IOCTL. Маркер, связанный с этим IOCTL, можно получить с **помощью \_ \_ маркера перевода SIO**.

можно использовать сопутствующий интерфейс, например, если конкретный поставщик предоставляет (1) большую часть контроля над поведением сокета и (2) элементы управления являются достаточно специфичными для поставщика, чтобы они не сопоставлялись с существующими Windowsными функциями сокетов или, скорее всего, будут определены в будущем. Для обнаружения и мониторинга других интерфейсов, которые могут поддерживаться сокетом, рекомендуется использовать модель COM вместо этого IOCTL. Этот запрос IOCTL представлен для (обратная) совместимости с системами, в которых COM недоступен, или по какой-либо другой причине.

### <a name="sio_associate_port_reservation-opcode-setting-i-t3"></a>\_ \_ Резервирование порта для сопоставления SIO \_ (параметр кода операции: I, T = = 3)

Свяжите сокет с постоянным или резервным резервированием для блока портов TCP или UDP, идентифицируемого маркером резервирования портов. Перед привязкой сокета необходимо выдать запрос IOCTL для [**\_ \_ \_ резервирования порта SIO**](/previous-versions/windows/desktop/legacy/gg699721(v=vs.85)) . Если и при привязке сокета, назначенный ему порт будет выбран из резервирования портов, определенного данным токеном. Если из указанного резервирования нет доступных портов, вызов функции [**BIND**](/windows/desktop/api/winsock/nf-winsock-bind) завершится ошибкой.

Более подробные сведения см. в справочнике по [**\_ \_ \_ резервированию порта для сопоставления SIO**](/previous-versions/windows/desktop/legacy/gg699721(v=vs.85)) .

[**Суперконтроллер ввода/вывода \_ \_ \_ резервирование портов связи**](/previous-versions/windows/desktop/legacy/gg699721(v=vs.85)) поддерживается в Windows Vista и более поздних версиях операционной системы.

### <a name="sio_base_handle-opcode-setting-o-t1"></a>\_Базовый \_ маркер sio (параметр кода операции: O, T = = 1)

Получает базовый маркер поставщика службы для данного сокета. Возвращаемое значение — это **сокет**.

Многоуровневый поставщик услуг никогда не перехватит этот IOCTL, так как возвращаемое значение должно быть маркером сокета от базового поставщика служб.

Если выходной буфер недостаточно велик для маркера сокета ( *кбаутбуффер* меньше, чем размер **сокета**), или параметр *лпваутбуффер* является **пустым** указателем, то в результате этого ioctl **возвращается \_ Ошибка сокета** , а [**всажетластеррор**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) возвращает [всаефаулт](windows-sockets-error-codes-2.md).

**Суперконтроллер ввода/вывода \_ базовый \_ маркер** определяется в файле заголовка *мсвсокк. h* и поддерживается в Windows Vista и более поздних версиях.

### <a name="sio_bsp_handle-opcode-setting-o-t1"></a>\_Маркер загрузочного процессора SIO \_ (параметр кода операции: O, T = = 1)

Получает базовый маркер поставщика службы для сокета, используемого функцией [**всасендмсг**](/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg) . Возвращаемое значение — это **сокет**.

Этот запрос IOCTL используется многоуровневый поставщик служб, чтобы гарантировать перехват поставщиком функции [**всасендмсг**](/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg) .

Если выходной буфер недостаточно велик для маркера сокета ( *кбаутбуффер* меньше, чем размер **сокета**), или параметр *лпваутбуффер* является **пустым** указателем, то в результате этого ioctl **возвращается \_ Ошибка сокета** , а [**всажетластеррор**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) возвращает [всаефаулт](windows-sockets-error-codes-2.md).

**Суперконтроллер ввода/вывода \_ \_обработчик BSP** определен в файле заголовка *мсвсокк. h* и поддерживается в Windows Vista и более поздних версиях.

### <a name="sio_bsp_handle_select-opcode-setting-o-t1"></a>\_ \_ Выбор обработчика контроллера SIO \_ (параметр кода операции: O, T = = 1)

Получает базовый маркер поставщика службы для сокета, используемого функцией [**SELECT**](/windows/desktop/api/Winsock2/nf-winsock2-select) . Возвращаемое значение — это **сокет**.

Этот запрос IOCTL используется многоуровневый поставщик служб, чтобы гарантировать перехват поставщиком функции [**SELECT**](/windows/desktop/api/Winsock2/nf-winsock2-select) .

Если выходной буфер недостаточно велик для маркера сокета ( *кбаутбуффер* меньше, чем размер **сокета**), или параметр *лпваутбуффер* является **пустым** указателем, то в результате этого ioctl **возвращается \_ Ошибка сокета** , а [**всажетластеррор**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) возвращает [всаефаулт](windows-sockets-error-codes-2.md).

**Суперконтроллер ввода/вывода \_ в \_ \_** файле заголовка *мсвсокк. h* определено значение SELECT для обработчика загрузочных процессоров, которое поддерживается в Windows Vista и более поздних версиях.

### <a name="sio_bsp_handle_poll-opcode-setting-o-t1"></a>\_ \_ Опрос обработчика контроллера SIO \_ (параметр кода операции: O, T = = 1)

Получает базовый маркер поставщика службы для сокета, используемого функцией [**всаполл**](/windows/win32/api/winsock2/nf-winsock2-wsapoll) . Параметр *лповерлаппед* должен быть **пустым** указателем. Возвращаемое значение — это **сокет**.

Этот запрос IOCTL используется многоуровневый поставщик служб, чтобы гарантировать перехват поставщиком функции [**всаполл**](/windows/win32/api/winsock2/nf-winsock2-wsapoll) .

Если выходной буфер недостаточно велик для маркера сокета ( *кбаутбуффер* меньше, чем размер **сокета**), то параметр *лпваутбуффер* является **пустым** указателем, или параметр *лповерлаппед* не является **пустым** указателем, **\_ Ошибка сокета** возвращается в результате этого IOCTL и [**всажетластеррор**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) возвращает [всаефаулт](windows-sockets-error-codes-2.md).

**Суперконтроллер ввода/вывода \_ \_ \_ опрос обработчика BSP** определяется в файле заголовка *мсвсокк. h* и поддерживается в Windows Vista и более поздних версиях.

### <a name="sio_chk_qos-opcode-setting-i-o-t3"></a>\_QoS SIO \_ (параметр кода операции: I, O, T = = 3)

Извлекает сведения о характеристиках трафика QoS. На этапе перехода в систему отправляющей системы между настройкой потока и получением сообщения RESV (см. сведения о [том, как служба RSVP вызывает TC](/previous-versions/windows/desktop/qos/how-the-rsvp-service-invokes-tc) для получения дополнительных сведений о переходном этапе) трафик, связанный с потоком RSVP, основан на типе службы ([наилучшие усилия](/previous-versions/windows/desktop/qos/best-effort), [управляемая нагрузка](/previous-versions/windows/desktop/qos/controlled-load)или [гарантированная](/previous-versions/windows/desktop/qos/guaranteed)). Дополнительные сведения см. в разделе [использование \_ службы \_ QoS SIO](/previous-versions/windows/desktop/qos/using-sio-chk-qos) по [качеству обслуживания раздела Quality Service](/previous-versions/windows/desktop/qos/qos-start-page) SDK платформы.

### <a name="sio_cpu_affinity-opcode-setting-i-t3"></a>SIO_CPU_AFFINITY (параметр кода операции: I, T = = 3)

Включает совместное использование портов и возможность получения индикации. Если приложение использует этот параметр сокета для связывания сокетов с разными процессорами, а затем привязывает сокеты к одному и тому же адресу, то приемы приема будут распределяться между сокетами на основе хэша масштабирования на стороне приема (RSS). Параметры RSS не меняются, поэтому любой заданный поток (локальная конечная точка, пара удаленных конечных точек) всегда будет указан на одном процессоре. В результате все пакеты, принадлежащие заданному потоку, будут обозначены одним и тем же сокетом. Этот запрос IOCTL должен быть вызван перед привязкой, в противном случае будет возвращен ВСАЕИНВАЛ. Входной буфер — это индекс процессора (от 0) типа USHORT. Запрос IOCTL несовместим с SO_REUSEADDR и SO_REUSE_MULTICASTPORT. Поддерживается только для сокетов UDP.

> [!NOTE]
> если используется версия 10.0.19041.0 (Windows 10, версия 2004) Windows SDK, используйте значение `0x98000015` вместо имени **SIO_CPU_AFFINITY**.

### <a name="sio_enable_circular_queueing-opcode-setting-v-t1"></a>\_Включение \_ циклической \_ очереди в SIO (параметр кода операции: V, T = = 1)

Указывает на базовый поставщик услуг, ориентированный на сообщения, что переданное сообщение никогда не должно быть удалено из-за переполнения очереди буфера. Вместо этого самое старое сообщение в очереди должно быть устранено, чтобы охватить вновь полученное сообщение. Входные и выходные буферы не требуются. Обратите внимание, что этот запрос IOCTL допустим только для сокетов, связанных с ненадежными протоколами, ориентированными на сообщения. Код ошибки [всаенопротупт](windows-sockets-error-codes-2.md) указывается для поставщиков услуг, которые не поддерживают этот запрос IOCTL.

### <a name="sio_find_route-opcode-setting-o-t1"></a>\_Поиск \_ маршрута sio (параметр кода операции: O, T = = 1)

При выдаче этот запрос IOCTL запрашивает возможность обнаружения маршрута к удаленному адресу, указанному в качестве [**SOCKADDR**](sockaddr-2.md) во входном буфере. Если адрес уже существует в локальном кэше, его запись становится недействительной. При использовании протокола IPX для Novell этот вызов инициирует Жетлокалтаржет IPX (ГЛТ), который запрашивает сеть для данного удаленного адреса.

### <a name="sio_flush-opcode-setting-v-t1"></a>\_Сброс sio (параметр кода операции: V, T = = 1)

Удаляет текущее содержимое очереди отправки, связанной с этим сокетом. Входные и выходные буферы не требуются. Код ошибки [всаенопротупт](windows-sockets-error-codes-2.md) указывается для поставщиков услуг, которые не поддерживают этот запрос IOCTL.

### <a name="sio_get_broadcast_address-opcode-setting-o-t1"></a>\_Получение \_ широковещательного \_ адреса sio (параметр кода операции: O, T = = 1)

Этот запрос IOCTL заполняет выходной буфер структурой [SOCKADDR](sockaddr-2.md) , содержащей подходящий широковещательный адрес для использования с [**SendTo**](/windows/desktop/api/winsock/nf-winsock-sendto) /  [**всасендто**](/windows/desktop/api/Winsock2/nf-winsock2-wsasendto). Этот запрос IOCTL не поддерживается для сокетов IPv6 и возвращает код ошибки [всаенопротупт](windows-sockets-error-codes-2.md) .

### <a name="sio_get_extension_function_pointer-opcode-setting-o-i-t1"></a>\_ \_ Указатель функции получения расширения SIO \_ \_ (параметр кода операции: O, I, T = = 1)

Получение указателя на указанную функцию расширения, поддерживаемую связанным поставщиком служб. Входной буфер содержит глобальный уникальный идентификатор (**GUID**), значение которого определяет рассматриваемую функцию расширения. Указатель на нужную функцию возвращается в выходном буфере. Идентификаторы функций расширения устанавливаются поставщиками поставщиков услуг и должны быть включены в документацию поставщика, в которой описываются возможности и семантика функций расширения.

значения GUID для функций расширения, поддерживаемых поставщиком услуг Windows TCP/IP, определяются в файле заголовка *мсвсокк. h* . Возможны следующие значения для этих идентификаторов GUID:

| Термин                                                                                                                | Описание                                                                               |
|-|-|
| <span id="WSAID_ACCEPTEX"></span><span id="wsaid_acceptex"></span>ВСАИД \_ акцептекс<br/>                                     | Функция расширения [**акцептекс**](/windows/win32/api/mswsock/nf-mswsock-acceptex) .<br/>                         |
| <span id="WSAID_CONNECTEX"></span><span id="wsaid_connectex"></span>ВСАИД \_ коннектекс<br/>                                  | Функция расширения [**коннектекс**](/windows/desktop/api/Mswsock/nc-mswsock-lpfn_connectex) . <br/>                      |
| <span id="WSAID_DISCONNECTEX"></span><span id="wsaid_disconnectex"></span>ВСАИД \_ дисконнектекс<br/>                         | Функция расширения [**дисконнектекс**](/previous-versions/windows/desktop/legacy/ms737757(v=vs.85)) . <br/>                |
| <span id="WSAID_GETACCEPTEXSOCKADDRS"></span><span id="wsaid_getacceptexsockaddrs"></span>ВСАИД \_ жетакцептекссоккаддрс<br/> | Функция расширения [**жетакцептекссоккаддрс**](/windows/win32/api/mswsock/nf-mswsock-getacceptexsockaddrs) .<br/> |
| <span id="WSAID_TRANSMITFILE"></span><span id="wsaid_transmitfile"></span>ВСАИД \_ TRANSMITFILE<br/>                         | Функция расширения [**TransmitFile**](/windows/win32/api/mswsock/nf-mswsock-transmitfile) .<br/>                 |
| <span id="WSAID_TRANSMITPACKETS"></span><span id="wsaid_transmitpackets"></span>ВСАИД \_ трансмитпаккетс<br/>                | Функция расширения [**трансмитпаккетс**](/windows/desktop/api/Mswsock/nc-mswsock-lpfn_transmitpackets) . <br/>          |
| <span id="WSAID_WSARECVMSG"></span><span id="wsaid_wsarecvmsg"></span>ВСАИД \_ всареквмсг<br/>                               | Функция расширения [**LPFN_WSARECVMSG (всареквмсг)**](/windows/win32/api/mswsock/nc-mswsock-lpfn_wsarecvmsg) .<br/>                     |
| <span id="WSAID_WSASENDMSG"></span><span id="wsaid_wsasendmsg"></span>ВСАИД \_ всасендмсг<br/>                               | Функция расширения [**всасендмсг**](/windows/desktop/api/winsock2/nf-winsock2-wsasendmsg) . <br/>                      |

### <a name="sio_get_group_qos-opcode-setting-o-i-t1"></a>\_Получение \_ \_ качества обслуживания группы sio (параметр кода операции: O, I, T = = 1)

Зарезервировано для будущего использования с сокетами.

Получите структуру [**QoS**](/windows/win32/api/winsock2/ns-winsock2-qos) , связанную с группой сокетов, к которой принадлежит этот сокет. Входной буфер является необязательным. Некоторые протоколы (например, RSVP) позволяют использовать входной буфер для уточнения запроса на качество обслуживания. Структура **качества обслуживания** будет скопирована в выходной буфер. Если этот сокет не принадлежит подходящей группе сокетов, члены **сендингфловспек** и **рецеивингфловспек** возвращенной структуры **качества обслуживания** устанавливаются в **значение NULL**. Код ошибки [всаенопротупт](windows-sockets-error-codes-2.md) указывается для поставщиков услуг, которые не поддерживают качество обслуживания.

### <a name="sio_get_interface_list-opcode-setting-o-t0"></a>\_ \_ Список интерфейсов получения SIO \_ (параметр кода операции: O, T = = 0)

Возвращает список настроенных интерфейсов IP и их параметры в виде массива структур [**\_ сведений о интерфейсе**](/windows/desktop/api/Ws2ipdef/ns-ws2ipdef-interface_info) .

> [!Note]  
> поддержка этой команды обязательна для поставщиков служб TCP/IP, соответствующих сокетам Windows 2.

Параметр *лпваутбуффер* указывает на буфер, в котором хранятся сведения об интерфейсах в виде массива структур [**\_ сведений о интерфейсах**](/windows/desktop/api/Ws2ipdef/ns-ws2ipdef-interface_info) для одноадресных IP-адресов в интерфейсах. Параметр *кбаутбуффер* задает длину выходного буфера. Число возвращаемых интерфейсов (число структур, возвращаемых в буфере, на которое указывает параметр *лпваутбуффер* ) можно определить на основе фактической длины выходного буфера, возвращаемого в параметре *лпкббитесретурнед* .

Если функция [**всаиоктл**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) вызывается с помощью **\_ \_ \_ списка интерфейсов SIO Get** , а элемент Level параметра Socket *s* не определен как **иппрото \_ IP**, то возвращается **всаеинвал** . Вызов функции **всаиоктл** с **SIO \_ Get \_ Interface \_ List** возвращает **всаефаулт** , если параметр *кбаутбуффер* , указывающий длину выходного буфера, слишком мал, то получает список настроенных интерфейсов.

**Суперконтроллер ввода/вывода \_ \_ \_ список интерфейсов GET** поддерживается в Windows Me/98 и Windows NT 4,0 с пакетом обновления 4 (SP4) и более поздних версий.

### <a name="sio_get_interface_list_ex-opcode-setting-o-t0"></a>\_Получение \_ списка интерфейсов SIO \_ \_ (параметр кода операции: O, T = = 0)

Зарезервировано для будущего использования с сокетами.

Возвращает список настроенных интерфейсов IP и их параметров в виде массива [**\_ сведений о интерфейсе \_ ex**](/windows/desktop/api/Ws2ipdef/ns-ws2ipdef-interface_info_ex) .

Параметр *лпваутбуффер* указывает на буфер, в котором хранятся сведения об интерфейсах в виде массива [**сведений о интерфейсе \_ \_**](/windows/desktop/api/Ws2ipdef/ns-ws2ipdef-interface_info_ex) , например структуры для одноадресных IP-адресов в интерфейсе. Параметр *кбаутбуффер* задает длину выходного буфера. Число возвращаемых интерфейсов (число структур, возвращаемых в *лпваутбуффер*) можно определить на основе фактической длины выходного буфера, возвращаемого в параметре *лпкббитесретурнед* .

**Суперконтроллер ввода/вывода \_ ПОЛУЧЕНИЕ \_ \_ списка \_ интерфейсов** в настоящее время не поддерживается в Windows.

### <a name="sio_get_qos-opcode-setting-o-t1"></a>\_Получение \_ качества обслуживания sio (параметр кода операции: O, T = = 1)

Зарезервировано для будущего использования с сокетами. Получение структуры [**QoS**](/windows/win32/api/winsock2/ns-winsock2-qos) , связанной с сокетом. Входной буфер является необязательным. Некоторые протоколы (например, RSVP) позволяют использовать входной буфер для уточнения запроса на качество обслуживания. Структура **качества обслуживания** будет скопирована в выходной буфер. Размер выходного буфера должен быть достаточно большим, чтобы вместить полную структуру **QoS** . Код ошибки [всаенопротупт](windows-sockets-error-codes-2.md) указывается для поставщиков услуг, которые не поддерживают качество обслуживания.

Отправитель может не вызывать **SIO для \_ получения \_ QoS** , пока сокет не будет подключен.

Получатель может вызвать **SIO для \_ получения \_ качества обслуживания** , как только оно будет привязано.

### <a name="sio_get_tx_timestamp"></a>SIO_GET_TX_TIMESTAMP

Сокет IOCTL, используемый для получения меток времени для передаваемых пакетов (TX). Допустимо только для сокетов датаграмм.

Код элемента управления **SIO_GET_TX_TIMESTAMP** удаляет отметку времени передачи из очереди передачи отметок времени сокета. Сначала включите получение метки времени с помощью [**SIO_TIMESTAMPING**](#sio_timestamping) сокета IOCTL. Затем извлеките отметки времени TX по ИДЕНТИФИКАТОРу, вызвав функцию [**всаиоктл**](/windows/win32/api/winsock2/nf-winsock2-wsaioctl) (или [**вспиоктл**](/previous-versions/windows/hardware/network/ff566296(v=vs.85))) со следующими параметрами.

Для **SIO_GET_TX_TIMESTAMP** входные данные представляют собой идентификатор метки типа **UINT32** , а выходные данные — это значение **UINT64** timestamp. При успешном выполнении отметка времени TX доступна и возвращается. Если нет доступных отметок времени передачи, [**всажетластеррор**](/windows/win32/api/winsock/nf-winsock-wsagetlasterror) возвращает **всаеваулдблокк**.

> [!NOTE]
> Отметка времени TX не поддерживается при выполнении совместной отправки через **UDP_SEND_MSG_SIZE**.

См. также раздел " [отметка времени Winsock](/windows/win32/winsock/winsock-timestamping)".

### <a name="sio_ideal_send_backlog_change-opcode-setting-v-t0"></a>\_Оптимальное \_ \_ изменение невыполненной работы SIO \_ (параметр кода операции: V, T = = 0)

Уведомляет приложение об изменении идеального значения невыполненной отправки (ISB) для базового соединения.

при отправке данных через tcp-соединение с помощью Windowsных сокетов важно обеспечить достаточное количество необработанных данных (отправленных, но еще не подтвержденных) в tcp, чтобы добиться максимальной пропускной способности. Оптимальное значение объема данных, необходимых для достижения наилучшей пропускной способности для подключения TCP, называется идеальным размером невыполненной отправки (ISB). Значение ISB является функцией произведения задержки пропускной способности подключения TCP и полученного окна приема получателя (а также частично перегрузки в сети).

значение ISB для каждого подключения доступно в реализации протокола TCP в Windows Server 2008, Windows Vista с пакетом обновления 1 (SP1) и более поздних версиях операционной системы. **\_ Оптимальный запрос \_ на \_ отработку невыполненной работы \_ по отправке SIO** может использоваться приложением для получения уведомления при динамическом изменении значения ISB для соединения.

Дополнительные сведения см. в справочнике [**по \_ \_ \_ \_ изменению невыполненной работы SIO**](/previous-versions/windows/desktop/legacy/bb736548(v=vs.85)) .

[**Суперконтроллер ввода/вывода \_ оптимальное \_ \_ \_ изменение невыполненной работы отправки**](/previous-versions/windows/desktop/legacy/bb736548(v=vs.85)) поддерживается на Windows Server 2008, Windows Vista с пакетом обновления 1 (SP1) и более поздних версиях операционной системы.

### <a name="sio_ideal_send_backlog_query-opcode-setting-o-t0"></a>\_Идеальный \_ запрос на \_ отработку невыполненной работы по отправке SIO \_ (параметр кода операции: O, T = = 0)

Извлекает оптимальное значение невыполненной отправки (ISB) для базового соединения.

при отправке данных через tcp-соединение с помощью Windowsных сокетов важно обеспечить достаточное количество необработанных данных (отправленных, но еще не подтвержденных) в tcp, чтобы добиться максимальной пропускной способности. Оптимальное значение объема данных, необходимых для достижения наилучшей пропускной способности для подключения TCP, называется идеальным размером невыполненной отправки (ISB). Значение ISB является функцией произведения задержки пропускной способности подключения TCP и полученного окна приема получателя (а также частично перегрузки в сети).

значение ISB для каждого подключения доступно в реализации протокола TCP в Windows Server 2008 и более поздних версиях. Запрос IOCTL с **\_ идеальными для \_ отправки \_ невыполненной работы \_** может использоваться приложением для запроса значения ISB для соединения.

Более подробные сведения см. в справочнике по [**\_ \_ \_ \_ запросу невыполненной работы по отправке SIO**](/previous-versions/windows/desktop/legacy/bb736549(v=vs.85)) .

[**Суперконтроллер ввода/вывода \_ идеальный \_ \_ \_ запрос на отработку невыполненной работы**](/previous-versions/windows/desktop/legacy/bb736549(v=vs.85)) поддерживается на Windows Server 2008, Windows Vista с пакетом обновления 1 (SP1) и более поздних версиях операционной системы.

### <a name="sio_keepalive_vals-opcode-setting-i-t3"></a>\_Валс KeepAlive SIO \_ (параметр кода операции: I, T = = 3)

Включает или отключает параметр для каждого подключения параметра проверки **активности** TCP, который указывает время ожидания и интервал поддержания активности TCP. Дополнительные сведения о параметре проверки активности см. в разделе 4.2.3.6 ( *требования для узлов Интернета) — уровни взаимодействия* , указанные в RFC 1122, доступны на [веб-сайте IETF](https://www.ietf.org/rfc/rfc1122.txt). (Этот ресурс может быть доступен только на английском языке.)

**Суперконтроллер ввода/вывода \_ \_ВАЛС KeepAlive** можно использовать для включения или отключения проверок активности и установки времени ожидания и интервала проверки активности. Время ожидания проверки активности указывает время ожидания (в миллисекундах) без активности, пока не будет отправлен первый пакет проверки активности. Интервал проверки активности определяет интервал (в миллисекундах) между отправкой успешных пакетов проверки активности, если подтверждение не получено.

[**Таким образом \_**](so-keepalive.md) , параметр KeepAlive, который является одним из [ \_ параметров сокета сокета Sol](sol-socket-socket-options.md), также может использоваться для включения или отключения поддержки TCP-активности в соединении, а также для запроса текущего состояния этого параметра. Чтобы запросить, включена ли поддержка TCP-активности на сокете, функцию [**жетсоккопт**](/windows/desktop/api/winsock/nf-winsock-getsockopt) можно вызвать с помощью параметра **so \_ KeepAlive** . Чтобы включить или отключить поддержку поддержания активности TCP, функцию [**сетсоккопт**](/windows/desktop/api/winsock/nf-winsock-setsockopt) можно вызвать с помощью параметра [**so \_ KeepAlive**](so-keepalive.md) . Если поддержка проверки активности TCP включена с **таким образом \_**, то для времени ожидания и интервала проверки активности используются параметры TCP по умолчанию, если эти значения не были изменены с помощью **SIO \_ KeepAlive \_ Валс**.

Более подробные сведения см. в справочнике по [**\_ KeepAlive \_ Валс**](/previous-versions/windows/desktop/legacy/dd877220(v=vs.85)) . **Суперконтроллер ввода/вывода \_ KEEPALIVE \_ валс** поддерживается в Windows 2000 и более поздних версиях.

### <a name="sio_loopback_fast_path-opcode-setting-i-t3"></a>\_замыкание сигнала SIO \_ FAST \_ пути (параметр кода операции: I, T = = 3)

Настраивает сокет TCP для более низкой задержки и более быстрых операций в интерфейсе замыкания на себя. Этот запрос IOCTL запрашивает использование в стеке TCP/IP специального быстрого пути для операций замыкания на себя на этом сокете. запрос IOCTL FAST с помощью [**\_ обратного замыкания на себя \_ \_**](/previous-versions/windows/desktop/legacy/jj841212(v=vs.85)) можно использовать только с сокетами TCP. Этот запрос IOCTL должен использоваться на обеих сторонах сеанса замыкания на себя. Быстрый путь TCP замыкания на себя поддерживается с помощью интерфейса замыкания на себя IPv4 или IPv6. по умолчанию в качестве **\_ \_ \_ пути FAST замыкания контроллера SIO** отключено.

дополнительные сведения см. в справочнике [**по \_ \_ FAST \_ пути на замыкание SIO**](/previous-versions/windows/desktop/legacy/jj841212(v=vs.85)) . **Суперконтроллер ввода/вывода \_ \_ \_ путь FAST замыкания на себя** поддерживается в Windows 8, Windows Server 2012 и более поздних версиях.

### <a name="sio_multipoint_loopback-opcode-setting-v-t1"></a>\_Петлевой MULTIPOINT \_ (параметр кода операции: V, T = = 1)

Определяет, будут ли данные, отправляемые приложением на локальном компьютере (не обязательное одним сокетом) в сеансе многоадресной рассылки, приниматься сокетом, присоединенным к группе назначения многоадресной рассылки через интерфейс замыкания на себя. Значение **true** приводит к тому, что данные многоадресной рассылки, отправляемые приложением на локальном компьютере, доставляются в Прослушивающий сокет через интерфейс замыкания на себя. Значение **false** указывает, что данные многоадресной рассылки, отправляемые приложением на локальном компьютере, не доставляются в Прослушивающий сокет через интерфейс замыкания на себя. По умолчанию **\_ \_ петлевой контроллер SIO MULTIPOINT** включен.

### <a name="sio_multicast_scope-opcode-setting-i-t1"></a>\_Многоадресная \_ область sio (параметр кода операции: I, T = = 1)

Указывает область, в которой будут выполняться многоадресные передачи. Область определяется как количество сегментов маршрутизируемых сетей, подпадающих под действие. Нулевая область означает, что многоадресная передача не будет помещаться в сеть, но может быть распределена между сокетами на локальном узле. Значение области, равное единице (по умолчанию), указывает, что передача будет размещена на канале передачи, но не будет пересекать маршрутизаторы. Более высокие значения области определяют количество маршрутизаторов, которые могут быть перепутаны. Обратите внимание, что это соответствует параметру срока жизни (TTL) в многоадресной IP-рассылке. По умолчанию областью действия является 1.

### <a name="sio_query_rss_processor_info-opcode-setting-o-t1"></a>\_ \_ \_ Сведения о обработчике запросов SIO в формате RSS \_ (параметр кода операции: O, T = = 1)

Запрашивает связь между сокетом и ядром процессора RSS и узлом NUMA.

[**\_ \_ \_ \_ Сведения о процессоре суперконтроллера**](/previous-versions/windows/desktop/legacy/jj553482(v=vs.85)) ввода-вывода в формате RSS запрос IOCTL возвращает структуру [**\_ \_ соответствия процессоров сокетов**](/windows/desktop/api/Ws2def/ns-ws2def-socket_processor_affinity) , которая содержит [**\_ номер процессора**](/windows/win32/api/winnt/ns-winnt-processor_number) и идентификатор узла NUMA. Возвращенная **Структура \_ номеров процессоров** содержит номер группы и относительный номер процессора в группе.

Более подробные сведения см. в справочнике по [**\_ \_ \_ \_ сведениям о процессоре SIO**](/previous-versions/windows/desktop/legacy/jj553482(v=vs.85)) . **Суперконтроллер ввода/вывода \_ \_ \_ \_ сведения о обработчике RSS-канала для запросов** поддерживаются в Windows 8, Windows Server 2012 и более поздних версиях.

### <a name="sio_query_rss_scalability_info-opcode-setting-o-t3"></a>\_ \_ \_ Сведения о масштабируемости RSS запроса SIO \_ (параметр кода операции: O, T = = 3)

Запрашивает разгрузку интерфейсов для возможности масштабирования на стороне приема (RSS). Структура аргумента, возвращаемая для **\_ \_ \_ \_ сведений о масштабируемости RSS запроса SIO** , указана в структуре **\_ \_ сведений о масштабируемости RSS** , определенной в файле заголовка *мсткпип. h* . Эта структура определяется следующим образом:

```cpp
// Scalability info for the transport
typedef struct _RSS_SCALABILITY_INFO {
   BOOLEAN RssEnabled;
} RSS_SCALABILITY_INFO, *PRSS_SCALABILITY_INFO;
```

Значение, возвращаемое в элементе **рссенаблед** , указывает, включена ли поддержка RSS по крайней мере в одном интерфейсе.

Если выходной буфер не достаточен для структуры **\_ \_ сведений о масштабируемости RSS** ( *кбаутбуффер* меньше, чем размер **\_ \_ информации о масштабируемости RSS**), или параметр *лпваутбуффер* является **пустым** указателем, то в результате этого ioctl возвращается **\_ Ошибка сокета** , а [**всажетластеррор**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) возвращает [всаеинвал](windows-sockets-error-codes-2.md).

В высокоскоростной сети, в которой несколько процессоров находятся в пределах одной системы, способность стека сетевых протоколов масштабироваться в многопроцессорной системе, запрещена, поскольку архитектура NDIS 5,1 и более ранних версий ограничивает скорость обработки протокола одним ЦП. Масштабирование на стороне приема (RSS) устраняет эту проблему, разрешая сетевую загрузку с сетевого адаптера на несколько процессоров.

**Суперконтроллер ввода/вывода \_ \_ \_ \_ сведения о масштабируемости RSS-канала запросов** поддерживаются в Windows Vista и более поздних версиях.

### <a name="sio_query_transport_setting-opcode-setting-i-t3"></a>\_ \_ Параметр транспорта запросов SIO \_ (параметр кода операции: I, T = = 3)

Запрашивает параметры транспорта на сокете. Запрашиваемый параметр транспорта основан на [**\_ \_ идентификаторе параметра транспорта**](/windows/win32/api/transportsettingcommon/ns-transportsettingcommon-transport_setting_id) , переданном в параметре *лпвинбуффер* .

Единственным параметром транспорта, который сейчас определяет, является возможность получения **\_ \_ уведомлений \_ в режиме реального времени** на сокете TCP.

если [**\_ \_ идентификатор параметра транспорта**](/windows/win32/api/transportsettingcommon/ns-transportsettingcommon-transport_setting_id) имеет значение **Guid** , установленное в **режиме реального \_ времени \_ , это \_** запрос на запрос параметров уведомлений в режиме реального времени для сокета TCP, используемого с [**контролчаннелтригжер**](/uwp/api/Windows.Networking.Sockets.ControlChannelTrigger) , для получения сетевых уведомлений в фоновом режиме в приложении Windows Store. При успешном вызове [**всаиоктл**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) или [**ВСПИОКТЛ**](/previous-versions/windows/hardware/network/ff566296(v=vs.85)) этот запрос IOCTL возвращает [**\_ \_ \_ \_ выходную структуру параметра уведомления в режиме реального времени**](/windows/desktop/api/Mstcpip/ns-mstcpip-real_time_notification_setting_input) с текущим состоянием.

Более подробные сведения см. в справочнике по [**\_ \_ \_ параметрам транспорта запросов SIO**](/previous-versions/windows/desktop/legacy/jj553483(v=vs.85)) . **Суперконтроллер ввода/вывода \_ \_ \_ параметр транспорта запросов** поддерживается в Windows 8, Windows Server 2012 и более поздних версиях.

### <a name="sio_query_wfp_ale_endpoint_handle-opcode-setting-o-t3"></a>\_Обработчик SIO запрос на \_ \_ \_ конечную точку ALE WFP \_ (параметр кода операции: O, T = = 3)

Запрашивает обработчика конечных точек принудительного применения уровня приложения (ALE).

платформа фильтрации Windows (WFP) поддерживает проверку и изменение сетевого трафика. в Windows Vista в WFP основное внимание уделяется сценариям, где хост-компьютер является конечной точкой связи. однако на Windows Server 2008 существуют реализации брандмауэров с пограничными брандмауэрами, которые хотели бы использовать платформу WFP для проверки и сквозного трафика прокси-сервера. Примером такого устройства является сервер Internet Security and Acceleration (ISA).

В некоторых сценариях брандмауэра может потребоваться возможность внедрять входящий пакет в путь отправки, связанный с существующей конечной точкой. Необходим механизм обнаружения маркера конечной точки транспортного уровня, связанного с конечной точкой назначения. Приложение, создавшее конечную точку, владеет этими конечными точками транспортного уровня. Этот запрос IOCTL используется для предоставления маркера сокета для сопоставления с маркерами конечной точки транспортного уровня.

Если выходной буфер недостаточно велик для маркера конечной точки ( *кбаутбуффер* меньше размера **UINT64**) или параметр *лпваутбуффер* является **пустым** указателем, то в результате выполнения этого ioctl возвращается **\_ Ошибка сокета** , а [**всажетластеррор**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) возвращает [всаеинвал](windows-sockets-error-codes-2.md).

**Суперконтроллер ввода/вывода \_ \_обработчик запросов \_ к \_ конечным \_ точкам ALE WFP** поддерживается в Windows Vista и более поздних версиях.

### <a name="sio_query_wfp_connection_redirect_context-opcode-setting-i-t3"></a>\_Запрос SIO \_ \_ \_ контекста перенаправления соединения WFP \_ (параметр кода операции: I, T = = 3)

запрашивает контекст перенаправления для записи перенаправления, используемой службой перенаправления Windows фильтрации платформы (WFP).

В [**\_ запросе SIO \_ \_ \_ \_ контекст перенаправления подключения WFP**](/previous-versions/windows/desktop/legacy/hh859712(v=vs.85)) используется для обеспечения отслеживания подключений через посредника при перенаправленных соединениях сокетов. Эта функция WFP упрощает отслеживание записей перенаправления из первоначального перенаправления соединения к конечному подключению.

Более подробные сведения см. в разделе ссылка на [**\_ \_ \_ \_ \_ контекст перенаправления подключения WFP**](/previous-versions/windows/desktop/legacy/hh859712(v=vs.85)) . **Суперконтроллер ввода/вывода \_ \_ \_ \_ \_ контекст перенаправления соединения WFP** поддерживается в Windows 8, Windows Server 2012 и более поздних версиях.

### <a name="sio_query_wfp_connection_redirect_records-opcode-setting-i-t3"></a>SIO \_ запрос \_ на \_ \_ Перенаправление соединений WFP \_ (параметр кода операции: I, T = = 3)

запрашивает запись перенаправления для принятого подключения TCP/IP для использования службой перенаправления платформы фильтрации Windows (WFP).

[**Записи о перенаправлении подключений в протоколе SIO используют запросы на \_ \_ \_ \_ \_ перенаправление запросов WFP**](/previous-versions/windows/desktop/legacy/hh859713(v=vs.85)) , чтобы обеспечить отслеживание подключений через посредника при перенаправленных соединениях сокетов. Эта функция WFP упрощает отслеживание записей перенаправления из первоначального перенаправления соединения к конечному подключению.

Более подробные сведения см. в справочнике по [**\_ \_ \_ \_ \_ записям перенаправления подключения WFP**](/previous-versions/windows/desktop/legacy/hh859713(v=vs.85)) . **Суперконтроллер ввода/вывода \_ запросы \_ на \_ \_ перенаправление \_ подключений WFP** поддерживаются в Windows 8, Windows Server 2012 и более поздних версиях.

### <a name="sio_rcvall-opcode-setting-i-t3"></a>SIO \_ рквалл (параметр кода операции: I, T = = 3)

Позволяет сокету принимать все пакеты IPv4 или IPv6, передающие срауигх сетевой интерфейс. Маркер сокета, переданный функции [**всаиоктл**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) , должен быть одним из следующих:

-   Сокет IPv4, созданный с семейством адресов, имеющим значение AF \_ INET, тип сокета, установленный в значение Сокк \_ RAW, и протокол, установленный в иппрото \_ IP.
-   Сокет IPv6, созданный с семейством адресов, настроенным на AF \_ INET6, тип сокета, установленный в Сокк \_ RAW, и протокол, установленный в иппрото \_ IPv6.

Сокет также должен быть привязан к явному локальному интерфейсу IPv4 или IPv6, что означает, что вы не можете выполнить привязку к **адресу \_** или **in6addr \_ любому** из них.

на Windows Server 2008 и более ранних версиях параметр IOCTL [**\_ рквалл**](/previous-versions/windows/desktop/legacy/ee309610(v=vs.85)) не будет записывать локальные пакеты, отправленные из сетевого интерфейса. Это включает пакеты, полученные на другом интерфейсе, и перенаправляли сетевой интерфейс, указанный для **SIO \_ рквалл** IOCTL.

в Windows 7 и Windows Server 2008 R2 это было изменено, так что также фиксируются локальные пакеты, отправленные из сетевого интерфейса. Это относится к пакетам, полученным в другом интерфейсе, и последующем пересылке сетевого интерфейса, привязанного к сокету, с помощью интерфейса [**SIO \_ рквалл**](/previous-versions/windows/desktop/legacy/ee309610(v=vs.85)) IOCTL.

Для установки этого IOCTL требуются права администратора на локальном компьютере.

Эта функция иногда называется неизбирательным режимом.

Возможные значения параметра **SIO \_ рквалл** ioctl указаны в перечислении **\_ значений рквалл** , определенных в файле заголовка *мсткпип. h* . Ниже приведены возможные значения для SIO \_ рквалл.

| Термин                                                                                                                 | Описание                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                |
|-|-|
| <span id="RCVALL_OFF"></span><span id="rcvall_off"></span>РКВАЛЛ \_<br/>                                     | Отключите этот параметр, чтобы сокет не получал все пакеты IPv4 или IPv6 в сети. <br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| <span id="RCVALL_ON"></span><span id="rcvall_on"></span>РКВАЛЛ \_<br/>                                        | Включите этот параметр, чтобы сокет получит все пакеты IPv4 или IPv6 в сети. Этот параметр включает неизбирательный режим на плате сетевого интерфейса (NIC), если сетевой адаптер поддерживает неизбирательный режим. В сегменте локальной сети с сетевым концентратором сетевая карта, поддерживающая неизбирательный режим, захватывает весь трафик IPv4 или IPv6 в локальной сети, включая трафик между другими компьютерами в одном сегменте локальной сети. Все захваченные пакеты (IPv4 или IPv6, в зависимости от сокета) будут переданы в необработанный сокет. <br/> Этот параметр не будет захватывать другие пакеты (например, пакеты ARP, IPX и NetBEUI) в интерфейсе.<br/> NetMon использует тот же режим для сетевого интерфейса, но не использует этот параметр для записи трафика.<br/> |
| <span id="RCVALL_SOCKETLEVELONLY"></span><span id="rcvall_socketlevelonly"></span>РКВАЛЛ \_ соккетлевелонли<br/> | Эта функция в настоящее время не реализована, поэтому установка этого параметра не влияет на.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     |
| <span id="RCVALL_IPLEVEL"></span><span id="rcvall_iplevel"></span>РКВАЛЛ \_ иплевел<br/>                         | Включите этот параметр, чтобы сокет IPv4 или IPv6 получал все пакеты на уровне IP-адреса в сети. Этот параметр не включает неизбирательный режим на плате сетевого интерфейса. Этот параметр влияет только на обработку пакетов на уровне IP-адреса. Сетевая карта по-прежнему получает только пакеты, направленные на настроенные адрес рассылки и адреса многоадресной рассылки. Тем не менее, сокет с включенным параметром будет получать не только пакеты, направленные на определенные IP-адреса, но и все пакеты IPv4 или IPv6, получаемые сетевым адаптером.<br/> Этот параметр не записывает другие пакеты (например, пакеты ARP, IPX и NetBEUI), полученные через интерфейс.<br/>                                                                                             |



 

Более подробные сведения см. в справочнике по [**SIO \_ рквалл**](/previous-versions/windows/desktop/legacy/ee309610(v=vs.85)) .

**Суперконтроллер ввода/вывода \_ рквалл** поддерживается в Windows 2000 и более поздних версиях.

### <a name="sio_rcvall_igmpmcast-opcode-setting-i-t3"></a>SIO \_ рквалл \_ игмпмкаст (параметр кода операции: I, T = = 3)

Позволяет сокету получать весь IGMP-трафик многоадресной рассылки в сети без получения другого многоадресного IP-трафика. Маркер сокета, передаваемый функции [**всаиоктл**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) , должен иметь \_ семейство адресов AF INET, \_ тип необработанного сокета Сокк и \_ протокол IGMP иппрото. Сокет также должен быть привязан к явному локальному интерфейсу, что означает, что невозможно выполнить привязку к любому АДРЕСу \_ .

После привязки сокета и набора запросов IOCTL вызовы функций [**всарекв**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv) или [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) возвращают IP-Датаграммы многоадресной рассылки, передаваемые через данный интерфейс. Обратите внимание, что необходимо указать достаточно большой буфер. Для установки этого IOCTL требуются права администратора на локальном компьютере.

**Суперконтроллер ввода/вывода \_ рквалл \_ игмпмкаст** поддерживается в Windows 2000 и более поздних версиях.

### <a name="sio_rcvall_mcast-opcode-setting-i-t3"></a>SIO \_ рквалл \_ мкаст (параметр кода операции: I, T = = 3)

Позволяет сокету принимать весь многоадресный IP-трафик в сети (т. е. все IP-пакеты, предназначенные для IP-адресов в диапазоне от 224.0.0.0 до 239.255.255.255). Маркер сокета, передаваемый функции [**всаиоктл**](/windows/desktop/api/Winsock2/nf-winsock2-wsaioctl) , должен иметь \_ семейство адресов AF INET, \_ тип необработанного сокета Сокк и протокол иппрото \_ UDP. Сокет также должен быть привязан к явному локальному интерфейсу, что означает, что невозможно выполнить привязку к любому АДРЕСу \_ . Сокет должен быть привязан к порту нуль.

После привязки сокета и набора запросов IOCTL вызовы функций [**всарекв**](/windows/desktop/api/Winsock2/nf-winsock2-wsarecv) или [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) возвращают IP-Датаграммы многоадресной рассылки, передаваемые через данный интерфейс. Обратите внимание, что необходимо указать достаточно большой буфер. Для установки этого IOCTL требуются права администратора на локальном компьютере.

**Суперконтроллер ввода/вывода \_ рквалл \_ мкаст** поддерживается в Windows 2000 и более поздних версиях.

### <a name="sio_release_port_reservation-opcode-setting-i-t3"></a>\_ \_ Резервирование портов освобождения SIO \_ (параметр кода операции: I, T = = 3)

Освобождает резервирование среды выполнения для блока портов TCP или UDP. Резервируемое резервирование среды выполнения должно быть получено из процесса выдачи с помощью [**запроса ввода/вывода для \_ \_ \_ резервирования порта**](/previous-versions/windows/desktop/legacy/gg699720(v=vs.85)) .

Более подробные сведения см. в справочнике по [**\_ \_ \_ резервированию портов для освобождения SIO**](/previous-versions/windows/desktop/legacy/gg699722(v=vs.85)) .

[**Суперконтроллер ввода/вывода \_ \_ \_ резервирование портов выпуска**](/previous-versions/windows/desktop/legacy/gg699722(v=vs.85)) поддерживается в Windows Vista и более поздних версиях операционной системы.

### <a name="sio_routing_interface_change-opcode-setting-i-t1"></a>\_ \_ Изменение интерфейса маршрутизации SIO \_ (параметр кода операции: I, T = = 1)

Получение уведомления об изменении интерфейса маршрутизации, которое следует использовать для обращения к удаленному адресу во входном буфере (указывается как структура [**SOCKADDR**](sockaddr-2.md) ). При завершении этого IOCTL не будут предоставлены выходные данные нового интерфейса маршрутизации. завершение просто означает, что интерфейс маршрутизации для данного назначения изменился и должен быть выполнен запрос через **\_ интерфейс маршрутизации SIO с \_ помощью \_ запроса** IOCTL.

Предполагается, что, хотя это и не является обязательным, приложение использует перекрывающиеся операции ввода-вывода, чтобы получать уведомления об изменении интерфейса маршрутизации по завершении запроса на **\_ \_ \_ изменение интерфейса маршрутизации SIO** . Кроме того, если **\_ интерфейс маршрутизации \_ SIO \_ изменился** на неблокирующем сокете с параметрами *лповерлаппед* и *лпкомплетионраутине* , для которых установлено **значение NULL**), он будет немедленно возвращать и [всаеваулдблокк](windows-sockets-error-codes-2.md) в качестве ошибки, а приложение может ожидать события изменения маршрутизации с помощью вызова [**всаевентселект**](/windows/desktop/api/Winsock2/nf-winsock2-wsaeventselect) или [**всаасинкселект**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) с \_ \_ \_ установленным битом изменения интерфейса маршрутизации в битовой маске сетевого события.

Он знает, что сведения о маршрутизации в большинстве случаев остаются стабильными, поэтому, чтобы приложение сознало несколько необработанных запросов IOCTL, чтобы получать уведомления о всех назначениях, которые он интересует, а также о том, что поставщик услуг должен отслеживать эти запросы, будет использовать значительный объем системных ресурсов. Эту ситуацию можно избежать, расширив смысл входных параметров и добавив требования поставщика услуг следующим образом:

-   Приложение может указать адрес шаблона для конкретного семейства протоколов (аналогично тому, который используется при вызове [**BIND**](/windows/desktop/api/winsock/nf-winsock-bind) при запросе на привязку к любому доступному адресу) для запроса уведомлений об изменениях маршрутизации. Это позволяет приложению удерживать только одно необработанное **\_ \_ \_ изменение интерфейса маршрутизации SIO** для всех используемых сокетов и назначений, а затем использовать **\_ \_ \_ запрос интерфейса маршрутизации SIO** для получения фактических сведений о маршрутизации.
-   Поставщик услуг может игнорировать сведения, заданные приложением во входном буфере **\_ \_ интерфейса \_ маршрутизации SIO** (как если бы приложение указало адрес с подстановочным знаком), и завершить **\_ интерфейс маршрутизации SIO \_ \_ изменить** запрос IOCTL или \_ \_ событие изменения интерфейса маршрутизации для передачи сигнала \_ в случае любого изменения информации маршрутизации (а не только маршрута к назначению, указанному во входном буфере).

### <a name="sio_routing_interface_query-opcode-setting-i-o-t1"></a>\_ \_ Запрос интерфейса маршрутизации SIO \_ (параметр кода операции: I, O, T = = 1)

Для получения адреса локального интерфейса (представленного в виде структуры [**SOCKADDR**](sockaddr-2.md) ), который должен использоваться для отправки на удаленный адрес, указанный во входном буфере (как **SOCKADDR**). Удаленные адреса многоадресной рассылки можно отправить во входной буфер, чтобы получить адрес предпочтительного интерфейса для многоадресной передачи. В любом случае возвращаемый адрес интерфейса может использоваться приложением в последующем запросе BIND ().

Обратите внимание, что маршруты могут быть изменены. Поэтому приложения не могут полагаться на сведения, возвращаемые **\_ \_ \_ запросом интерфейса маршрутизации SIO** , как постоянные. Приложения могут регистрироваться для уведомлений об изменениях маршрутизации **через \_ интерфейс маршрутизации SIO \_ \_ изменение** ioctl, который обеспечивает уведомление через перекрывающиеся операции ввода-вывода или \_ \_ \_ события изменения интерфейса маршрутизации. Чтобы гарантировать, что приложение всегда имеет текущие сведения о интерфейсе маршрутизации для данного назначения, можно использовать следующую последовательность действий.

-   Выдача **\_ интерфейса маршрутизации SIO \_ \_ изменение** ioctl
-   Выдача **\_ \_ \_ запроса интерфейса маршрутизации SIO** ioctl
-   Всякий раз, когда **\_ \_ интерфейс маршрутизации \_ суперконтроллера** ввода/вывода уведомляет приложение об изменении маршрутизации (с помощью перекрывающегося элемента I/O или посредством сигнализации \_ \_ \_ события изменения интерфейса маршрутизации), должна повторяться вся последовательность действий.

Если выходной буфер недостаточно велик для размещения адреса интерфейса, то в \_ результате выполнения этого ioctl возвращается ошибка сокета, а [**Всажетластеррор**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) возвращает [всаефаулт](windows-sockets-error-codes-2.md). В этом случае в *лпкббитесретурнед* будет возвращен требуемый размер выходного буфера. Обратите внимание, что код ошибки ВСАЕФАУЛТ также возвращается в том случае, если параметр *лпвинбуффер*, *лпваутбуффер* или *лпкббитесретурнед* полностью не содержится в допустимой части адресного пространства пользователя.

Если адрес назначения, указанный во входном буфере, недоступен через какой-либо из доступных интерфейсов, то в \_ результате выполнения этого ioctl возвращается ошибка сокета, а [**Всажетластеррор**](/windows/desktop/api/winsock/nf-winsock-wsagetlasterror) возвращает [всаенетунреач](windows-sockets-error-codes-2.md) или даже [всаенетдовн](windows-sockets-error-codes-2.md) , если все сетевые подключения потеряны.

### <a name="sio_set_compatibility_mode-opcode-setting-i-t3"></a>\_ \_ Режим СОВМЕСТИМОСТИ набора SIO \_ (параметр кода операции: I, T = = 3)

запрашивает, как сетевой стек должен обрабатывать определенные поведения, для которых по умолчанию обработка поведения может отличаться в разных версиях Windows. Структура аргумента для **\_ \_ \_ режима совместимости набора SIO** указывается в структуре **\_ \_ режима совместимости WSA** , определенной в файле заголовка *мсвсоккдеф. h* . Эта структура определяется следующим образом:

```cpp
/* Argument structure for SIO_SET_COMPATIBILITY_MODE */
typedef struct _WSA_COMPATIBILITY_MODE {
    WSA_COMPATIBILITY_BEHAVIOR_ID BehaviorId;
    ULONG TargetOsVersion;
} WSA_COMPATIBILITY_MODE, *PWSA_COMPATIBILITY_MODE;
```

Значение, указанное в элементе **бехавиорид** , указывает на запрошенное поведение. значение, указанное в элементе **TargetOsVersion** , указывает на версию Windows, запрашиваемую для поведения.

Элемент **бехавиорид** может быть одним из значений типа перечисления " **\_ \_ \_ идентификатор действия совместимости WSA** ", определенного в файле заголовка *мсвсоккдеф. h* . Возможные значения для элемента **бехавиорид** :

| Термин                                                                                                                                                                             | Описание                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
|-|-|
| <span id="WsaBehaviorAll"></span><span id="wsabehaviorall"></span><span id="WSABEHAVIORALL"></span>всабехавиоралл<br/>                                                     | Это эквивалентно запросу всех возможных совместимых вариантов поведения, определенных для **\_ \_ \_ идентификатора режима совместимости WSA**.<br/>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       |
| <span id="WsaBehaviorReceiveBuffering"></span><span id="wsabehaviorreceivebuffering"></span><span id="WSABEHAVIORRECEIVEBUFFERING"></span>всабехавиоррецеивебуфферинг<br/> | если элементу **TargetOsVersion** присвоено значение для Windows Vista или более поздней версии, уменьшение размера буфера приема TCP на этом сокете с помощью параметра **SO \_ рквбуф** может быть даже после установления TCP-подключения. <br/> если для элемента **TargetOsVersion** задано значение, предшествующее Windows Vista, уменьшение размера буфера приема TCP на этом сокете с помощью параметра **\_ рквбуф** socket не разрешается после установки соединения. <br/>                                                                                                                                                                                  |
| <span id="WsaBehaviorAutoTuning"></span><span id="wsabehaviorautotuning"></span><span id="WSABEHAVIORAUTOTUNING"></span>всабехавиораутотунинг<br/>                         | если для элемента **TargetOsVersion** задано значение Windows Vista или более поздней версии, автоматическая настройка окна приема включена, а коэффициент масштабирования окна TCP уменьшается до 2 по умолчанию, равной 8.<br/> если для **TargetOsVersion** задано значение, предшествующее Windows Vista, автоматическая настройка окна приема отключена. Параметр масштабирования окна TCP также отключается, и максимальный размер окна приема ограничен 65 535 байт. Параметр масштабирования окна TCP не может быть согласован в соединении, даже если для этого сокета был вызван параметр **so \_ рквбуф** , указывающий значение более 65 535 байт до установки соединения.<br/> |



 

Более подробные сведения см. в справочнике по [**\_ \_ \_ режиму совместимости с набором SIO**](/previous-versions/windows/desktop/legacy/cc136103(v=vs.85)) .

**Суперконтроллер ввода/вывода \_ \_ \_ режим совместимости SET** поддерживается в Windows Vista и более поздних версиях.

### <a name="sio_set_group_qos-opcode-setting-i-t1"></a>\_Установка \_ \_ качества обслуживания sio (параметр кода операции: I, T = = 1)

Зарезервировано.

### <a name="sio_set_priority_hint-opcode-setting-i-t3"></a>SIO_SET_PRIORITY_HINT (параметр кода операции: I, T = = 3)

Предоставляет подсказку для основного транспортного протокола, чтобы обрабатывать трафик на этом сокете с указанным приоритетом. *Лпвинбуффер* должен указывать на переменную типа **PRIORITY_HINT** с *кбинбуффер* , для которого задано значение sizeof (PRIORITY_HINT). Параметры *лпваутбуффер* и *Кбаутбуффер* должны иметь **значение NULL** и 0 соответственно. реализация Microsoft Windows TCP поддерживает этот запрос IOCTL, начиная с Windows 10, версия 1809 (10,0; Сборка 17763) и более поздних версий следующим образом: Если для запрошенного значения приоритета задано значение **иоприоритихинтверилов**, TCP использует модифицированную версию алгоритма LEDBAT (определенную в RFC 6817) для управления скоростью исходящего трафика на сокете. Этот IOCTL не влияет на входящий трафик. LEDBAT — это алгоритм очистки, и его цель — сократить задержку и предотвратить неблагоприятное воздействие на трафик с нормальным приоритетом, изменяя способ передачи трафика с нормальным приоритетом.

См. также [RFC 6817](https://tools.ietf.org/html/rfc6817).

**SIO_SET_PRIORITY_HINT** поддерживается в Windows 10, версия 1809 (10,0; Сборка 17763) и более поздние версии.

### <a name="sio_set_qos-opcode-setting-i-t1"></a>\_Установка \_ качества обслуживания sio (параметр кода операции: I, T = = 1)

Свяжите указанную структуру [**QoS**](/windows/win32/api/winsock2/ns-winsock2-qos) с сокетом. Выходной буфер не требуется, структура **качества обслуживания** будет получена из входного буфера. Код ошибки [всаенопротупт](windows-sockets-error-codes-2.md) указывается для поставщиков услуг, которые не поддерживают качество обслуживания.

### <a name="sio_tcp_initial_rto-opcode-setting-i-t3"></a>SIO_TCP_INITIAL_RTO (параметр кода операции: I, T = = 3)

Управляет начальными характеристиками повторной передачи (SYN/SYN + ACK) TCP-сокета, настраивая начальные параметры времени ожидания повторной передачи (RTO). Параметры конфигурации указываются в структуре [**параметров TCP \_ начального \_ \_ параметра RTO**](/windows/desktop/api/mswsock/ns-mswsock-transmit_file_buffers) .

Более подробные сведения см. в справочнике по [**SIO_TCP_INITIAL_RTO**](./sio-tcp-initial-rto.md) . [**SIO_TCP_INITIAL_RTO**](./sio-tcp-initial-rto.md) поддерживается в Windows 8, Windows Server 2012 и более поздних версиях.

### <a name="sio_timestamping"></a>SIO_TIMESTAMPING

Сокет IOCTL, используемый для настройки приема отметок времени передачи или приема сокета. Допустимо только для сокетов датаграмм. Тип входных данных для **SIO_TIMESTAMPING** — структура [**TIMESTAMPING_CONFIG**](/windows/win32/api/mstcpip/ns-mstcpip-timestamping_config) .

См. также раздел " [отметка времени Winsock](/windows/win32/winsock/winsock-timestamping)".

### <a name="sio_translate_handle-opcode-setting-i-o-t1"></a>\_Маркер перевода SIO \_ (параметр кода операции: I, O, T = = 1)

Чтобы получить соответствующий маркер *для сокетов* , допустимый в контексте сопутствующего интерфейса (например, \_ нетдев и th \_ TAPI). Константа манифеста, определяющая сопутствующий интерфейс вместе с любыми другими необходимыми параметрами, задается во входном буфере. После завершения этой функции соответствующий обработчик будет доступен в выходном буфере. Дополнительные сведения о конкретном сопутствующем интерфейсе см. в соответствующем разделе в [приложении Winsock](winsock-annexes.md) . Код ошибки [всаенопротупт](windows-sockets-error-codes-2.md) указывается для поставщиков услуг, которые не поддерживают этот запрос IOCTL для указанного сопутствующего интерфейса. Этот запрос IOCTL получает маркер, связанный с использованием **\_ \_ маркера преобразования SIO**.

Для обнаружения и мониторинга других интерфейсов, которые могут поддерживаться сокетом, рекомендуется использовать модель COM вместо этого IOCTL. Этот запрос IOCTL используется для обеспечения обратной совместимости с системами, в которых COM недоступен или не может использоваться по какой-либо другой причине.

### <a name="sio_udp_connreset-opcode-setting-i-t3"></a>SIO \_ UDP \_ коннресет (параметр кода операции: I, T = = 3)

**Windows XP:** Определяет \_ , передаются ли сообщения о НЕдостижимых UDP-портах. Задайте значение **true** , чтобы включить создание отчетов. Задайте значение **false** , чтобы отключить отчеты.

### <a name="sio_set_wfp_connection_redirect_records-opcode-setting-i-t3"></a>SIO \_ Установка \_ \_ \_ записей перенаправления соединения WFP \_ (параметр кода операции: I, T = = 3)

задает для записи перенаправления новый сокет TCP, используемый для подключения к конечному месту назначения для использования службой перенаправления платформы фильтрации Windows (WFP).

[**\_ \_ \_ \_ \_ Записи перенаправления подключения суперконтроллера**](/previous-versions/windows/desktop/legacy/hh859714(v=vs.85)) ввода-вывода по протоколу ioctl используются в рамках отслеживания подключений через посредника при перенаправленных соединениях сокетов. Эта функция WFP упрощает отслеживание записей перенаправления из первоначального перенаправления соединения к конечному подключению.

Более подробные сведения см. в справочнике по [**\_ \_ \_ \_ \_ записям перенаправления подключения для набора SIO**](/previous-versions/windows/desktop/legacy/hh859714(v=vs.85)) . **Суперконтроллер ввода/вывода \_ в Windows 8, Windows Server 2012 и более поздних версий поддерживаются \_ \_ \_ \_ записи перенаправления подключений WFP** .

### <a name="sio_tcp_info-opcode-setting-i-o-t3"></a>\_Сведения TCP SIO \_ (параметр кода операции: I, O, T = = 3)

Возвращает статистику TCP для сокета. Статистика TCP предоставляется в структуре [**TCP \_ info \_ v0**](/windows/desktop/api/Mstcpip/ns-mstcpip-tcp_info_v0) .

В отличие от получения статистики TCP с помощью функции [**жетперткпконнектионестатс**](/windows/win32/api/iphlpapi/nf-iphlpapi-getpertcpconnectionestats) , получение статистики TCP с помощью этого управляющего кода не требует от пользовательского кода загрузки, хранения и фильтрации таблицы соединений TCP, а также не требует повышенных привилегий для использования.

Дополнительные сведения см. в [**статье \_ \_ о SIO TCP**](/previous-versions/windows/desktop/legacy/mt823415(v=vs.85)). **Суперконтроллер ввода/вывода \_ \_сведения TCP** поддерживаются в Windows 10, версии 1703, Windows Server 2016 и более поздних версиях.

## <a name="remarks"></a>Комментарии

Winsock ioctl определяются в нескольких файлах заголовков. В их число входят файлы заголовков *Winsock2. h*, *мсвсокк. h* и *мсткпип. h* .

в пакете Microsoft Windows Software Development Kit (SDK), выпущенном для Windows Vista и более поздних версий, организация файлов заголовков изменилась, а в файлах заголовков *Ws2def. h*, *Ws2ipdef. h* и *мсвсоккдеф. h* также определен ряд Winsock-ioctl. Файл заголовка *Ws2def. h* автоматически включается в заголовочный файл *Winsock2. h* . Файл заголовка *Ws2ipdef. h* автоматически включается в заголовочный файл *Ws2tcpip. h* . Файл заголовка *мсвсоккдеф. h* автоматически включается в заголовочный файл *мсвсоккдеф. h* .

## <a name="requirements"></a>Требования

|Требование|Значение|
|-|-|
| Заголовок<br/> | <dl> <dt>Winsock2. h;</dt> <dt>Мсткпип. h;</dt> <dt>Мсвсокк. h;</dt> <dt>мсвсоккдеф. h в Windows Vista, Windows Server 2008 и Windows 7 (включая мсвсокк. h);</dt> <dt>Ws2def. h в Windows Vista, Windows Server 2008 и Windows 7 (включая Winsock2. h);</dt> <dt>Ws2ipdef. h в Windows Vista, Windows Server 2008 и Windows 7 (включая Ws2tcpip. h)</dt> </dl> |
