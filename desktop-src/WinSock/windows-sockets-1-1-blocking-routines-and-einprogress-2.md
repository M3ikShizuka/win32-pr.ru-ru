---
description: одной из серьезных проблем при переносе приложений из среды Berkeley sockets в среду Windows является блокировка; то есть вызов функции, которая не возвращает значение до завершения связанной операции.
ms.assetid: 13aedad7-5f3b-4d73-b8e5-be3a095294bc
title: Windows Подпрограммы блокировки сокетов 1,1 и ЕИНПРОГРЕСС
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b4028549862412b80d1343851fb2a147da804095821fdefab4b6aae0eb6ec5f2
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119641224"
---
# <a name="windows-sockets-11-blocking-routines-and-einprogress"></a>Windows Подпрограммы блокировки сокетов 1,1 и ЕИНПРОГРЕСС

одной из серьезных проблем при переносе приложений из среды Berkeley sockets в среду Windows является блокировка; то есть вызов функции, которая не возвращает значение до завершения связанной операции. Проблема возникает, когда операция требует произвольного времени для выполнения. пример представляет собой функцию [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) , которая может блокироваться до получения данных от одноранговой системы. Поведение по умолчанию в модели BIND-сокетов заключается в том, что сокет должен работать в блокирующем режиме, если программист явно не запрашивает, что операции обрабатываются как неблокирующие. Windows В средах с сокетами 1,1 не может рассчитывать на приоритетное планирование. поэтому настоятельно рекомендуется, чтобы программисты использовали неблокируемые (асинхронные) операции, если это возможно с Windows сокетами 1,1. Так как это было не всегда возможно, были предоставлены средства псевдо-блокировки, описанные ниже.

> [!Note]  
> Windows Сокеты 2 работают только в вытеснениях 32-разрядных операционных системах, в которых взаимоблокировки не являются проблемой. рекомендации по программированию для сокетов Windows 1,1 не требуются в сокетах Windows 2.

 

Даже на блокирующем сокете некоторые функции, например [**BIND**](/windows/desktop/api/winsock/nf-winsock-bind), [**жетсоккопт**](/windows/desktop/api/winsock/nf-winsock-getsockopt)и [**жетпирнаме**](/windows/desktop/api/winsock/nf-winsock-getpeername) , выполняются немедленно. Нет никакой разницы между блокировкой и неблокирующей операцией для этих функций. Другие операции, такие как [**recv**](/windows/desktop/api/winsock/nf-winsock-recv), могут завершиться немедленно или выполнить произвольное время, в зависимости от различных условий транспорта. При применении к блокирующему сокету эти операции называются операциями блокировки. Следующие функции могут блокироваться:

-   [**полученных**](/windows/desktop/api/winsock/nf-winsock-recv)
-   [**реквфром**](/windows/desktop/api/winsock/nf-winsock-recvfrom)
-   [**Отправить**](/windows/desktop/api/Winsock2/nf-winsock2-send)
-   [**cервера**](/windows/desktop/api/winsock/nf-winsock-sendto)

с 16-разрядными Windows сокетами 1,1, операция блокирования, которая не может быть завершена немедленно, обрабатывается с помощью псевдо-блокировки следующим образом.

поставщик услуг инициирует операцию, затем вводит цикл, в котором он отправляет все Windows сообщения (при необходимости передавая процессор другому потоку), а затем проверяет завершение функции Windowsных сокетов. Если функция завершена или при вызове [**всаканцелблоккингкалл**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) , функция блокировки завершается с соответствующим результатом.

Поставщик услуг должен разрешить установку блокирующего ловушки, которая не обрабатывает сообщения, чтобы избежать возможности повторного входа в систему во время выполнения блокирующей операции. Простейшая функция блокирующего ловушки возвратит **значение false**. если библиотека DLL Windows sockets зависит от сообщений для внутренней операции, она может выполнить **PeekMessage**(**хмивнд**...) перед выполнением ловушки блокировки приложения, чтобы он мог получать свои сообщения, не влияя на остальную часть системы.

в 16-разрядной среде Windows сокетах 1,1, если получено Windows сообщение для процесса, для которого выполняется операция блокировки, существует риск, что приложение попытается выполнить другой вызов Windows сокетов. из-за трудностей в безопасном управлении этим состоянием Windows сокеты 1,1 не поддерживают такое поведение приложения. приложению запрещено выполнять больше одного вложенного вызова функции Windows сокетов. Для конкретной задачи допускается только один невыполненный вызов функции. Единственными исключениями являются две функции, которые помогают программисту в такой ситуации: [**всаисблоккинг**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) и [**всаканцелблоккингкалл**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall).

функция [**всаисблоккинг**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) может быть вызвана в любое время, чтобы определить, выполняется ли блокировка Windows сокеты 1,1. Аналогичным образом функцию [**всаканцелблоккингкалл**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) можно вызвать в любое время, чтобы отменить выполняющийся блокирующий вызов. любой другой вложенность функций Windows сокетов завершается сбоем с ошибкой всаеинпрогресс.

Следует подчеркнуть, что это ограничение применяется как к блокирующей, так и к неблокирующей операциям. для приложений Windows sockets 2, которые согласовывают версию 2,0 или более позднюю во время вызова [**сбой wsastartup**](/windows/desktop/api/winsock/nf-winsock-wsastartup), никаких ограничений на вложение операций не выполняется. операции могут быть вложенными в редкие обстоятельства, например во время обратного вызова условного приема [**всаакцепт**](/windows/desktop/api/Winsock2/nf-winsock2-wsaaccept) , или если поставщик услуг в свою очередь вызывает функцию Windows sockets 2.

Хотя этот механизм достаточно для простых приложений, он не поддерживает сложные требования к диспетчеризации сообщений для более сложных приложений (например, с помощью модели MDI). для таких приложений API Windows sockets включает функцию [**всасетблоккингхук**](/windows/desktop/api/winsock2/nf-winsock2-wsasetblockinghook), которая позволяет приложению указать специальную подпрограмму, которую можно вызвать вместо подпрограммы диспетчеризации сообщений по умолчанию, описанной в предыдущем обсуждении.

поставщик сокетов Windows вызывает блокирующий ловушку только в том случае, если выполняются все перечисленные ниже условия.

-   Подпрограммы — это одна из них, которая определяется как возможность блокировки.
-   Указанный сокет является блокирующим сокетом.
-   Запрос не может быть выполнен немедленно.

По умолчанию для сокета задано блокирование, но функция [**иоктлсоккет**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) с функцией **Фионбио** ioctl или [**всаасинкселект**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) может установить сокет в неблокирующий режим.

Ловушка блокировки никогда не вызывается, и приложению не нужно беспокоиться о проблемах повторного входа, которые могут возникнуть в блокирующем ловушке, если приложение соответствует следующим рекомендациям:

-   Он использует только неблокируемые сокеты.
-   В нем используются подпрограммы [**всаасинкселект**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) и/или **всаасинкжетксбии** вместо [**SELECT**](/windows/desktop/api/Winsock2/nf-winsock2-select) и подпрограмм **жетксбии** .

если приложение Windows sockets 1,1 вызывает асинхронную или неблочную операцию, которая принимает указатель на объект памяти (например, буфер или глобальную переменную) в качестве аргумента, то ответственность за то, что объект доступен для Windows сокетов во всей операции, несет приложение. приложение не должно вызывать функцию Windows, которая может повлиять на сопоставление или влияние на жизнеспособность используемой памяти.

 

 



