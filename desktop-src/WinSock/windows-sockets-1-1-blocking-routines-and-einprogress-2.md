---
description: Одной из серьезных проблем при переносе приложений из среды Berkeley Sockets в среду Windows является блокировка. то есть вызов функции, которая не возвращает значение до завершения связанной операции.
ms.assetid: 13aedad7-5f3b-4d73-b8e5-be3a095294bc
title: Подпрограммы блокировки Windows Sockets 1,1 и ЕИНПРОГРЕСС
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1ea6d45b4d25578505a3cb4ab4beb7c2c2fe90e4
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "105711380"
---
# <a name="windows-sockets-11-blocking-routines-and-einprogress"></a>Подпрограммы блокировки Windows Sockets 1,1 и ЕИНПРОГРЕСС

Одной из серьезных проблем при переносе приложений из среды Berkeley Sockets в среду Windows является блокировка. то есть вызов функции, которая не возвращает значение до завершения связанной операции. Проблема возникает, когда операция требует произвольного времени для выполнения. пример представляет собой функцию [**recv**](/windows/desktop/api/winsock/nf-winsock-recv) , которая может блокироваться до получения данных от одноранговой системы. Поведение по умолчанию в модели BIND-сокетов заключается в том, что сокет должен работать в блокирующем режиме, если программист явно не запрашивает, что операции обрабатываются как неблокирующие. Среды Windows Sockets 1,1 не могут предположить приоритетное планирование. Поэтому настоятельно рекомендуется, чтобы программисты использовали неблокируемые (асинхронные) операции, если это возможно с сокетами Windows 1,1. Так как это было не всегда возможно, были предоставлены средства псевдо-блокировки, описанные ниже.

> [!Note]  
> Сокеты Windows 2 работают только в вытеснениях 32-разрядных операционных системах, в которых взаимоблокировки не являются проблемой. Рекомендации по программированию для сокетов Windows 1,1 не требуются в сокетах Windows 2.

 

Даже на блокирующем сокете некоторые функции, например [**BIND**](/windows/desktop/api/winsock/nf-winsock-bind), [**жетсоккопт**](/windows/desktop/api/winsock/nf-winsock-getsockopt)и [**жетпирнаме**](/windows/desktop/api/winsock/nf-winsock-getpeername) , выполняются немедленно. Нет никакой разницы между блокировкой и неблокирующей операцией для этих функций. Другие операции, такие как [**recv**](/windows/desktop/api/winsock/nf-winsock-recv), могут завершиться немедленно или выполнить произвольное время, в зависимости от различных условий транспорта. При применении к блокирующему сокету эти операции называются операциями блокировки. Следующие функции могут блокироваться:

-   [**полученных**](/windows/desktop/api/winsock/nf-winsock-recv)
-   [**реквфром**](/windows/desktop/api/winsock/nf-winsock-recvfrom)
-   [**Отправить**](/windows/desktop/api/Winsock2/nf-winsock2-send)
-   [**cервера**](/windows/desktop/api/winsock/nf-winsock-sendto)

При использовании 16-разрядных сокетов Windows 1,1 операция блокирования, которая не может быть завершена немедленно, обрабатывается с помощью псевдо-блокировки следующим образом.

Поставщик услуг инициирует операцию, затем вводит цикл, в котором он отправляет все сообщения Windows (при необходимости передавая процессор другому потоку), а затем проверяет завершение функции сокетов Windows. Если функция завершена или при вызове [**всаканцелблоккингкалл**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) , функция блокировки завершается с соответствующим результатом.

Поставщик услуг должен разрешить установку блокирующего ловушки, которая не обрабатывает сообщения, чтобы избежать возможности повторного входа в систему во время выполнения блокирующей операции. Простейшая функция блокирующего ловушки возвратит **значение false**. Если библиотека DLL Windows Sockets зависит от сообщений для внутренней операции, она может выполнить **PeekMessage**(**хмивнд**...) перед выполнением ловушки блокировки приложения, чтобы он мог получать свои сообщения, не влияя на остальную часть системы.

В 16-разрядной среде Windows Sockets 1,1, если получено сообщение Windows для процесса, для которого выполняется операция блокировки, существует риск, что приложение попытается выдать другой вызов сокетов Windows. Из-за трудностей в безопасном управлении этим состоянием Windows Sockets 1,1 не поддерживает такое поведение приложения. Приложению не разрешено выполнять несколько вложенных вызовов функций сокетов Windows. Для конкретной задачи допускается только один невыполненный вызов функции. Единственными исключениями являются две функции, которые помогают программисту в такой ситуации: [**всаисблоккинг**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) и [**всаканцелблоккингкалл**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall).

Функцию [**всаисблоккинг**](/windows/desktop/api/winsock2/nf-winsock2-wsaisblocking) можно вызвать в любое время, чтобы определить, выполняется ли блокирующий вызов сокетов Windows 1,1. Аналогичным образом функцию [**всаканцелблоккингкалл**](/windows/desktop/api/winsock2/nf-winsock2-wsacancelblockingcall) можно вызвать в любое время, чтобы отменить выполняющийся блокирующий вызов. Любое другое вложение функций сокетов Windows завершается сбоем с ошибкой ВСАЕИНПРОГРЕСС.

Следует подчеркнуть, что это ограничение применяется как к блокирующей, так и к неблокирующей операциям. Для приложений Windows Sockets 2, которые согласовывают версию 2,0 или более позднюю во время вызова [**сбой WSAStartup**](/windows/desktop/api/winsock/nf-winsock-wsastartup), никаких ограничений на вложение операций не выполняется. Операции могут быть вложенными в редкие обстоятельства, например во время обратного вызова условного приема [**всаакцепт**](/windows/desktop/api/Winsock2/nf-winsock2-wsaaccept) , или если поставщик услуг в свою очередь вызывает функцию Windows Sockets 2.

Хотя этот механизм достаточно для простых приложений, он не поддерживает сложные требования к диспетчеризации сообщений для более сложных приложений (например, с помощью модели MDI). Для таких приложений API сокетов Windows включает функцию [**всасетблоккингхук**](/windows/desktop/api/winsock2/nf-winsock2-wsasetblockinghook), которая позволяет приложению указать специальную подпрограмму, которую можно вызвать вместо подпрограммы диспетчеризации сообщений по умолчанию, описанной в предыдущем обсуждении.

Поставщик сокетов Windows вызывает блокирующий ловушку только в том случае, если выполняются все перечисленные ниже условия.

-   Подпрограммы — это одна из них, которая определяется как возможность блокировки.
-   Указанный сокет является блокирующим сокетом.
-   Запрос не может быть выполнен немедленно.

По умолчанию для сокета задано блокирование, но функция [**иоктлсоккет**](/windows/desktop/api/winsock/nf-winsock-ioctlsocket) с функцией **Фионбио** ioctl или [**всаасинкселект**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) может установить сокет в неблокирующий режим.

Ловушка блокировки никогда не вызывается, и приложению не нужно беспокоиться о проблемах повторного входа, которые могут возникнуть в блокирующем ловушке, если приложение соответствует следующим рекомендациям:

-   Он использует только неблокируемые сокеты.
-   В нем используются подпрограммы [**всаасинкселект**](/windows/desktop/api/winsock/nf-winsock-wsaasyncselect) и/или **всаасинкжетксбии** вместо [**SELECT**](/windows/desktop/api/Winsock2/nf-winsock2-select) и подпрограмм **жетксбии** .

Если приложение Windows Sockets 1,1 вызывает асинхронную или неблочную операцию, которая принимает указатель на объект памяти (например, в буфер или глобальную переменную) в качестве аргумента, то ответственность за то, что объект будет доступен для сокетов Windows в ходе операции, несет приложение. Приложение не должно вызывать функции Windows, которые могут повлиять на сопоставление или устранить жизнеспособность задействованной памяти.

 

 



