---
description: '\_Параметр ексклусивеаддрусе Socket предотвращает принудительное привязку других сокетов к тому же адресу и порту.'
ms.assetid: ce0d8188-54be-46e8-8753-d0680f690b84
title: Параметр SO_EXCLUSIVEADDRUSE Socket (Winsock2. h)
ms.topic: reference
ms.date: 05/31/2018
ms.openlocfilehash: de9d7b00cc2fcd01fc9d440ce2ef889a9e1be937d5d83af90cfa71bf6f83d14c
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "117927346"
---
# <a name="so_exclusiveaddruse-socket-option"></a>SO, \_ параметр ексклусивеаддрусе Socket

\_Параметр ексклусивеаддрусе Socket предотвращает принудительное привязку других сокетов к тому же адресу и порту.

## <a name="syntax"></a>Синтаксис

Параметр SO \_ ексклусивеаддрусе предотвращает принудительное связывание других сокетов с одним и тем же адресом и портом. практика, включенная с помощью \_ параметра so реусеаддр Socket. Такое повторное использование может быть выполнено вредоносными приложениями для нарушения работы приложения. \_Параметр ексклусивеаддрусе очень удобен для системных служб, которым требуется высокий уровень доступности.

В следующем примере кода показана установка этого параметра.


```C++
#ifndef UNICODE
#define UNICODE
#endif

#ifndef WIN32_LEAN_AND_MEAN
#define WIN32_LEAN_AND_MEAN
#endif

#include <windows.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdio.h>
#include <stdlib.h>             // Needed for _wtoi

#pragma comment(lib, "Ws2_32.lib")

int __cdecl wmain(int argc, wchar_t ** argv)
{
    WSADATA wsaData;
    int iResult = 0;
    int iError = 0;

    SOCKET s = INVALID_SOCKET;
    SOCKADDR_IN saLocal;
    int iOptval = 0;

    int iFamily = AF_UNSPEC;
    int iType = 0;
    int iProtocol = 0;

    int iPort = 0;

    // Validate the parameters
    if (argc != 5) {
        wprintf(L"usage: %ws <addressfamily> <type> <protocol> <port>\n", argv[0]);
        wprintf(L"    opens a socket for the specified family, type, & protocol\n");
        wprintf(L"    sets the SO_EXCLUSIVEADDRUSE socket option on the socket\n");
        wprintf(L"    then tries to bind the port specified on the command-line\n");
        wprintf(L"%ws example usage\n", argv[0]);
        wprintf(L"   %ws 0 2 17 5150\n", argv[0]);
        wprintf(L"   where AF_UNSPEC=0 SOCK_DGRAM=2 IPPROTO_UDP=17  PORT=5150\n",
                argv[0]);
        wprintf(L"   %ws 2 1 17 5150\n", argv[0]);
        wprintf(L"   where AF_INET=2 SOCK_STREAM=1 IPPROTO_TCP=6  PORT=5150\n", argv[0]);
        wprintf(L"   See the documentation for the socket function for other values\n");
        return 1;
    }

    iFamily = _wtoi(argv[1]);
    iType = _wtoi(argv[2]);
    iProtocol = _wtoi(argv[3]);

    iPort = _wtoi(argv[4]);

    if (iFamily != AF_INET && iFamily != AF_INET6) {
        wprintf(L"Address family must be either AF_INET (2) or AF_INET6 (23)\n");
        return 1;
    }

    if (iPort <= 0 || iPort >= 65535) {
        wprintf(L"Port specified must be greater than 0 and less than 65535\n");
        return 1;
    }
    // Initialize Winsock
    iResult = WSAStartup(MAKEWORD(2, 2), &wsaData);
    if (iResult != 0) {
        wprintf(L"WSAStartup failed with error: %d\n", iResult);
        return 1;
    }
    // Create the socket
    s = socket(iFamily, iType, iProtocol);
    if (s == INVALID_SOCKET) {
        wprintf(L"socket failed with error: %ld\n", WSAGetLastError());
        WSACleanup();
        return 1;
    }
    // Set the exclusive address option
    iOptval = 1;
    iResult = setsockopt(s, SOL_SOCKET, SO_EXCLUSIVEADDRUSE,
                         (char *) &iOptval, sizeof (iOptval));
    if (iResult == SOCKET_ERROR) {
        wprintf(L"setsockopt for SO_EXCLUSIVEADDRUSE failed with error: %ld\n",
                WSAGetLastError());
    }

    saLocal.sin_family = (ADDRESS_FAMILY) iFamily;
    saLocal.sin_port = htons( (u_short) iPort);
    saLocal.sin_addr.s_addr = htonl(INADDR_ANY);

    // Bind the socket
    iResult = bind(s, (SOCKADDR *) & saLocal, sizeof (saLocal));
    if (iResult == SOCKET_ERROR) {

        // Most errors related to setting SO_EXCLUSIVEADDRUSE
        //    will occur at bind.
        iError = WSAGetLastError();
        if (iError == WSAEACCES)
            wprintf(L"bind failed with WSAEACCES (access denied)\n");
        else
            wprintf(L"bind failed with error: %ld\n", iError);

    } else {
        wprintf(L"bind on socket with SO_EXCLUSIVEADDRUSE succeeded to port: %ld\n",
                iPort);
    }

    // cleanup
    closesocket(s);
    WSACleanup();

    return 0;
}

```



Чтобы обеспечить любой результат, \_ перед вызовом функции [**BIND**](/windows/desktop/api/winsock/nf-winsock-bind) необходимо задать параметр so ексклусиваддрусе (это также относится к \_ параметру so реусеаддр). В таблице 1 перечислены последствия установки \_ параметра so ексклусивеаддрусе. Подстановочный знак указывает на привязку к подстановочному адресу, например 0.0.0.0 для IPv4 и:: для IPv6. Особая указывает на привязку к определенному интерфейсу, например привязку IP-адреса, назначенного адаптеру. Specific2 Указывает привязку к определенному адресу, отличному от адреса, связанного с в конкретном случае.

> [!Note]  
> Вариант Specific2 применяется только в том случае, если первая привязка выполняется с конкретным адресом. для случая, когда первый сокет привязан к подстановочному знаку, запись для конкретного охватывает все конкретные варианты адресов.

 

Например, рассмотрим компьютер с двумя интерфейсами IP: 10.0.0.1 и 10.99.99.99. Если первая привязка — 10.0.0.1 и порт 5150 с \_ установленным параметром so ексклусивеаддрусе, вторая привязка к 10.99.99.99 и port 5150 с любыми параметрами или вообще не задается. Однако если первый сокет привязан к адресу с подстановочным знаком (0.0.0.0) и порту 5150 с таким образом \_ , все последующие привязки к одному и тому же порту, независимо от IP-адреса, будут завершаться сбоем с всаеаддринусе (10048) или всаеакцесс (10013), в зависимости от того, какие параметры были заданы во втором сокете привязки.

### <a name="bind-behavior-with-various-options-set"></a>Поведение привязки с различными наборами параметров



Вторая привязка

Первая привязка

*Итак, \_ ексклусивеаддрусе*

*Нет параметров* или *поэтому \_ реусеаддр*

*Подстановочный знак*

*Зависящ*

*Подстановочный знак*

*Зависящ*

$ {ROWSPAN3} $*so \_ ексклусивеаддрусе*$ {Remove} $  

*Подстановочный знак*

Сбой (10048)

Сбой (10048)

Сбой (10048)

Сбой (10048)

*Зависящ*

Сбой (10048)

Сбой (10048)

Сбой (10048)

Сбой (10048)

*Specific2*

Недоступно

Success

Недоступно

Success

$ {ROWSPAN3} $*нет параметров*$ {Remove} $  

*Подстановочный знак*

Сбой (10048)

Сбой (10048)

Сбой (10048)

Сбой (10048)

*Зависящ*

Сбой (10048)

Сбой (10048)

Сбой (10048)

Сбой (10048)

*Specific2*

Недоступно

Success

Недоступно

Success

$ {ROWSPAN3} $*so \_ реусеаддр*$ {Remove} $  

*Подстановочный знак*

Сбой (10013)

Сбой (10013)

Успех\*

Success

*Зависящ*

Сбой (10013)

Сбой (10013)

Success

Успех\*

*Specific2*

Недоступно

Success

Недоступно

Success

\* Поведение не определено, в котором сокет будет принимать пакеты.



 

Если первая привязка задает параметр без параметров или \_ реусеаддр, а вторая привязка делает так \_ реусеаддр, то второй сокет переберет порт и поведение, относительно того, какой сокет будет принимать пакеты, не определен. Итак, \_ ексклусивеаддрусе была введена для решения этой ситуации.

Сокет с таким образом \_ ексклусивеаддрусе набор нельзя всегда использовать повторно сразу после закрытия сокета. Например, если сокет прослушивания с установленным флагом Exclusive принимает соединение, после которого закрывается Прослушивающий сокет, другой сокет не может выполнить привязку к тому же порту, что и первый Прослушивающий сокет с флагом Exclusive, пока принятое соединение больше не будет активно.

Такая ситуация может быть довольно сложной; Несмотря на то, что сокет был закрыт, базовый транспорт может не завершить свое подключение. Даже после закрытия сокета система должна отправить все буферизованные данные, передать корректное отключение к одноранговой сети и дождаться корректного отключения от однорангового узла. Поэтому возможно, что базовый транспорт никогда не освобождает подключение, например, когда одноранговый узел объявляет окно нулевого размера или другие подобные атаки. В предыдущем примере сокет прослушивания был закрыт после того, как было принято клиентское подключение. Теперь, даже если клиентское подключение закрыто, порт по-прежнему может не использоваться повторно, если подключение клиента остается в активном состоянии из-за неподтвержденных данных и т. д.

Чтобы избежать такой ситуации, приложения должны обеспечить корректное завершение работы: вызвать [**Завершение работы**](/windows/desktop/api/winsock/nf-winsock-shutdown) с \_ флагом SD Send, а затем [](/windows/desktop/api/winsock/nf-winsock-recv) дождаться цикла приема, пока не будут возвращены нулевые байты. Это позволяет избежать проблемы, связанной с повторной попыткой использования порта, гарантирует, что все данные были получены одноранговым узлом, и убедитесь, что все данные успешно получены одноранговым узлом.

Параметр SO-1 \_ может быть установлен на сокете для предотвращения перехода порта в одно из активных состояний ожидания, однако это не рекомендуется, так как может привести к нежелательным последствиям, так как это может привести к сбросу соединения. Например, если данные были получены, но еще не подтверждены одноранговым узлом, а локальный компьютер закрывает сокет с установленным параметром " \_ Ожидание", подключение сбрасывается и узел отклоняет неподтвержденные данные. Кроме того, выбор подходящего времени для задержки является сложной задачей. значение слишком мало для большого количества прерванных подключений, в то время как большое время ожидания может привести к тому, что система будет уязвима к атакам типа "отказ в обслуживании", установив множество соединений и предотвращая выполнение множества потоков приложения.

> [!Note]  
> Перед закрытием сокета, использующего \_ параметр so ексклусивеаддрусе, необходимо корректно завершить работу. Несоблюдение этого требования может привести к атаке типа "отказ в обслуживании", если связанная служба должна перезапуститься.

 

## <a name="requirements"></a>Требования



| Требование | Значение |
|-------------------------------------|---------------------------------------------------------------------------------------|
| Минимальная версия клиента<br/> | Windows 2000 Professional \[только классические приложения\]<br/>                            |
| Минимальная версия сервера<br/> | Windows 2000 Server \[только классические приложения\]<br/>                                  |
| Заголовок<br/>                   | <dl> <dt>Winsock2. h</dt> </dl> |



 

 




