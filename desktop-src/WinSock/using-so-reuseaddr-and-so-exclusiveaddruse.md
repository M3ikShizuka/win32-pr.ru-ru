---
description: Разработка безопасной высокоуровневой сетевой инфраструктуры — это приоритет большинства разработчиков сетевых приложений. Однако при рассмотрении полностью безопасных решений безопасность сокетов часто оказывается слишком важной.
ms.assetid: b37a3e33-65ee-43b1-bc8b-3280db7ebee4
title: Использование SO_REUSEADDR и SO_EXCLUSIVEADDRUSE
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: aaa4024f031102cbd634c235bb39f4c7860e6c1d
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "103814353"
---
# <a name="using-so_reuseaddr-and-so_exclusiveaddruse"></a>Использование \_ реусеаддр и так далее \_ ексклусивеаддрусе

Разработка безопасной высокоуровневой сетевой инфраструктуры — это приоритет большинства разработчиков сетевых приложений. Однако при рассмотрении полностью безопасных решений безопасность сокетов часто оказывается слишком важной. Безопасность сокетов, в частности, связана с процессами, которые привязаны к тому же порту, который ранее был связан с другим процессом приложения. В прошлом было возможно, что сетевое приложение "перехватывает" порт другого приложения, что может привести к атаке типа "отказ в обслуживании" или краже данных.

Как правило, безопасность сокетов применяется к процессам на стороне сервера. В частности, безопасность сокетов применяется к любому сетевому приложению, которое принимает подключения и получает IP-трафик датаграмм. Обычно эти приложения привязаны к хорошо известному порту и являются общими целями для вредоносного сетевого кода.

Клиентские приложения менее вероятно являются целями таких атак — не так как они менее уязвимы, но так как большинство клиентов привязаны к временным локальным портам, а не к статическим портам службы. Клиентские сетевые приложения всегда должны выполнять привязку к временным портам (указав порт 0 в структуре [**SOCKADDR**](sockaddr-2.md) , на которую указывает параметр *Name* при вызове функции [**BIND**](/windows/win32/api/winsock/nf-winsock-bind) ), если не существует привлекательной архитектуры. Временные локальные порты состоят из портов, превышающих порт 49151. Большинство серверных приложений для выделенных служб привязаны к широко известному зарезервированному порту, который меньше или равен порту 49151. Таким образом, для большинства приложений обычно возникает конфликт запросов привязки между клиентскими и серверными приложениями.

В этом разделе описывается уровень безопасности по умолчанию на различных платформах Microsoft Windows, а также сведения о том, как определенные параметры сокета **\_ Реусеаддр** и [поэтому \_ ексклусивеаддрусе](so-exclusiveaddruse.md) влияют на безопасность сетевых приложений. В Windows Server 2003 и более поздних версиях доступна дополнительная функция, называемая расширенной безопасностью сокетов. Доступность этих параметров сокетов и улучшенной безопасности сокетов различается в разных версиях операционных систем Майкрософт, как показано в таблице ниже.

| Платформа            | Итак, \_ реусеаддр | Итак, \_ ексклусивеаддрусе                  | Повышенная безопасность сокетов |
|---------------------|---------------|---------------------------------------|--------------------------|
| Windows 95          | Доступно     | Недоступно                         | Недоступно            |
| Windows 98          | Доступно     | Недоступно                         | Недоступно            |
| Windows Me          | Доступно     | Недоступно                         | Недоступно            |
| Windows NT 4.0      | Доступно     | Доступно в пакете обновления 4 и более поздних версий | Недоступно            |
| Windows 2000        | Доступно     | Доступно                             | Недоступно            |
| Windows XP          | Доступно     | Доступно                             | Недоступно            |
| Windows Server 2003 | Доступно     | Доступно                             | Доступно                |
| Windows Vista       | Доступно     | Доступно                             | Доступно                |
| Windows Server 2008 | Доступно     | Доступно                             | Доступно                |
| Windows 7and более поздней версии  | Доступно     | Доступно                             | Доступно                |

## <a name="using-so_reuseaddr"></a>Использование \_ реусеаддр

Этот **параметр \_ позволяет сокету** принудительно выполнять привязку к порту, используемому другим сокетом. Второй сокет вызывает [**сетсоккопт**](/windows/win32/api/winsock/nf-winsock-setsockopt) с параметром *optname* , для которого задано значение **\_ реусеаддр** , а параметр *оптвал* — логическим значением **true** перед вызовом [**BIND**](/windows/win32/api/winsock/nf-winsock-bind) на том же порту, что и Исходный сокет. После успешной привязки второго сокета поведение всех сокетов, привязанных к этому порту, является неопределенным. Например, если все сокеты на том же порте предоставляют службу TCP, то любые входящие запросы TCP-соединений через порт не могут быть гарантированно обработаны правильным сокетом — поведение не детерминировано. Вредоносная программа может использовать **\_ реусеаддр,** чтобы принудительно использовать сокеты BIND, уже используемые для стандартных сетевых протоколов, чтобы запретить доступ к этим службам. Для использования этого параметра специальные привилегии не требуются.

Если клиентское приложение привязывается к порту до того, как серверное приложение сможет выполнить привязку к тому же порту, могут возникнуть проблемы. Если серверное приложение принудительно привязывается к тому же порту с помощью параметра **so \_ реусеаддр** , то поведение всех сокетов, привязанных к этому порту, не определено.

Исключением из этого недетерминированного поведения являются сокеты многоадресной рассылки. Если два сокета привязаны к одному интерфейсу и порту и являются членами одной группы многоадресной рассылки, данные будут доставляться обоим сокетам, а не произвольно выбранному.

## <a name="using-so_exclusiveaddruse"></a>Использование \_ ексклусивеаддрусе

До появления параметра **\_ ексклусивеаддрусе** Socket существовало очень мало разработчиков сетевых приложений, чтобы предотвратить привязку вредоносной программы к порту, на котором в сетевом приложении привязываются собственные сокеты. Для решения этой проблемы безопасности сокеты Windows предоставили вариант **\_ ексклусивеаддрусе** Socket, который стал доступен в Windows NT 4,0 с пакетом обновления 4 (SP4) и более поздних версий.

Параметр **\_ ексклусивеаддрусе** Socket может использоваться только членами группы безопасности «Администраторы» в Windows XP и более ранних версиях. Причины, по которым это требование было изменено в Windows Server 2003 и более поздних версиях, обсуждаются далее в этой статье.

Этот **параметр \_ ексклусивеаддрусе** устанавливается путем вызова функции [**сетсоккопт**](/windows/win32/api/winsock/nf-winsock-setsockopt) с параметром *optname* , для которого задано **значение \_ ексклусивеаддрусе** , а параметр *оптвал* — логическим значением **true** перед привязкой к сокету. После установки параметра поведение последующих вызовов [**BIND**](/windows/win32/api/winsock/nf-winsock-bind) различается в зависимости от сетевого адреса, указанного в каждом вызове **привязки** .

В следующей таблице описывается поведение, которое происходит в Windows XP и более ранних версиях, когда второй сокет пытается выполнить привязку к адресу, ранее привязанному к первому сокету, используя определенные параметры сокета.

> [!NOTE]  
> В таблице ниже "подстановочный знак" обозначает адрес с подстановочными знаками для данного протокола (например, "0.0.0.0" для IPv4 и "::" для IPv6). "Конкретное" обозначает конкретный IP-адрес, назначенный интерфейсу. Ячейки таблицы указывают, является ли привязка успешной ("Success"), или возвращается ошибка ("INUSE" для ошибки [всаеаддринусе](windows-sockets-error-codes-2.md) ; "Доступ" для ошибки [всаеакцес](windows-sockets-error-codes-2.md) ).

<table>
    <tr>
        <td bgcolor="#C0C0C0" colspan="2" rowspan="3">Первый вызов <a href="/windows/win32/api/winsock/nf-winsock-bind"><strong>привязки</strong></a></td>
        <td bgcolor="#C0C0C0" colspan="6">Второй вызов <a href="/windows/win32/api/winsock/nf-winsock-bind"><strong>BIND</strong></a></td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0" colspan="2">Значение по умолчанию</td>
        <td bgcolor="#C0C0C0" colspan="2">SO_REUSEADDR</td>
        <td bgcolor="#C0C0C0" colspan="2">SO_EXCLUSIVEADDRUSE</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td bgcolor="#C0C0C0">Specific</td>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td bgcolor="#C0C0C0">Specific</td>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td bgcolor="#C0C0C0">Specific</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0" rowspan="2">Значение по умолчанию</td>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>Успех</td>
        <td>Успех</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0">Specific</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>Успех</td>
        <td>Успех</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0" rowspan="2">SO_REUSEADDR</td>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>Успех</td>
        <td>Успех</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0">Specific</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>Успех</td>
        <td>Успех</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0" rowspan="2">SO_EXCLUSIVEADDRUSE</td>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ACCESS;</td>
        <td>ACCESS;</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0">Specific</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ACCESS;</td>
        <td>ACCESS;</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
    </tr>
</table>

Если два сокета привязаны к одному и тому же номеру порта, но в разных явных интерфейсах, конфликт не возникает. Например, если у компьютера есть два IP-интерфейса, 10.0.0.1 и 10.99.99.99, если первый вызов [**BIND**](/windows/win32/api/winsock/nf-winsock-bind) находится на 10.0.0.1 с портом 5150, и **поэтому указан \_ ексклусивеаддрусе** , то второй вызов для **привязки** 10.99.99.99 с портом также имеет значение 5150, и никакие параметры не указаны успешно. Однако если первый сокет привязан к адресу-шаблону и порту 5150, то любой последовательный вызов привязки к порту 5150 с **таким образом \_ ексклусивеаддрусе** закончится ошибкой с [всаеаддринусе](windows-sockets-error-codes-2.md) или [всаеакцес](windows-sockets-error-codes-2.md) , возвращенными операцией **привязки** .

В случае, когда первый вызов [**привязывает**](/windows/win32/api/winsock/nf-winsock-bind) наборы **таким образом, что \_ реусеаддр** или вообще не имеет параметров сокета, второй вызов **BIND** перехватывает порт, и приложение не сможет определить, какой из двух сокетов получил определенные пакеты, отправляемые на общий порт.

Типичное приложение, вызывающее функцию [**BIND**](/windows/win32/api/winsock/nf-winsock-bind) , не выделяет привязанный сокет для монопольного использования, если только для сокета не был вызван параметр **\_ ексклусивеаддрусе** Socket до вызова функции **BIND** . Если клиентское приложение привязывается к временному порту или определенному порту до того, как серверное приложение привязывается к тому же порту, то могут возникнуть проблемы. Серверное приложение может принудительно выполнить привязку к тому же порту с помощью параметра **\_ реусеаддр** Socket на сокете перед вызовом функции **BIND** , но поведение всех сокетов, привязанных к этому порту, затем не определено. Если серверное приложение пытается использовать параметр **\_ ексклусивеаддрусе** Socket для монопольного использования порта, запрос завершится ошибкой.

И наоборот, сокет с **таким образом \_ ексклусивеаддрусе** не может быть повторно использован сразу после закрытия сокета. Например, если сокет прослушивания с таким же набором **\_ ексклусивеаддрусе** принимает соединение и затем закрывается, другой сокет (также с **таким \_ ексклусивеаддрусе**) не может выполнить привязку к тому же порту, что и первый сокет, пока исходное соединение не станет неактивным.

Эта проблема может стать сложной, поскольку базовый транспортный протокол может не прерывать соединение, даже если сокет был закрыт. Даже после закрытия сокета приложением система должна передать все буферизованные данные, отправить корректное сообщение об отключении на одноранговый узел и дождаться соответствующего корректного сообщения об отключении от однорангового узла. Возможно, базовый транспортный протокол не может освободить подключение. Например, одноранговый узел, участвующий в исходном соединении, может объявить окно нулевого размера или другую форму "атаки". В этом случае клиентское соединение остается в активном состоянии, несмотря на запрос на его закрытие, так как неподтвержденные данные остаются в буфере.

Чтобы избежать такой ситуации, сетевые приложения должны обеспечить корректное завершение работы, вызывая [**Завершение работы**](/windows/win32/api/winsock/nf-winsock-shutdown) с \_ установленным флагом SD Send, а [](/windows/win32/api/winsock/nf-winsock-recv) затем дожидаться цикла приема, пока для соединения не будут возвращены нулевые байты. Это гарантирует, что все данные поступают одноранговым узлом, а также подтверждает, что узел получил все переданные сведения и не позволяет устранить упомянутую выше ошибку повторного использования портов.

Параметр SO- \_ Socket сокета может быть установлен на сокете, чтобы запретить переход порта в активное состояние ожидания, однако это не рекомендуется, так как может привести к желаемым эффектам, таким как Сброс подключений. Например, если данные получены одноранговым узлом, но остаются неподтвержденными, а локальный компьютер закрывает сокет с \_ установленным для него устаревшим значением, подключение между двумя компьютерами сбрасывается, а неподтвержденные данные отклоняются одноранговым узлом. Выбор подходящего времени для использования в случае небольшого значения времени ожидания часто приводит к внезапному прерыванию подключений, в то время как большие значения времени ожидания приводят к тому, что система подвержена атакам типа "отказ в обслуживании" (путем установления большого количества подключений и потенциального зависания или блокировки потоков приложений). Закрытие сокета, имеющего ненулевое значение времени ожидания, может также привести к блокировке вызова [**функции closesocket**](/windows/win32/api/winsock/nf-winsock-closesocket) .

## <a name="enhanced-socket-security"></a>Повышенная безопасность сокетов

Улучшенная безопасность сокетов была добавлена в выпуске Windows Server 2003. В предыдущих выпусках серверных операционных систем Майкрософт безопасность сокетов по умолчанию позволяла легко перехватывать порты из неподозрительных приложений. В Windows Server 2003 сокеты по умолчанию не находятся в состоянии, доступном для совместного подключения. Таким образом, если приложение хочет разрешить другим процессам повторно использовать порт, к которому уже привязан сокет, он должен быть специально включен. В этом случае первый сокет, вызывающий [**привязку**](/windows/win32/api/winsock/nf-winsock-bind) к порту, должен иметь **\_ реусеаддр,** установленный на сокете. Единственное исключение из этого случая возникает, когда второй вызов **привязки** выполняется той же учетной записью пользователя, которая выполнила исходный вызов для **привязки**. Это исключение существует исключительно для обеспечения обратной совместимости.

В следующей таблице описывается поведение, возникающее в операционных системах Windows Server 2003 и более поздних версиях, когда второй сокет пытается выполнить привязку к адресу, ранее привязанному к первому сокету, используя определенные параметры сокета.

> [!NOTE]
> В таблице ниже "подстановочный знак" обозначает адрес с подстановочными знаками для данного протокола (например, "0.0.0.0" для IPv4 и "::" для IPv6). "Конкретное" обозначает конкретный IP-адрес, назначенный интерфейсу. Ячейки таблицы указывают, успешно ли выполнена привязка ("Success") или возвращена ошибка ("INUSE" для ошибки [всаеаддринусе](windows-sockets-error-codes-2.md) ; "Доступ" для ошибки [всаеакцес](windows-sockets-error-codes-2.md) ).
>
> Также обратите внимание, что в этой конкретной таблице оба вызова [**BIND**](/windows/win32/api/winsock/nf-winsock-bind) выполняются под одной и той же учетной записью пользователя.

<table>
    <tr>
        <td bgcolor="#C0C0C0" colspan="2" rowspan="3">Первый вызов <a href="/windows/win32/api/winsock/nf-winsock-bind"><strong>привязки</strong></a></td>
        <td bgcolor="#C0C0C0" colspan="6">Второй вызов <a href="/windows/win32/api/winsock/nf-winsock-bind"><strong>BIND</strong></a></td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0" colspan="2">Значение по умолчанию</td>
        <td bgcolor="#C0C0C0" colspan="2">SO_REUSEADDR</td>
        <td bgcolor="#C0C0C0" colspan="2">SO_EXCLUSIVEADDRUSE</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td bgcolor="#C0C0C0">Specific</td>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td bgcolor="#C0C0C0">Specific</td>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td bgcolor="#C0C0C0">Specific</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0" rowspan="2">Значение по умолчанию</td>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>Успешно</td>
        <td>ACCESS;</td>
        <td>Успешно</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>Успешно</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0">Specific</td>
        <td>Успешно</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>Успешно</td>
        <td>ACCESS;</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0" rowspan="2">SO_REUSEADDR</td>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>Успех</td>
        <td>Успех</td>
        <td>Успех</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>Успешно</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0">Specific</td>
        <td>Успешно</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>Успех</td>
        <td>Успех</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0" rowspan="2">SO_EXCLUSIVEADDRUSE</td>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ACCESS;</td>
        <td>ACCESS;</td>
        <td>ACCESS;</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ACCESS;</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0">Specific</td>
        <td>Успешно</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>Успешно</td>
        <td>ACCESS;</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
    </tr>
</table>

Несколько записей в таблице выше.

Например, если первый вызывающий объект задает **\_ ексклусивеаддрусе** для определенного адреса, а второй вызывающий объект пытается вызвать [**BIND**](/windows/win32/api/winsock/nf-winsock-bind) с адресом-шаблоном в том же порте, второй вызов **BIND** будет выполнен. В этом конкретном случае второй вызывающий объект привязывается ко всем интерфейсам, кроме определенного адреса, к которому привязан первый вызывающий объект. Обратите внимание, что обратный в данном случае не имеет значения true: Если первый вызывающий метод устанавливает **так, что \_ ексклусивеаддрусе** и вызывает **BIND** с флагом-шаблоном, второй вызывающий объект не может вызвать **BIND** с тем же портом.

Поведение привязки сокета изменяется, когда вызовы привязок сокета выполняются под разными учетными записями пользователей. В таблице ниже указывается поведение, которое происходит в операционных системах Windows Server 2003 и более поздних версиях, когда второй сокет пытается выполнить привязку к адресу, ранее привязанному к первому сокету, используя определенные параметры сокета и другую учетную запись пользователя.

<table>
    <tr>
        <td bgcolor="#C0C0C0" colspan="2" rowspan="3">Первый вызов <a href="/windows/win32/api/winsock/nf-winsock-bind"><strong>привязки</strong></a></td>
        <td bgcolor="#C0C0C0" colspan="6">Второй вызов <a href="/windows/win32/api/winsock/nf-winsock-bind"><strong>BIND</strong></a></td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0" colspan="2">Значение по умолчанию</td>
        <td bgcolor="#C0C0C0" colspan="2">SO_REUSEADDR</td>
        <td bgcolor="#C0C0C0" colspan="2">SO_EXCLUSIVEADDRUSE</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td bgcolor="#C0C0C0">Specific</td>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td bgcolor="#C0C0C0">Specific</td>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td bgcolor="#C0C0C0">Specific</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0" rowspan="2">Значение по умолчанию</td>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ACCESS;</td>
        <td>ACCESS;</td>
        <td>ACCESS;</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ACCESS;</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0">Specific</td>
        <td>Успешно</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>Успешно</td>
        <td>ACCESS;</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0" rowspan="2">SO_REUSEADDR</td>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ACCESS;</td>
        <td>Успех</td>
        <td>Успех</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ACCESS;</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0">Specific</td>
        <td>Успешно</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>Успех</td>
        <td>Успех</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0" rowspan="2">SO_EXCLUSIVEADDRUSE</td>
        <td bgcolor="#C0C0C0">Подстановочный знак</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ACCESS;</td>
        <td>ACCESS;</td>
        <td>ACCESS;</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ACCESS;</td>
    </tr>
    <tr>
        <td bgcolor="#C0C0C0">Specific</td>
        <td>Успешно</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>Успешно</td>
        <td>ACCESS;</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
        <td>ИСПОЛЬЗУЕМЫХ</td>
    </tr>
</table>

Обратите внимание, что поведение по умолчанию отличается в случае, когда вызовы [**привязки**](/windows/win32/api/winsock/nf-winsock-bind) выполняются под разными учетными записями пользователей. Если первый вызывающий объект не задает параметры на сокете и привязывается к подстановочному адресу, второй вызывающий объект не может установить параметр **so \_ реусеаддр** и успешно выполнить привязку к тому же порту. Поведение по умолчанию без Set Options также возвращает ошибку.

В Windows Vista и более поздних версиях можно создать двойной сокет стека, работающий как с IPv6, так и с IPv4. Если сокет с двумя стеками привязан к адресу с подстановочными знаками, указанный порт резервируется как в сетевых стеках IPv4, так и IPv6, а также на проверках, связанных с **таким \_ реусеаддр** , и **поэтому \_ ексклусивеаддрусе** (если задан). Эти проверки должны выполняться в обоих сетевых стеках. Например, если сокет TCP с двумя стеками устанавливает **так, что \_ ексклусивеаддрусе** , а затем пытается выполнить привязку к порту 5000, то другие TCP-сокеты не могут быть предварительно привязаны к порту 5000 (с помощью подстановочного знака или специального символа). В этом случае, если TCP-сокет IPv4 был ранее привязан к адресу замыкания на порте 5000, вызов [**привязки**](/windows/win32/api/winsock/nf-winsock-bind) для двойного сокета стека завершится с [всаеакцес](windows-sockets-error-codes-2.md).

## <a name="application-strategies"></a>Стратегии приложений

При разработке сетевого приложения, работающего на уровне сокета, важно учитывать необходимый тип безопасности сокета. Клиентские приложения — приложения, которые соединяют или отправляют данные в службу — редко занимают дополнительные действия, так как они привязаны к случайному временному порту (эфемерный). Если для правильной работы клиента требуется определенная локальная привязка портов, необходимо учитывать безопасность сокета.

Параметр **\_ реусеаддр** имеет очень мало использования в обычных приложениях, помимо многоадресных сокетов, где данные доставляются во все сокеты, привязанные к одному и тому же порту. В противном случае любое приложение, устанавливающее этот параметр сокета, должно быть переработано для удаления зависимости, так как она еминентли уязвима для "захвата сокета". Пока для потенциального захвата порта в серверном приложении можно использовать параметр **\_ реусеаддр** Socket, приложение должно считаться небезопасным.

Все серверные приложения должны **иметь \_ Ексклусивеаддрусе, чтобы обеспечить** высокий уровень безопасности сокетов. Это не только предотвращает перехват порта вредоносными программами, но и указывает, привязано ли другое приложение к запрошенному порту. Например, вызов для [**привязки**](/windows/win32/api/winsock/nf-winsock-bind) к адресу с подстановочными знаками процесса с установленным параметром сокета **so \_ ексклусивеаддрусе** завершится ошибкой, если другой процесс в данный момент привязан к тому же порту в определенном интерфейсе.

Наконец, несмотря на то, что в Windows Server 2003 улучшена безопасность сокетов, приложение должно всегда устанавливать параметр **so \_ ексклусивеаддрусе** , чтобы обеспечить его привязку ко всем конкретным интерфейсам, запрошенным процессом. Безопасность сокетов в Windows Server 2003 обеспечивает повышенный уровень безопасности для устаревших приложений, но разработчики приложений должны по-прежнему проектировать свои продукты, учитывая все аспекты безопасности.
