---
title: Регистрация обратного вызова COM
description: Вместо опроса изменений в состоянии задания можно выполнить регистрацию, чтобы получить уведомление при изменении состояния задания.
ms.assetid: 29350ea4-f7a9-4a42-a531-2cf623fe247b
keywords:
- БИТЫ задания передачи, уведомление о событии
- Регистрация для получения битов уведомления о событиях
- БИТЫ уведомлений о событиях
- БИТЫ уведомлений о событиях, обратные вызовы
- БИТЫ событий уведомления
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 753feb481a578c30322d18def07418c2dcb611d601fcb438b0e85e843697790b
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118680008"
---
# <a name="registering-a-com-callback"></a>Регистрация обратного вызова COM

Вместо [опроса](polling-for-the-status-of-the-job.md) изменений в состоянии задания можно выполнить регистрацию, чтобы получить уведомление при изменении состояния задания. Чтобы получить уведомление, необходимо реализовать интерфейс [**IBackgroundCopyCallback2**](/windows/desktop/api/Bits3_0/nn-bits3_0-ibackgroundcopycallback2) . Интерфейс содержит следующие методы, которые вызываются BITS в зависимости от регистрации:

-   [**жобтрансферред**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopycallback-jobtransferred)
-   [**жоберрор**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopycallback-joberror)
-   [**жобмодификатион**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopycallback-jobmodification)
-   [**филетрансферред**](/windows/desktop/api/Bits3_0/nf-bits3_0-ibackgroundcopycallback2-filetransferred)

Пример, в котором реализован интерфейс [**IBackgroundCopyCallback2**](/windows/desktop/api/Bits3_0/nn-bits3_0-ibackgroundcopycallback2) , см. в примере кода в разделе интерфейс [**ибаккграундкопикаллбакк**](/windows/desktop/api/Bits/nn-bits-ibackgroundcopycallback) .

Интерфейс [**IBackgroundCopyCallback2**](/windows/desktop/api/Bits3_0/nn-bits3_0-ibackgroundcopycallback2) предоставляет уведомление при передаче файла. Как правило, этот метод используется для проверки файла, чтобы файл был доступен для загрузки одноранговыми узлами. в противном случае файл недоступен для одноранговых узлов, пока не будет вызван метод [**использованием метода ibackgroundcopyjob:: Complete**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-complete) . Чтобы проверить файл, вызовите метод [**IBackgroundCopyFile3:: сетвалидатионстате**](/windows/desktop/api/Bits3_0/nf-bits3_0-ibackgroundcopyfile3-setvalidationstate) .

Существует два метода регистрации обратного вызова COM: регистрация объекта обратного вызова или Регистрация идентификатора класса обратного вызова. Использование объекта обратного вызова упрощается и снижает издержки; Использование CLSID обратного вызова является более надежным, но более сложным. Вы можете зарегистрировать либо оба, либо ни одного из них, если он существует и по-прежнему будет вызываться, и будет возвращаться к созданию нового объекта на основе указанного идентификатора класса, если это не удается.

### <a name="registering-a-callback-object"></a>Регистрация объекта обратного вызова

Чтобы зарегистрировать свою реализацию в БИТАХ, вызовите метод [**использованием метода ibackgroundcopyjob:: сетнотифинтерфаце**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-setnotifyinterface) . Чтобы указать, какие методы BITS вызывают, вызовите метод [**использованием метода ibackgroundcopyjob:: сетнотифифлагс**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-setnotifyflags).

Интерфейс уведомления станет недействительным после завершения работы приложения. Служба BITS не сохраняет интерфейс уведомления. В результате процесс инициализации приложения должен зарегистрировать существующие задания, для которых вы хотите получить уведомление. Если необходимо собрать сведения о состоянии и ходе выполнения, произошедшие с момента последнего запуска приложения, следует опросить сведения о состоянии и ходе выполнения во время инициализации приложения.

Перед выходом приложение должно очистить указатель интерфейса обратного вызова (**сетнотифинтерфаце (null)**). Более эффективным является очистка указателя обратного вызова, что позволяет службе BITS обнаружить, что она больше не действительна.

Обратите внимание, что если несколько приложений вызывают метод [**сетнотифинтерфаце**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-setnotifyinterface) для установки интерфейса уведомления для задания, Последнее приложение вызывает метод **сетнотифинтерфаце** , который будет получать уведомления — другие приложения не будут получать уведомления.

В следующем примере показано, как зарегистрироваться для получения уведомлений. В примере предполагается, что указатель интерфейса [**использованием метода ibackgroundcopyjob**](/windows/desktop/api/Bits/nn-bits-ibackgroundcopyjob) является допустимым. Дополнительные сведения о классе примера Кнотифинтерфаце, используемом в следующем примере, см. в разделе интерфейс [**ибаккграундкопикаллбакк**](/windows/desktop/api/Bits/nn-bits-ibackgroundcopycallback) .


```C++
HRESULT hr;
IBackgroundCopyJob* pJob;
CNotifyInterface *pNotify = new CNotifyInterface();

if (pNotify)
{
    hr = pJob->SetNotifyInterface(pNotify);
    if (SUCCEEDED(hr))
    {
        hr = pJob->SetNotifyFlags(BG_NOTIFY_JOB_TRANSFERRED | 
                                  BG_NOTIFY_JOB_ERROR );
    }
    pNotify->Release();
    pNotify = NULL;

    if (FAILED(hr))
    {
        //Handle error - unable to register callbacks.
    }
}
```



### <a name="registering-a-callback-clsid"></a>Регистрация CLSID обратного вызова

Чтобы зарегистрировать CLSID обратного вызова с помощью битов, вызовите метод [**IBackgroundCopyJob5:: SetProperty**](/windows/desktop/api/Bits5_0/nf-bits5_0-ibackgroundcopyjob5-setproperty) со **\_ \_ свойством \_ \_ задания BITS** PropertyId. Чтобы указать, какие методы BITS вызывают, вызовите метод [**использованием метода ibackgroundcopyjob:: сетнотифифлагс**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-setnotifyflags) .

Перед регистрацией идентификатора CLSID в задании BITS необходимо убедиться, что идентификатор CLSID уведомления зарегистрирован на сервере вне процесса COM. Реализация [сервера COM](/windows/desktop/com/com-server-responsibilities) значительно сложнее, чем определение и передача объекта обратного вызова, но предлагает несколько важных преимуществ. Сервер COM позволяет службе BITS поддерживать связь между заданием BITS и кодом приложения при перезагрузке системы, а также для больших или длительных заданий. Сервер COM также позволяет приложению полностью завершить работу, пока служба BITS продолжит выполнять передачи в фоновом режиме, что может улучшить использование аккумулятора, ЦП и памяти системы.

Чтобы предоставить уведомление, которое вы зарегистрировали для получения, служба BITS сначала пытается вызвать соответствующий метод существующего объекта обратного вызова, который вы могли присоединить. Если существующего объекта нет или этот существующий объект был отключен (как правило, в результате завершения работы приложения), служба BITS вызовет CoCreateInstance, используя CLSID уведомлений для создания экземпляра нового объекта обратного вызова, и будет использовать этот объект для последующих обратных вызовов до тех пор, пока он не будет отключен или не будет заменен новым вызовом [**использованием метода ibackgroundcopyjob:: сетнотифинтерфаце**](/windows/desktop/api/Bits/nf-bits-ibackgroundcopyjob-setnotifyinterface).

В отличие от объектов обратного вызова, CLSID обратного вызова сохраняется вместе с соответствующими заданиями BITS, если служба BITS или система остановлены и перезапущены. Приложение может очистить любой ранее установленный идентификатор CLSID уведомления перед выходом (или в любой другой момент), передав новый CLSID уведомления GUID \_ null, но ваше приложение может предпочесть оставить идентификатор CLSID уведомления зарегистрированным, если приложение зарегистрировано для запуска com в ответ на запросы CoCreateInstance для идентификатора CLSID. Обратите внимание, что если в нескольких приложениях задано **свойство \_ \_ \_ \_ CLSID уведомления свойства задания BITS** , то последним задается последний CLSID, который будет использоваться BITS для создания экземпляров объектов обратного вызова — экземпляры других идентификаторов CLSID создаваться не будут. Аналогично, если одно приложение регистрирует CLSID и другой регистрирует объект обратного вызова, применяются обычные правила для объекта обратного вызова, которые применяют приоритет, и CLSID не будет использоваться, если объект обратного вызова не был сброшен или отключен.

В следующем примере показано, как зарегистрировать уведомления CLSID. В примере предполагается, что указатель интерфейса [**IBackgroundCopyJob5**](/windows/desktop/api/Bits5_0/nn-bits5_0-ibackgroundcopyjob5) является допустимым и что приложение уже зарегистрировано как внутрипроцессный COM-сервер, реализующий класс кнотифинтерфаце. Дополнительные сведения о классе примера Кнотифинтерфаце, используемом в следующем примере, см. в разделе интерфейс [**ибаккграундкопикаллбакк**](/windows/desktop/api/Bits/nn-bits-ibackgroundcopycallback) .


```C++
HRESULT hr; 
IBackgroundCopyJob5* job; 
BITS_JOB_PROPERTY_VALUE propertyValue; 
propertyValue.ClsID = __uuidof(CNotifyInterface); 

hr = job->SetProperty(BITS_JOB_PROPERTY_NOTIFICATION_CLSID, propertyValue); 
if (SUCCEEDED(hr)) 
{ 
    hr = job->SetNotifyFlags(BG_NOTIFY_JOB_TRANSFERRED |  
                             BG_NOTIFY_JOB_ERROR); 
} 

if (FAILED(hr)) 
{ 
    // Handle error - unable to register callbacks. 
} 
```



 

 