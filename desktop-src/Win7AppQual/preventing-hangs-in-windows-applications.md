---
description: узнайте, как предотвратить зависание в Windowsных приложениях для платформ Windows 7 и Windows Server 2008 R2.
ms.assetid: 698a046b-1934-49cd-a717-d61e7e1ec534
title: Предотвращение зависаний в приложениях для Windows
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5509b8733e45b105694a8bfdadddae0d67096b92c390ed98b3dd937817823b39
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118994829"
---
# <a name="preventing-hangs-in-windows-applications"></a>Предотвращение зависаний в приложениях для Windows

## <a name="affected-platforms"></a>Затронутые платформы

**клиенты** — Windows 7  
**серверы** — Windows Server 2008 R2  









## <a name="description"></a>Описание

**Зависания — перспектива пользователя**

Пользователи, например реагирующие приложения. При щелчке меню они хотят, чтобы приложение реагировало мгновенно, даже если в данный момент он печатает свою работу. При сохранении длинного документа в своем любимом текстовом процессоре они хотят продолжать ввод, пока диск все еще вращается. Пользователи получают неограниченный доступ, когда приложение не реагирует на них своевременно.

Программист может распознавать множество законных причин, чтобы приложение не было мгновенно реагировать на вводимые пользователем данные. Приложение может быть занято перерасчетом некоторых данных или просто ожиданием завершения операций дискового ввода-вывода. Однако при исследовании пользователей мы понимаем, что пользователи получают раздражен и разочарованы через несколько секунд с момента реагирования. Через 5 секунд они попытаются завершить зависание приложения. Как правило, зависание приложений является наиболее распространенным источником сбоев пользователей при работе с приложениями Win32.

Существует множество разных основных причин зависания приложения, а не все они сами по себе переносятся в Неотвечающий пользовательский интерфейс. Однако Неотвечающий пользовательский интерфейс — это один из наиболее распространенных ситуаций зависания, и в настоящее время этот сценарий получает максимальную поддержку операционной системы как для обнаружения, так и для восстановления. Windows автоматически обнаруживает, собирает сведения об отладке и при необходимости завершает или перезапускает зависание приложений. В противном случае пользователю может потребоваться перезагрузить компьютер, чтобы восстановить зависание приложения.

**Зависание — перспектива операционной системы**

Когда приложение (или точнее, поток) создает окно на рабочем столе, оно переходит в неявный контракт с диспетчер окон рабочего стола (DWM) для своевременной обработки сообщений окна. DWM отправляет сообщения (ввод с клавиатуры и с помощью мыши и сообщения из других окон, а также саму себя) в очередь сообщений конкретного потока. Поток извлекает и отправляет эти сообщения через очередь сообщений. Если поток не обрабатывает очередь, вызывая метод "onmessage ()", сообщения не обрабатываются и окно зависает: оно не может ни перерисовывать, ни принимать входные данные от пользователя. Операционная система обнаруживает это состояние, подключив таймер к ожидающим сообщениям в очереди сообщений. Если сообщение не было получено в течение 5 секунд, DWM объявляет окно как зависло. Это конкретное состояние окна можно запросить с помощью API Ишунгаппвиндов ().

Обнаружение — это только первый шаг. На этом этапе пользователь по-прежнему даже не может завершить работу приложения. нажатие кнопки X (Close) приведет к появлению \_ сообщения о закрытии WM, которое будет задержано в очереди сообщений, как и любое другое сообщение. Диспетчер окон рабочего стола помогает легко скрывать и заменять зависание окна с копией "фантомной" копии, отображающей растровое изображение предыдущей клиентской области исходного окна (и добавляя "не отвечает" на строку заголовка). Пока поток исходного окна не извлекает сообщения, DWM управляет обеими окнами одновременно, но позволяет пользователю взаимодействовать только с фантомной копией. С помощью этого несинхронизированного окна пользователь может только перемещать, сокращать и, что самое важное, закрыть приложение, не отвечающее на запросы, но не изменять его внутреннее состояние.

Весь процесс Ghost выглядит следующим образом:

![снимок экрана, на котором показано диалоговое окно "Блокнот не отвечает".](images/preventinghangs-ghostwindow.gif)

Диспетчер окон рабочего стола выполняет одно последнее действие; он интегрируется с отчеты об ошибках Windows, позволяя пользователю не только закрывать и при необходимости перезапускать приложение, но и передавать ценные данные отладки в корпорацию майкрософт. Вы можете получить эти данные о зависании для своих приложений, зарегистрировавшись на веб-сайте Винкуал.

в Windows 7 добавлена одна новая функция для этого интерфейса. Операционная система анализирует зависание приложения и при определенных обстоятельствах дает пользователю возможность отменить блокировку и снова заставить приложение реагировать на запросы. Текущая реализация поддерживает отмену блокирующих вызовов сокета; в будущих выпусках больше операций будет отменено пользователем.

Чтобы интегрировать приложение с процессом восстановления после зависания и максимально использовать доступные данные, выполните следующие действия.

-   Убедитесь, что приложение регистрируется для перезапуска и восстановления, что делает зависание как можно более свободным для пользователя. Правильно зарегистрированное приложение может автоматически перезапуститься с большей частью несохраненных данных. Это работает как для зависаний приложений, так и для сбоев.
-   Получите сведения о частоте, а также об отладке данных для зависших и аварийно завершенных приложений с веб-сайта Винкуал. Эти сведения можно использовать даже во время бета-тестирования, чтобы улучшить код. краткий обзор см. в разделе "введение в отчеты об ошибках Windows".
-   Функцию дублирования можно отключить в приложении с помощью вызова Дисаблепроцессвиндовсгхостинг (). Однако это не даст пользователю среднего времени закрывать и перезапускать зависание приложение и часто завершает перезагрузку.

**Зависания — перспектива разработчика**

Операционная система определяет зависание приложения как поток пользовательского интерфейса, который не обрабатывал сообщения по крайней мере 5 секунд. Очевидные ошибки вызывают некоторые зависания, например поток, ожидающий события, который никогда не оповещается, и два потока, удерживающих блокировку и пытающиеся получить другие. Эти ошибки можно устранить без чрезмерного объема усилий. Однако многие зависания не настолько очевидны. Да, поток пользовательского интерфейса не получает сообщения, но он по-другому занят выполнением других важных действий и в конечном итоге вернется к обработке сообщений.

Однако пользователь воспринимает это как ошибку. Проект должен соответствовать ожиданиям пользователя. Если проект приложения ведет к неотвечающему приложению, проект придется изменить. И, наконец, это важно, поэтому невозможность реагирования не может быть исправлена как ошибка в коде. на этапе проектирования требуется предварительная работа. Попытка модифицировать существующую базу кода приложения, чтобы сделать пользовательский интерфейс более быстрым реагированием, часто слишком дорого. Могут помочь следующие рекомендации по проектированию.

-   Обеспечьте скорость реагирования пользовательского интерфейса требованием верхнего уровня; пользователь всегда должен иметь контроль над вашим приложением
-   Убедитесь, что пользователи могут отменять операции, выполнение которых занимает больше одной секунды, а также выполнять операции в фоновом режиме. При необходимости укажите соответствующий пользовательский интерфейс хода выполнения

![Снимок экрана, на котором показано диалоговое окно "копирование элементов".](images/preventinghangs-progressbar.gif)

-   Очередь длительных или блокирующих операций в качестве фоновых задач (для этого требуется хорошо продуманный механизм обмена сообщениями для информирования потока пользовательского интерфейса о завершении работы).
-   Обеспечьте простоту кода для потоков пользовательского интерфейса; Удалите столько блокирующих вызовов API, сколько возможно
-   Отображать окна и диалоговые окна, только когда они готовы и полностью работоспособны. Если в диалоговом окне необходимо отобразить сведения, требующие слишком большого количества ресурсов для вычисления, сначала покажите некоторые общие сведения и обновите ее на лету, когда становятся доступными дополнительные данные. хорошим примером является диалоговое окно свойства папки из проводника Windows. Он должен отображать общий размер папки, сведения, недоступные в файловой системе. Диалоговое окно сразу же появляется, и поле "размер" обновляется из рабочего потока:

![снимок экрана, на котором показана страница "общие" Windows свойств с текстом "size", "size in disk" и "Contains" в кружке.](images/preventinghangs-updatingdialog.gif)

К сожалению, не существует простого способа проектирования и написания реагирующего приложения. Windows не предоставляет простой асинхронной платформы, которая позволяет легко планировать блокирование или длительные операции. В следующих разделах представлены некоторые рекомендации по предотвращению зависаний и выделению некоторых распространенных ловушек.

## <a name="best-practices"></a>Советы и рекомендации

**Упрощение потока пользовательского интерфейса**

Основной обязанностью потока пользовательского интерфейса является получение и отправка сообщений. Любые другие виды работы представляют риск зависания окон, принадлежащих данному потоку.

**Запреща**

-   Перемещение ресурсоемких или неограниченных алгоритмов, которые приводят к созданию долго выполняющихся операций в рабочих потоках
-   Определите столько блокирующих вызовов функций, сколько возможно, и попытайтесь переместить их в рабочие потоки. любой вызов функции в другую библиотеку DLL должен быть подозрительным
-   Сделайте дополнительные усилия, чтобы удалить все вызовы API файлового ввода-вывода и сетевых интерфейсов из рабочего потока. Эти функции могут блокироваться в течение нескольких секунд, если не минут. Если вам нужно выполнять операции ввода-вывода в потоке пользовательского интерфейса, рассмотрите возможность использования асинхронного ввода-вывода
-   Имейте в виду, что поток пользовательского интерфейса также обслуживает все серверы COM, размещенные в одном потоке (STA), размещаемые в процессе. Если вы сделаете вызов блокировки, эти серверы COM не будут отвечать, пока очередь сообщений не будет обслуживаться повторно.

**Чего не следует делать:**

-   Дождитесь любого объекта ядра (например, события или мьютекса) в течение слишком короткого промежутка времени; Если нужно подождать все, попробуйте использовать Мсгваитформултиплеобжектс (), который будет разблокирован при поступлении нового сообщения
-   Совместное использование очереди сообщений окна потока с другим потоком с помощью функции Аттачсреадинпут (). нетрудно правильно синхронизировать доступ к очереди, но это также может помешать Windows операционной системе правильно обнаружить зависание окна.
-   Используйте TerminateThread () в любом из рабочих потоков. Таким образом, завершение потока не позволит ему выпустить блокировки или события сигнала и легко привести к потере потерянных объектов синхронизации.
-   Вызовите любой "Неизвестный" код из потока пользовательского интерфейса. Это особенно верно, если приложение имеет модель расширяемости. нет никакой гарантии, что код третьей стороны следует правилам реагирования.
-   Сделайте любой разновидность блокирующего широковещательного вызова. SendMessage ( \_ рассылка HWND) помещает вас в милость каждого некорректно написанного приложения, которое в настоящее время выполняется

**Реализация асинхронных шаблонов**

Удаление длительных или блокирующих операций из потока пользовательского интерфейса требует реализации асинхронной платформы, которая позволяет разгрузить эти операции в рабочие потоки.

**Запреща**

-   Используйте асинхронные API-интерфейсы оконных сообщений в потоке пользовательского интерфейса, особенно путем замены SendMessage на один из неблокирующих одноранговых узлов: i Message, Сенднотифимессаже или Сендмессажекаллбакк
-   Используйте фоновые потоки для выполнения длительных или блокирующих задач. Использование нового API пула потоков для реализации рабочих потоков
-   Предоставление поддержки отмены для длительных фоновых задач. Для блокировки операций ввода-вывода Используйте отмену ввода-вывода, но только в качестве последнего средства. отменить операцию "Right" непросто.
-   Реализация асинхронного проектирования для управляемого кода с помощью шаблона IAsyncResult или с помощью событий

**Разумное использование блокировок**

Приложению или библиотеке DLL требуются блокировки для синхронизации доступа к внутренним структурам данных. Использование нескольких блокировок повышает параллелизм и делает приложение более быстрым реагированием. Однако использование нескольких блокировок также повышает вероятность получения этих блокировок в различных заказах и вызовет взаимоблокировку потоков. Если два потока содержат блокировку, а затем пытаются получить блокировку другого потока, их операции формируют циклическое ожидание, блокирующее все данные о ходе выполнения этих потоков вперед. Эту взаимоблокировку можно избежать, убедившись, что все потоки в приложении всегда получают все блокировки в одном и том же порядке. Однако не всегда удается получить блокировки в прямом порядке. Программные компоненты могут быть составлены, но получение блокировок не может быть разрешено. Если ваш код вызывает какой-либо другой компонент, блокировки этого компонента теперь становятся частью неявного порядка блокировки, даже если эти блокировки не видны.

Все еще сложнее, так как операции блокировки включают гораздо больше обычных функций для критических секций, мьютексов и других традиционных блокировок. Любой вызов блокировки, пересекающий границы потоков, имеет свойства синхронизации, которые могут привести к взаимоблокировке. Вызывающий поток выполняет операцию с семантикой "получить" и не может разблокировать, пока целевой поток выполнит вызов. Очень несколько функций user32 (например, SendMessage), а также множество блокирующих вызовов COM, попадающие в эту категорию.

Что еще хуже, операционная система имеет собственную внутреннюю блокировку конкретного процесса, которая иногда удерживается во время выполнения кода. Эта блокировка запрашивается при загрузке библиотек DLL в процесс и поэтому называется блокировкой загрузчика. Функция DllMain всегда выполняется при блокировке загрузчика; При получении каких-либо блокировок в DllMain (и не следует) необходимо сделать блокировку загрузчика частью порядка блокировки. Вызов некоторых API-интерфейсов Win32 может также получить блокировку загрузчика от своих функций, таких как LoadLibraryEx, ошибка GetModuleHandle и особенно CoCreateInstance.

Чтобы связать все это вместе, Взгляните на пример кода ниже. Эта функция получает несколько объектов синхронизации и неявно определяет порядок блокировки, что не обязательно очевидно при проверке курсора. При вводе функции код получает критическую секцию и не освобождает его до выхода из функции, тем самым делая его верхним узлом в нашей иерархии блокировок. Затем код вызывает функцию Win32 Лоадикон (), которая, в своюмся, может вызвать загрузчик операционной системы для загрузки этого двоичного файла. Эта операция получит блокировку загрузчика, которая теперь также становится частью этой иерархии блокировок (убедитесь, что функция DllMain не получает \_ блокировку g CS). Далее код вызывает SendMessage (), блокируя межпотоковую операцию, которая не будет возвращаться, если поток пользовательского интерфейса не ответит. Опять же, убедитесь, что поток пользовательского интерфейса никогда не получает g \_ CS.

```
bool foo::bar (char* buffer)  
{  
      EnterCriticalSection(&g_cs);  
      // Get 'new data' icon  
      this.m_Icon = LoadIcon(hInst, MAKEINTRESOURCE(5));  
      // Let UI thread know to update icon SendMessage(hWnd,WM_COMMAND,IDM_ICON,NULL);  
      this.m_Params = GetParams(buffer);  
      LeaveCriticalSection(&g_cs);
      return true;  
}  
```

Просмотрев этот код, кажется ясно, что мы неявно сделали g \_ CS для блокировки верхнего уровня в нашей иерархии блокировок, даже если нам нужно синхронизировать доступ к переменным-членам класса.

**Запреща**

-   Разработайте иерархию блокировок и подчиняюте ее. Добавьте все необходимые блокировки. Существует гораздо больше примитивов синхронизации, чем только мьютексы и Критикалсектионс; Все они должны быть добавлены. Включить блокировку загрузчика в иерархию, если вы принимаете какие-либо блокировки в DllMain ()
-   Согласование протокола блокировки с зависимостями. Любой код, который вызывает приложение или который может вызвать ваше приложение, должен использовать одну и ту же иерархию блокировки
-   Структуры данных блокировки не являются функциями. Перемещение блокировок от точек входа функций и защита доступа к данным только с помощью блокировок. Если меньше кода работает при блокировке, то существует меньше шансов на взаимоблокировки.
-   Анализ приобретений и выпусков блокировок в коде обработки ошибок. Часто при попытке восстановления после возникновения ошибки иерархия блокировок забывает.
-   Замена вложенных блокировок на счетчики ссылок — они не могут быть взаимоблокировками. Независимые элементы в списках и таблицах являются хорошими кандидатами
-   Будьте внимательны при ожидании обработки потока из библиотеки DLL. Всегда считайте, что код может быть вызван при блокировке загрузчика. Лучше сослаться на ресурсы и позволить рабочему потоку выполнять собственную очистку (а затем использовать Фрилибраряндекситсреад для корректного завершения).
-   Используйте API обхода цепочки ожидания, если хотите диагностировать собственные взаимоблокировки.

**Чего не следует делать:**

-   Выполните любые действия, отличные от очень простых операций инициализации в функции DllMain (). Дополнительные сведения см. в разделе Функция обратного вызова функции DllMain. Особенно не вызывайте LoadLibraryEx или CoCreateInstance
-   Напишите собственные примитивы блокировки. Пользовательский код синхронизации может легко ввести в базу кода небольшие ошибки. Вместо этого используйте Расширенный выбор объектов синхронизации операционной системы.
-   Выполнять любые действия в конструкторах и деструкторах для глобальных переменных, они выполняются при блокировке загрузчика

**Будьте внимательны с исключениями**

Исключения позволяют разделить нормальную последовательность программ и обработку ошибок. В связи с этим разделение может быть трудно понять точное состояние программы до исключения, а обработчик исключений может пропустить важные шаги в восстановлении допустимого состояния. Это особенно справедливо для получения блокировок, которые необходимо освободить в обработчике, чтобы предотвратить дальнейшие взаимоблокировки.

Эта проблема показана в приведенном ниже образце кода. Неограниченный доступ к переменной "buffer" иногда приводит к нарушению прав доступа (AV). Эта антивирусная программа перехвачена собственным обработчиком исключений, но не имеет простого способа определить, была ли критическая секция уже получена во время исключения (антивирусная программа, возможно, даже заняла место в коде EnterCriticalSection).

```
 BOOL bar (char* buffer)  
{  
   BOOL rc = FALSE;  
   __try {  
      EnterCriticalSection(&cs);  
      while (*buffer++ != '&') ;  
      rc = GetParams(buffer);  
      LeaveCriticalSection(&cs);  
   } __except (EXCEPTION_EXECUTE_HANDLER)  
   {  
      return FALSE;  
   } 
   return rc;  
}  
```

**Запреща**

-   Удалить \_ \_ try и \_ \_ EXCEPT, если это возможно; не использовать сетунхандледексцептионфилтер
-   Если вы используете исключения C++, заключите свои блокировки в пользовательские шаблоны автозамены, \_ такие как. Блокировка должна быть освобождена в деструкторе. Для собственных исключений Освободите блокировки в \_ \_ операторе Finally.
-   Будьте внимательны при работе с кодом, который выполняется в собственном обработчике исключений; исключение могло привести к утечке множества блокировок, поэтому обработчик не должен получить

**Чего не следует делать:**

-   Обрабатывайте собственные исключения, если они не нужны или не требуются для API-интерфейсов Win32. при использовании собственных обработчиков исключений для создания отчетов или восстановления данных после разрушительных сбоев рассмотрите возможность использования механизма операционной системы по умолчанию отчеты об ошибках Windows
-   Используйте исключения C++ с любым кодом пользовательского интерфейса (User32). исключение, создаваемое в обратном вызове, передается через уровни кода на языке C, предоставленные операционной системой. Этот код не знает о семантике отката C++

## <a name="links-to-resources"></a>Ссылки на ресурсы

-   [Отчеты об ошибках Windows](../wer/windows-error-reporting.md)
-   [Асинхронная разработка](https://msdn.microsoft.com/library/ms228969(v=VS.80).aspx)
-   [Асинхронный ввод-вывод](../fileio/synchronous-and-asynchronous-i-o.md)
-   [**Функция Аттачсреадинпут**](/windows/win32/api/winuser/nf-winuser-attachthreadinput)
-   [**Автоматический \_ класс PTR**](https://msdn.microsoft.com/library/ew3fk483(v=VS.71).aspx)
-   [**Функция Дисаблепроцессвиндовсгхостинг**](/windows/win32/api/winuser/nf-winuser-disableprocesswindowsghosting)
-   [**Функция обратного вызова функции DllMain**](../dlls/dllmain.md)
-   [События](https://msdn.microsoft.com/library/wewwczdw(v=VS.80).aspx)
-   [**Функция onmessage**](/windows/win32/api/winuser/nf-winuser-getmessage)
-   [Отмена ввода-вывода](../fileio/canceling-pending-i-o-operations.md)
-   [**Функция Ишунгаппвиндов**](/windows/win32/api/winuser/nf-winuser-ishungappwindow)
-   [Очередь сообщений](../winmsg/using-messages-and-message-queues.md)
-   [**Функция Мсгваитформултиплеобжектс**](/windows/win32/api/winuser/nf-winuser-msgwaitformultipleobjects)
-   [Новый API пула потоков](../procthread/thread-pool-api.md)
-   [**Функция onmessage**](/windows/win32/api/winuser/nf-winuser-postmessagea)
-   [Перезагрузка и восстановление](../recovery/registering-for-application-restart.md)
-   [**Функция Сендмессажекаллбакк**](/windows/win32/api/winuser/nf-winuser-sendmessagecallbacka)
-   [**Функция Сенднотифимессаже**](/windows/win32/api/winuser/nf-winuser-sendnotifymessagea)
-   [Объекты синхронизации](../sync/about-synchronization.md)
-   [**TerminateThread, функция**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-terminatethread)
-   [Отчеты об ошибках Windows](../wer/windows-error-reporting.md)
-   [винкуал](/windows-hardware/drivers/dashboard/winqual-submission-tool--winqualexe-)

 

 
