---
title: ЖЕСТКОЕ соответствие
description: При включении СТРОГОй проверки типов часть исходного кода, который успешно компилируется, может выдавать сообщения об ошибках.
ms.assetid: 88368fec-b375-4ad0-aa13-ffadf0338a44
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 02d04c3a849dc62647758e3515728e3dd3f65dcb
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104413225"
---
# <a name="strict-compliance"></a>ЖЕСТКОЕ соответствие

При включении **строгой** проверки типов часть исходного кода, который успешно компилируется, может выдавать сообщения об ошибках. В следующих разделах описаны минимальные требования к компиляции кода при включенном параметре **On** . Рекомендуется выполнить дополнительные действия, особенно для создания переносимого кода.

## <a name="general-requirements"></a>Общие требования

Основное требование заключается в том, что необходимо объявить правильные типы обработчиков и указатели функций вместо того, чтобы полагаться на более общие типы. Нельзя использовать один тип обработчика, где ожидается другой. Это также означает, что может потребоваться изменить объявления функций и использовать дополнительные приведения типов.

Для достижения лучших результатов тип универсального **маркера** следует использовать только при необходимости.

## <a name="declaring-functions-within-your-application"></a>Объявление функций в приложении

Убедитесь, что объявлены все функции приложения. Рекомендуется размещать все объявления функций в включаемом файле, так как вы можете легко проверить объявления и найти параметры и возвращаемые типы, которые следует изменить.

При использовании параметра компилятора **/Zg** для создания файлов заголовков для функций следует помнить, что результаты будут разными, в зависимости от того, включена ли **строго** проверка типов. При использовании **строгого** отключения все типы обработчиков создают один и тот же базовый тип. При **использовании требований** с поддержкой определенных типов они создают разные базовые типы. Чтобы избежать **конфликта, необходимо** повторно создать файл заголовка каждый раз при включении или отключении или изменении файла заголовка для использования типов **HWND**, **HDC**, **Handle** и т. д. вместо базовых типов.

Все объявления функций, скопированные из Windows. h в исходный код, могли быть изменены, а локальное объявление может устареть. Удалите локальное объявление.

## <a name="types-that-require-casts"></a>Типы, для которых требуются приведения

Некоторые функции имеют универсальные типы возвращаемых значения или параметры. Например, функция [**SendMessage**](/windows/win32/api/winuser/nf-winuser-sendmessage) возвращает данные, которые могут быть любого числа типов, в зависимости от контекста. Если в исходном коде отображаются какие-либо из этих функций, убедитесь, что используется правильная операция приведения типов и что это возможно. В следующем списке приведен пример этих функций.

-   [**локаллокк**](/windows/desktop/api/winbase/nf-winbase-locallock)
-   [**GlobalLock**](/windows/desktop/api/winbase/nf-winbase-globallock)
-   [**жетвиндовлонг**](/windows/win32/api/winuser/nf-winuser-getwindowlonga)
-   [**SetWindowLong**](/windows/win32/api/winuser/nf-winuser-setwindowlonga)
-   [**SendMessage**](/windows/win32/api/winuser/nf-winuser-sendmessage)
-   [**дефвиндовпрок**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)
-   [**сенддлгитеммессаже**](/windows/win32/api/winuser/nf-winuser-senddlgitemmessagea)

При вызове [**SendMessage**](/windows/win32/api/winuser/nf-winuser-sendmessage), [**дефвиндовпрок**](/windows/desktop/api/winuser/nf-winuser-defwindowproca)или [**сенддлгитеммессаже**](/windows/win32/api/winuser/nf-winuser-senddlgitemmessagea)сначала следует привести результат к типу **uint \_ ptr**. Необходимо выполнить аналогичные действия для любой функции, возвращающей значение **\_ типа** **lResult** или long, где результат содержит маркер. Это необходимо для написания переносимого кода, так как размер маркера зависит от версии Windows. Приведение **\_ типа uint PTR** обеспечивает правильное преобразование. В следующем коде показан пример, в котором **SendMessage** возвращает дескриптор кисти:


```C++
HBRUSH hbr;

hbr = (HBRUSH)(UINT_PTR)SendMessage(hwnd, WM_CTLCOLOR, ..., ...);
```



Параметр **CreateWindow** и **CreateWindowEx** *HMENU* иногда используется для передачи идентификатора элемента управления целочисленного типа (ID). В этом случае необходимо привести идентификатор к типу **HMENU** :


```C++
HWND hwnd;
int id;

hwnd = CreateWindow(
        TEXT("Button"), TEXT("OK"), BS_PUSHBUTTON,
        x, y, cx, cy, hwndParent,
        (HMENU)id,    // Cast required here
        hinst,
        NULL);
```



## <a name="additional-considerations"></a>Дополнительные сведения

Чтобы получить максимальную пользу от **строгой** проверки типов, необходимо следовать дополнительным рекомендациям. В будущих версиях Windows код будет более переносимым, если вы внесете следующие изменения.

Типы **wParam**, **lParam**, **lResult** и **лпвоид** — это *типы данных с полиморфизмом*. Они хранят различные виды данных в разное время, даже если включена **строго** проверка типов. Чтобы получить преимущества проверки типов, необходимо как можно быстрее привести значения этих типов. (Обратите внимание, что средство взлома сообщений автоматически переводит *wParam* и *lParam* в переносимом виде.)

Соблюдайте особое внимание, чтобы различать типы **хмодуле** и **HINSTANCE** . Даже при **строгом** включении они определяются как один и тот же базовый тип. Большинство функций управления модулями ядра используют типы **HINSTANCE** , но существует несколько функций, которые возвращают или принимают только типы **хмодуле** .

## <a name="related-topics"></a>См. также

<dl> <dt>

[Отключение](disabling-strict.md)
</dt> <dt>

[Включение параметра](enabling-strict.md)
</dt> </dl>

 

 