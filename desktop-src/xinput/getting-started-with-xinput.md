---
title: начало работы с Ксинпут
description: Ксинпут — это API, позволяющий приложениям принимать входные данные от контроллера Xbox для Windows. Поддерживаются эффекты румблеа контроллера, речевой ввод и вывод.
ms.assetid: 7b5eec3e-b3da-de5c-c926-8258c1418ef0
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 68a9ca17e3046db676887290b9b9dcbb7318f2dc89d4dd9543cbe790bf271b60
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118962503"
---
# <a name="getting-started-with-xinput"></a>начало работы с Ксинпут

Ксинпут — это API, позволяющий приложениям принимать входные данные от контроллера Xbox для Windows. Поддерживаются эффекты румблеа контроллера, речевой ввод и вывод.

В этом разделе содержится краткий обзор возможностей Ксинпут и их настройки в приложении. Это включает в себя следующее:

-   [Введение в Ксинпут](#introduction-to-xinput)
    -   [Контроллер Xbox](#the-xbox-controller)
-   [Использование Ксинпут](#using-xinput)
    -   [Несколько контроллеров](#multiple-controllers)
    -   [Получение состояния контроллера](#getting-controller-state)
    -   [Неработающая зона](#dead-zone)
    -   [Установка эффектов вибрации](#setting-vibration-effects)
    -   [Получение идентификаторов звуковых устройств](#getting-audio-device-identifiers)
    -   [Получение идентификаторов GUID DirectSound (только для устаревших пакетов SDK DirectX)](#getting-directsound-guids-legacy-directx-sdk-only)
-   [Связанные темы](#related-topics)

## <a name="introduction-to-xinput"></a>Введение в Ксинпут

Консоль Xbox использует игровой контроллер, совместимый с Windows. приложения могут использовать API ксинпут для взаимодействия с этими контроллерами, когда они подключены к Windows компьютеру (за один раз может быть подключено до четырех уникальных контроллеров).

С помощью этого API можно запрашивать состояние любого подключенного контроллера Xbox, а также устанавливать эффекты вибрации. Контроллеры, подключенные к гарнитуре, также могут быть запрошены для устройств ввода и вывода звука, которые можно использовать с гарнитурой для обработки голоса.

### <a name="the-xbox-controller"></a>Контроллер Xbox

Контроллер Xbox имеет два аналоговых устройства направления, каждое с цифровой кнопкой, два аналоговых триггера, цифровую клавиатуру с четырьмя направлениями и восемь цифровых кнопок. Состояния каждого из этих входных данных возвращаются в структуре [**\_ игрового ксинпут**](/windows/desktop/api/XInput/ns-xinput-xinput_gamepad) при вызове функции [**ксинпутжетстате**](/windows/desktop/api/XInput/nf-xinput-xinputgetstate) .

Контроллер также имеет два мотора вибрации, чтобы предоставить пользователю возможность принудительной обратной связи. Скорость этих моторов задается в структуре [**\_ вибрации ксинпут**](/windows/desktop/api/XInput/ns-xinput-xinput_vibration) , которая передается в функцию [**ксинпутсетстате**](/windows/desktop/api/XInput/nf-xinput-xinputsetstate) для установки эффектов вибрации.

При необходимости можно подключить гарнитуру к контроллеру. Гарнитура имеет микрофон для речевого ввода и наушники для вывода звука. Вы можете вызвать функцию [**ксинпутжетаудиодевицеидс**](/windows/desktop/api/XInput/nf-xinput-xinputgetaudiodeviceids) или Legacy [**ксинпутжетдсаундаудиодевицегуидс**](/windows/desktop/api/XInput/nf-xinput-xinputgetdsoundaudiodeviceguids) , чтобы получить идентификаторы устройств, которые соответствуют устройствам для микрофона и наушников. Затем можно использовать [Основные API аудио](/windows/desktop/CoreAudio/core-audio-apis-in-windows-vista) для получения голосового ввода и отправки звуковых данных.

## <a name="using-xinput"></a>Использование Ксинпут

Использование Ксинпут — это просто вызов функций Ксинпут по мере необходимости. С помощью функций Ксинпут можно получить состояние контроллера, получить идентификаторы головного телефона и установить эффекты румбле контроллера.

### <a name="multiple-controllers"></a>Несколько контроллеров

API Ксинпут поддерживает до четырех контроллеров, подключенных в любое время. Для всех функций Ксинпут требуется параметр *двусериндекс* , который передается для указания устанавливаемого или запрашиваемого контроллера. Этот идентификатор будет находиться в диапазоне 0-3 и автоматически задается Ксинпут. Число соответствует порту, в который подключен контроллер, и не может быть изменен.

Каждый контроллер отображает, какой идентификатор используется, выосвещения квадранта в «кольце света» в центре контроллера. Значение *двусериндекс* , равное 0, соответствует верхнему левому квадранту; Нумерация продолжается вокруг кольца в порядке по часовой стрелке.

Приложения должны поддерживать несколько контроллеров.

### <a name="getting-controller-state"></a>Получение состояния контроллера

В течение всего времени работы приложения получение состояния от контроллера, вероятно, будет выполняться чаще всего. Из фрейма в кадр в игровом приложении необходимо получить состояние и сведения об игре, обновленные для отражения изменений контроллера.

Чтобы получить состояние, используйте функцию [**ксинпутжетстате**](/windows/desktop/api/XInput/nf-xinput-xinputgetstate) :

```cpp
DWORD dwResult;    
for (DWORD i=0; i< XUSER_MAX_COUNT; i++ )
{
    XINPUT_STATE state;
    ZeroMemory( &state, sizeof(XINPUT_STATE) );

    // Simply get the state of the controller from XInput.
    dwResult = XInputGetState( i, &state );

    if( dwResult == ERROR_SUCCESS )
    {
        // Controller is connected
    }
    else
    {
        // Controller is not connected
    }
}
```

Обратите внимание, что возвращаемое значение [**ксинпутжетстате**](/windows/desktop/api/XInput/nf-xinput-xinputgetstate) можно использовать, чтобы определить, подключен ли контроллер. Приложения должны определять структуру для хранения сведений о внутреннем контроллере; Эти сведения следует сравнить с результатами **ксинпутжетстате** , чтобы определить, какие изменения, например нажатия кнопок или аналогового контроллера, были сделаны в кадре. В приведенном выше примере *g \_ Controllers* представляет такую структуру.

После того как состояние получено в структуре [**\_ состояния ксинпут**](/windows/desktop/api/XInput/ns-xinput-xinput_state) , его можно проверить на наличие изменений и получить конкретные сведения о состоянии контроллера.

Элемент *двпаккетнумбер* структуры [**\_ состояния ксинпут**](/windows/desktop/api/XInput/ns-xinput-xinput_state) можно использовать, чтобы проверить, изменилось ли состояние контроллера с момента последнего вызова [**ксинпутжетстате**](/windows/desktop/api/XInput/nf-xinput-xinputgetstate). Если *двпаккетнумбер* не меняется между двумя последовательными вызовами **ксинпутжетстате**, то состояние не изменилось. Если он отличается, приложение должно проверить элемент *планшета* в структуре **\_ состояния ксинпут** , чтобы получить более подробные сведения о состоянии.

По соображениям производительности не вызывайте [**ксинпутжетстате**](/windows/desktop/api/XInput/nf-xinput-xinputgetstate) для пустого слота пользователя в каждом кадре. Рекомендуется проделать проверки для новых контроллеров каждые несколько секунд.

### <a name="dead-zone"></a>Неработающая зона

Чтобы пользователи имели единообразный интерфейс игрового процесса, игра должна правильно реализовать неработающую зону. Недействующая зона — это значения перемещения, сообщаемые контроллером даже в том случае, если аналоговые сумбстиккс не были затронуты и центрированы. Существует также некоторая зона для двух аналоговых триггеров.

> [!Note]  
> Игры, использующие Ксинпут, которые не фильтруют неработающую зону, будут испытывать низкую игрового процессау. Обратите внимание, что некоторые контроллеры являются более важными, чем другие, поэтому неработающая зона может отличаться от единицы к единице. Рекомендуется тестировать игры с несколькими контроллерами Xbox в разных системах.

Приложения должны использовать "неработающие зоны" в аналоговых входах (триггеры, устройства), чтобы указать, когда перемещение было достаточно, чтобы подсчитаться допустимым.

Приложение должно проверить неработающие зоны и ответить на аппоприатели, как показано в следующем примере:

```cpp
XINPUT_STATE state = g_Controllers[i].state;

float LX = state.Gamepad.sThumbLX;
float LY = state.Gamepad.sThumbLY;

//determine how far the controller is pushed
float magnitude = sqrt(LX*LX + LY*LY);

//determine the direction the controller is pushed
float normalizedLX = LX / magnitude;
float normalizedLY = LY / magnitude;

float normalizedMagnitude = 0;

//check if the controller is outside a circular dead zone
if (magnitude > INPUT_DEADZONE)
{
    //clip the magnitude at its expected maximum value
    if (magnitude > 32767) magnitude = 32767;

    //adjust magnitude relative to the end of the dead zone
    magnitude -= INPUT_DEADZONE;

    //optionally normalize the magnitude with respect to its expected range
    //giving a magnitude value of 0.0 to 1.0
    normalizedMagnitude = magnitude / (32767 - INPUT_DEADZONE);
}
else //if the controller is in the deadzone zero out the magnitude
{
    magnitude = 0.0;
    normalizedMagnitude = 0.0;
}

//repeat for right thumb stick
```

В этом примере вычисляется вектор направления контроллера и расстояние от вектора, который был отправлен контроллером. Это позволяет принудительно применять циклическое деадзоне, просто проверяя, превышает ли величина контроллера значение деадзоне. Кроме того, код нормализует величину контроллера, которую затем можно умножить на фактор для определенной игры, чтобы преобразовать расположение контроллера в единицы, относящиеся к игре.

Обратите внимание, что вы можете определить собственные зоны для устройств и триггеров (в любом месте от 0-65534) или использовать предоставленный деадзонес, определенный как \_ левый игровой планшет ксинпут \_ \_ \_ деадзоне, ксинпут \_ игровой планшет, \_ правый \_ бегунок \_ и \_ \_ \_ пороговое значение триггера игровой планшет в деадзоне. h:

```cpp
#define XINPUT_GAMEPAD_LEFT_THUMB_DEADZONE  7849
#define XINPUT_GAMEPAD_RIGHT_THUMB_DEADZONE 8689
#define XINPUT_GAMEPAD_TRIGGER_THRESHOLD    30
```

После применения деадзоне может оказаться полезным масштабировать результирующий диапазон \[ 0,0.. 1.0 \] с плавающей запятой (как в примере выше) и при необходимости применить нелинейное преобразование.

Например, при работе с играми может быть полезно выполнить куб результата, чтобы лучше поработать с автомобилями с помощью игрового планшета, так как кубинг дает больше точности в нижних диапазонах, что желательно, так как игроки обычно применяют мягкую принудительную работу, чтобы получить незаметное перемещение или применить жесткое принудительное выполнение в одном направлении для получения ответа на Rd.

### <a name="setting-vibration-effects"></a>Установка эффектов вибрации

Помимо состояния контроллера, вы также можете отправить данные вибрации на контроллер, чтобы изменить отзыв, предоставленный пользователю контроллера. Контроллер содержит два румбленых мотора, которые можно независимо контролировать путем передачи значений в функцию [**ксинпутсетстате**](/windows/desktop/api/XInput/nf-xinput-xinputsetstate) .

Скорость каждого мотора может быть указана с помощью значения WORD в структуре [**\_ вибрации ксинпут**](/windows/desktop/api/XInput/ns-xinput-xinput_vibration) , которая передается в функцию [**ксинпутсетстате**](/windows/desktop/api/XInput/nf-xinput-xinputsetstate) следующим образом:

```cpp
XINPUT_VIBRATION vibration;
ZeroMemory( &vibration, sizeof(XINPUT_VIBRATION) );
vibration.wLeftMotorSpeed = 32000; // use any value between 0-65535 here
vibration.wRightMotorSpeed = 16000; // use any value between 0-65535 here
XInputSetState( i, &vibration );
```

Обратите внимание, что правый мотор является высокочастотным мотором, левый мотор — это двигатель с низкой частотой. Им не всегда нужно присвоить одинаковую сумму, так как они предоставляют различные эффекты.

### <a name="getting-audio-device-identifiers"></a>Получение идентификаторов звуковых устройств

Головной телефон для контроллера Xbox имеет следующие функции:

-   Запись звука с помощью микрофона
-   Воспроизведение звука с помощью наушников

Используйте этот код для получения идентификаторов устройств для гарнитуры:

```cpp
WCHAR renderId[ 256 ] = {0};
WCHAR captureId[ 256 ] = {0};
UINT rcount = 256;
UINT ccount = 256;

XInputGetAudioDeviceIds( i, renderId, &rcount, captureId, &ccount );
```

После получения идентификаторов устройств можно создать соответствующие интерфейсы. Например, если вы используете Ксаудио 2,8, используйте этот код для создания главной речи для этого устройства:

```cpp
IXAudio2* pXAudio2 = NULL;
HRESULT hr;
if ( FAILED(hr = XAudio2Create( &pXAudio2, 0, XAUDIO2_DEFAULT_PROCESSOR ) ) )
    return hr;

IXAudio2MasteringVoice* pMasterVoice = NULL;
if ( FAILED(hr = pXAudio2->CreateMasteringVoice( &pMasterVoice, XAUDIO2_DEFAULT_CHANNELS, XAUDIO2_DEFAULT_SAMPLERATE, 0, renderId, NULL, AudioCategory_Communications ) ) )
    return hr;
```

Сведения об использовании идентификатора устройства Каптуреид см. в разделе [запись потока](/windows/desktop/CoreAudio/capturing-a-stream).

### <a name="getting-directsound-guids-legacy-directx-sdk-only"></a>Получение идентификаторов GUID DirectSound (только для устаревших пакетов SDK DirectX)

Гарнитура, которую можно подключить к контроллеру Xbox, имеет две функции: она может записывать звук с помощью микрофона, а также воспроизводить звук с помощью наушников. В API Ксинпут эти функции выполняются через [DirectSound](/previous-versions/windows/desktop/ee416960(v=vs.85))с использованием интерфейсов **IDirectSound8** и **IDirectSoundCapture8** .

Чтобы связать микрофон и наушники гарнитуры с соответствующими интерфейсами [DirectSound](/previous-versions/windows/desktop/ee416960(v=vs.85)) , необходимо получить директсаундгуидс для записи и отрисовки устройств, вызвав [**ксинпутжетдсаундаудиодевицегуидс**](/windows/desktop/api/XInput/nf-xinput-xinputgetdsoundaudiodeviceguids).

> [!Note]  
> использование устаревшей [DirectSound](/previous-versions/windows/desktop/ee416960(v=vs.85)) не рекомендуется и недоступно в приложениях Windows Store. Сведения в этом разделе относятся только к версии пакета SDK для DirectX Ксинпут (Ксинпут 1,3). Windows 8 версия ксинпут (ксинпут 1,4) использует исключительно Windows идентификаторы устройств API аудио-сеансов (васапи), полученные через [**ксинпутжетаудиодевицеидс**](/windows/desktop/api/XInput/nf-xinput-xinputgetaudiodeviceids).

```cpp
XInputGetDSoundAudioDeviceGuids( i, &dsRenderGuid, &dsCaptureGuid );

```

После получения идентификаторов GUID можно создать соответствующие интерфейсы, вызвав DirectSoundCreate8 и DirectSoundCaptureCreate8 следующим образом:

```cpp
// Create IDirectSound8 using the controller's render device
if( FAILED( hr = DirectSoundCreate8( &dsRenderGuid, &pDS, NULL ) ) )
   return hr;

// Set coop level to DSSCL_PRIORITY
if( FAILED( hr = pDS->SetCooperativeLevel( hWnd, DSSCL_NORMAL ) ) )
   return hr;

// Create IDirectSoundCapture using the controller's capture device
if( FAILED( hr = DirectSoundCaptureCreate8( &dsCaptureGuid, &pDSCapture, NULL ) ) )
   return hr;
```

## <a name="related-topics"></a>Связанные темы

[Справочник по программированию](programming-reference.md)