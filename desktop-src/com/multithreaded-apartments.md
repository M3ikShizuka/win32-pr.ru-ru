---
title: Многопоточные подразделения
description: Многопоточные подразделения
ms.assetid: d3e6acd9-cd5c-4a2c-8526-4f43db3b606b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: dc2594f9341fc662b068fb7e007e538282a31273
ms.sourcegitcommit: 5f33645661bf8c825a7a2e73950b1f4ea0f1cd82
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/21/2020
ms.locfileid: "105681704"
---
# <a name="multithreaded-apartments"></a>Многопоточные подразделения

В многопоточной модели апартамента все потоки в процессе, которые были инициализированы как свободные, находятся в одном апартаменте. Поэтому нет необходимости выполнять маршалирование между потоками. Потокам не требуется получать и отправлять сообщения, так как COM не использует сообщения окна в этой модели.

Вызовы методов объектов в многопоточном апартаменте могут выполняться в любом потоке в апартаменте. Сериализация вызовов отсутствует; многие вызовы могут происходить с одним и тем же методом или с одним и тем же объектом одновременно. Объекты, созданные в многопоточном апартаменте, должны иметь возможность обрабатывать вызовы методов из других потоков в любое время.

Поскольку вызовы объектов не сериализуются каким-либо образом, параллельный параллелизм объектов обеспечивает наивысшую производительность и использует лучшее преимущество многопроцессорного оборудования для перекрестных потоков, кросс-процессов и вызовов между компьютерами. Это означает, однако, что код объектов должен обеспечивать синхронизацию в своих реализациях интерфейса, как правило, с помощью примитивов синхронизации, таких как объекты событий, критические разделы, мьютексы или семафоры, которые описаны далее в этом разделе. Кроме того, поскольку объект не управляет временем существования потоков, обращающихся к нему, в объекте (локальное хранилище потока) не может храниться состояние конкретного потока.

Ниже приведены некоторые важные соображения, касающиеся синхронизации многопоточных подразделения.

-   COM обеспечивает синхронизацию вызовов только для однопотоковых апартаментов.
-   Многопоточные подразделения не получают вызовы при выполнении вызовов (в одном потоке).
-   Многопоточные подразделения не могут выполнять синхронизированные входные вызовы.
-   Асинхронные вызовы преобразуются в синхронные вызовы в многопоточных апартаментах.
-   Фильтр сообщений не вызывается ни для одного потока в многопоточном апартаменте.

Чтобы инициализировать поток как свободный поток, вызовите [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex), указав \_ многопоточность. Сведения о потоковой работе сервера в процессе см. [в разделе проблемы потоковой](in-process-server-threading-issues.md)обработки на сервере.

Несколько клиентов могут одновременно вызывать, из разных потоков, объект, поддерживающий свободную потоковую связь. В свободных потоках внешние серверы, COM, через подсистему RPC создает пул потоков в серверном процессе и клиентский вызов (или несколько клиентских вызовов) может быть доставлен любым из этих потоков в любое время. Сервер вне процесса должен также реализовать синхронизацию в своей фабрике классов. В свободных потоках внутрипроцессный объект может принимать прямые вызовы из нескольких потоков клиента.

Клиент может работать с COM в нескольких потоках. Все потоки принадлежат одному и тому же многопоточному подразделению. Указатели интерфейса передаются непосредственно из потока в поток в многопоточном апартаменте, поэтому указатели интерфейса не маршалируются между своими потоками. Фильтры сообщений (реализации [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter)) не используются в многопоточных подразделениях. Клиентский поток будет приостановлен при вызове COM-вызова объектов, находящихся вне апартамента, и возобновляться при возврате вызова. Вызовы между процессами по-прежнему обрабатываются RPC.

Потоки, инициализированные с моделью в свободной потоковой модели, должны реализовывать собственную синхронизацию. Как упоминалось ранее в этом разделе, Windows включает эту реализацию с помощью следующих примитивов синхронизации:

-   Объекты событий предоставляют способ сигнализации одного или нескольких потоков о произошедшем событии. Любой поток в процессе может создать объект события. Маркер события возвращается функцией создания события [**CreateEvent**](/windows/desktop/api/synchapi/nf-synchapi-createeventa). После создания объекта события потоки с маркером объекта могут ожидать его до продолжения выполнения.
-   Критические разделы используются для раздела кода, который требует эксклюзивного доступа к определенному набору общих данных, прежде чем его можно будет выполнить и использовать только в потоках одного процесса. Критическая секция похожа на пересчет, через который может пройти только один поток за раз. он работает следующим образом:
    -   Чтобы гарантировать, что ни один поток за раз обращается к общим данным, основной поток процесса выделяет глобальную КРИТическую \_ структуру данных секции и инициализирует ее члены. Поток, поступающий в критическую секцию, вызывает функцию [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) и изменяет элементы структуры данных.
    -   Поток, пытающийся войти в критическую секцию, вызывает [**EnterCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-entercriticalsection) , который проверяет, была ли \_ изменена структура данных критической секции. В этом случае другой поток находится в критическом разделе, а следующий поток помещается в спящий режим. Поток, который выходит из критической секции, вызывает [**LeaveCriticalSection**](/windows/desktop/api/synchapi/nf-synchapi-leavecriticalsection), который сбрасывает структуру данных. Когда поток покидает критическую секцию, система пробуждает один из спящих потоков, который затем входит в критическую секцию.
-   Мьютексы выполняют ту же функцию, что и критическая секция, за исключением того, что мьютекс доступен для потоков, выполняющихся в разных процессах. Владелец объекта Mutex похож на пол в споре. Процесс создает объект мьютекса, вызывая функцию [**CreateMutex**](/windows/desktop/api/synchapi/nf-synchapi-createmutexa) , которая возвращает маркер. Первый поток, запрашивающий объект Mutex, получает его владение. Когда поток завершился с мьютексом, владение передается другим потокам на основе первого поступления.
-   Семафоры используются для поддержания счетчика ссылок на некоторый доступный ресурс. Поток создает семафор для ресурса, вызывая функцию [**createsemaphore-**](/windows/desktop/api/winbase/nf-winbase-createsemaphorea) и передавая указатель на ресурс, начальное число ресурсов и максимальное число ресурсов. Эта функция возвращает маркер. Поток, запрашивающий ресурс, передает его обработчик семафора в вызове функции [**WaitForSingleObject**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) . Объект семафора опрашивает ресурс, чтобы определить, доступен ли он. В этом случае семафор уменьшает число ресурсов и пробуждает ожидающий поток. Если значение счетчика равно нулю, поток остается в спящем режиме до тех пор, пока другой поток не освободит ресурс, в результате чего семафор увеличит число до одного.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Доступ к интерфейсам в разных апартаментах](accessing-interfaces-across-apartments.md)
</dt> <dt>

[Выбор потоковой модели](choosing-the-threading-model.md)
</dt> <dt>

[Проблемы потоковой обработки в процессе сервера](in-process-server-threading-issues.md)
</dt> <dt>

[Процессы, потоки и подразделения](processes--threads--and-apartments.md)
</dt> <dt>

[Однопотоковое и многопоточное взаимодействие](single-threaded-and-multithreaded-communication.md)
</dt> <dt>

[Подразделения с одним потоком](single-threaded-apartments.md)
</dt> </dl>

 

 