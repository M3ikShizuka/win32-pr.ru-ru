---
title: Связь Inter-Object
description: Модель COM разработана таким образом, чтобы клиенты могли прозрачно взаимодействовать с объектами независимо от того, где они выполняются в одном процессе, на одном компьютере или на другом компьютере.
ms.assetid: dd4adafb-a7e4-44ba-ae4a-80585875ecb6
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d49d3d584ba6aa25a721276559a65ca2f9f9deded76616b93ff9953affce3553
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "120070834"
---
# <a name="inter-object-communication"></a>Связь Inter-Object

Модель COM разработана таким образом, чтобы клиенты могли прозрачно взаимодействовать с объектами, независимо от того, где эти объекты являются руннингâ, в одном и том же процессе, на одном компьютере или на другом компьютере. Это обеспечивает единую модель программирования для всех типов объектов, а также для клиентов объектов и серверов объектов.

С точки зрения клиента доступ ко всем объектам осуществляется через указатели интерфейса. Указатель должен быть внутри процесса. Фактически любой вызов функции интерфейса всегда достигает некоторого фрагмента внутрипроцессного кода. Если объект находится внутри процесса, вызов напрямую достигает него без промежуточного кода инфраструктуры системы. Если объект находится вне процесса, вызов сначала достигает того, что называется прокси-объектом, предоставляемым COM или объектом (если это необходимо для реализации). Пакеты прокси-сервера вызывают параметры (включая все указатели интерфейсов) и создают соответствующий удаленный вызов процедуры (или другой механизм связи в случае настраиваемых прокси-серверов) для другого процесса или другого компьютера, на котором находится реализация объекта. Этот процесс упаковки указателей для передачи через границы процесса называется *упаковкой*.

С точки зрения сервера все вызовы функций интерфейса объекта выполняются через указатель на этот интерфейс. Опять же, указатель имеет контекст только в одном процессе, и вызывающий объект всегда должен быть частью внутрипроцессного кода. Если объект находится в процессе, вызывающий является сам клиент. В противном случае вызывающий объект является объектом-заглушкой, предоставляемым либо COM, либо самим объектом. Заглушка получает удаленный вызов процедуры (или другой механизм связи в случае настраиваемых прокси-серверов) от "прокси" в клиентском процессе, расмаршалирует параметры и вызывает соответствующий интерфейс в объекте сервера. С точки зрения клиентов и серверов они всегда взаимодействуют напрямую с каким-либо другим внутрипроцессный код.

COM обеспечивает реализацию маршалирования, называемую *стандартным упаковкой*. Эта реализация очень хорошо работает для большинства объектов и значительно сокращает требования к программированию, делая процесс упаковки эффективным прозрачным.

Тем не менее, четкое разделение интерфейса от реализации прозрачности процесса COM может быть получено в некоторых ситуациях. Структура интерфейса, нацеленного на свою функцию с точки зрения клиента, иногда может привести к проектированию решений, которые конфликтуют с эффективной реализацией этого интерфейса в сети. В таких случаях, что требуется, не является чисто прозрачным процессом, но «обработка прозрачности», если не требуется. COM предоставляет эту возможность, позволяя разработчику объектов поддерживать *Пользовательский маршалирование* (также называемый [**IMarshal**](/windows/win32/api/objidlbase/nn-objidlbase-imarshal) упаковкой). Стандартная упаковка на самом деле является экземпляром пользовательского маршалирования; Это реализация по умолчанию, используемая, когда объекту не требуется пользовательская упаковка.

Можно реализовать настраиваемую упаковку, чтобы объект мог принимать различные действия при использовании из сети, чем при локальном доступе, и он полностью прозрачен для клиента. Эта архитектура позволяет разрабатывать интерфейсы клиента и объекта без проблем с производительностью сети, а затем в дальнейшем устранять проблемы с производительностью сети, не нарушая установленный проект.

COM не указывает, как структурированы компоненты. Он указывает, как они взаимодействуют. COM оставляет сведения о внутренней структуре компонента для языков программирования и сред разработки. И наоборот, в средах программирования нет установленных стандартов для работы с объектами за пределами немедленного приложения. Microsoft Visual C++, например, очень хорошо работает для манипулирования объектами внутри приложения, но не поддерживает работу с объектами вне приложения. Как правило, все остальные языки программирования одинаковы в этом отношении. Таким образом, чтобы обеспечить взаимодействие готовность, COM, через независимые от языка интерфейсы, выбирает, где не выходит языки программирования.

Двойное косвенное обращение к структуре VTBL означает, что указатели в таблице указателей функций не должны указывать непосредственно на реальную реализацию в реальном объекте. Это основа прозрачности процесса.

Для внутрипроцессного сервера, где объект загружается непосредственно в клиентский процесс, указатели функций в таблице указывают непосредственно на фактическую реализацию. В этом случае вызов функции от клиента к методу интерфейса напрямую передает управление выполнением методу. Однако это не может работать для локальных и удаленных объектов, так как указатели на память не могут совместно использоваться процессами. Тем не менее, клиент должен иметь возможность вызывать методы интерфейса, как если бы он вызывал фактическую реализацию. Таким образом, клиент равномерно передает управление методу в некоторый объект, делая вызов.

Клиент всегда вызывает методы интерфейса в некоторых внутрипроцессный объект. Если фактический объект является локальным или удаленным, выполняется вызов прокси-объекта, который затем выполняет удаленный вызов процедуры к фактическому объекту.

Так какой же метод фактически выполняется? Ответ заключается в том, что при вызове необработанного интерфейса каждый метод интерфейса реализуется прокси-объектом. Прокси-объект всегда является внутрипроцессный объект, который действует от имени вызываемого объекта. Этот прокси-объект знает, что фактический объект выполняется на локальном или удаленном сервере.

Прокси-объект упаковывает параметры функции в некоторые пакеты данных и создает вызов RPC к локальному или удаленному объекту. Этот пакет забирается объектом-заглушкой в процессе сервера на локальном или удаленном компьютере, который распаковать параметры и вызовет реальную реализацию метода. Когда эта функция возвращает, заглушка упаковывает все выходные параметры и возвращаемое значение и отправляет их обратно прокси-серверу, который распаковать их и вернет к исходному клиенту.

Таким образом, клиент и сервер всегда взаимодействуют друг с другом, как если бы все выполнялось в процессе. Все вызовы клиента и все вызовы сервера в какой-то момент находятся в процессе. Но поскольку структура VTBL позволяет некоторым агентам, например COM, перехватывать все вызовы функций и возвратить из функций, этот агент может перенаправлять эти вызовы в вызов RPC по мере необходимости. Хотя вызовы внутри процесса выполняются быстрее, чем необработанные вызовы, различия в процессах полностью прозрачны для клиента и сервера.

Дополнительные сведения см. в следующих разделах:

-   [Сведения о маршалировании](marshaling-details.md)
-   [Прокси](proxy.md)
-   [Заглушка](stub.md)
-   [Канал](channel.md)
-   [Microsoft RPC](microsoft-rpc.md)

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[COM-клиенты и серверы](com-clients-and-servers.md)
</dt> <dt>

[Маршалирование интерфейса](interface-marshaling.md)
</dt> </dl>

 

 