---
title: Маскировка (COM)
description: Маскировка — это возможность обеспечения безопасности COM, которая определяет, какие идентификаторы клиентские проекты применяют к серверу во время олицетворения.
ms.assetid: 5b97d9d6-8fa9-4da2-8351-64772227d9a2
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 588651cfa37def4e174ef0f2fdba9b79b0c60ca8
ms.sourcegitcommit: 9eebab0ead09cecdbc24f5f84d56c8b6a7c22736
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/10/2021
ms.locfileid: "124369546"
---
# <a name="cloaking-com"></a>Маскировка (COM)

Маскировка — это возможность обеспечения безопасности COM, которая определяет, какие идентификаторы клиентские проекты применяют к серверу во время олицетворения. Когда задается маскировка, промежуточный сервер маскирует свое собственное удостоверение и передает удостоверение клиента серверу, который он вызывает от имени клиента. Практически удостоверение клиента, отображаемое сервером, — это удостоверение, связанное с прокси. Удостоверение прокси-сервера определяется несколькими факторами, одним из которых является заданный тип маскировки (если таковой имеется). В поставщике безопасности SChannel не поддерживается маскировка.

В следующих разделах приводятся дополнительные сведения о маскировке.

-   [Типы маскировки](#types-of-cloaking)
-   [Влияние маскировки на удостоверение клиента](#how-cloaking-affects-client-identity)
-   [Настройка маскировки](#setting-cloaking)
-   [Уровни маскировки и олицетворения](#cloaking-and-impersonation-levels)
-   [Сценарии маскировки](#cloaking-scenarios)
-   [Связанные разделы](#related-topics)

## <a name="types-of-cloaking"></a>Типы маскировки

Существует два типа маскировки: *статическая* маскировка и *Динамическая* маскировка:

-   При статическом скрытии (ЕОАК \_ static \_ маскировка) сервер видит маркер потока от первого вызова клиента серверу. Для первого вызова, если удостоверение прокси-сервера было ранее задано во время вызова [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket), используется удостоверение прокси-сервера. Однако если удостоверение прокси-сервера не было задано ранее, используется токен потока. Если токен потока отсутствует, используется токен процесса. Для всех будущих вызовов используется удостоверение, заданное при первом вызове.
-   При динамическом маскировке (ЕОАК \_ Dynamic \_ маскировка) при каждом вызове для определения удостоверения клиента используется текущий маркер потока (если имеется токен потока). Если токен потока отсутствует, используется токен процесса. Это означает, что серверы, вызываемые от имени клиента во время олицетворения, видят идентификатор клиента COM, который вызвал вызов, что обычно является требуемым поведением. (Конечно, чтобы олицетворение завершилось успешно, клиент должен был предоставить ему право на олицетворение, установив соответствующий уровень олицетворения. Дополнительные сведения см. в разделе [уровни олицетворения](impersonation-levels.md).) Этот тип маскировки является дорогостоящим.

## <a name="how-cloaking-affects-client-identity"></a>Влияние маскировки на удостоверение клиента

Когда выполняется зашифрованный вызов и сервер запрашивает у клиента удостоверение, обычно он получает удостоверение, привязанное к прокси-серверу. (Иногда служба проверки подлинности выполняет перевод из реальной идентификации, но обычно удостоверение прокси-сервера — это удостоверение, которое видит сервер.) Прокси-сервер предоставляет удостоверение серверу, который зависит от типа заданной маскировки и других факторов.

Для суммирования удостоверение клиента является функцией флага маскировки, маркером процесса, присутствием или отсутствием маркера потока, а также от того, было ли ранее задано удостоверение прокси-сервера. В следующей таблице показана результирующая идентификация прокси-сервера (удостоверение клиента), если эти факторы различаются.



| Флаги маскировки                     | Присутствие токена потока  | Удостоверение прокси-сервера задано ранее | Удостоверение прокси-сервера (удостоверение клиента)                    |
|------------------------------------|------------------------|-------------------------------|-----------------------------------------------------|
| Маскировка не задана<br/>        | Не заботиться<br/>  | Не заботиться<br/>         | Маркер процесса или удостоверение проверки подлинности<br/> |
| ЕОАК \_ статическая \_ маскировка<br/>  | Присутствует<br/>     | Нет<br/>                 | Токен потока<br/>                             |
| ЕОАК \_ статическая \_ маскировка<br/>  | Присутствует<br/>     | Да<br/>                | Текущее удостоверение прокси-сервера<br/>                   |
| ЕОАК \_ статическая \_ маскировка<br/>  | Отсутствует<br/> | Нет<br/>                 | Токен процесса<br/>                            |
| ЕОАК \_ статическая \_ маскировка<br/>  | Отсутствует<br/> | Да<br/>                | Текущее удостоверение прокси-сервера<br/>                   |
| \_динамическое \_ МАСКИРОВКа еоак<br/> | Присутствует<br/>     | Не заботиться<br/>         | Токен потока<br/>                             |
| \_динамическое \_ МАСКИРОВКа еоак<br/> | Отсутствует<br/> | Не заботиться <br/>        | Токен процесса<br/>                            |



 

В следующей блок-схеме показано, как удостоверение прокси определяется в различных ситуациях.

![Схема, показывающая последовательность для определения удостоверения прокси-сервера.](images/9e8409b7-8475-4824-bdff-cf6b09c139c5.png)

## <a name="setting-cloaking"></a>Настройка маскировки

Маскировка устанавливается как флаг возможности в вызове [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity), который задает маскировку для всего процесса. Затем функция маскировки устанавливается до тех пор, пока клиент не изменит его с помощью вызова Иклиентсекурити::[**сетбланкет**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket) (или для [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket)), который задает маскировку для прокси-сервера.

По умолчанию маскировка не задана. Чтобы задать его, передайте \_ еоак \_ статическую маскировку или еоак \_ динамическую \_ маскировку в параметр *пкапабилитиес* в [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) или [**сетбланкет**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket).

Если статическая Маскировка включена с помощью [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity), каждый прокси-сервер принимает маркер (поток или процесс) при первом вызове на прокси-сервере. Если статическая Маскировка включена с помощью [**сетбланкет**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket), прокси-сервер выбирает в это время маркер в потоке. Если маркер потока недоступен при вызове **сетбланкет** , маркер процесса используется для удостоверения прокси-сервера. По сути, **сетбланкет** исправляет удостоверение прокси-сервера.

При динамическом маскировке удостоверение прокси-сервера определяется таким же образом независимо от того, задано ли динамическое маскировка с помощью [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) или [**сетбланкет**](/windows/win32/api/objidl/nf-objidl-iclientsecurity-setblanket). Текущий токен потока используется при его наличии; в противном случае используется токен процесса.

Если маскировка задана для всего процесса с помощью вызова [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) и необходимо выполнить вызовы с маркером процесса, не олицетворять во время вызовов.

## <a name="cloaking-and-impersonation-levels"></a>Уровни маскировки и олицетворения

Как упоминалось ранее, функция маскировки определяет, какое удостоверение будет представлено серверу во время олицетворения. Маскировка позволяет серверу проецировать идентификатор, отличный от собственного, на другой сервер, который вызывается от имени клиента. Уровень олицетворения указывает, сколько полномочий клиент предоставил серверу.

Олицетворение без маскировки работает, но может быть не лучшим выбором, так как в некоторых случаях окончательный сервер должен идентифицировать удостоверение начального вызывающего. Это невозможно сделать без использования маскировки, так как трудно убедиться, что доступ к удаленному компьютеру имеют только полномочные клиенты. Если олицетворение используется без маскировки, то удостоверение, представленное для подчиненного сервера, заключается в том, что вызывает немедленно вызывающий процесс.

Однако маскировка не полезна без олицетворения. Маскировка имеет смысл только в том случае, если клиент установил уровень олицетворения олицетворения или делегата. (С более низким уровнем олицетворения сервер не может делать немаскированные вызовы.) Успешная маскировка зависит от количества перекрестных границ компьютеров и от уровня олицетворения, который указывает, какой уровень полномочий должен выполнять сервер от имени клиента.

В некоторых ситуациях сервер имеет смысл установить маскировку, когда клиент устанавливает уровень олицетворения на уровне RPC C, выполняющего \_ \_ \_ \_ олицетворение. Однако действуют некоторые ограничения. Если исходный клиент устанавливает уровень олицетворения для \_ \_ олицетворения на уровне RPC C \_ \_ , промежуточный сервер (действующий как клиент на том же компьютере) может быть замаскирован только на один компьютер. Это обусловлено тем, что токен олицетворения на уровне олицетворения может передаваться только на один компьютер. После перекрестной границы компьютера доступ к локальным ресурсам возможен только для локальных ресурсов. Удостоверение, представленное серверу, зависит от типа заданной маскировки. Если маскировка не задана, удостоверение, представленное серверу, будет таким же, как и процесс, выполняющий немедленное обращение.

Для маскировки на нескольких компьютерах необходимо указать как соответствующий флаг возможностей маскировки, так и олицетворение на уровне делегата. При таком типе олицетворения как локальные, так и сетевые учетные данные клиента предоставляются серверу, поэтому маркер олицетворения может пересекать любое количество компьютеров. Опять же, удостоверение, представленное серверу, зависит от типа заданной маскировки. Если для олицетворения на уровне делегата не задана маскировка, удостоверение, представленное на сервере, состоит в том, что процесс, выполняющий вызов.

Например, предположим, что обработка вызовов B, а B вызывает C. B, установила маскировку, а параметр олицетворения имеет значение IMPERSONATE. Если A, B и C находятся на одном и том же компьютере, передача токена олицетворения из A в B и затем в C будет работать. Но если A и C находятся на одном и том же компьютере, а B — нет, передача маркера будет работать между A и B, но не с B на C. Вызов из B в C будет невозможен, так как B не может вызвать C во время маскировки. Однако если объект устанавливает уровень олицетворения, он может быть передан из B в C, а вызов может быть выполнен успешно.

## <a name="cloaking-scenarios"></a>Сценарии маскировки

На следующем рисунке обработка вызова B вызывает C, вызывает D, если маскировка не задана. В результате каждый промежуточный процесс видит удостоверение процесса, вызвавшего его.

![Схема, показывающая процесс, когда скрытие не задано.](images/0d2eb6cf-97d6-4c4e-b97e-abad854b1120.png)

При статической маскировке сервер видит удостоверение прокси-сервера, которое было задано при первом вызове от клиента к серверу. На следующем рисунке показан пример удостоверения прокси-сервера, устанавливаемого во время вызова из B в C. При последующем вызове Process D видит удостоверение B, если статическая маскировка задана в B и C.

![Схема, на которой показан процесс статического маскирования.](images/520938e0-c4a6-4ac1-937d-02baf2007a27.png)

При использовании динамической маскировки удостоверение вызывающего объекта во время олицетворения основано на текущем маркере потока, если таковой имеется. На следующем рисунке показана ситуация, когда B и C Set Dynamic маскировка и D видят удостоверение объекта, несмотря на более ранний вызов из B в C.

![Схема, на которой показан процесс динамической маскировки.](images/d0848465-82f3-4d5a-851e-566d7800ada0.png)

## <a name="related-topics"></a>Связанные разделы

<dl> <dt>

[Делегирование и олицетворение](delegation-and-impersonation.md)
</dt> </dl>

 

