---
title: Реализации интерфейсов и интерфейсов
description: COM делает фундаментальное различие между определениями интерфейсов и их реализациями.
ms.assetid: f50b3e8f-bf87-4525-b47b-96e75b3a05b9
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bee00521b847acbd063f1cd7ad84a0eb231f78d7bd274b7a4658996dbdd61150
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119992704"
---
# <a name="interfaces-and-interface-implementations"></a>Реализации интерфейсов и интерфейсов

COM делает фундаментальное различие между определениями интерфейсов и их реализациями.

*Интерфейс* фактически является контрактом, состоящим из группы связанных прототипов функций, использование которых определено, но его реализация не имеет. Эти прототипы функций эквивалентны чисто виртуальным базовым классам в программировании на C++. Определение интерфейса определяет функции элементов интерфейса, называемые *методами*, типы возвращаемых данных, число и типы их параметров, а также то, что они должны делать. Нет реализации, связанной с интерфейсом.

*Реализация интерфейса* — это код, предоставляемый программистом для выполнения действий, указанных в определении интерфейса. Реализации многих интерфейсов, которые программист может использовать в приложении на основе объектов, включены в библиотеки COM. Однако программисты могут игнорировать эти реализации и написать свои собственные. Реализация интерфейса должна быть связана с объектом при создании экземпляра этого объекта, а реализация предоставляет службы, предлагаемые объектом.

Например, гипотетический интерфейс с именем "noreturn" может определять два метода: Push и POP, которые указывают, что последовательные вызовы метода Pop возвращают в обратном порядке значения, ранее переданные методу Push. Это определение интерфейса не будет указывать, как функции должны быть реализованы в коде. При реализации интерфейса один программист может реализовать стек как массив и реализовать методы push и POP таким образом, чтобы получить доступ к этому массиву, тогда как другой программист может использовать связанный список и реализовать соответствующие методы. Независимо от конкретной реализации методов push и POP, в памяти представление указателя на интерфейс «гвоздика» и, следовательно, его использование клиентом, полностью определяется определением интерфейса.

Простые объекты поддерживают только один интерфейс. Более сложные объекты, такие как внедряемые объекты, обычно поддерживают несколько интерфейсов. Клиенты имеют доступ к COM-объекту только через указатель на один из его интерфейсов, который, в свою очередь, позволяет клиенту вызывать любой из методов, составляющих этот интерфейс. Эти методы определяют, как клиент может использовать данные объекта.

Интерфейсы определяют контракт между объектом и его клиентами. В контракте указываются методы, которые должны быть связаны с каждым интерфейсом, и поведение каждого из этих методов должно быть в терминах ввода и вывода. Контракт обычно не определяет, как реализовать методы в интерфейсе. Еще один важный аспект контракта заключается в том, что если объект поддерживает интерфейс, он должен поддерживать все методы этого интерфейса каким-либо образом. Не все методы в реализации должны выполнять какие-либо действия. Если объект не поддерживает функцию, подразумеваемую методом, его реализация может быть простым возвратом или, возможно, возвратом осмысленного сообщения об ошибке, но методы должны существовать.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[COM-объекты и интерфейсы](com-objects-and-interfaces.md)
</dt> </dl>

 

 




