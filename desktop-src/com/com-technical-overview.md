---
title: Технический обзор COM
ms.assetid: 519c87cc-b442-4187-af2a-124a1e4e8b49
description: 'Дополнительные сведения: технический обзор COM'
keywords:
- COM технического обзора com
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: be5dc95ffae5166d86cd8110cab1a6b90e6ffa5c
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "104141390"
---
# <a name="com-technical-overview"></a>Технический обзор COM

В этом разделе приводятся общие сведения об объектной модели компонентов (COM) Microsoft.

-   [Введение в модель COM](#introduction-to-com)
-   [Объекты и интерфейсы](#objects-and-interfaces)
-   [Реализация интерфейса](#interface-implementation)
-   [Интерфейс IUnknown](#the-iunknown-interface)
-   [Модель "клиент-сервер"](#the-clientserver-model)
-   [Диспетчер служб](#service-control-manager)
-   [Возможность многократного использования](#reusability)
-   [Объекты хранилища и потока](#storage-and-stream-objects)
-   [Передача данных](#data-transfer)
-   [Удаленное взаимодействие](#remoting)
-   [Безопасность](#security)
-   [См. также](#related-topics)

## <a name="introduction-to-com"></a>Введение в модель COM

Модель COM определяет двоичный стандарт взаимодействия для создания многократно используемых библиотек программного обеспечения, взаимодействующих во время выполнения. Вы можете использовать библиотеки COM без необходимости их компиляции в приложение. COM — это основа для ряда продуктов и технологий Майкрософт, таких как проигрыватель Windows Media и Windows Server.

Модель COM определяет двоичный стандарт, который применяется ко многим операционным системам и аппаратным платформам. Для сетевых вычислений COM определяет стандартный формат подключения и протокол для взаимодействия между объектами, которые выполняются на разных аппаратных платформах. COM не зависит от языка реализации. Это означает, что вы можете создавать библиотеки COM с помощью различных языков программирования, таких как C++ и платформа .NET Framework.

Спецификация COM предоставляет все фундаментальные концепции, обеспечивающие многократное использование межплатформенного программного обеспечения.

-   Двоичный стандарт для вызовов функций между компонентами.
-   Предоставление строго типизированных группирований функций в интерфейсах.
-   Базовый интерфейс, обеспечивающий полиморфизм, обнаружение компонентов и отслеживание времени существования объектов.
-   Механизм, однозначно определяющий компоненты и их интерфейсы.
-   Загрузчик компонента, который создает экземпляры компонентов из развертывания.

Модель COM состоит из нескольких частей, которые совместно позволяют создавать приложения, основанные на повторно используемых компонентах:

-   *Система узла* , предоставляющая среду выполнения, которая соответствует спецификации COM.
-   *Интерфейсы* , определяющие контракты функций и *компоненты* , реализующие интерфейсы.
-   *Серверы* , предоставляющие компоненты системе, и *Клиенты* , использующие функции, предоставляемые компонентами.
-   *Реестр* , который отслеживает, где разворачиваются компоненты на локальном и удаленном узлах.
-   *Диспетчер управления службами* , который находит компоненты на локальных и удаленных узлах и подключает серверы к клиентам.
-   Протокол *структурированного хранилища* , определяющий способ перемещения по содержимому файлов в файловой системе узла.

Включение повторного использования кода на разных узлах и платформах является центральным для COM. Реализация интерфейса с возможностью повторного использования называется *компонентом*, *объектом компонента* или *COM-объектом*. Компонент реализует один или несколько интерфейсов COM.

Пользовательская библиотека COM определяется путем проектирования интерфейсов, реализуемых библиотекой. Потребители библиотеки могут обнаруживать и использовать ее функции, не зная сведений о развертывании и реализации вашей библиотеки.

## <a name="objects-and-interfaces"></a>Объекты и интерфейсы

COM-объект предоставляет свои возможности через *интерфейс*, который представляет собой коллекцию функций-членов. COM-интерфейс определяет ожидаемое поведение и обязанности компонента, а также указывает строго типизированный контракт, предоставляющий небольшой набор связанных операций. Все взаимодействие между компонентами COM осуществляется через интерфейсы, а все службы, предлагаемые компонентом, предоставляются через его интерфейс. Вызывающий объект может обращаться только к функциям-членам интерфейса. Внутреннее состояние недоступно для вызывающего объекта, если оно не представлено в интерфейсе.

Интерфейсы строго типизированы. Каждый интерфейс имеет собственный уникальный идентификатор интерфейса с именем IID, который устраняет конфликты, которые могут возникнуть при работе с понятными для человека именами. IID — это глобальный уникальный идентификатор (GUID), который совпадает с универсальным уникальным ИДЕНТИФИКАТОРом (UUID), определенным в распределенной вычислительной среде (использование) Open Software Foundation (DCE). При создании нового интерфейса необходимо создать новый идентификатор для этого интерфейса. Когда вызывающий объект использует интерфейс, он должен использовать уникальный идентификатор. Эта явная идентификация повышает надежность, устраняя конфликты имен, которые могут привести к сбою во время выполнения.

При определении нового интерфейса можно создать определение интерфейса с помощью языка определения интерфейса (IDL). Из этого определения интерфейса компилятор Microsoft IDL создает файлы заголовков для использования приложениями, использующими интерфейс, и исходный код для обработки удаленных вызовов процедур. IDL, предоставляемый корпорацией Майкрософт, основан на простых расширениях для DCE IDL, промышленном стандарте для распределенных вычислений на основе удаленного вызова процедур (RPC). IDL является средством для удобства работы с конструктором интерфейсов и не является центральным для COM-взаимодействия. При использовании IDL не требуется создавать файлы заголовков вручную для каждой среды программирования. Дополнительные сведения см. в разделе [Определение COM-интерфейсов](defining-com-interfaces.md).

Наследование используется реже в COM-интерфейсах. Модель COM поддерживает наследование интерфейса только для повторного использования контракта, связанного с базовым интерфейсом. COM не поддерживает выборочное наследование; Таким образом, если один интерфейс наследуется от другого, он включает все функции, определяемые базовым интерфейсом. Кроме того, интерфейсы используют только одиночное наследование, а не множественное наследование для получения функций из базового интерфейса.

## <a name="interface-implementation"></a>Реализация интерфейса

Невозможно самостоятельно создать экземпляр COM-интерфейса. Вместо этого создается экземпляр класса, который реализует интерфейс. В C++ COM-интерфейс моделируется как *абстрактный базовый класс*, что означает, что интерфейс является классом C++, который содержит только чистые виртуальные функции-члены. Библиотека C++ реализует COM-объекты, наследуя сигнатуры функций членов из одного или нескольких интерфейсов, переопределяя каждую функцию-член и предоставляя реализацию для каждой функции.

Для реализации COM-интерфейса можно использовать любой язык программирования, поддерживающий концепцию указателей на функции. Например, в языке C интерфейсом является структура, содержащая указатель на таблицу указателей на функцию, по одному для каждого метода в интерфейсе.

При реализации интерфейса класс должен предоставлять реализацию для каждой функции в интерфейсе. Если класс не работает в функции интерфейса, реализация может быть единственной инструкцией return.

Класс COM определяется с помощью уникального 128-разрядного класса (CLSID), связывающего класс с определенным развертыванием в файловой системе, для Windows — DLL или EXE. CLSID — это идентификатор GUID, который означает, что ни один из других классов не имеет такого же идентификатора CLSID. Использование уникальных идентификаторов классов предотвращает конфликты имен между классами. Например, два разных поставщика могут написать класс с именем Кстакк, но оба класса имеют уникальный идентификатор CLSID, что позволяет избежать возникновения конфликта.

Получить новый идентификатор CLSID можно с помощью функции [**CoCreateGuid**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateguid) или средства разработки COM, такого как Visual Studio, которое вызывает эту функцию внутренним образом.

## <a name="the-iunknown-interface"></a>Интерфейс IUnknown

Все COM-интерфейсы наследуют от интерфейса [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) . Интерфейс **IUnknown** содержит фундаментальные операции com для управления полиморфизмом и временем существования экземпляра. Интерфейс **IUnknown** имеет три функции члена с именами [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)), [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref)и [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release). Все COM-объекты необходимы для реализации интерфейса **IUnknown** .

Функция-член [**QueryInterface**](/windows/desktop/api/Unknwn/nf-unknwn-iunknown-queryinterface(q)) предоставляет полиморфизм для com. Вызовите метод **QueryInterface** , чтобы определить во время выполнения, поддерживает ли COM-объект определенный интерфейс. COM-объект возвращает указатель интерфейса в `ppvObject` параметре, если он реализует запрошенный интерфейс, в противном случае возвращает `NULL` . Функция-член **QueryInterface** позволяет осуществлять навигацию по всем интерфейсам, которые поддерживает объект COM.

Время существования экземпляра COM-объекта определяется по *счетчику ссылок*. Элемент [**IUnknown**](/windows/desktop/api/Unknwn/nn-unknwn-iunknown) функции [**AddRef**](/windows/win32/api/unknwn/nf-unknwn-iunknown-addref) и [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) контролируют счетчик. **AddRef** увеличивает значение счетчика и **выпуска** уменьшает число. Если счетчик ссылок достигает нуля, функция-член **выпуска** может освободить экземпляр, так как он не использует вызывающие объекты.

## <a name="the-clientserver-model"></a>Модель "клиент-сервер"

COM-класс реализует ряд COM-интерфейсов. Реализация состоит из двоичных файлов, которые выполняются, когда вызывающий объект взаимодействует с экземпляром класса COM. COM позволяет использовать класс в различных приложениях, включая приложения, написанные без знания конкретного класса. На платформе Windows классы существуют либо в динамической библиотеке (DLL), либо в другом приложении (EXE).

В своей системе размещения COM поддерживает базу данных регистрации всех идентификаторов CLSID для COM-объектов, установленных в системе. База данных регистрации — это сопоставление между каждым идентификатором CLSID и расположением библиотеки DLL или EXE, в котором находится соответствующий класс. COM запрашивает эту базу данных каждый раз, когда вызывающий объект хочет создать экземпляр класса COM. Вызывающему объекту необходимо получить сведения только об идентификаторе CLSID, чтобы запросить новый экземпляр класса.

Взаимодействие между COM-объектом и его вызывающими объектами моделируется как отношение "клиент-сервер". Клиент является вызывающим объектом, который запрашивает COM-объект из системы, а сервер является модулем, предоставляющим COM-объекты, которые предоставляют службы клиентам.

Клиент COM — это любой вызывающий объект, передающий в систему идентификатор CLSID для запроса экземпляра COM-объекта. Самый простой способ создать экземпляр — вызвать функцию COM, [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).

Функция [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) создает один экземпляр указанного идентификатора CLSID и возвращает указатель интерфейса типа, запрошенного клиентом. Клиент несет ответственность за управление временем существования экземпляра путем вызова его функции [**выпуска**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) , когда клиент завершит его использование. Чтобы создать несколько объектов на основе одного идентификатора CLSID, вызовите функцию [**кожетклассобжект**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetclassobject) . Чтобы подключиться к объекту, который уже создан и запущен, вызовите функцию [**жетактивеобжект**](/previous-versions/windows/desktop/api/oleauto/nf-oleauto-getactiveobject) .

COM-сервер предоставляет системе реализацию COM. Сервер связывает CLSID с классом COM, внедряет реализацию класса, реализует фабрику класса для создания экземпляров класса и предоставляет для выгрузки сервера.

> [!Note]  
> Сервер COM не совпадает с COM-объектом, который он предоставляет системе.

 

Чтобы включить создание COM-объекта, сервер COM должен предоставить реализацию интерфейса [**IClassFactory**](/windows/win32/api/unknwn/nn-unknwn-iclassfactory) . Клиенты могут вызывать метод [**CreateInstance**](/windows/desktop/api/Unknwn/nf-unknwn-iclassfactory-createinstance) для запроса нового экземпляра COM-объекта, но обычно такие запросы инкапсулируются в функции [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) .

Сервер COM можно развернуть как общую библиотеку, которая загружается в процесс клиента во время выполнения (DLL на платформах Windows) или как исполняемый модуль (EXE на платформах Windows). Дополнительные сведения см. в разделе [Регистрация приложений COM](registering-com-applications.md).

## <a name="service-control-manager"></a>Диспетчер служб

Диспетчер управления службами (SCM) обрабатывает клиентский запрос для экземпляра COM-объекта. В следующем списке показана последовательность событий.

-   Клиент запрашивает указатель интерфейса на COM-объект из библиотеки COM, вызывая функцию, например [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) , с идентификатором CLSID COM-объекта.
-   Библиотека COM отправляет службе SCM запрос на поиск сервера, соответствующего запрошенному идентификатору CLSID.
-   SCM находит сервер и запрашивает создание объекта COM из фабрики класса, предоставляемой сервером.
-   В случае успеха библиотека COM возвращает клиенту указатель на интерфейс.

После того как система COM подключает серверный объект к клиенту, клиент и объект обмениваются данными напрямую. Нет дополнительных издержек при вызове через промежуточное время выполнения.

При регистрации сервера COM в системе размещения можно указать различные способы активации сервера. В следующем списке показаны три способа активации сервера COM с помощью SCM:

-   Внутрипроцессный: SCM Возвращает путь к файлу библиотеки DLL, содержащей реализацию сервера объектов. Библиотека COM загружает библиотеку DLL и запрашивает ее указатель интерфейса фабрики класса.
-   Локальный: SCM запускает локальный исполняемый файл, который регистрирует фабрику класса при запуске, и его указатель интерфейса доступен для системы и клиентов.
-   Удаленный: локальный SCM получает указатель интерфейса фабрики классов от SCM, который работает на удаленном компьютере.

Когда клиент запрашивает COM-объект, Библиотека COM обращается к SCM на локальном узле. SCM находит соответствующий COM-сервер, который может быть локальным или удаленным, и сервер возвращает указатель интерфейса на фабрику класса сервера. Когда фабрика класса доступна, Библиотека COM или клиент может использовать фабрику классов для создания запрошенного объекта. Дополнительные сведения см. в разделе [Реализация IClassFactory](implementing-iclassfactory.md).

## <a name="reusability"></a>Повторное использование

COM поддерживает возможность повторного *использования*, что означает, что сведения о реализации повторно используемого компонента не предоставляются клиентам. Чтобы обеспечить возможность повторного использования черного ящика, COM поддерживает два механизма, с помощью которых один объект может использовать другой. Две формы многократного использования называются *вложенностью* и *агрегированием*. По соглашению используемый объект называется *внутренним объектом*, а объект, который используется для внутреннего объекта, называется *внешним объектом*.

Во вложении внешний объект ведет себя как клиент внутреннего объекта. Внешний объект является логическим контейнером для внутреннего объекта, а когда внешний объект использует службы внутреннего объекта, внешний объект делегирует реализацию интерфейсам внутреннего объекта. Это означает, что внешний объект реализуется с точки зрения служб внутреннего объекта. Внешний объект может не поддерживать те же интерфейсы, что и внутренний объект, а внешний объект может использовать интерфейс внутреннего объекта для реализации частей другого интерфейса внешнего объекта.

В агрегате внешний объект предоставляет интерфейсы из внутреннего объекта, как если бы они были реализованы во внешнем объекте. Это полезно, когда внешний объект всегда будет делегировать каждый вызов одного из его интерфейсов в тот же интерфейс внутреннего объекта. Агрегирование — это удобство, позволяющее внешнему объекту избежать дополнительных затрат на реализацию.

Дополнительные сведения см. в разделе [повторное использование объектов](reusing-objects.md).

## <a name="storage-and-stream-objects"></a>Объекты хранилища и потока

Объекты COM сохраняют состояние в файле с помощью *структурированного хранилища*, которое представляет собой форму постоянного хранилища, позволяющего переходить по содержимому файла с помощью семантики файловой системы. Подобная обработка содержимого файла позволяет выполнять такие функции, как добавочный доступ, транзакции и совместное использование между процессами.

Спецификация постоянного хранилища COM предоставляет два типа элементов хранения: объекты хранилища и объекты потока. Эти объекты реализуются библиотекой COM, а пользовательские приложения редко реализуют эти элементы хранения. Объекты хранилища реализуют интерфейс [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) , а объекты потока реализуют интерфейс [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) .

Объект потока содержит данные и концептуально напоминает отдельный файл в файловой системе. У каждого потока есть права доступа и один указатель поиска. С помощью интерфейса [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) можно читать, записывать, искать и выполнять другие операции с базовыми данными потока. Потоку присваивается имя с помощью текстовой строки. Он может содержать любую внутреннюю структуру, так как это плоский поток байтов. Кроме того, функции в интерфейсе **IStream** похожи на стандартные функции, основанные на обработке файлов, например, в библиотеке времени выполнения C ANSI.

Объект хранилища концептуально напоминает каталог в файловой системе. Каждое хранилище может содержать любое количество объектов вложенного хранилища и любое количество потоков. У каждого хранилища есть свои права доступа. С помощью интерфейса [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) можно выполнять такие операции, как перечисление, перемещение, копирование, переименование, создание и удаление элементов. Объект хранилища не хранит определяемые приложением данные, но сохраняет неявные имена элементов (хранилищ и потоков), которые он содержит.

Объекты хранилища и потока могут совместно обрабатываться между процессами, когда они реализуются в соответствии со спецификацией COM на хост-платформе. Это позволяет объектам, которые выполняются внутри процесса или вне процесса, иметь одинаковый добавочный доступ к их хранилищу файлов. Так как COM загружается в каждый процесс отдельно, он использует поддерживаемые механизмы общей памяти для передачи состояния открытых элементов и их режимов доступа между процессами.

Каждый объект хранения и потоковой передачи в структурированном файле имеет имя для его обнаружения. Имя — это строка, которая соответствует определенному соглашению. Дополнительные сведения см. в разделе [соглашения об именовании объектов хранилища](/windows/desktop/Stg/storage-object-naming-conventions). Имя передается в функции [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) , чтобы указать, в каком элементе хранилища следует работать. Имена объектов корневого хранилища совпадают с именами файлов в базовой файловой системе, и эти имена должны соответствовать соглашениям файловой системы и ограничениям. Строки, передаваемые в функции, связанные с хранилищем, имена файлов которых передаются в файловую систему без интерпретации или изменения.

Имена элементов, содержащихся в объектах хранилища, управляются реализацией определенного объекта хранилища. Все реализации объектов хранилища должны поддерживать имена элементов длиной 32 символов, а некоторые реализации могут поддерживать более длинные имена. Имена сохраняются с сохранением регистра, но сравниваются без учета регистра. Приложения, определяющие имена элементов хранилища, должны выбирать имена, которые работают в любой ситуации.

Доступ к каждому элементу в структурированном файле хранилища осуществляется с помощью функций и интерфейсов, реализованных в COM. Это означает, что другие приложения могут просматривать файл, перейдя к функциям интерфейса [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) , которые предоставляют службы, аналогичные каталогам. Кроме того, другие приложения могут использовать данные этого файла без необходимости запуска приложения, записывающего файл. Когда COM-приложение обращается к структурированным файлам хранилища другого приложения, применяются стандартные права доступа Windows, и приложение должно иметь достаточные привилегии.

COM-объект может выполнять чтение и запись в постоянное хранилище. Клиент запрашивает один из интерфейсов, связанных с сохраняемостью, для COM-объекта в зависимости от контекста операции. COM-объекты могут реализовывать любое сочетание следующих интерфейсов:

-   [**Иперсистстораже**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststorage): объект COM считывает и записывает свое постоянное состояние в объект хранилища. Клиент предоставляет объект с указателем [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) через этот интерфейс. Это единственный интерфейс сохраняемости, который включает семантику для добавочного доступа.
-   [**IPersistStream**](/windows/desktop/api/ObjIdl/nn-objidl-ipersiststream): объект COM считывает и записывает свое постоянное состояние в объект потока. Клиент предоставляет объект с помощью указателя [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) через этот интерфейс.
-   [**IPersistFile**](/windows/desktop/api/ObjIdl/nn-objidl-ipersistfile): объект COM считывает и записывает свое постоянное состояние непосредственно в файл в базовой системе. Этот интерфейс не включает [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) или [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream) , если доступ к базовому файлу через эти интерфейсы отсутствует, но интерфейс **IPersistFile** не имеет семантики для хранения и потоков. Клиент предоставляет объект с именем файла и вызывает функции [**Save**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-save) или [**Load**](/windows/desktop/api/ObjIdl/nf-objidl-ipersistfile-load) .

## <a name="data-transfer"></a>Передача данных

Структурированное хранилище предоставляет базу обмена данными между COM-объектами и процессами, которая называется *однородным обменом данными*. До реализации модели COM в OLE 2, при передаче данных в Windows были указаны *протоколы переноса*, такие как буфер обмена и протоколы перетаскивания. Каждый протокол передает собственный набор функций, которые применяют протокол к запросу, а конкретный код был необходим для обработки каждого отдельного протокола и процедуры Exchange. Единая передача данных представляет все передачи данных с помощью интерфейса [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) , который отделяет общие операции обмена данными от протокола передачи.

Интерфейс [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) инкапсулирует стандартные операции получения и задания данных, запросов и перечислений, а также уведомления, которые обнаруживают, когда изменяются данные в объекте. Однородные передачи данных позволяют использовать подробные описания форматов данных, а также разные носители для передачи данных.

Во время равномерной пересылки данных все протоколы обмениваются указателем на интерфейс [**IDataObject**](/windows/desktop/api/ObjIdl/nn-objidl-idataobject) . Сервер является источником данных и реализует один объект данных, который можно использовать в любом протоколе обмена данными. Клиент использует данные и запрашивает данные из объекта данных при получении указателя **IDataObject** от любого протокола. После обмена указателями обе стороны обрабатывали обмен данными единообразно через интерфейс **IDataObject** .

Модель COM определяет две структуры данных, которые обеспечивают единообразную пересылку данных. Структура [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) представляет обобщенный формат буфера обмена, а структура [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) представляет собой носитель передачи в виде маркера памяти.

Клиент создает структуру [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) для указания типа данных, запрашиваемых из источника данных, и используется источником данных для описания форматов, которые он предоставляет. Клиент запрашивает у источника данных доступные форматы, запрашивая интерфейс [**иенумформатетк**](/windows/desktop/api/ObjIdl/nn-objidl-ienumformatetc) . Дополнительные сведения см. [в разделе Структура форматетк](the-formatetc-structure.md).

Клиент создает структуру [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) и передает ее методу [**GetData**](/windows/desktop/api/ObjIdl/nf-objidl-idataobject-getdata) , а объект данных возвращает данные в предоставленной структуре **стгмедиум** .

Структура [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) позволяет клиентам и источникам данных выбирать наиболее эффективный носитель Exchange. Например, если данные для обмена имеют очень большой размер, источник данных может указывать дисковый носитель в качестве предпочтительного формата вместо основной памяти. Такая гибкость обеспечивает эффективный обмен данными, который может быть таким же быстрым, как и передача указателя на [**IStorage**](/windows/desktop/api/objidl/nn-objidl-istorage) или [**IStream**](/windows/desktop/api/objidl/nn-objidl-istream). Дополнительные сведения см. [в разделе Структура стгмедиум](the-stgmedium-structure.md).

Клиент источника данных может потребовать уведомления при изменении данных. COM обрабатывает уведомления об изменении данных с помощью объекта *приемника уведомлений* , который реализует интерфейс [**иадвисесинк**](/windows/desktop/api/ObjIdl/nn-objidl-iadvisesink) . Объект приемника уведомлений и интерфейс **иадвисесинк** реализуются клиентом, который передает указатель **иадвисесинк** в источник данных. Когда источник данных обнаруживает изменение в базовых данных, он вызывает метод **иадвисесинк** для уведомления клиента. Дополнительные сведения см. в разделе [уведомление об изменении данных](data-notification.md).

## <a name="remoting"></a>Удаленное взаимодействие

Модель COM позволяет выполнять удаленное и распределенное вычисление. *Удаленное взаимодействие интерфейсов* позволяет функции-члену возвращать указатель интерфейса на объект COM, который находится в другом процессе или на другом главном компьютере. Инфраструктура, которая выполняет удаленное взаимодействие интерфейсов, прозрачна как для клиента, так и для сервера объектов. Ни клиент, ни сервер не нуждаются в сведениях о развертывании другого, чтобы взаимодействовать через удаленный интерфейс. Клиент вызывает функции-члены для того же интерфейса, чтобы взаимодействовать с COM-объектом, который находится в процессе, вне процесса на локальном узле или на удаленном компьютере. Локальные и удаленные вызовы на одном интерфейсе неразличимы для клиента.

Для взаимодействия с COM-объектом клиент всегда вызывает внутрипроцессный метод. Если COM-объект находится в процессе, вызов осуществляется напрямую. Если COM-объект находится вне процесса или удаленно, COM предоставляет реализацию *прокси-сервера* , которая перенаправляет вызов объекта с помощью протокола удаленного вызова процедур (RPC).

COM-объект всегда получает вызовы от клиента с помощью внутрипроцессного метода. Если вызывающий объект находится в процессе, вызов осуществляется напрямую. Если вызывающий объект находится вне процесса или удаленно, COM предоставляет реализацию *заглушки* , которая получает удаленный вызов процедуры от прокси-сервера в клиентском процессе.

*Маршалирование* — это процедура упаковки стека вызовов для передачи из прокси-сервера в заглушку. *Распаковка* — это распаковка, которая происходит в принимающей стороне. Возвращаемые значения маршалируются и расмаршалируются из заглушки в прокси-сервер. Такой тип взаимодействия также называется отправкой вызова *по каналу* передачи.

Каждый тип данных имеет правила для маршалирования. Указатели интерфейса также имеют протокол маршалирования, который инкапсулируется в функцию [**комаршалинтерфаце**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) . В большинстве случаев достаточно реализовать *стандартную упаковку интерфейса*, предоставляемую системой, но COM-объект может реализовывать *настраиваемый пользовательский интерфейс* , чтобы управлять созданием удаленных прокси объектов. Дополнительные сведения см. в разделе [Обмен данными между объектами](inter-object-communication.md).

## <a name="security"></a>Безопасность

Модель COM предоставляет две формы безопасности приложений. Одна из них — *Безопасность активации*, которая указывает, как создаются новые объекты, как клиенты подключаются к новым и существующим объектам и каким образом защищаются определенные общедоступные службы, такие как таблица классов и выполняемая таблица объектов. Другой — *вызов безопасности*, который указывает, как безопасность работает в установленном соединении между клиентом и COM-объектом.

Безопасность активации автоматически применяется диспетчером управления службами (SCM). Когда SCM получает запрос на получение COM-объекта, он проверяет запрос на соответствие сведениям о безопасности, хранящимся в реестре.

Реализации SCM обычно предлагают управляемую реестром конфигурацию для администрирования развернутых классов и для конкретных учетных записей пользователей на узле. Дополнительные сведения см. в разделе [Безопасность активации](activation-security.md).

Безопасность вызовов применяется автоматически или обеспечивается приложением. Если приложение предоставляет сведения о настройке, COM выполняет необходимые проверки для защиты приложения.

Механизм автоматического выполнения проверяет безопасность процесса, но не для отдельных объектов или методов. Если приложению требуется более детализированная безопасность, COM предоставляет функции, которые могут использоваться приложениями для собственной проверки безопасности.

Автоматические и настраиваемые механизмы можно использовать совместно, поэтому приложение может попросить COM выполнить автоматическую проверку безопасности, а затем выполнить собственную.

Службы безопасности вызовов COM делятся на следующие категории:

-   Общие функции, вызываемые как клиентами, так и серверами, которые позволяют регистрировать автоматический механизм безопасности и службы автоматической проверки подлинности. Общие интерфейсы API безопасности вызовов — это функции [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) и [**кокуеряусентикатионсервицес**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryauthenticationservices) .
-   Интерфейсы на клиентских прокси, которые позволяют клиенту управлять безопасностью при вызовах отдельных интерфейсов. Интерфейсы [**иклиентсекурити**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) и функции [**кокуерипроксибланкет**](/windows/desktop/api/combaseapi/nf-combaseapi-coqueryproxyblanket), [**CoSetProxyBlanket**](/windows/desktop/api/combaseapi/nf-combaseapi-cosetproxyblanket)и [**кокопипрокси**](/windows/desktop/api/combaseapi/nf-combaseapi-cocopyproxy) обеспечивают безопасность вызовов удаленного объекта.
-   Функции на стороне сервера и интерфейсы контекста вызова, которые позволяют серверу получать сведения о безопасности вызова и олицетворять вызывающего. Интерфейс [**исерверсекурити**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) и функции [**кожеткаллконтекст**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext), [**коимперсонатеклиент**](/windows/desktop/api/combaseapi/nf-combaseapi-coimpersonateclient)и [**кореверттоселф**](/windows/desktop/api/combaseapi/nf-combaseapi-coreverttoself) обеспечивают безопасность вызовов на стороне сервера.

Часто клиент запрашивает COM-объект для интерфейса [**иклиентсекурити**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) , который реализуется локально на уровне удаленного взаимодействия. Клиент использует этот интерфейс для управления безопасностью отдельных прокси-серверов интерфейса объекта COM перед выполнением вызова в одном из интерфейсов.

При поступлении вызова на сервер сервер может вызвать функцию [**кожеткаллконтекст**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetcallcontext) для получения интерфейса [**исерверсекурити**](/windows/win32/api/objidlbase/nn-objidlbase-iserversecurity) , который позволяет серверу проверять проверку подлинности клиента и олицетворять клиента при необходимости. Объект **исерверсекурити** действителен на время вызова.

Вызовите функцию [**CoInitializeSecurity**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializesecurity) , чтобы инициализировать уровень безопасности и задать указанные значения по умолчанию для безопасности. Если процесс не вызывает **CoInitializeSecurity**, COM вызывает его автоматически при первом маршалировании или распаковке интерфейса, регистрируя системную безопасность по умолчанию. Функция **CoInitializeSecurity** позволяет клиенту установить безопасность вызова по умолчанию для процесса, что позволяет избежать использования [**иклиентсекурити**](/windows/desktop/api/ObjIdl/nn-objidl-iclientsecurity) для отдельных прокси-серверов. Функция **CoInitializeSecurity** позволяет серверу регистрировать автоматические службы проверки подлинности для процесса. Дополнительные сведения см. в разделе [Настройка безопасности Process-Wide с помощью CoInitializeSecurity](setting-processwide-security-with-coinitializesecurity.md).

## <a name="related-topics"></a>См. также

<dl> <dt>

[COM-клиенты и серверы](com-clients-and-servers.md)
</dt> <dt>

[Определение COM-интерфейсов](defining-com-interfaces.md)
</dt> <dt>

[Регистрация приложений COM](registering-com-applications.md)
</dt> <dt>

[Безопасность в COM](security-in-com.md)
</dt> <dt>

[Процессы, потоки и подразделения](processes--threads--and-apartments.md)
</dt> </dl>

 

 
