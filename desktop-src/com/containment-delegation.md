---
title: Включение и делегирование
description: Наиболее распространенным механизмом повторного использования объектов в COM является включение или делегирование.
ms.assetid: 56396c11-889a-4f28-8fa7-9e48c805c501
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3d26e0c1d1e48596cb9acef740405c797f6f0f46
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "104332355"
---
# <a name="containmentdelegation"></a>Включение и делегирование

Наиболее распространенным механизмом повторного использования объектов в COM является *Включение или делегирование*. Этот тип повторного использования является знакомым понятием в большинстве объектно-ориентированных языков и систем. Внешний объект, который должен использовать внутренний объект, выступает в качестве клиента объекта для внутреннего объекта. Внешний объект "содержит" внутренний объект, а если внешний объект требует службы внутреннего объекта, внешний объект явно делегирует реализацию методам внутреннего объекта. То есть внешний объект использует службы внутреннего объекта для реализации самого себя.

Внешние и внутренние объекты не обязательно должны поддерживать одни и те же интерфейсы, хотя, безусловно, разумно содержать объект, реализующий интерфейс, который не реализует внешний объект, и реализовывать методы внешнего объекта просто как вызовы соответствующих методов во внутреннем объекте. Однако если сложность внешнего и внутреннего объектов сильно отличается, внешний объект может реализовать некоторые методы его интерфейсов, делегируя вызовы к методам интерфейса, реализованным во внутреннем объекте.

Реализовать вложение для внешнего объекта очень просто. Внешний объект создает внутренние объекты, которые он должен использовать как любой другой клиент. Ничего нового — этот процесс похож на объект C++, который сам содержит строковый объект C++, используемый для выполнения определенных строковых функций, даже если внешний объект не считается строковым объектом в его собственном правом. Затем, используя указатель на внутренний объект, вызов метода во внешнем объекте создает вызов метода внутреннего объекта.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Статистической обработки](aggregation.md)
</dt> </dl>

 

 




