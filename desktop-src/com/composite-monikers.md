---
title: Составные моникеры
description: Одной из наиболее полезных функций моникеров является то, что вы можете объединить или составить моникеры.
ms.assetid: ea2453f3-7a64-4ce0-87c2-de6224ca71df
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5b5375bb505ff3737fb4e0cdea894790d93c0051
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "103779811"
---
# <a name="composite-monikers"></a>Составные моникеры

Одной из наиболее полезных функций моникеров является то, что вы можете объединить или составить моникеры. *Составной моникер* — это моникер, который является композицией других моникеров и может определять отношение между частями. Это позволяет собрать полный путь к объекту, заданному двумя или более моникерами, эквивалентными частичным путям. Вы можете создать моникеры того же класса (например, два моникера файла) или различных классов (например, моникер файла и моникер элемента). Если вы написали собственный класс моникера, можно также составлять моникеры с моникерами файлов или элементов. Основное преимущество составного подхода состоит в том, что он предоставляет один фрагмент кода для реализации любого возможного моникера, который представляет собой сочетание более простых моникеров. Это значительно сокращает потребность в конкретных пользовательских классах моникера.

Поскольку моникеры различных классов могут состоять друг с другом, моникеры предоставляют возможность объединения нескольких пространств имен. Файловая система определяет общее пространство имен для объектов, хранящихся в виде файлов, так как все приложения понимают имя пути файловой системы. Аналогичным образом объект-контейнер также определяет частное пространство имен для содержащихся в нем объектов, так как ни один контейнер не понимает имена, созданные другим контейнером. Моникеры позволяют объединять эти пространства имен, поскольку могут составляться моникеры и моникеры элементов. Клиент моникера может выполнять поиск по пространству имен для всех объектов с помощью одного механизма. Клиент просто вызывает [**IMoniker:: биндтубжект**](/windows/desktop/api/ObjIdl/nf-objidl-imoniker-bindtoobject) в моникере, а код моникера обрабатывает остальное. Вызов [**IMoniker::**](/windows/desktop/api/ObjIdl/nf-objidl-imoniker-getdisplayname) lt для составного объекта создает имя, используя объединение всех отображаемых имен отдельных моникеров.

Более того, поскольку можно написать собственный класс моникера, композиция моникера позволяет добавлять пользовательские расширения в пространство имен для объектов.

Иногда два моникера конкретных классов можно комбинировать особым образом. Например, моникер файла, представляющий неполный путь, и другой моникер файла, представляющий относительный путь, можно объединить, чтобы сформировать один моникер файла, представляющий полный путь. Например, моникеры файла "c: \\ Рабочая \\ графика" могут состоять из относительного моникера файла ".. \\ Backup \\myfile.doc "равно" c: \\ Рабочая \\ Архивация \\myfile.doc ". Это пример *неуниверсальной композиции*.

*Универсальная композиция*, с другой стороны, разрешает подключение любых двух моникеров независимо от их классов. Например, можно создать моникер элемента в моникере файла, но не наоборот, в других случаях.

Поскольку неуниверсальная композиция зависит от класса используемых моникеров, его сведения определяются реализацией конкретного класса моникера. При написании нового класса моникера можно определить новые типы неуниверсальных композиций. Универсальные композиции, напротив, определяются OLE. Моникеры, созданные в результате универсальной композиции, называются универсальными составными моникерами.

Эти три класса, моникеры файлов, моникеры элементов и универсальные составные моникеры, все работают вместе и являются наиболее часто используемыми классами моникеров.

Клиенты моникера должны вызывать [**IMoniker:: компосевис**](/windows/desktop/api/ObjIdl/nf-objidl-imoniker-composewith) , чтобы создать составной объект с другим именем. Моникер, который вызывается внутренним образом, определяет, может ли он выполнять универсальную или неуниверсальную композицию. Если реализация моникера определяет, что универсальная композиция может использоваться, OLE предоставляет функцию [**креатеженериккомпосите**](/windows/desktop/api/Objbase/nf-objbase-creategenericcomposite) для упрощения этого.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Специальные имена](anti-monikers.md)
</dt> <dt>

[Моникеры класса](class-monikers.md)
</dt> <dt>

[Моникеры файлов](file-monikers.md)
</dt> <dt>

[Моникеры элементов](item-monikers.md)
</dt> <dt>

[Моникеры указателей](pointer-monikers.md)
</dt> </dl>

 

 




