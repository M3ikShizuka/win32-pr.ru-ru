---
title: Повторное использование объектов
description: Повторное использование объектов
ms.assetid: 07055fea-bdfe-4c7a-be07-2edcbf609dd9
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 03a830eb539823b0350c9ce41a096cda821bb0cb
ms.sourcegitcommit: 917c90b6ed4af323fedada331211b40396876424
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/08/2020
ms.locfileid: "104533080"
---
# <a name="reusing-objects"></a>Повторное использование объектов

Важной целью любой объектной модели является предоставление авторам объектов возможности повторного использования и расширения объектов, предоставляемых другими пользователями, в виде частей собственных реализаций. Одним из способов сделать это в Microsoft Visual C++ и других языках является использование *наследования реализации*, которое позволяет объекту наследовать (подкласс) некоторые из его функций из другого объекта при переопределении других функций.

Проблема для взаимодействия с объектом в масштабе всей системы с помощью традиционной наследования реализации заключается в том, что контракт (интерфейс) между объектами в иерархии реализации не определен явным образом. Фактически он является неявным и неоднозначным. Когда родительский или дочерний объект изменяет свою реализацию, поведение связанных компонентов может стать неопределенным или унстабли реализованным. В любом приложении, где реализация может управляться одной группой инженеров, которая обновляет все компоненты одновременно, это не всегда является серьезной проблемой. В среде, в которой компоненты одной команды созданы с использованием черного ящика и других компонентов, созданных другими группами, этот тип нестабильной работы будет неустойчивым. Кроме того, наследование реализации обычно работает только внутри границ процесса. Это делает традиционную реализацию наследования непрактичной для крупных, развивающихся систем, состоящих из программных компонентов, созданных многими инженерными группами.

Ключом к созданию повторно используемых компонентов является возможность интерпретировать объект как непрозрачную рамку. Это означает, что фрагмент кода, пытающийся повторно использовать другой объект, не знает ничего и должен знать ничего, о внутренней структуре или реализации используемого компонента. Иными словами, код, пытающийся повторно использовать компонент, зависит от поведения объекта, а не от его точной реализации.

Чтобы обеспечить возможность повторного использования черного ящика, COM использует другие установленные механизмы повторного использования, такие как *Включение, делегирование* и *агрегирование*.

> [!NOTE]  
> Для удобства используемый объект называется *внутренним объектом* , и объект, выполняющий использование этого внутреннего объекта, является *внешним объектом*.

 

Важно помнить оба этих механизма того, как внешний объект отображается для его клиентов. С точки зрения клиентов, оба объекта реализуют интерфейсы, к которым клиент может получить указатель. Клиент рассматривает внешний объект как непрозрачное поле и, следовательно, не заботится о внутренней структуре внешней обжектâ € ", а также о том, что клиент заботится только о поведении.

Дополнительные сведения см. в следующих разделах:

-   [Включение и делегирование](containment-delegation.md)
-   [Статистической обработки](aggregation.md)

 

 




