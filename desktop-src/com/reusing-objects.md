---
title: Повторное использование объектов
description: Повторное использование объектов
ms.assetid: 07055fea-bdfe-4c7a-be07-2edcbf609dd9
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 71b6ef6d28b23ff2fcda5ed46d9b99a6634389793e48275c36e2f8a708f7266d
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118309425"
---
# <a name="reusing-objects"></a>Повторное использование объектов

Важной целью любой объектной модели является предоставление авторам объектов возможности повторного использования и расширения объектов, предоставляемых другими пользователями, в виде частей собственных реализаций. одним из способов сделать это в Microsoft Visual C++ и других языках является использование *наследования реализации*, которое позволяет объекту наследовать (подкласс) некоторые из его функций из другого объекта при переопределении других функций.

Проблема для взаимодействия с объектом в масштабе всей системы с помощью традиционной наследования реализации заключается в том, что контракт (интерфейс) между объектами в иерархии реализации не определен явным образом. Фактически он является неявным и неоднозначным. Когда родительский или дочерний объект изменяет свою реализацию, поведение связанных компонентов может стать неопределенным или унстабли реализованным. В любом приложении, где реализация может управляться одной группой инженеров, которая обновляет все компоненты одновременно, это не всегда является серьезной проблемой. В среде, в которой компоненты одной команды созданы с использованием черного ящика и других компонентов, созданных другими группами, этот тип нестабильной работы будет неустойчивым. Кроме того, наследование реализации обычно работает только внутри границ процесса. Это делает традиционную реализацию наследования непрактичной для крупных, развивающихся систем, состоящих из программных компонентов, созданных многими инженерными группами.

Ключом к созданию повторно используемых компонентов является возможность интерпретировать объект как непрозрачную рамку. Это означает, что фрагмент кода, пытающийся повторно использовать другой объект, не знает ничего и должен знать ничего, о внутренней структуре или реализации используемого компонента. Иными словами, код, пытающийся повторно использовать компонент, зависит от поведения объекта, а не от его точной реализации.

Чтобы обеспечить возможность повторного использования черного ящика, COM использует другие установленные механизмы повторного использования, такие как *Включение, делегирование* и *агрегирование*.

> [!NOTE]  
> Для удобства используемый объект называется *внутренним объектом* , и объект, выполняющий использование этого внутреннего объекта, является *внешним объектом*.

 

Важно помнить оба этих механизма того, как внешний объект отображается для его клиентов. С точки зрения клиентов, оба объекта реализуют интерфейсы, к которым клиент может получить указатель. Клиент рассматривает внешний объект как непрозрачное поле и, следовательно, не заботится о внутренней структуре внешней обжектâ € ", а также о том, что клиент заботится только о поведении.

Дополнительные сведения см. в следующих разделах:

-   [Включение и делегирование](containment-delegation.md)
-   [Агрегирование](aggregation.md)

 

 




