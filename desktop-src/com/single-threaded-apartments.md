---
title: Single-Threaded подразделения
description: Single-Threaded подразделения
ms.assetid: 2f345ae2-8314-4067-a6d6-5a0275941ed4
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0f0a8cb1422b6866d9e0d043fdd46c895e6d335b
ms.sourcegitcommit: 9eebab0ead09cecdbc24f5f84d56c8b6a7c22736
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/10/2021
ms.locfileid: "124369486"
---
# <a name="single-threaded-apartments"></a>Single-Threaded подразделения

Использование однопотоковых апартаментов (процесс модели апартамента) предоставляет парадигму на основе сообщений для работы с несколькими объектами, выполняющимися одновременно. Он позволяет писать более эффективный код, разрешая поток, ожидая выполнения некоторой длительной операции, чтобы разрешить выполнение другого потока.

Каждый поток в процессе, который инициализируется как процесс модели апартамента и извлекает и отправляет сообщения окна, является однопотоковым апартаментным потоком. Каждый поток находится в собственном апартаменте. В подразделении указатели интерфейса могут передаваться без маршалирования, поэтому все объекты в одном потоковом апартаменте взаимодействуют напрямую.

Логическая группировка связанных объектов, которые выполняются в одном и том же потоке и поэтому должны иметь синхронное выполнение, может находиться в одном потоке апартамента с одним потоком. Однако объект модели подразделения не может находиться в более чем одном потоке. Вызовы объектов в других потоках должны выполняться в контексте потока-владельца, поэтому распределенные потоки COM переключаются автоматически при вызове на прокси-сервере.

Межпроцессные и многопоточные модели похожи. Когда необходимо передать указатель интерфейса в объект в другом контейнере (в другом потоке) в рамках одного процесса, используется та же модель, что и объекты в разных процессах для передачи указателей между границами процесса. Получив указатель на стандартный объект маршалирования, можно маршалировать указатели на интерфейсы между границами потоков (между апартаментами) точно так же, как и между процессами. (При передаче между апартаментами должны быть маршалированы указатели интерфейса.)

Правила для однопотоковых подразделения просты, но важно тщательно проследить их:

-   Каждый объект должен находиться в одном потоке (в однопотоковом подразделении).
-   Инициализируйте библиотеку COM для каждого потока.
-   Маршалирует все указатели на объекты при передаче их между апартаментами.
-   Каждый однопотоковый апартамент должен иметь цикл сообщений для обработки вызовов из других процессов и подразделений в рамках одного процесса. Для однопотоковых апартаментов без объектов (только для клиента) также необходим цикл обработки сообщений для отправки широковещательных сообщений, используемых некоторыми приложениями.
-   Основанные на библиотеке DLL или внутрипроцессный объекты не вызывают функции инициализации COM; Вместо этого они регистрируют свою потоковую модель с **ThreadingModel** именованным значением в разделе [InprocServer32](inprocserver32.md) реестра. Объекты, поддерживающие подразделение, также должны тщательно записывать точки входа библиотеки DLL. Существуют особые соображения, которые применяются к потокам внутрипроцессного сервера. Дополнительные сведения см. [в разделе проблемы потоковой обработки на сервере](in-process-server-threading-issues.md).

Хотя несколько объектов могут находиться в одном потоке, ни один объект модели апартамента не может находиться в нескольких потоках.

Каждый поток клиентского процесса или сервера вне процесса должен вызывать [**Соинициализацию**](/windows/desktop/api/Objbase/nf-objbase-coinitialize)или вызывать метод [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex) , а также указывать \_ апартментсреадед для параметра *двкоинит* . Основной апартамент — это поток, который сначала вызывает **CoInitializeEx** . Сведения о внутрипроцессного серверах см. [в статье проблемы потоковой обработки в процессе сервера](in-process-server-threading-issues.md).

Все вызовы объекта должны выполняться в своем потоке (в его апартаменте). Нельзя вызывать объект непосредственно из другого потока; использование объектов в этом свободно-потоковом режиме может привести к проблемам с приложениями. Следствием этого правила является то, что все указатели на объекты должны быть упакованы при передаче между апартаментами. Для этой цели COM предоставляет следующие две функции:

-   [**Комаршалинтерсреадинтерфацеинстреам**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) маршалирует интерфейс в объект потока, который возвращается вызывающему объекту.
-   [**Кожетинтерфацеандрелеасестреам**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) отменяет упаковку указателя интерфейса из объекта потока и освобождает его.

Эти функции заключают вызовы в функции [**комаршалинтерфаце**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterface) и [**каунмаршалинтерфаце**](/windows/desktop/api/combaseapi/nf-combaseapi-counmarshalinterface) , требующие использования \_ флага мшкткс INPROC.

Как правило, маршалирование выполняется автоматически с помощью COM. Например, при передаче указателя интерфейса в качестве параметра в вызове метода на прокси-сервере в объект в другом апартаменте или при вызове [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance), com выполняет упаковку автоматически. Однако в некоторых особых случаях, когда модуль записи приложения передает указатели интерфейса между апартаментами без использования обычных механизмов COM, модуль записи должен обработать упаковку вручную.

Если одно подразделение (апартамент 1) в процессе имеет указатель интерфейса и другое подразделение (апартамент 2), то Апартамент 1 должен вызвать [**комаршалинтерсреадинтерфацеинстреам**](/windows/desktop/api/combaseapi/nf-combaseapi-comarshalinterthreadinterfaceinstream) для маршалирования интерфейса. Поток, созданный этой функцией, является потокобезопасным и должен храниться в переменной, доступной для подразделения 2. Апартамент 2 должен передать этот поток в [**кожетинтерфацеандрелеасестреам**](/windows/desktop/api/combaseapi/nf-combaseapi-cogetinterfaceandreleasestream) для распаковки интерфейса и получить указатель на прокси-сервер, через который он может получить доступ к интерфейсу. Главный апартамент должен оставаться активным до тех пор, пока клиент не завершит все COM-операции (так как некоторые внутрипроцессный объекты загружаются в основном апартаменте, как описано в статье [проблемы с потоковым сервером обработки](in-process-server-threading-issues.md)). После того как один объект передается между потоками таким образом, очень просто передавать указатели интерфейса в качестве параметров. Таким образом, распределенная модель COM выполняет упаковку и переключение потоков для приложения.

Для обработки вызовов из других процессов и подразделений в рамках одного процесса каждый однопотоковый апартамент должен иметь цикл обработки сообщений. Это означает, что Рабочая функция потока должна иметь цикл DispatchMessage/Message. Если для обмена данными между потоками используются другие примитивы синхронизации, функция [**мсгваитформултиплеобжектс**](/windows/desktop/api/winuser/nf-winuser-msgwaitformultipleobjects) может использоваться для ожидания как для сообщений, так и для событий синхронизации потоков. В документации по этой функции есть пример такого цикла комбинирования.

COM создает скрытое окно, используя Windows класс "олемаинсреадвндкласс" в каждом однопотоковом подразделении. Вызов объекта получается как сообщение окна в скрытое окно. Когда апартамент объекта получает и отправляет сообщение, оно получит скрытое окно. Затем процедура окна будет вызывать соответствующий метод интерфейса объекта.

Когда несколько клиентов вызывают объект, вызовы помещаются в очередь сообщений, а объект получит вызов каждый раз, когда его апартамент извлекает и отправляет сообщения. Поскольку вызовы синхронизированы COM и вызовы всегда доставляются потоком, который принадлежит подразделению объекта, реализации интерфейса объекта не должны обеспечивать синхронизацию. Однопотоковые подразделения могут реализовать [**IMessageFilter**](/windows/desktop/api/ObjIdl/nn-objidl-imessagefilter) , чтобы позволить им отменять вызовы или принимать сообщения окна при необходимости.

Объект может быть повторно введен, если одна из его реализаций метода интерфейса извлекает и отправляет сообщения или выполняет вызов ОРПК другому потоку, тем самым вызывая другой вызов, который доставляется объекту (в том же апартаменте). OLE не препятствует повторному входу в том же потоке, но может способствовать обеспечению безопасности потоков. Это аналогично тому, как процедура окна может быть повторно введена, если она извлекает и отправляет сообщения при обработке сообщения. Однако вызов необработанного однопотокового подразделения сервера, который вызывает другой однопотоковый Апартаментный сервер, позволит повторно ввести первый сервер.

## <a name="related-topics"></a>Связанные разделы

<dl> <dt>

[Доступ к интерфейсам в разных апартаментах](accessing-interfaces-across-apartments.md)
</dt> <dt>

[Выбор потоковой модели](choosing-the-threading-model.md)
</dt> <dt>

[Многопоточные подразделения](multithreaded-apartments.md)
</dt> <dt>

[Проблемы потоковой обработки в процессе сервера](in-process-server-threading-issues.md)
</dt> <dt>

[Процессы, потоки и подразделения](processes--threads--and-apartments.md)
</dt> <dt>

[Однопотоковое и многопоточное взаимодействие](single-threaded-and-multithreaded-communication.md)
</dt> </dl>

 

 