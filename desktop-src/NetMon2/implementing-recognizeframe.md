---
description: Сетевые мониторы вызывают функцию Рекогнизефраме средства синтаксического анализа, чтобы определить, что средство синтаксического анализа распознает необработанные данные кадра.
ms.assetid: 6d0574da-f0ec-4ed9-bfb0-023dff2ac6fe
title: Реализация Рекогнизефраме
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d970eee80a04168b3fa06b117c2c219c506da7ea
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "104348945"
---
# <a name="implementing-recognizeframe"></a>Реализация Рекогнизефраме

Сетевые мониторы вызывают функцию [**рекогнизефраме**](recognizeframe.md) средства синтаксического анализа, чтобы определить, что средство синтаксического анализа распознает необработанные данные кадра. Неутвержденные данные могут находиться в начале кадра, но обычно неутвержденные данные находятся в середине кадра. На следующем рисунке показаны неутвержденные данные, расположенные в середине рамки.

![Неутвержденные данные, расположенные в середине кадра](images/recognizeframe1.png)

Сетевой монитор предоставляет следующие сведения при вызове функции [**рекогнизефраме**](recognizeframe.md) :

-   Маркер фрейма.
-   Указатель на начало кадра.
-   Указатель на начало неутвержденных данных.
-   Значение MAC первого протокола в кадре.
-   Число байтов в неутвержденных данных; то есть байты, оставшиеся в кадре.
-   Обработчик предыдущего протокола.
-   Смещение предыдущего протокола.

Если библиотека DLL средства синтаксического анализа определяет, что необработанные данные начинаются с протокола синтаксического анализа, то библиотека DLL синтаксического анализатора определяет, где запускается следующий протокол, и какой протокол следует за ним. Библиотека DLL средства синтаксического анализа выполняет следующие условные действия:

-   Если библиотека DLL анализатора распознает необработанные данные, DLL-файл синтаксического анализатора устанавливает параметр *ппротоколстатус* и возвращает указатель на следующий протокол в кадре или **значение NULL**. **Значение NULL** возвращается, если текущий протокол является последним в кадре.
-   Если библиотека DLL анализатора распознает необработанные данные и определяет протокол, указанный ниже (из сведений, предоставленных протоколом), то DLL-файл синтаксического анализатора возвращает указатель на маркер следующего протокола в параметре *фнекстпротокол* функции.
-   Если DLL-файл синтаксического анализатора не распознает необработанные данные, Библиотека DLL средства синтаксического анализа возвращает указатель на начало необработанных данных, а сетевой монитор продолжит попытки выполнить синтаксический анализ необработанных данных.

**Реализация Рекогнизефраме**

1.  Протестируйте, чтобы определить, что вы распознаете протокол.
2.  Если вы распознаете ненужные данные и знаете, какой протокол следует, установите для параметра *ппротоколстатус* \_ состояние протокола \_ следующий \_ протокол, установите *фнекстпротокол* на указатель, указывающий на маркер для следующего протокола, а затем верните указатель на следующий протокол.

    –или–

    Если вы распознаете ненужные данные и не знаете, какой протокол следует, установите *ппротоколстатус* в \_ состояние протокола \_ , а затем верните указатель на следующий протокол.

    –или–

    Если вы распознаете ненужные данные, а протокол является последним протоколом в кадре, установите *ппротоколстатус* в \_ состояние протокола \_ затребован, а затем возвратите **null**.

    –или–

    Если не удается распознать ненужные данные, установите *ппротоколстатус* в \_ состояние протокола \_ не \_ распознано, а затем верните указатель, который передается вам в *ппротокол*.

Ниже приведена базовая реализация [**рекогнизефраме**](recognizeframe.md).

``` syntax
#include <windows.h>

LPBYTE BHAPI MyProtocol_RecognizeFrame( HFRAME hFrame,
                                        LPBYTE        pMacFrame,
                                        LPBYTE        pProtocol,
                                        DWORD         MacType,
                                        DWORD         BytesLeft,
                                        HPROTOCOL     hPrevProtocol,
                                        DWORD         nPreviuosProtOffset,
                                        LPDWORD       pProtocolStatus,
                                        LPHPROTOCOL   phNextProtocol,
                                        LPDWORD       InstData)
  
  // Test unclaimed data. 
  
  // If unclaimed data is recognized, but you do not know what follows.
  *pProtocolStatus =  PROTOCOL_STATUS_RECOGNIZED;
  return pProtocol + MY_PROTOCOL_LENGTH;
  
  // If unclaimed data is recognized and you know what follows.
  *pProtocolStatus =  PROTOCOL_STATUS_NEXT_PROTOCOL;
  phNextProtocol = GetProtocolFromTable(
                                        hTable,
                                        ItemToFind,
                                        lpInstData);
  return  pProtocol + MY_PROTOCOL_LENGTH;
  
  // If unclaimed data is recognized and the protocol is the last 
  // protocol in the frame.
  *pProtocolStatus =  PROTOCOL_STATUS_CLAIMED;
  return NULL;
  
  // If the unclaimed data is not recognized.
  *pProtocolStatus =  PROTOCOL_STATUS_NOT_RECOGNIZED;
  return *pProtocol;

}
```

 

 



