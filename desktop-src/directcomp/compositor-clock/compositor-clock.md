---
title: Часы компоновщика
description: API-интерфейс для работы с часами предоставляет статистику и управление частотой кадров для плавного представления содержимого на экране, в максимально возможной частоте ритмичности и в различных конфигурациях оборудования.
ms.topic: article
ms.date: 09/10/2021
ms.openlocfilehash: 211684d8e199c61ec76fad6dbad168088056473a
ms.sourcegitcommit: 2c13d0f1620f7c089687ef1d97e8c1d22e5d537a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/24/2021
ms.locfileid: "128524027"
---
# <a name="compositor-clock"></a>Часы компоновщика

> [!NOTE]
> **Некоторые сведения относятся к предварительной версии продукта, в которую перед коммерческим выпуском могут быть внесены существенные изменения. Корпорация Майкрософт не дает никаких гарантий, явных или подразумеваемых, в отношении предоставленной здесь информации.**

## <a name="overview"></a>Обзор

API-интерфейс для работы с часами предоставляет статистику и управление частотой кадров для плавного представления содержимого на экране, в максимально возможной частоте ритмичности и в различных конфигурациях оборудования. Обычно это обработано API-интерфейсами DirectX. Но они обладают строгими связями с фиксированной частотой обновления и конфигурацией с одним дисплеем. Например, Вот упрощенный фрагмент псевдо-кода, демонстрирующий, как обычно создаются приложения для отрисовки с частотой обновления дисплея.

```cpp
void GameLoop()
{
    CreateRenderingObjects();
    auto pSwapChain = CreateSwapChain();

    while (pSwapChain->WaitForVerticalBlank())
    {
        ProcessInput();
        RenderFrame(pSwapChain);
        pSwapChain->Present();
    }
}
```

В этом типе цикла предполагается, что существует одна вертикальная (вбланк) ритмичность. Неясно, что должно делать приложение, если его окно находится на двух мониторах, исходящий из которых находится за пределами, или у которых вообще есть разные частоты. Фактически API-интерфейс DXGI имеющуюся цепочку буферов всегда использует ритмичность основного монитора независимо от того, на каком окне оно отображается. Это вызывает проблемы для приложений, для которых требуется гладкое представление на всех мониторах. Одним из реальных примеров является воспроизведение видео на дополнительном мониторе, обновление которого отличается от основного. сценарий, который существовал с момента появления нескольких мониторов; и он непропорционально влияет на игроки, у которых обычно есть 60-процентный монитор для дополнительного пользовательского интерфейса, и монитор с более высокой частотой (144 + Гц) для игр.

Вторая проблема заключается в настройке частоты кадров на основе производительности компьютера. Это типично для приложений воспроизведения видео, которые хотят определить, видны ли видеокадры пользователем в ожидаемое время, или невозможность сделать презентацию нечетными, надеется настройку презентации для повышения производительности. Например, служба потоковой передачи видео может переключиться на поток низкого качества, если компьютер не способен поддерживать требуемую частоту кадров с самым высоким качеством. Это также обрабатывается API-интерфейсами DXGI, и, таким образом, они зависят от того же ограничения архитектуры и уязвимости API.

Наконец, API предоставляет приложениям возможность участвовать в новой функции повышения частоты кадров, именуемой частотой динамического обновления, при которой система работает по относительно низкой частоте обновления для обычных операций, например &mdash; 60 Гц, &mdash; но ускоряется до более высокой частоты, например &mdash; 120Hz, &mdash; когда приложение выполняет определенные операции с учетом задержки, например рукописный ввод с помощью пера.  или сенсорного панорамирования. Функция повышения существует, так как работает с высокой частотой 100% времени с точки зрения потребления энергии. В то же время, благодаря тем же ограничениям API DXGI, изменение частоты обновления экрана в произвольные моменты обычно является дорогостоящим, включающим в себя уведомления об изменении режима трансляции для всех приложений, и затраты всех этих приложений, которые запускают код для реагирования на изменения. Таким образом, функция повышения частоты обновления выполняет нетипичное изменение конфигурации, которое не выдает никаких уведомлений, но, следовательно, должно быть абстрактным от большинства приложений, что продолжает предполагать, что система работает с меньшей частотой. Эта виртуализация работает путем выдачи приложений только для всех остальных вбланк, или каждых трех вбланкс или любого другого целочисленного интервала, чтобы приложение видит эффективную частоту обновления, которая является целой частью реальной частоты. Это позволяет использовать существующий механизм вбланк без дополнительной платы для создания идеально низкой частоты. Выравниваемая вбланк представляется динамическим режимом скорости обновления в операционной системе (ОС), например 60 Гц/120Hz. Обратите внимание, что, следовательно, функция усиления работает только в том случае, чтобы повысить частоту до более высокой, так как не так просто вставлять искусственный вбланкс, так как он пропускает реальную вбланкс.

API-интерфейс для работы с часами компоновщика позволяет приложению не только запрашивать вход в систему или выходить из режима повышения, но и наблюдать за истинной частотой обновления в этом режиме, чтобы вы могли представлять содержимое с более высокой частотой.

## <a name="the-api"></a>API-интерфейс

API состоит из трех частей. Первый предлагает независимый от экрана период пульса для приложений, которые должны быть представлены на нескольких мониторах по частоте кадров. Второй позволяет приложениям запрашивать частоту повышения с частотой динамического обновления. Третья программа предлагает статистические данные о поведении механизма композиции системы, разделенные на отдельные дисплеи.

Каждая часть API влияет на рабочий цикл компоновщика системы. Этот рабочий цикл — это обычная ритмичность, которая создает один кадр компоновщика на цикл. Этот цикл может быть не согласован для отображения вбланкс, в зависимости от рабочей нагрузки системы, количества дисплеев и других факторов.

## <a name="wait-for-the-compositor-clock"></a>Ожидание времени для компоновщика

Цель этого сигнала — заменить использование метода [**идксгиаутпут:: ваитфорвбланк**](/windows/win32/api/dxgi/nf-dxgi-idxgioutput-waitforvblank) , обеспечивая более высокую гибкость при различных частотах обновления, и упростить шаблоны использования для разработчиков. Как и в случае с **ваитфорвбланк**, система должна определить, ожидает ли приложение этого сигнала или нет, так что если нет приложений, ожидающих, система не сможет направить видеоадаптеру отключать вертикальное пустое прерывание. 

Это крайне важно для управления питанием, тем самым определяя архитектуру API в вызове функции Wait, вместо того чтобы принимать или возвращать событие (графическая система не может определить, ожидается ли он). На этом низком уровне приложения должны использовать этот API для управления потоками отрисовки, отделенными от потоков пользовательского интерфейса общего назначения, аналогично использованию **идксгиаутпут:: ваитфорвбланк** .

Как упоминалось в обзоре, существует несколько аспектов, которые могут поддерживаться в **ваитфорвбланк** .

* Следующее вертикальное поле пусто, если часы компоновщика не обязательно являются источником из основного дисплея.
* Пробуждение приложений по переменным нормам на дисплеях, поддерживающих динамическое обновление.
* Пробуждение приложений для определенных приложением событий.

Как правило, предполагается, что многие приложения будут синхронизироваться с часами компоновщика для лучшего времени их кадров; но некоторые исключения могут включать в себя платформы мультимедиа и игры, на которых необходимо пробудить вертикальную пустую часть определенного экрана.

### <a name="handle-usage-with-compositor-clock"></a>Использование обработчиков с часами компоновщика

В настоящее время приложения переводятся на каждые вертикальные пробелы через механизм DXGI, но часто имеют другие события, для которых они также требуются для пробуждения. Вместо того чтобы обрабатывать эти события отдельно, часы компоновщика могут принимать дескрипторы для нескольких событий и сообщать о следующем кадре и о каждом срабатывании событий. Затем приложение может пробудить один сигнал, зная событие, вызвавшее его пробуждение.

### <a name="cycle-for-compositor-clock-events"></a>Цикл для событий синхронизации для компоновщика

Часы компоновщика всегда проводятся на вертикальной пустой части монитора или в другом таймере. Если компоновщик находится в спящем режиме, но он по-прежнему обновляется, этот сигнал по-прежнему будет срабатывать на вбланк основного дисплея.

### <a name="c-example"></a>Пример C++

```cpp
void GameLoop(HANDLE hQuitGameEvent)
{
    DWORD waitResult;

    CreateRenderingObjects();
    auto pSwapChain = CreateSwapChain();

    do
    {
        // Do all of the work for a single frame
        ProcessInput();
        RenderFrame(pSwapChain);
        pSwapChain->Present();

        // Wait for the compositor heartbeat before starting a new frame
        waitResult = DCompositionWaitForCompositorClock(1, &hQuitGameEvent, INFINITE);

        // If we get WAIT_RESULT_0+count it means the compositor clock ticked,
        // and we should render another frame. Our count is one, as we're
        // passing only one extra handle. Otherwise, either we got a failure or
        // another thread signaled our "quit" event, and in either case we want
        // to exit the loop
    } while (waitResult == WAIT_OBJECT_0 + 1);
}
```

## <a name="boost-compositor-clock"></a>Часы компоновщика усиления

Если источник синхронизирующих импульсов поддерживает динамическую частоту обновления (Эта функция включена в параметрах расширенного отображения; в списке поддерживаются только значения частоты обновления переменных), система сможет динамически переключаться между двумя тарифами. Существует неповышенный режим, который обычно будет 60 Гц, и повышенная скорость, которая обычно вдвое выше по адресу 120Hz. Эта более высокая частота обновления должна использоваться для улучшения содержимого с учетом задержки, такого как цифровая рукописная запись. На схеме ниже показано, как система переключается между выполнением с базовой скоростью 60 Гц (1), а затем для 6 кадров (2-7) с цифровым рукописным вводом в 120Hz. Наконец, после того, как рукописный ввод больше не обновляется, система переключается обратно в режим 60 Гц.

Ниже приведена иллюстрация динамической частоты кадров для повышения.

![Частота обновления повысилась в flip2; рукописный ввод заканчивается на flip8, и ставка возвращает 60 Гц](images/dyn-refresh-rate.png)

И вот как DWM обрабатывает запросы на повышение производительности.

![Блок-схема, показывающая, как DWM обрабатывает запросы на повышение](images/dwm-boosting.png)

Если приложение, запрашивающее повышение, завершается, запросы на повышение производительности будут также завершены. Приложения, которые по-прежнему активны с несколькими запросами на повышение производительности, могут проверить количество ссылок, чтобы определить, сколько раз следует увеличить значение. Вызовы повышения являются полностью совместимыми, даже если система не находится в режиме динамического обновления, где коэффициент усиления будет равен 1x.

### <a name="c-example"></a>Пример C++

В этом примере обрабатывается **WM_TOUCH** для повышения частоты обновления, когда это приложение получает сенсорный ввод с целью предоставления более плавного сенсорного панорамирования с высокой частотой. Более сложное приложение может сначала выполнить распознавание жестов и повысить его только при обнаружении панорамы.

```cpp
int g_activeTouchPoints = 0;

LRESULT OnTouch(HWND hWnd, WPARAM wParam, LPARAM lParam)
{
    LRESULT result = 0;
    UINT inputCount = LOWORD(wParam);
    auto hTouchInput = reinterpret_cast<HTOUCHINPUT>(lParam);

    // Allocate room for touch data (assume throwing new)
    auto pInputs = new TOUCHINPUT[inputCount];

    if (GetTouchInputInfo(hTouchInput, inputCount, pInputs, sizeof(TOUCHINPUT)))
    {
        for (int index = 0; index < inputCount; index++)
        {
            auto& touchInput = pInputs[index];

            // The first time we receive a touch down, boost the compositor
            // clock so we do our stuff at high frequency. Once the last touch
            // up happens, return to the base frequency
            if (touchInput.dwFlags & TOUCHEVENTF_DOWN)
            {
                if (!g_activeTouchPoints)
                {
                    // We're going from zero to one active points -- boost 
                    DCompositionBoostCompositorClock(true);
                }

                g_activeTouchPoints++;
            }
            else if (touchInput.dwFlags && TOUCHEVENTWF_UP)
            {
                g_activeTouchPoints--;

                if (g_activeTouchPoints == 0)
                {
                    DCompositionBoostCompositorClock(false);
                }
            }

            // Perform other normal touch processing here...
        }

        // We handled the window message; close the handle
        CloseTouchInputHandle(hTouchInput);
    }
    else
    {
        // We couldn't handle the message; forward it to the system
        result = DefWindowProc(hWnd, WM_TOUCH, wParam, lParam);
    }

    delete[] pInputs;
    return result;
}
```

## <a name="frame-statistics"></a>Статистика кадров

> [!NOTE]
> Мы планируем, чтобы приложения использовали функцию "Статистика кадров" преимущественно для телеметрии, а не для настройки содержимого.

Windows приложения часто отправляют содержимое в компоновщик, который отображается в различных расположениях через адаптеры и экраны отображения. Мы не всегда отображаем на экране, поэтому в этом API используются [*целевые объекты*](#glossary). Вместо того, чтобы полагаться на одну статистику, чтобы представить время, когда кадр достигает экрана, [**дкомпоситионжеттаржетстатистикс**](/windows/win32/api/dcomp/nf-dcomp-dcompositiongettargetstatistics) предлагает статистику кадров для каждого кадра компоновщика по мере попадания на каждый целевой объект. Компоновщик работает на регулярной основе, что может произойти в вбланк или не может. Это означает, что если изображение дублируется или содержимое отображается в нескольких местах, приложение, платформа или данные телеметрии могут учитывать все это. Однако эти фреймы для этого компоновщика предоставляют неполные сведения о несоставных кадрах, например в *ифлип* (независимо от отражения) в имеющуюся цепочку буферов.

В качестве примера использования новая инфраструктура Media Foundation, основанная на имеющуюся цепочку буферов композиции, основывается на [**дкомпоситионжетстатистикс**](/windows/win32/api/dcomp/nf-dcomp-dcompositiongetstatistics) и [**дкомпоситионжеттаржетстатистикс**](/windows/win32/api/dcomp/nf-dcomp-dcompositiongettargetstatistics) , чтобы определить качество представления с помощью телеметрии. Помимо этого API, они будут вызывать отдельный API, когда их фреймы находятся в ифлип и не переносятся в компоновщик.

Для определенных применений мы ожидаем, что приложения будут использовать [**идкомпоситиондевице:: жетфраместатистикс**](/windows/win32/api/dcomp/nf-dcomp-idcompositiondevice-getframestatistics) для получения оценки того, когда будет получен следующий кадр компоновщика путем проверки [**DCOMPOSITION_FRAME_STATISTICS:: некстестиматедфраметиме**](/windows/win32/api/dcomptypes/ns-dcomptypes-dcomposition_frame_statistics).

Во-первых, приложение будет запрашивать последний кадр, относящийся к состоянию представления кадра с помощью различных фраз. Приложение будет иметь существующий *фрамеид* , предоставленный имеющуюся цепочку буферов композиции, или будущие интерфейсы, о которых требуется получить сведения, или вызвать [**дкомпоситионжетфрамеид**](/windows/win32/api/dcomp/nf-dcomp-dcompositiongetframeid) для получения последней **COMPOSITION_FRAME_ID** указанного [**COMPOSITION_FRAME_ID_TYPE**](/windows/win32/api/dcomptypes/ne-dcomptypes-composition_frame_id_type).

* **COMPOSITION_FRAME_ID_CREATED**. Компоновщик начал работу над фреймом.
* **COMPOSITION_FRAME_ID_CONFIRMED**. ИДЕНТИФИКАТОР кадра, в котором завершена работа ЦП, и все, что произошло.
* **COMPOSITION_FRAME_ID_COMPLETED**. Работа GPU завершена для всех целевых объектов, связанных с кадром.

> [!NOTE]
> **COMPOSITION_Frame_ID** монотонно возрастает; так что предыдущие кадры компоновщика можно вывести из него.

Затем приложение запросит основные сведения о фрейме компоновки и список *targetId*, которые являются частью кадра, вызвав [**дкомпоситионжетстатистикс**](/windows/win32/api/dcomp/nf-dcomp-dcompositiongetstatistics). Наконец, если приложению требуются сведения для каждого целевого объекта, то оно будет использовать [**дкомпоситионжеттаржетстатистикс**](/windows/win32/api/dcomp/nf-dcomp-dcompositiongettargetstatistics) для получения сведений для указанных Фрамеид и targetId.

### <a name="c-example"></a>Пример C++

В следующем примере показана пошаговая коллекция статистики кадров из API, которая затем суммируется в функции **таржетфрамерате** для отображения частоты кадров в наборе кадров. Опять же, этот тип кода ожидается в телеметрии или в платформах, а не в приложении.

```cpp
class FrameStatisticsCollector
{
private:
    // Collect at most 4 target monitors
    static constexpr UINT sc_maxTargetCount = 4;

    struct CompositionTargetStats
    {
        COMPOSITION_FRAME_ID frameId;
        COMPOSITION_FRAME_STATS frameStats;

        COMPOSITION_TARGET_ID targetId;
        COMPOSITION_TARGET_STATS targetStats;
    };

    UINT64 m_qpcFrequency;
    COMPOSITION_FRAME_ID m_lastCollectedFrameId = 0;
    std::vector<CompositionTargetStats> m_targetStats;

public:
    FrameStatisticsCollector()
    {
        QueryPerformanceFrequency(&m_qpcFrequency);
        m_lastCollectedFrameId = CurrentFrameId();
    }

    // Queries the compositor clock statistics API to determine the last frame
    // completed by the composition engine
    COMPOSITION_FRAME_ID CurrentFrameId() const
    {
        COMPOSITION_FRAME_ID frameId;
        if (FAILED(_DCompositionGetFrameId(frameIdType, &frameId)))
        {
            frameId = 0;
        }

        return frameId;
    }

    // Queries the system to get information about the latest composition frames
    void CollectStats()
    {
        COMPOSITION_FRAME_ID currentFrameId = CurrentFrameId(COMPOSITION_FRAME_ID_COMPLETED);

        while (m_active && (currentFrameId > m_endFrameId))
        {
            auto newEndFrameId = m_endFrameId + 1;

            COMPOSITION_FRAME_STATS frameStats = {};
            COMPOSITION_TARGET_ID targetIds[sc_maxTargetCount] = {};
            UINT targetCount;

            hr = _DCompositionGetStatistics(newEndFrameId,
                &frameStats,
                _countof(targetIds),
                targetIds,
                &targetCount);
            if (SUCCEEDED(hr))
            {
                // We track up to sc_maxTargetCount targets per frame
                targetCount = min<UINT>(targetCount, _countof(targetIds));

                for (UINT uIndex = 0; uIndex < targetCount; uIndex++)
                {
                    COMPOSITION_TARGET_STATS targetStats = {};
                    hr = DCompositionGetTargetStatistics(newEndFrameId,
                        &targetIds[uIndex],
                        &targetStats);
                    if (SUCCEEDED(hr))
                    {
                        CompositionTargetStats compTargetStats = { newEndFrameId,
                                                                  frameStats,
                                                                  targetIds[uIndex],
                                                                  targetStats };

                        m_compTargetStats.push_back(compTargetStats);
                    }
                    else
                    {
                        m_active = false;
                    }
                }

                m_endFrameId = newEndFrameId;
            }
            else
            {
                m_active = false;
            }
        }
    }

    // Compute the frame rate for the given composition target in frames per
    // second, over the specified frame interval based on historical statistics
    // data
    float TargetFrameRate(
        _const COMPOSITION_TARGET_ID& targetId,
        COMPOSITION_FRAME_ID beginFrameId,
        COMPOSITION_FRAME_ID endFrameId)  const
    {
        UINT frameCount = 0;
        UINT64 beginTime = 0;
        UINT64 endTime = 0;

        for (const auto& stats : m_compTargetStats)
        {
            if ((stats.frameId >= beginFrameId) && (stats.frameId <= endFrameId))
            {
                if (stats.frameId == beginFrameId)
                {
                    beginTime = stats.frameStats.startTime;
                }

                if (stats.frameId == endFrameId)
                {
                    endTime = stats.frameStats.startTime +
                        stats.frameStats.framePeriod;
                }

                if ((stats.targetId == targetId) &&
                    (stats.targetStats.presentTime != 0))
                {
                    frameCount++;
                }
            }
        }

        if ((beginTime != 0) &&
            (endTime != 0) &&
            (endTime > beginTime) &&
            (frameCount != 0))
        {
            auto seconds = static_cast<float>(endTime - beginTime) /
                static_cast<float>(m_qpcFrequency);

            return static_cast<float>(frameCount) / seconds;
        }
        else
        {
            return 0.0f;
        }
    }
};
```

## <a name="glossary"></a>Глоссарий

* **Цель**: Растровое изображение, в которое механизм композиции преобразует визуальное дерево. Это изображение обычно является изображением.
* **Кадр для компоновщика**. Один из рабочих циклов компоновщика &mdash; это не обязательно вбланк.
