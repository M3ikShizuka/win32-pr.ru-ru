---
title: Совместное использование поверхности API графических интерфейсов Windows
description: В этом разделе представлен технический обзор взаимодействия с использованием поверхности API графических интерфейсов Windows, включая Direct3D 11, Direct2D, DirectWrite, Direct3D 10 и Direct3D 9Ex.
ms.assetid: 65abf33e-3d15-42ff-99bd-674f24da773e
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1d889797902c964e603adefc51b25039afca7d46
ms.sourcegitcommit: ea4baf9953a78d2d6bd530b680601e39f3884541
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/01/2020
ms.locfileid: "103794221"
---
# <a name="surface-sharing-between-windows-graphics-apis"></a>Совместное использование поверхности API графических интерфейсов Windows

В этом разделе представлен технический обзор взаимодействия с использованием поверхности API графических интерфейсов Windows, включая Direct3D 11, Direct2D, DirectWrite, Direct3D 10 и Direct3D 9Ex. Если у вас уже есть опыт работы с этими API, этот документ поможет вам использовать несколько интерфейсов API для визуализации на одной и той же поверхности приложения, предназначенной для операционных систем Windows 7 или Windows Vista. В этом разделе также приводятся рекомендации и ссылки на дополнительные ресурсы.

> [!Note]  
> Для обеспечения взаимодействия Direct2D и DirectWrite в среде выполнения DirectX 11,1 можно использовать [устройства Direct2D и контексты устройств](/windows/desktop/Direct2D/devices-and-device-contexts) для непосредственного отображения на устройствах Direct3D 11.

 

В этом разделе содержатся следующие подразделы.

-   [Введение](#introduction)
-   [Общие сведения о взаимодействии API](#api-interoperability-overview)
-   [Сценарии взаимодействия](#interoperability-scenarios)
    -   [Общий доступ к устройствам Direct3D 10,1 с помощью Direct2D](#direct3d-101-device-sharing-with-direct2d)
    -   [Синхронизированные общие поверхности DXGI 1,1](#dxgi-11-synchronized-shared-surfaces)
    -   [Взаимодействие между интерфейсами API на основе Direct3D 9Ex и DXGI](#interoperability-between-direct3d-9ex-and-dxgi-based-apis)
-   [Заключение](#conclusion)

## <a name="introduction"></a>Введение

В этом документе взаимодействие API графических интерфейсов Windows относится к совместному использованию одной и той же области отрисовки различными интерфейсами API. Такой тип взаимодействия позволяет приложениям создавать привлекательные экраны, используя несколько API графических интерфейсов Windows, а также упростить миграцию на новые технологии, обеспечивая совместимость с существующими интерфейсами API.

В Windows 7 (и Windows Vista SP2 с пакетом взаимодействия Windows 7, Vista 7IP) API графической отрисовки — это Direct3D 11, Direct2D, Direct3D 10,1, Direct3D 10,0, Direct3D 9Ex, Direct3D 9C и более ранние API Direct3D, а также GDI и GDI+. Компонент Windows Imaging Component (WIC) и DirectWrite — это связанные технологии для обработки изображений, и Direct2D выполняет отрисовку текста. API ускорения видео DirectX (ДКСВА), основанный на Direct3D 9C и Direct3D 9Ex, используется для обработки видео.

Так как API графических интерфейсов Windows развиваются в сторону, основанной на Direct3D, корпорация Майкрософт придает больше усилий для обеспечения взаимодействия между API. Новые API-интерфейсы Direct3D и интерфейсы API более высокого уровня, основанные на интерфейсах API Direct3D, также обеспечивают поддержку, необходимую для обеспечения совместимости с более старыми API. Чтобы продемонстрировать, Direct2D приложения могут использовать Direct3D 10,1, совместно используя устройство Direct3D 10,1. Кроме того, интерфейсы API Direct3D 11, Direct2D и Direct3D 10,1 могут использовать преимущества графической инфраструктуры DirectX (DXGI) 1,1, которая обеспечивает синхронизированные общие поверхности, полностью поддерживающие взаимодействие между этими API. API-интерфейсы DXGI 1,1 взаимодействуют с GDI, а с GDI+ по ассоциации, получая контекст устройства GDI из поверхности DXGI 1,1. Дополнительные сведения см. в документации по взаимодействию с DXGI и GDI, доступной на сайте MSDN.

Несинхронизированный общий доступ к поверхности поддерживается средой выполнения Direct3D 9Ex. Видеоприложения на основе ДКСВА могут использовать вспомогательную функцию взаимодействия 9Ex и DXGI Direct3D для совместимости с Direct3D 9Ex на основе ДКСВА с Direct3D 11 для Compute Shader или могут взаимодействовать с Direct2D для двумерных элементов управления или отрисовки текста. WIC и DirectWrite также взаимодействуют с GDI, Direct2D и ассоциациями, другими API-интерфейсами Direct3D.

Direct3D 10,0, Direct3D 9C и более ранние среды выполнения Direct3D не поддерживают общие поверхности. Копии памяти системы будут по-прежнему использоваться для взаимодействия с интерфейсами API на основе GDI или DXGI.

Обратите внимание, что сценарии взаимодействия в этом документе относятся к отрисовке нескольких графических интерфейсов API в общей области отрисовки, а не в одном окне приложения. Синхронизация для отдельных интерфейсов API, предназначенных для разных поверхностей, которые затем объединяются в одно окно, выходит за рамки данного документа.

## <a name="api-interoperability-overview"></a>Общие сведения о взаимодействии API

Совместный доступ к поверхности API графических интерфейсов Windows можно описать с помощью сценариев API и API и соответствующих функций взаимодействия. В Windows 7 и начиная с Windows Vista с пакетом обновления 2 (SP2) с 7IP новые API и связанные среды выполнения включают Direct2D и связанные технологии: Direct3D 11 и DXGI 1,1. Производительность GDI была также улучшена в Windows 7. В пакет обновления 1 (SP1) для Windows Vista появился Direct3D 10,1. На следующей схеме показана поддержка взаимодействия между API.

![Схема поддержки взаимодействия между API графических интерфейсов Windows](images/surface-sharing-interoperability.png)

На этой диаграмме стрелки показывают сценарии взаимодействия, в которых одна и та же поверхность может быть доступна для подключенных API. Синие стрелки указывают механизмы взаимодействия, появившиеся в Windows Vista. Зеленые стрелки указывают поддержку взаимодействия для новых API или усовершенствований, которые помогают старым API взаимодействовать с более новыми API. Например, зеленые стрелки представляют общий доступ к устройствам, поддержку синхронизированной общей поверхности, вспомогательный модуль синхронизации Direct3D 9Ex/DXGI и получение контекста устройства GDI из совместимой области.

## <a name="interoperability-scenarios"></a>Сценарии взаимодействия

Начиная с Windows 7 и Windows Vista 7IP, основные предложения от API графических интерфейсов Windows поддерживают поддержку нескольких интерфейсов API для одной и той же поверхности DXGI 1,1.

**Direct3D 11, Direct3D 10,1, Direct2D — взаимодействие друг с другом**

API Direct3D 11, Direct3D 10,1 и Direct2D (и связанные с ним API, такие как DirectWrite и WIC) могут взаимодействовать друг с другом с помощью устройства Direct3D 10,1 или синхронизированных общих поверхностей.

### <a name="direct3d-101-device-sharing-with-direct2d"></a>Общий доступ к устройствам Direct3D 10,1 с помощью Direct2D

Совместное использование устройств между Direct2D и Direct3D 10,1 позволяет приложению использовать оба API для беспрепятственного и эффективного отображения на одной поверхности DXGI 1,1, используя один и тот же базовый объект устройства Direct3D. Direct2D предоставляет возможность вызывать API-интерфейсы Direct2D с помощью существующего устройства Direct3D 10,1, используя тот факт, что Direct2D построен на основе среды выполнения Direct3D 10,1 и DXGI 1,1. В следующих фрагментах кода показано, как Direct2D получает целевой объект отрисовки устройства Direct3D 10,1 из поверхности DXGI 1,1, связанной с устройством. Целевой объект отрисовки устройства Direct3D 10,1 может выполнять вызовы рисования Direct2D между API Бегиндрав и EndDraw.


```C++
// Direct3D 10.1 Device and Swapchain creation
HRESULT hr = D3D10CreateDeviceandSwapChain1(
                pAdapter,
                DriverType,
                Software,
                D3D10_CREATE_DEVICE_BGRA_SUPPORT,
                featureLevel,
                D3D10_1_SDK_VERSION,
                pSwapChainDesc,
                &pSwapChain,
                &pDevice
                );

hr = pSwapChain->GetBuffer(
        0,
        __uuidof(IDXGISurface),
        (void **)&pDXGIBackBuffer
        ));

// Direct3D 10.1 API rendering calls
...

hr = D2D1CreateFactory(
        D2D1_FACTORY_TYPE_SINGLE_THREADED,
        &m_spD2DFactory
        ));

pD2DFactory->CreateDxgiSurfaceRenderTarget(
        pDXGIBackBuffer,
        &renderTargetProperties,
        &pD2DBackBufferRenderTarget
        ));
...

pD2DBackBufferRenderTarget->BeginDraw();
//Direct2D API rendering calls
...

pD2DBackBufferRenderTarget->EndDraw();

pSwapChain->Present(0, 0);
```



**Замечания**

-   Связанное устройство Direct3D 10,1 должно поддерживать формат BGRA. Это устройство было создано путем вызова D3D10CreateDevice1 с параметром D3D10 \_ Create \_ Device \_ BGRA \_ support. Формат BGRA поддерживается начиная с Direct3D 10 на уровне компонентов 9,1.
-   Приложение не должно создавать несколько ID2D1RenderTargets, сопоставленных с одним и тем же устройством Direct3D 10.1.
-   Для оптимальной производительности следует постоянно размещать по крайней мере один ресурс, например текстуры или поверхности, связанные с устройством.

Совместное использование устройств подходит для внутрипроцессного, однопотокового использования одного устройства отрисовки, совместно используемого как интерфейсами API отрисовки Direct3D 10,1, так и Direct2D. Синхронизированные общие поверхности позволяют использовать многопоточные, внутрипроцессный и необработанное использование нескольких устройств отрисовки, используемых интерфейсами API Direct3D 10,1, Direct2D и Direct3D 11.

Другой способ взаимодействия Direct3D 10,1 и Direct2D заключается в использовании ID3D1RenderTarget:: Креатешаредбитмап, который создает объект ID2D1Bitmap из Идксгисурфаце. Вы можете записать сцену Direct3D 10.1 в растровое изображение и визуализировать ее с помощью Direct2D. Дополнительные сведения см. в разделе [метод ID2D1RenderTarget:: креатешаредбитмап](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-createsharedbitmap).

### <a name="direct2d-software-rasterization"></a>Direct2Dное растрирование программного обеспечения

Совместное использование устройств с помощью Direct3D 10,1 не поддерживается при использовании модуля подготовки программного обеспечения Direct2D, например путем указания D2D1 рендеринга \_ \_ \_ использования целевого \_ \_ программного обеспечения \_ в D2D1 \_ прорисовка целевого \_ объекта \_ при создании целевого объекта прорисовки Direct2D.

Direct2D может использовать средство программной прорисовки WARP10 для совместного использования устройства с Direct3D 10 или Direct3D 11, но производительность значительно снижается.

### <a name="dxgi-11-synchronized-shared-surfaces"></a>Синхронизированные общие поверхности DXGI 1,1

Все интерфейсы API Direct3D 11, Direct3D 10,1 и Direct2D используют DXGI 1,1, который предоставляет функции для синхронизации чтения и записи в одну и ту же поверхность видеопамяти (DXGISurface1) двумя или более устройствами Direct3D. Устройства отрисовки, использующие синхронизированные общие поверхности, могут быть устройствами Direct3D 10,1 или Direct3D 11, работающими в одном процессе или между процессами.

Приложения могут использовать синхронизированные общие поверхности для взаимодействия любых устройств на базе DXGI 1,1, таких как Direct3D 11 и Direct3D 10,1, или между Direct3D 11 и Direct2D, получая устройство Direct3D 10,1 из Direct2D целевого объекта прорисовки.

В API-интерфейсах Direct3D 10,1 и более поздних версий для использования DXGI 1,1 Убедитесь, что устройство Direct3D создано с помощью объекта адаптера DXGI 1,1, который перечисляются из объекта фабрики DXGI 1,1. Вызовите CreateDXGIFactory1, чтобы создать объект IDXGIFactory1, и EnumAdapters1, чтобы перечислить объект IDXGIAdapter1. Объект IDXGIAdapter1 необходимо передать в рамках вызова D3D10CreateDevice или D3D10CreateDeviceAndSwapChain. Дополнительные сведения об API-интерфейсах DXGI 1,1 см. в [руководстве по программированию для DXGI](https://msdn.microsoft.com/library/ee418147(VS.85).aspx).

### <a name="apis"></a>Программные интерфейсы

**\_ \_ \_ Общие \_ кэйедмутекс ресурсов D3D10**  
При создании синхронизированного общего ресурса Установите флаг D3D10 \_ ресурсов \_ \_ Общие \_ кэйедмутекс в D3D10 \_ ресурс \_ Прочие \_ .  


```C++
typedef enum D3D10_RESOURCE_MISC_FLAG {
    D3D10_RESOURCE_MISC_GENERATE_MIPS      = 0x1L,
    D3D10_RESOURCE_MISC_SHARED             = 0x2L,
    D3D10_RESOURCE_MISC_TEXTURECUBE        = 0x4L,
    D3D10_RESOURCE_MISC_SHARED_KEYEDMUTEX  = 0x10L,
    D3D10_RESOURCE_MISC_GDI_COMPATIBLE     = 0x20L,
}   D3D10_RESOURCE_MISC_FLAG;
```



**\_ \_ \_ Общие \_ кэйедмутекс ресурсов D3D10**  
Позволяет синхронизировать созданный ресурс с помощью API-интерфейсов Идксгикэйедмутекс:: Аккуиресинк и Релеасесинк. Следующие API-интерфейсы Direct3D 10,1 для создания ресурсов, которые принимают \_ параметр флага D3D10 ресурса, были \_ \_ расширены для поддержки нового флага.  

-   ID3D10Device1::CreateTexture1D
-   ID3D10Device1::CreateTexture2D
-   ID3D10Device1::CreateTexture3D
-   ID3D10Device1:: CreateBuffer

  
Если какая-либо из перечисленных функций вызывается с \_ \_ \_ \_ УСТАНОВЛЕНным флагом D3D10 reshared кэйедмутекс, то возвращаемый интерфейс может быть запрошен для интерфейса Идксгикэйедмутекс, который реализует интерфейсы API аккуиресинк и релеасесинк для синхронизации доступа к поверхности. Устройство, создающее поверхность и любое другое устройство, открывающее поверхность (с помощью Опеншаредресаурце), требуется для вызова Идксгикэйедмутекс:: Аккуиресинк перед всеми командами отрисовки на поверхность, и Идксгикэйедмутекс:: Релеасесинк при завершении подготовки к просмотру.  
Устройства деформации и ссылки не поддерживают общие ресурсы. Попытка создать ресурс с этим флагом на устройстве деформации или на устройство ссылки приведет к тому, что метод Create вернет \_ код ошибки E OUTOFMEMORY.  
**ИНТЕРФЕЙС ИДКСГИКЭЙЕДМУТЕКС**  
Новый интерфейс в DXGI 1,1, Идксгикэйедмутекс представляет ключ мьютекса, который обеспечивает эксклюзивный доступ к общему ресурсу, используемому несколькими устройствами. Справочную документацию об этом интерфейсе и его двух методах, Аккуиресинк и Релеасесинк, см. в разделе [идксгикэйедмутекс](https://msdn.microsoft.com/library/ee421920(VS.85).aspx).  
</dl>

### <a name="sample-synchronized-surface-sharing-between-two-direct3d-101-devices"></a>Пример: синхронизированный общий доступ к поверхности между двумя устройствами Direct3D 10,1

В приведенном ниже примере показан общий доступ к поверхности между двумя устройствами Direct3D 10,1. Синхронизированная Общая поверхность создается устройством Direct3D 10.1.


```C++
// Create Sync Shared Surface using Direct3D10.1 Device 1.
D3D10_TEXTURE2D_DESC desc;
ZeroMemory( &desc, sizeof(desc) );
desc.Width = width;
desc.Height = height;
desc.MipLevels = 1;
desc.ArraySize = 1;
// must match swapchain format in order to CopySubresourceRegion.
desc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
desc.SampleDesc.Count = 1;
desc.Usage = D3D10_USAGE_DEFAULT;
// creates 2D texture as a Synchronized Shared Surface.
desc.MiscFlags = D3D10_RESOURCE_MISC_SHARED_KEYEDMUTEX;
desc.BindFlags = D3D10_BIND_RENDER_TARGET | D3D10_BIND_SHADER_RESOURCE;
ID3D10Texture2D* g_pShared = NULL;
g_pd3dDevice1->CreateTexture2D( &desc, NULL, &g_pShared );

// QI IDXGIResource interface to synchronized shared surface.
IDXGIResource* pDXGIResource = NULL;
g_pShared->QueryInterface(__uuidof(IDXGIResource), (LPVOID*) &pDXGIResource);

// obtain handle to IDXGIResource object.
pDXGIResource->GetSharedHandle(&g_hsharedHandle);
pDXGIResource->Release();
if ( !g_hsharedHandle )
    return E_FAIL;

// QI IDXGIKeyedMutex interface of synchronized shared surface's resource handle.
hr = g_pShared->QueryInterface( __uuidof(IDXGIKeyedMutex),
    (LPVOID*)&g_pDXGIKeyedMutex_dev1 );
If ( FAILED( hr ) || ( g_pDXGIKeyedMutex_dev1 == NULL ) )
    return E_FAIL;
```



Одно устройство Direct3D 10.1 может получить синхронизированную общую область для отрисовки путем вызова Аккуиресинк, а затем освободить поверхность для отрисовки другого устройства путем вызова Релеасесинк. При отсутствии совместного использования синхронизированной общей поверхности с любым другим устройством Direct3D создатель может получить и освободить синхронизированную общую поверхность (для запуска и завершения подготовки к просмотру), добавив и выполнив одно и то же значение ключа.


```C++
// Obtain handle to Sync Shared Surface created by Direct3D10.1 Device 1.
hr = g_pd3dDevice2->OpenSharedResource( g_hsharedHandle,__uuidof(ID3D10Texture2D),
                                        (LPVOID*) &g_pdev2Shared);
if (FAILED (hr))
    return hr;
hr = g_pdev2Shared->QueryInterface( __uuidof(IDXGIKeyedMutex),
                                    (LPVOID*) &g_pDXGIKeyedMutex_dev2);
if( FAILED( hr ) || ( g_pDXGIKeyedMutex_dev2 == NULL ) )
    return E_FAIL;

// Rendering onto Sync Shared Surface from D3D10.1 Device 1 using D3D10.1 Device 2.
UINT acqKey = 1;
UINT relKey = 0;
DWORD timeOut = 5;
DWORD result = g_pDXGIKeyedMutex_dev2->AcquireSync(acqKey, timeOut);
if ( result == WAIT_OBJECT_0 )
    // Rendering calls using Device 2.
else
    // Handle unable to acquire shared surface error.
result = g_pDXGIKeyedMutex_dev2->ReleaseSync(relKey));
if (result == WAIT_OBJECT_0)
    return S_OK;
```



Второе устройство Direct3D 10.1 может получить синхронизированную общую область для отрисовки путем вызова Аккуиресинк, а затем освобождает поверхность для отрисовки первого устройства путем вызова Релеасесинк. Обратите внимание, что устройство 2 может получить синхронизированную общую поверхность, используя то же значение ключа, которое указано в вызове Релеасесинк устройством 1.


```C++
// Rendering onto Sync Shared Surface from D3D10.1 Device 1 using D3D10.1 Device 1.
UINT acqKey = 0;
UINT relKey = 1;
DWORD timeOut = 5;
DWORD result = g_pDXGIKeyedMutex_dev1->AcquireSync(acqKey, timeOut);
if (result == WAIT_OBJECT_0)
    // Rendering calls using Device 1.
else
    // Handle unable to acquire shared surface error.
result = g_pDXGIKeyedMutex_dev1->ReleaseSync(relKey));
if ( result == WAIT_OBJECT_0 )
    return S_OK;
```



Дополнительные устройства, совместно использующие одну и ту же поверхность, могут принять и освободить поверхность с помощью дополнительных ключей, как показано в следующих вызовах.


```C++
// Within Device 1's process/thread:
// Rendering onto Sync Shared Surface from D3D10.1 Device 1 using D3D10.1 Device 1
result = g_pDXGIKeyedMutex_dev1->AcquireSync(0, timeOut);
// Rendering calls using Device 1
...
result = g_pDXGIKeyedMutex_dev1->ReleaseSync(1);
...
////////////////////////////////////////////////////////////////////////////
// Within Device 2's process/thread:
// Rendering onto Sync Shared Surface from D3D10.1 Device 1 using D3D10.1 Device 2
result = g_pDXGIKeyedMutex_dev2->AcquireSync(1, timeOut);
// Rendering calls using Device 2
...
result = g_pDXGIKeyedMutex_dev1->ReleaseSync(2);

////////////////////////////////////////////////////////////////////////////
// Within Device 3's process/thread:
// Rendering onto Sync Shared Surface from D3D10.1 Device 1 using D3D10.1 Device 3
result = g_pDXGIKeyedMutex_dev1->AcquireSync(2, timeOut);
// Rendering calls using Device 3
...
result = g_pDXGIKeyedMutex_dev1->ReleaseSync(0);
...
```



Обратите внимание, что реальное приложение может всегда отображаться на промежуточной поверхности, которая затем копируется в общую область, чтобы предотвратить любое устройство, ожидающее другого устройства, которое использует эту поверхность.

### <a name="using-synchronized-shared-surfaces-with-direct2d-and-direct3d-11"></a>Использование синхронизированных общих поверхностей с Direct2D и Direct3D 11

Аналогично, для совместного использования интерфейсов API Direct3D 11 и Direct3D 10,1 можно создать синхронизированную общую область на любом устройстве API и предоставить общий доступ другим устройствам API в или из процесса.

Приложения, использующие Direct2D, могут использовать устройство Direct3D 10,1 и использовать синхронизированную общую поверхность для взаимодействия с Direct3D 11 или другими устройствами Direct3D 10,1, независимо от того, принадлежат ли они одному и тому же процессу или разным процессам. Однако для однопроцессных приложений с одним потоком совместное использование устройств является самым высокопроизводительным и эффективным способом взаимодействия между Direct2D и Direct3D 10 или Direct3D 11.

### <a name="software-rasterizer"></a>Средство программной прорисовки

Синхронизированные общие поверхности не поддерживаются, если приложения используют средства программной прорисовки Direct3D или Direct2D, в том числе средство средства прорисовки и деформацию, вместо использования аппаратного ускорения графики.

### <a name="interoperability-between-direct3d-9ex-and-dxgi-based-apis"></a>Взаимодействие между интерфейсами API на основе Direct3D 9Ex и DXGI

API-интерфейсы 9Ex Direct3D включали понятие общего доступа к поверхности, позволяющее другим API-интерфейсам считывать из общей поверхности. Чтобы предоставить общий доступ к чтению и записи на общую поверхность Direct3D 9Ex, необходимо добавить вручную синхронизацию с самим приложением.

### <a name="direct3d-9ex-shared-surfaces-plus-manual-synchronization-helper"></a>Общие поверхности Direct3D 9Ex и вспомогательное приложение синхронизации вручную

Самая фундаментальная задача в области взаимодействия Direct3D 9Ex и Direct3D 10 или 11 заключается в передаче одной поверхности с первого устройства (устройства A) второму (устройство б), таким образом, когда устройство б получает маркер на поверхности, подготовка к просмотру устройства A гарантированно завершена. Таким образом, устройство б может использовать эту область без беспокойства. Это очень похоже на проблему классической модели "производитель-получатель", и в этом обсуждении моделируется проблема. Первое устройство, использующее поверхность, а затем использующая ее, — это производитель (устройство а), а устройство, которое изначально ожидает, является потребителем (устройство б). Любое реальное приложение является более сложным, чем оно, и будет объединять несколько стандартных блоков "производитель-получатель" для создания требуемой функциональности.

Стандартные блоки "производитель-получатель" реализуются в вспомогательном модуле с помощью очереди поверхностей. Поверхности помещаются в очередь производителем и выводятся из очереди потребителем. В вспомогательном модуле представлены три интерфейса COM: Исурфацекуеуе, Исурфацепродуцер и Исурфацеконсумер.

### <a name="high-level-overview-of-helper"></a>High-Level обзор вспомогательной функции

Объект Исурфацекуеуе является стандартным блоком для использования общих поверхностей. Он создается с инициализированным устройством Direct3D и описанием для создания фиксированного количества общих поверхностей. Объект Queue управляет созданием ресурсов и открытием кода. Число и тип поверхностей фиксированы; После создания поверхностей приложение не сможет добавлять или удалять их.

Каждый экземпляр объекта Исурфацекуеуе обеспечивает сортировку односторонней улицы, которую можно использовать для отправки поверхностей с устройства, производящего работу, на устройство. Для включения общего доступа к контактам между устройствами конкретных приложений можно использовать несколько таких односторонних улиц.

**Создание или время существования объекта**  
Существует два способа создания объекта очереди: с помощью Креатесурфацекуеуе или метода Clone объекта Исурфацекуеуе. Поскольку интерфейсы являются COM-объектами, применяется стандартное управление жизненным циклом COM.  
**Модель "производитель-получатель"**  
Постановка в очередь (): производитель вызывает эту функцию, чтобы указать, что она выполняется с поверхностью, которая теперь может быть доступна для другого устройства. После возврата этой функции устройство производителя больше не имеет прав на поверхность, и его использование будет незащищенным.  
Вывод из очереди (). устройство, вызывающее потребление, вызывает эту функцию для получения общей поверхности. API гарантирует, что все выходящие из очереди поверхности будут готовы к использованию.  
**Метаданные**  
API поддерживает связывание метаданных с общими областями.  
В постановке в очередь () можно указать дополнительные метаданные, которые будут переданы устройству, используемому для использования. Метаданные должны быть меньше, чем максимальное значение, известное во время создания.  
Функция requeue () при необходимости может передавать буфер и указатель на размер буфера. Очередь заполняет буфер метаданными из соответствующего вызова очереди.  
**клонирования**  
Каждый объект Исурфацекуеуе разрешает одностороннюю синхронизацию. Предполагается, что подавляющее большинство приложений, использующих этот API, будет использовать закрытую систему. Простейшая закрытая система с двумя устройствами, отправляющим поверхности, должна иметь две очереди. Объект Исурфацекуеуе содержит метод Clone (), позволяющий создать несколько очередей, которые являются частью одного и того же крупного конвейера.  
Clone создает новый объект Исурфацекуеуе из существующего объекта и разделяет все открытые ресурсы между ними. Полученный объект имеет точно те же поверхности, что и исходная очередь. Клонированные очереди могут иметь разные размеры метаданных друг от друга.  
**Surfaces**  
Исурфацекуеуе отвечает за создание поверхностей и управление ими. Не допускается ставить в очередь произвольные поверхности. Кроме того, поверхность должна иметь только один активный "владелец". Он должен находиться в определенной очереди или использоваться конкретным устройством. Его нельзя использовать в нескольких очередях или для того, чтобы устройства продолжали использовать область после ее постановки в очередь.  
</dl>

### <a name="api-details"></a>Сведения об API

### <a name="isurfacequeue"></a>исурфацекуеуе

Очередь отвечает за создание и обслуживание общих ресурсов. Он также предоставляет функции для сцепления нескольких очередей с помощью клонирования. В очереди есть методы, которые открывают устройство, производящее создание, и устройство. В любое время можно открыть только один из них.

Очередь предоставляет следующие интерфейсы API:



|                             |                                                                                  |
|-----------------------------|----------------------------------------------------------------------------------|
| креатесурфацекуеуе          | Создает объект Исурфацекуеуе ("корневую" очередь).                              |
| Исурфацекуеуе:: Опенконсумер | Возвращает интерфейс для использования устройством для вывода из очереди.                        |
| Исурфацекуеуе:: Опенпродуцер | Возвращает интерфейс для устройства, создающего постановку в очередь.                        |
| Исурфацекуеуе:: Clone        | Создает объект Исурфацекуеуе, который совместно использует поверхности с объектом корневой очереди. |



 

**креатесурфацекуеуе**  


```C++
typedef struct SURFACE_QUEUE_DESC {
  UINT            Width;
  UINT            Height;
  DXGI_FORMAT     Format;
  UINT            NumSurfaces;
  UINT            MetaDataSize;
  DWORD           Flags;
} SURFACE_QUEUE_DESC;
```



**Члены**  

**Ширина**. **Высота**  измерений общих поверхностей. Все общие поверхности должны иметь одинаковые размеры.  
**Формат** Формат общих поверхностей. Все общие поверхности должны иметь одинаковый формат. Допустимые форматы зависят от устройств, которые будут использоваться, так как разные пары устройств могут совместно использовать различные типы форматов.  
**Нумсурфацес**  Количество поверхностей, входящих в очередь. Это фиксированное число.  
 **Метадатасизе**  Максимальный размер буфера метаданных.  
**Флаги**  Флаги для управления поведением очереди. См. заметки.  



```C++
HRESULT CreateSurfaceQueue(
  [in]   SURFACE_QUEUE_DESC *pDesc,
  [in]   IUnknown *pDevice,
  [out]  IDXGIXSurfaceQueue **ppQueue
);
```



**Параметры**

 *пдеск* \[ в \]  описание создаваемой очереди общей поверхности.  

 *пдевице* \[ на \]  устройстве, которое следует использовать для создания общих поверхностей. Это явный параметр из-за возможности Windows Vista. Для поверхностей, совместно используемых Direct3D 9 и Direct3D 10, поверхности должны создаваться с помощью Direct3D 9.  

 *ппкуеуе* \[ out \]  при возврате содержит указатель на объект исурфацекуеуе.  


**Возвращаемые значения**

Если *пдевице* не поддерживает совместное использование ресурсов, эта функция ВОЗВРАЩАЕТ ошибку DXGI, \_ \_ Недопустимый \_ вызов. Эта функция создает ресурсы. В случае сбоя он возвращает ошибку. Если оно завершается успешно, то возвращается значение S \_ ОК.

**Замечания**

При создании объекта Queue также создаются все поверхности. Предполагается, что все поверхности являются целевыми объектами рендеринга, и они будут созданы с помощью \_ \_ целевого объекта рендеринга привязки D3D10 \_ и \_ \_ \_ установленных флагов ресурсов шейдера D3D10 BIND (или эквивалентных флагов для разных сред выполнения).

Разработчик может указать флаг, указывающий, будет ли доступ к очереди выполняться несколькими потоками. Если флаги не заданы (**flags** = = 0), очередь будет использоваться несколькими потоками. Разработчик может указать единый потоковый доступ, который отключает код синхронизации и обеспечивает повышение производительности в этих случаях. Каждая клонированная очередь имеет собственный флаг, поэтому различные очереди в системе могут иметь разные элементы управления синхронизации.

 **Открытие производителя**  


```C++
HRESULT OpenProducer(
  [in]   IUnknown *pDevice,
  [out]  IDXGIXSurfaceProducer **ppProducer
);
```



**Параметры**  

*пдевице* \[ окне\]  

Устройство производителя, которое ставит в очередь поверхности. 

*пппродуцер* \[ out \] возвращает объект интерфейсу Producer.  


**Возвращаемые значения**

Если устройство не поддерживает совместное использование поверхностей, возвращает ошибку DXGI \_ , \_ Недопустимый \_ вызов.

**Открытие объекта-получателя**  


```C++
HRESULT OpenConsumer(
  [in]   IUnknown *pDevice,
  [out]  IDXGIXSurfaceConsumer **ppConsumer
);
```



**Параметры**  
 *пдевице* \[ окне\]  
 Устройство-потребитель, которое вымещает поверхности из очереди поверхности. 
 *ппконсумер* \[ \]  метод out возвращает объект для интерфейса потребителя.  


**Возвращаемые значения**

Если устройство не поддерживает совместное использование поверхностей, возвращает ошибку DXGI \_ , \_ Недопустимый \_ вызов.

**Замечания**

Эта функция открывает все поверхности в очереди для устройства ввода и кэширует их. Последующие вызовы для вывода из очереди будут просто переходить в кэш и не должны повторно открывать поверхности каждый раз.



### <a name="cloning-an-idxgixsurfacequeue"></a>Клонирование Идксгикссурфацекуеуе




```C++
typedef struct SHARED_SURFACE_QUEUE_CLONE_DESC {
  UINT         MetaDataSize;
  DWORD        Flags;
} SHARED_SURFACE_QUEUE_CLONE_DESC;
```



**Члены** **метадатасизе** и **flags** имеют то же поведение, что и для креатесурфацекуеуе.  



```C++
HRESULT Clone(
  [in]   SHARED_SURFACE_QUEUE_CLONE_DESC *pDesc,
  [out]  IDXGIXSurfaceQueue **ppQueue
);
```



**Параметры**

*пдеск* \[ в \] структуре, которая предоставляет описание создаваемого объекта Clone. Этот параметр должен быть инициализирован.  
*ппкуеуе* \[ out \] возвращает инициализированный объект.  
</dl>

**Замечания**

Можно клонировать из любого существующего объекта очереди, даже если он не является корневым.  
</dl>

### <a name="idxgixsurfaceconsumer"></a>идксгикссурфацеконсумер

<dl>


```C++
HRESULT Dequeue(
  [in]      REFIID    id,
  [out]     void      **ppSurface,
  [in,out]  void      *pBuffer,
  [in,out]  UINT      *pBufferSize,
  [in]      DWORD     dwTimeout
);
```



**Параметры**  
*идентификатор* \[ в\]  
РЕФИИД двухмерной поверхности устройства.  

-   Для IDirect3DDevice9 РЕФИИД должен быть \_ \_ Ууидоф (IDirect3DTexture9).
-   Для ID3D10Device РЕФИИД должен быть \_ \_ Ууидоф (ID3D10Texture2D).
-   Для ID3D11Device РЕФИИД должен быть \_ \_ Ууидоф (ID3D11Texture2D).

*ппсурфаце* \[ out \] возвращает указатель на поверхность.  
*pBuffer* \[ в, out \] необязательный параметр и, если Not **null**, при возврате содержит метаданные, переданные в соответствующий вызов очереди.  
*пбуфферсизе* \[ в \] *выpBuffer* размер в байтах. Возвращает число байтов, возвращенных в *pBuffer*. Если в вызове очереди не предоставлены метаданные, *pBuffer* имеет значение 0.  
*двтимеаут* \[ в \] задает значение времени ожидания. Дополнительные сведения см. в комментариях.  
</dl>

**Возвращаемые значения**

Эта функция может возвращать \_ время ожидания, если задано значение времени ожидания и функция не возвращает значение до истечения времени ожидания. См. заметки. Если нет доступных поверхностей, функция возвращает параметру WITH *ппсурфаце* значение **null**, *пбуфферсизе* значение 0, а возвращаемое значение — 0x80070120 (для Win32 \_ — \_ HRESULT ( \_ время ожидания ожидания)).  
</dl>

**Замечания**

Этот API может блокироваться, если очередь пуста. Параметр *двтимеаут* работает идентично API-интерфейсам синхронизации Windows, таким как WaitForSingleObject. Для поведения без блокировки используйте значение времени ожидания 0.  
</dl>

### <a name="isurfaceproducer"></a>исурфацепродуцер

Этот интерфейс предоставляет два метода, которые позволяют приложению ставить в очередь поверхности. После того как поверхность помещается в очередь, указатель поверхности становится недействительным и ненадежным для использования. Единственным действием, которое приложение должно выполнить с помощью указателя, является его освобождение.



|                           |                                                                                                                                                       |
|---------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------|
| Исурфацепродуцер:: поставить в очередь | Помещает поверхность в очередь для объекта очереди. По завершении этого вызова Производитель выполняет действия с поверхностью, а поверхность — готовой для другого устройства. |
| Исурфацепродуцер:: Flush   | Используется, если приложения должны иметь поведение без блокировки. Дополнительные сведения см. в разделе "Примечания".                                                                  |



 

**Очередь**  


```C++
HRESULT Enqueue(
  [in]  IUnknown *pSurface,
  [in]  void *pBuffer,
  [in]  UINT BufferSize,
  [in]  DWORD Flags
);
```



**Параметры**  
*псурфаце* \[ окне\]  
Поверхность создающего устройства, которая должна быть поставлена в очередь. Эта Рабочая область должна быть выведена из очереди из той же сети очередей. *pBuffer* \[ в \] необязательном параметре, который используется для передачи метаданных. Он должен указывать на данные, которые будут переданы в вызов вывода из очереди.  
*BufferSize* \[ \] размер *pBuffer* в байтах.  
*Флаги* \[ в \] необязательном параметре, который управляет поведением этой функции. Единственный флаг — \_ флаг очереди поверхности \_ — \_ \_ не \_ ждать. Дополнительные сведения см. в примечаниях к диску. Если флаг не передается (*flags* = = 0), используется поведение блокировки по умолчанию.  
</dl>

**Возвращаемые значения**

Эта функция может возвращать \_ ошибку \_ DXGI \_ , если не используется флаг " \_ флаг" \_ очереди поверхности \_ \_ \_ \_ .  
</dl>

**Замечания**

-   Эта функция помещает поверхность в очередь. Если в приложении не указан \_ флаг очереди поверхности \_ \_ , то \_ \_ Эта функция блокируется и ВЫПОЛНЯЕТ синхронизацию GPU-ЦП, чтобы гарантировать, что вся отрисовка на поверхности в очереди завершена. Если эта функция выполнена, поверхность будет доступна для вывода из очереди. Если требуется Неблокирующее поведение, используйте флаг "не \_ \_ ожидать". Дополнительные сведения см. в разделе Flush ().
-   Согласно правилам подсчета ссылок COM, поверхность, возвращаемая функцией вывода из очереди, будет иметь AddRef (), поэтому приложению не нужно делать это. После вызова очереди приложение должно освободить поверхность, так как она больше не используется.

**Очистка**  


```C++
HRESULT Flush(
  [in]  DWORD Flags,
  [out] UINT *nSurfaces
);
```



**Параметры**  
*Флаги* \[ окне\]  
Единственный флаг — \_ флаг очереди поверхности \_ — \_ \_ не \_ ждать. См. заметки. *нсурфацес* \[ out \] возвращает количество поверхностей, которые все еще находятся в состоянии ожидания и не сбрасываются.  
</dl>

**Возвращаемые значения**

Эта функция может возвращать \_ ошибку \_ DXGI \_ \_ , если не используется флаг \_ флага очереди поверхности " \_ \_ \_ не ожидать" \_ . Эта функция возвращает значение \_ ОК, если все поверхности были успешно сброшены. Эта функция возвращает \_ ошибку DXGI \_ \_ , пока \_ не была очищена ни одна из поверхностей. Вместе возвращаемое значение и *нсурфацес* указывают приложению, какая работа была выполнена, и если какая-то работа остается действительной.  
</dl>

**Замечания**

Flush имеет смысл только в том случае, если предыдущий вызов в очередь использовал флаг "не ожидать". \_ \_ в противном случае он будет недоступен. Если при вызове в очередь использовался \_ флаг "не \_ ожидать", постановка в очередь выполняется немедленно и синхронизация GPU-CPU не гарантируется. Поверхность по-прежнему считается поставленной в очередь. устройство, производящее работу, не может продолжать его использовать, но недоступно для вывода из очереди. Чтобы попытаться зафиксировать поверхность для вывода из очереди, необходимо вызвать Flush. Сброс пытается зафиксировать все поверхности, которые в настоящий момент поставлены в очередь. Если в параметре Flush не передается флаг, он блокирует и очищает всю очередь, подготавливая все поверхности в ней для вывода из очереди. Если \_ \_ используется флаг «не ожидать ожидания», то очередь будет проверять поверхности, чтобы узнать, готовы ли они к работе; этот шаг не блокируется. Поверхности, для которых завершена синхронизация GPU и ЦП, будут готовы для устройства потребителя. Поверхности, которые все еще ожидают обработки, не затрагиваются. Функция возвращает количество поверхностей, которые все еще необходимо сбросить.

> [!Note]  
> Сброс не нарушает семантику очереди. API гарантирует, что поверхности, поставленные в очередь первыми, будут зафиксированы до последующей постановки поверхностей, независимо от того, когда происходит синхронизация GPU и ЦП.

 

  
</dl>

### <a name="direct3d-9ex-and-dxgi-interop-helper-how-to-use"></a>Помощник по взаимодействию Direct3D 9Ex и DXGI: как использовать

Мы планируем использовать в большинстве случаев использование двух устройств, совместно использующих несколько поверхностей. Поскольку это также является простейшим сценарием, в этом документе подробно описывается использование API-интерфейсов для достижения этой цели, обсуждается неблокирующесть вариации и заканчивается краткий раздел об инициализации для трех устройств.

### <a name="two-devices"></a>Два устройства

Пример приложения, использующего этот вспомогательный метод, может одновременно использовать Direct3D 9Ex и Direct3D 11. Приложение может обрабатывать содержимое на обоих устройствах и представлять содержимое с помощью Direct3D 9. Обработка может означать визуализацию содержимого, декодирование видео, запуск шейдеров вычислений и т. д. Для каждого кадра приложение сначала будет работать с Direct3D 11, затем обрабатываться с помощью Direct3D 9 и, наконец, с Direct3D 9. Более того, при обработке с помощью Direct3D 11 будут получены некоторые метаданные, которые необходимо будет использовать в Direct3D 9. В этом разделе рассматривается использование вспомогательного метода в трех компонентах, соответствующих этой последовательности: инициализация, главный цикл и очистка.

**Инициализация**  
Инициализация включает следующие шаги:  

1.  Инициализируйте оба устройства.
2.  Создайте корневую очередь: m \_ 11to9Queue.
3.  Клонировать из корневой очереди: m \_ 9to11Queue.
4.  Вызовите Опенпродуцер/Опенконсумер в обеих очередях.

В именах очередей используются цифры от 9 до 11, чтобы указать, какой API является производителем, а что является потребителем: **m \_ в очередь ***потребителя*****. Соответственно, m \_ 11to9Queue указывает очередь, для которой устройство Direct3D 11 создает поверхности, используемые устройством Direct3D 9. Аналогичным образом, m \_ 9to11Queue указывает очередь, для которой Direct3D 9 создает поверхности, потребляемые Direct3D 11.  
Корневая очередь изначально заполнена, а все клонированные очереди изначально пусты. Это не должно быть проблемой для приложения, за исключением первого цикла постановки в очередь и вывода из очереди и доступности метаданных. Если при выводе запроса на получение метаданных из очереди не было задано ни одного из них (так как ничего не произошло или если очередь не установила ничего), вывод из очереди не получит никаких метаданных.  

1.  **Инициализируйте оба устройства.**  
    ```C++
    m_pD3D9Device = InitializeD3D9ExDevice();
    m_pD3D11Device = InitializeD3D11Device();
    ```

    

2.  **Создайте корневую очередь.**  
    На этом шаге также создаются поверхности. Ограничения размера и формата идентичны созданию общего ресурса. Размер буфера метаданных фиксируется во время создания, и в этом случае мы просто передаем UINT.  
    Очередь должна быть создана с фиксированным числом поверхностей. Производительность будет зависеть от сценария. Наличие нескольких поверхностей увеличивает вероятность того, что устройства заняты. Например, если имеется только одна поверхность, то не будет параллелизации между двумя устройствами. С другой стороны, увеличение количества поверхностей увеличивает объем памяти, что может снизить производительность. В этом примере используются две поверхности.  
    ```C++
    SURFACE_QUEUE_DESC Desc;
    Desc.Width        = 640;
    Desc.Height       = 480;
    Desc.Format       = DXGI_FORMAT_R16G16B16A16_FLOAT;
    Desc.NumSurfaces  = 2;
    Desc.MetaDataSize = sizeof(UINT);
    Desc.Flags        = 0;

    CreateSurfaceQueue(&Desc, m_pD3D9Device, &m_11to9Queue);
    ```

    

3.  **Клонировать корневую очередь.**  
    Каждая клонированная очередь должна использовать одни и те же поверхности, но может иметь разные размеры буфера метаданных и другие флаги. В этом случае нет метаданных от Direct3D 9 до Direct3D 11.  
    ```C++
    SURFACE_QUEUE_CLONE_DESC Desc;
    Desc.MetaDataSize = 0;
    Desc.Flags        = 0;

    m_11to9Queue->Clone(&Desc, &m_9to11Queue);
    ```

    

4.  **Откройте устройство Producer и потребитель.**  
    Приложение должно выполнить этот шаг перед вызовом постановки в очередь и вывода из очереди. При открытии производителя и потребителя возвращаются интерфейсы, которые содержат API постановки в очередь или из очереди.  
    ```C++
    // Open for m_p9to11Queue.
    m_p9to11Queue->OpenProducer(m_pD3D9Device, &m_pD3D9Producer);
    m_p9to11Queue->OpenConsumer(m_pD3D11Device, &m_pD3D11Consumer);

    // Open for m_p11to9Queue.
    m_p11to9Queue->OpenProducer(m_pD3D11Device, &m_pD3D11Producer);
    m_p11to9Queue->OpenConsumer(m_pD3D9Device, &m_pD3D9Consumer);
    ```

    

**Главный цикл**  
Использование очереди моделируется после классической проблемы с производителем или потребителем. Это следует рассматривать с точки зрения каждого устройства. Каждое устройство должно выполнить следующие действия: вывести из очереди, чтобы получить поверхность из очереди использования, обработать на поверхности, а затем поставить в очередь на ее создание. Для устройства Direct3D 11 использование Direct3D 9 почти идентично.  


```C++
// Direct3D 9 Device.
IDirect3DTexture9* pTexture9 = NULL;
REFIID             surfaceID9 = _uuidof(IDirect3DTexture9);
UINT               metaData;
UINT               metaDataSize;
while (!done)
{
    // Dequeue surface.
    m_pD3D9Consumer->Dequeue(surfaceID9, (void**)&pSurface9,
                             &metaData, &metaDataSize, INFINITE);

    // Process the surface.
    ProcessD3D9(pSurface9);

    // Present the surface using the meta data.
    PresentD3D9(pSurface9, metaData, metaDataSize);

    // Enqueue surface.
    m_pD3D9Producer->Enqueue(pSurface9, NULL, 0, 0);
}
```



**Очистка**  
Этот шаг очень прост. В дополнение к обычным действиям по очистке интерфейсов API Direct3D приложение должно освободить COM-интерфейсы возврата.  


```C++
m_pD3D9Producer->Release();
m_pD3D9Consumer->Release();
m_pD3D11Producer->Release();
m_pD3D11Consumer->Release();
m_p9to11Queue->Release();
m_p11to9Queue->Release();
```



</dl>

### <a name="non-blocking-use"></a>Использование без блокировки

Предыдущий пример имеет смысл для многопоточных случаев использования, в которых каждое устройство имеет собственный поток. В примере используются блокирующие версии API-интерфейсов: бесконечно для времени ожидания и флаги для постановки в очередь. Если вы хотите использовать вспомогательную функцию без блокировки, необходимо внести несколько изменений. В этом разделе показано Неблокирующее использование с обоими устройствами в одном потоке.

**Инициализация**  
Инициализация идентична за исключением флагов. Так как приложение является однопотоковым, используйте этот флаг для создания. Это выключает часть кода синхронизации, что может повысить производительность.  


```C++
SURFACE_QUEUE_DESC Desc;
Desc.Width        = 640;
Desc.Height       = 480;
Desc.Format       = DXGI_FORMAT_R16G16B16A16_FLOAT;
Desc.NumSurfaces  = 2;
Desc.MetaDataSize = sizeof(UINT);
Desc.Flags        = SURFACE_QUEUE_FLAG_SINGLE_THREADED;

CreateSurfaceQueue(&Desc, m_pD3D9Device, &m_11to9Queue);
```




```C++
SURFACE_QUEUE_CLONE_DESC Desc;
Desc.MetaDataSize = 0;
Desc.Flags        = SURFACE_QUEUE_FLAG_SINGLE_THREADED;

m_11to9Queue->Clone(&Desc, &m_9to11Queue);
```



Открытие устройств производителя и потребителя аналогично тому, как показано в примере блокировки.  
**Использование очереди**  
Существует множество способов использования очереди в неблокирующем режиме с различными характеристиками производительности. Следующий пример прост, но имеет низкую производительность из-за чрезмерного цикла и опроса. Несмотря на эти проблемы, в примере показано, как использовать вспомогательную функцию. Подход состоит в том, чтобы постоянно находиться в цикле и выставить в очередь, процесс, поставить в очередь и очистить. Если какие-либо из шагов завершаются неудачей, так как ресурс недоступен, приложение просто пытается снова выполнить следующий цикл.  


```C++
// Direct3D 11 Device.
ID3D11Texture2D* pSurface11 = NULL;
REFIID           surfaceID11 = __uuidof(ID3D11Texture2D);
UINT             metaData;
while (!done)
{
    //
    // D3D11 Portion.
    //

    // Dequeue surface.
    hr = m_pD3D11Consumer->Dequeue(surfaceID11,
                                   (void**)&pSurface11,
                                   NULL, 0, 0);
    // Only continue if we got a surface.
    if (SUCCEEDED(hr))
    {
        // Process the surface and return some meta data.
        ProcessD3D11(pSurface11, &metaData);

        // Enqueue surface.
        m_pD3D11Producer->Enqueue(pSurface11, &metaData,
                                  sizeof(UINT),
                                  SURFACE_QUEUE_FLAG_DO_NOT_WAIT);
    }
    // Flush the queue to check if any surfaces completed.
    m_pD3D11Producer->Flush(NULL,SURFACE_QUEUE_FLAG_DO_NOT_WAIT);

    //
    // Do the same with the Direct3D 9 Device.
    //

    // Dequeue surface.
    hr = m_pD3D9Consumer->Dequeue(surfaceID9,
                                  (void**)&pSurface9,
                                  &metaData,
                                  &metaDataSize, 0);
    // Only continue if we got a surface.
    if (SUCCEEDED(hr)))
    {
        // Process the surface.
        ProcessD3D9(pSurface9);

        // Present the surface using the meta data.
        PresentD3D9(pSurface9, metaData, metaDataSize);

        // Enqueue surface.
        m_pD3D9Producer->Enqueue(pSurface9, NULL, 0,
                                 SURFACE_QUEUE_FLAG_DO_NOT_WAIT);
    }
    // Flush the queue to check if any surfaces completed.
    m_pD3D9Producer->Flush(NULL,SURFACE_QUEUE_FLAG_DO_NOT_WAIT);
}
```



Более сложное решение может проверять возвращаемое значение из постановки в очередь и с записи на диск, чтобы определить, требуется ли очистка.  
</dl>

### <a name="three-devices"></a>Три устройства

Расширение предыдущих примеров для охвата нескольких устройств — это просто. Следующий код выполняет инициализацию. После создания объектов producer/consumer код для их использования будет одинаковым. В этом примере есть три устройства, и, следовательно, три очереди. Передает поток с Direct3D 9 на Direct3D 10 на Direct3D 11.


```C++
SURFACE_QUEUE_DESC Desc;
Desc.Width        = 640;
Desc.Height       = 480;
Desc.Format       = DXGI_FORMAT_R16G16B16A16_FLOAT;
Desc.NumSurfaces  = 2;
Desc.MetaDataSize = sizeof(UINT);
Desc.Flags        = 0;

SURFACE_QUEUE_CLONE_DESC Desc;
Desc.MetaDataSize = 0;
Desc.Flags        = 0;

CreateSurfaceQueue(&Desc, m_pD3D9Device, &m_11to9Queue);
m_11to9Queue->Clone(&Desc, &m_9to10Queue);
m_11to9Queue->Clone(&Desc, &m_10to11Queue);
```



Как упоминалось ранее, клонирование работает так же, независимо от того, какая очередь клонируется. Например, второй вызов клонирования мог быть отключен от \_ объекта 9to10Queue m.


```C++
// Open for m_p9to10Queue.
m_p9to10Queue->OpenProducer(m_pD3D9Device, &m_pD3D9Producer);
m_p9to10Queue->OpenConsumer(m_pD3D10Device, &m_pD3D10Consumer);

// Open for m_p10to11Queue.
m_p10to11Queue->OpenProducer(m_pD3D10Device, &m_pD3D10Producer);
m_p10to11Queue->OpenConsumer(m_pD3D11Device, &m_pD3D11Consumer);

// Open for m_p11to9Queue.
m_p11to9Queue->OpenProducer(m_pD3D11Device, &m_pD3D11Producer);
m_p11to9Queue->OpenConsumer(m_pD3D9Device, &m_pD3D9Consumer);
```



## <a name="conclusion"></a>Заключение

Вы можете создавать решения, использующие взаимодействие, чтобы использовать возможности нескольких API DirectX. Взаимодействие API графических интерфейсов Windows теперь предлагает стандартную среду выполнения для управления поверхностью 1,1. Эта среда выполнения позволяет использовать синхронизированную поддержку общего доступа к поверхности в новых интерфейсах API, таких как Direct3D 11, Direct3D 10,1 и Direct2D. Улучшения взаимодействия между новыми API-интерфейсами и существующими API-интерфейсами упрощают перенос приложений и обратную совместимость. Интерфейсы API потребителя 9Ex и DXGI 1,1 могут взаимодействовать, как показано в механизме синхронизации, предоставленном с помощью примера вспомогательного кода в коллекции кода MSDN.

 

 