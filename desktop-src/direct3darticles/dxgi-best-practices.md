---
title: Рекомендации по графической инфраструктуре DirectX (DXGI)
description: В этой статье обсуждаются проблемы с переносом ключей.
ms.assetid: 2df92ffe-1bfc-d682-2770-20cf0c831c9b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: be992fe2346868eb3481482325297a2c9ec27ee61bdd2c65f83b0f916fc22308
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118290241"
---
# <a name="directx-graphics-infrastructure-dxgi-best-practices"></a>Графическая инфраструктура DirectX (DXGI): рекомендации

Microsoft DirectX Graphics Infrastructure (DXGI) — это новая подсистема, впервые появившаяся в Windows Vista, которая инкапсулирует некоторые задачи низкого уровня, необходимые Direct3D 10 10.1, 11 и 11.1. С точки зрения программиста Direct3D 9, DXGI охватывает большую часть кода для перечисления, создания цепочки замены и представления, которые ранее были упакованы в интерфейсы API Direct3D 9. При переносе приложения на DXGI и Direct3D 10. x и Direct3D 11. x необходимо принять во внимание некоторые аспекты, чтобы обеспечить бесперебойную работу процесса.

В этой статье обсуждаются проблемы с переносом ключей.

-   [Проблемы во всех окнах](#full-screen-issues)
-   [Несколько мониторов](#multiple-monitors)
-   [Стили окна и DXGI](#window-styles-and-dxgi)
-   [Многопоточность и DXGI](#multithreading-and-dxgi)
-   [Гамма и DXGI](#gamma-and-dxgi)
-   [DXGI 1,1](#dxgi-11)
-   [DXGI 1,2](#dxgi-12)

## <a name="full-screen-issues"></a>Проблемы Full-Screen

При переносе от Direct3D 9 к DXGI и до Direct3D 10. x или Direct3D 11. x проблемы, связанные с переходом от окон к полноэкранному режиму, часто могут вызвать головную боль разработчиков. Основные проблемы возникают из-за того, что приложения Direct3D 9, в отличие от приложений DXGI, используют более практичный подход к отслеживанию стилей окон и состояний окон. Если код, меняющийся в режиме, переносится для выполнения на DXGI, это часто приводит к непредвиденному поведению.

Как правило, приложения Direct3D 9 обрабатывали переход в полноэкранный режим, устанавливая разрешение переднего буфера, принудительно переключая устройство в полноэкранный режим монопольного доступа, а затем устанавливая разрешения заднего буфера в соответствие. Для изменения размера окна использовался отдельный путь, так как им пришлось управлять из процесса окна, когда приложение получило \_ сообщение о размере WM.

DXGI пытается упростить этот подход, объединив два варианта. Например, при перетаскивании границы окна в оконном режиме приложение получает \_ сообщение о размере WM. DXGI перехватывает это сообщение и автоматически изменяет размер переднего буфера. Все, что требуется приложению — это вызвать [**идксгисвапчаин:: ресизебуфферс**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizebuffers) , чтобы изменить размер заднего буфера до размера, переданного в качестве параметров в \_ размерах WM. Аналогично, когда приложению нужно переключаться между полноэкранным и оконным режимом, приложение может просто вызвать [**идксгисвапчаин:: сетфуллскринстате**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-setfullscreenstate). DXGI изменяет размер переднего буфера в соответствии с только что выбранным полноэкранным режимом и отправляет \_ приложению сообщение о размере WM. Приложение снова вызывает **ресизебуфферс**, точно так же, как если бы граница окна была перемещена.

Методология предыдущего объяснения соответствует определенному пути. По умолчанию DXGI устанавливает разрешение в полноэкранном режиме для разрешения рабочего стола. Однако многие приложения переключаются на предпочтительное полноэкранное разрешение. В этом случае DXGI предоставляет [**идксгисвапчаин:: ресизетаржет**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget). Этот метод должен быть вызван перед вызовом [**сетфуллскринстате**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-setfullscreenstate). Несмотря на то, что эти методы можно вызывать в обратном порядке (сначала **сетфуллскринстате** , за которым следует **ресизетаржет**), это приводит к тому, что в \_ приложение отправляется дополнительное сообщение о размере WM. (Это также может вызвать мерцание, так как DXGI может принудительно выполнить два изменения режима.) После вызова **сетфуллскринстате** рекомендуется вызвать **ресизетаржет** еще раз с членом **рефрешрате** в [**\_ режиме DXGI \_ DESC**](/previous-versions/windows/desktop/legacy/bb173064(v=vs.85)) zerod. Это количество для инструкции без операций в DXGI, но оно может избежать проблем с частотой обновления, которые обсуждаются далее.

В полноэкранном режиме диспетчер окон рабочего стола (DWM) отключен. DXGI может выполнить перелистывание, чтобы отобразить содержимое заднего буфера вместо выполнения Блит, которое было бы выполнено в оконном режиме. Однако это повышение производительности можно отменить, если определенные требования не выполнены. Чтобы убедиться, что объект DXGI выполняет перелистывание вместо Блит, размер переднего буфера и заднего буфера должен быть одинаковым. Если приложение правильно обрабатывает \_ сообщения размером WM, это не должно быть проблемой. Кроме того, форматы должны быть одинаковыми.

Проблема для большинства приложений заключается в частоте обновления. Частота обновления, указанная в вызове [**ресизетаржет**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget) , должна быть частотой обновления, перечисленной объектом [**идксгиаутпут**](/windows/desktop/api/dxgi/nn-dxgi-idxgioutput) , используемым цепочкой подкачки. DXGI может автоматически вычислить это значение, если приложение отнулиет член **рефрешрате** в [**\_ режиме DXGI \_ DESC**](/previous-versions/windows/desktop/legacy/bb173064(v=vs.85)) , переданном в **ресизетаржет**. Важно не рассчитывать, что определенные частоты обновления всегда будут поддерживаться и просто жестко закодировать значение. Часто разработчики выбирают в качестве частоты обновления 60 Гц, не зная, что частота обновления с монитора составляет приблизительно 60 000/1 001 Гц от монитора. Если частота обновления не совпадает с ожидаемой частотой обновления 60, то DXGI вынуждена выполнить Блит в полноэкранном режиме, а не в виде зеркального отображения.

Последней проблемой, которую часто сталкиваются разработчики, является изменение разрешения полноэкранного режима в полноэкранном режиме. Иногда вызов [**ресизетаржет**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget) и [**сетфуллскринстате**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-setfullscreenstate) происходит с ошибкой, но полное разрешение экрана остается разрешением рабочего стола. Кроме того, разработчики могут создать цепочку полноэкранного буфера обмена и дать определенное разрешение, чтобы обнаружить, что DXGI по умолчанию имеет разрешение рабочего стола, независимо от числа переданных. Если не указано иное, в режиме DXGI по умолчанию используется разрешение рабочего стола для всех цепочек подкачки. При создании цепи подкачки для полноэкранного режима элемент **flags** в [**\_ \_ цепочке \_ перекачки DXGI**](/windows/desktop/api/dxgi/ns-dxgi-dxgi_swap_chain_desc) имеет значение, чтобы [**\_ \_ \_ \_ \_ \_ Переключить**](/windows/desktop/api/dxgi/ne-dxgi-dxgi_swap_chain_flag) поведение DXGI по умолчанию. Этот флаг также можно передать в **ресизетаржет** , чтобы включить или отключить эту функцию динамически.

## <a name="multiple-monitors"></a>Несколько мониторов

При использовании DXGI с несколькими мониторами необходимо выполнить два правила.

Первое правило применяется к созданию двух или более цепочек подкачки в полноэкранном режиме на нескольких мониторах. При создании таких цепочек подкачки лучше всего создать все цепочки подкачки в окне, а затем установить их в полноэкранном режиме. Если цепочки буферов размещаются в полноэкранном режиме, создание второй цепочки подкачки приведет к отправке изменения режима в первую цепочку буферов, что может привести к завершению полноэкранного режима.

Второе правило применяется к выходам. Ватчфул выходные данные, используемые при создании цепочек подкачки. С помощью DXGI объект [**идксгиаутпут**](/windows/desktop/api/dxgi/nn-dxgi-idxgioutput) управляет тем, какой монитор использует цепочка буферов, когда становится полноэкранным. В отличие от DXGI, Direct3D 9 не имел концепции выходов.

## <a name="window-styles-and-dxgi"></a>Стили окна и DXGI

Приложениям Direct3D 9 во время переключения между полноэкранными и оконными режимами было много работы. Большая часть этой работы включала изменение стилей окна для добавления и удаления границ, добавления полос прокрутки и т. д. При переносе приложений в DXGI и Direct3D 10. x или Direct3D 11. x этот код часто остается на месте. В зависимости от сделанных изменений переключение между режимами может привести к непредвиденному поведению. Например, при переключении в оконный режим приложение может больше не иметь границы окна или окна, несмотря на наличие кода, который специально задает эти стили. Это происходит потому, что DXGI теперь обрабатывает большую часть этого стиля, изменяемую самостоятельно. Настройка стилей окна вручную может помешать работе DXGI, и это может привести к непредвиденному поведению.

Рекомендуется сделать как можно меньше работы и позволить DXGI работать с окнами большей части взаимодействия. Однако если приложению требуется обрабатывать собственное поведение окон, [**идксгифактори:: макевиндовассоЦиатион**](/windows/desktop/api/dxgi/nf-dxgi-idxgifactory-makewindowassociation) можно использовать, чтобы сообщить DXGI о необходимости отключить часть ее автоматической обработки окон.

## <a name="multithreading-and-dxgi"></a>Многопоточность и DXGI

В многопоточных приложениях использовать DXGI необходимо с особой осторожностью во избежание возникновения взаимоблокировок. Из-за того, что в связи с тем, что взаимодействие с приложением DXGI связано с окнами, оно иногда отправляет сообщения окна в соответствующее окно приложения. Для выполнения функции DXGI необходимо, чтобы изменения происходили до того, как они будут продолжены, поэтому он будет использовать [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage), который является синхронным вызовом. Приложение должно обработать сообщение окна перед возвратом **SendMessage** .

В приложении, в котором вызовы DXGI и конвейер сообщений находятся в одном потоке (или в приложении с одним потоком), необходимо выполнить небольшие действия. Когда вызов DXGI находится в том же потоке, что и конвейер сообщений, [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) вызывает [*WindowProc*](/previous-versions/windows/desktop/legacy/ms633573(v=vs.85))окна. Это обходит конвейер сообщений и позволяет продолжить выполнение после вызова **SendMessage**. Помните, что вызовы [**идксгисвапчаин**](/windows/desktop/api/dxgi/nn-dxgi-idxgiswapchain) , такие как [**идксгисвапчаин::P**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-present)повторной отправки, также считаются вызовами DXGI. DXGI может отложить работу от [**ресизебуфферс**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizebuffers) или [**Ресизетаржет**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-resizetarget) до вызова **Present** .

Если вызов и генератор сообщений DXGI находятся в разных потоках, необходимо соблюдать осторожность, чтобы избежать взаимоблокировок. Когда конвейер сообщений и SendMessage находятся в разных потоках, [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) добавляет сообщение в очередь сообщений окна и ожидает, пока окно не обработает это сообщение. Если процедура окна занята или не вызвана конвейером сообщений, сообщение может быть не обработано, а DXGI будет ждать бесконечно.

Например, если приложение с конвейером сообщений находится в одном потоке и его отрисовке на другом, может потребоваться изменить режимы. Поток конвейера сообщений сообщает потоку отрисовки об изменении режимов и ожидает завершения изменения режима. Однако поток отрисовки вызывает функции DXGI, которые, в свою очередь, вызывают [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage), которые блокируют, пока конвейер сообщений не обработает сообщение. Взаимоблокировка возникает потому, что оба потока заблокированы и ожидают друг друга. Чтобы избежать этого, никогда не блокируйте конвейер сообщений. Если блок недоступен, все взаимодействие с DXGI должно выполняться в том же потоке, что и конвейер сообщений.

## <a name="gamma-and-dxgi"></a>Гамма и DXGI

Хотя гамма может быть лучше обработана в Direct3D 10. x или Direct3D 11. x с помощью текстур SRGB, гамма-шкала все еще может быть полезной для разработчиков, которым требуется другое значение гаммы, чем 2,2, или использование формата целевого объекта прорисовки, не поддерживающего SRGB. При настройке гамма-шкалы с помощью DXGI необходимо учитывать две проблемы. Первая причина заключается в том, что значения пандуса, передаваемые в [**идксгиаутпут:: сетгаммаконтрол**](/windows/desktop/api/dxgi/nf-dxgi-idxgioutput-setgammacontrol) , являются значениями с плавающей запятой, а не значениями **слов** . Кроме того, убедитесь, что код, перенесенный с Direct3D 9, не пытается преобразовать их в значения **слов** , прежде чем передавать их в **сетгаммаконтрол**.

Вторая ситуация заключается в том, что после перехода на полноэкранный режим [**сетгаммаконтрол**](/windows/desktop/api/dxgi/nf-dxgi-idxgioutput-setgammacontrol) может не работать, в зависимости от используемого объекта [**идксгиаутпут**](/windows/desktop/api/dxgi/nn-dxgi-idxgioutput) . При переходе на полноэкранный режим DXGI создает новый выходной объект и использует объект для всех последующих операций с выходными данными. При вызове **сетгаммаконтрол** для выходных данных, перечисленных перед переключением в полноэкранный режим, вызов не направлен к выходным данным, используемым DXGI в данный момент. Чтобы избежать этого, вызовите метод [**идксгисвапчаин:: жетконтаинингаутпут**](/windows/desktop/api/dxgi/nf-dxgi-idxgiswapchain-getcontainingoutput) , чтобы получить текущие выходные данные, а затем вызовите **сетгаммаконтрол** из этих выходных данных, чтобы получить правильное поведение.

Сведения об использовании гамма-коррекции см. [в разделе Использование гамма-коррекции](/windows/desktop/direct3ddxgi/using-gamma-correction).

## <a name="dxgi-11"></a>DXGI 1,1

среда выполнения Direct3D 11, входящая в Windows 7 и установленную на Windows Vista (см. [KB971644](https://support.microsoft.com/kb/971644)), включает в себя версию 1,1 для DXGI. Это обновление добавляет определения для ряда новых форматов (особенно BGRA, 10-разрядного смещения x2 и BC6H и BC7 для сжатия текстур Direct3D 11), а также новую версию фабрики DXGI и интерфейсов адаптеров ([**CreateDXGIFactory1**](/windows/desktop/api/dxgi/nf-dxgi-createdxgifactory1), [**IDXGIFactory1**](/windows/desktop/api/dxgi/nn-dxgi-idxgifactory1), [**IDXGIAdapter1**](/windows/desktop/api/dxgi/nn-dxgi-idxgiadapter1)) для перечисления подключений к удаленному рабочему столу.

При использовании Direct3D 11 среда выполнения по умолчанию будет использовать DXGI 1,1 при вызове [**D3D11CreateDevice**](/windows/desktop/api/d3d11/nf-d3d11-d3d11createdevice) или [**D3D11CreateDeviceAndSwapChain**](/windows/desktop/api/d3d11/nf-d3d11-d3d11createdeviceandswapchain) с пустым указателем [**идксгиадаптер**](/windows/desktop/api/dxgi/nn-dxgi-idxgiadapter) . Смешивание использования DXGI 1,0 и DXGI 1,1 в одном процессе не поддерживается. Смешивание экземпляров объектов DXGI из разных фабрик в одном процессе также не поддерживается. Таким образом, при использовании DirectX 11 любое явное использование интерфейсов DXGI использует [**IDXGIFactory1**](/windows/desktop/api/dxgi/nn-dxgi-idxgifactory1) , созданную точкой входа [**CreateDXGIFactory1**](/windows/desktop/api/dxgi/nf-dxgi-createdxgifactory1) в "DXGI.DLL", чтобы гарантировать, что приложение всегда использует DXGI 1,1.

## <a name="dxgi-12"></a>DXGI 1,2

среда выполнения Direct3D 11,1, включенная в Windows 8, также включает в себя версию 1,2 для DXGI.

DXGI 1,2 включает следующие функции.

-   стерео отрисовка
-   16-разрядные форматы на пиксель

    -   \_Формат DXGI \_ B5G6R5 \_ UNORM и DXGI \_ \_ B5G5R5A1 \_ UNORM теперь полностью поддерживаются
    -   \_ \_ добавлен новый \_ Формат B5G5R5A1 UNORM в формате DXGI

-   форматы видео
-   новые интерфейсы DXGI

Дополнительные сведения о возможностях DXGI 1,2 см. в разделе [улучшения dxgi 1,2](/windows/desktop/direct3ddxgi/dxgi-1-2-improvements).

 

 