---
title: Про приложения DirectX
description: показано, как измерять некоторые из наиболее важных измерений времени производительности для приложения DirectX с помощью средств XPerf и GPUView, поставляемых в составе набор средств производительности Windows.
ms.assetid: 4B2F7273-C9B0-4DD3-B559-6220CDE62129
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0280389d4f8f2161e5e07f8906df7ea0484ad458
ms.sourcegitcommit: d75fc10b9f0825bbe5ce5045c90d4045e3c53243
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/13/2021
ms.locfileid: "127162631"
---
# <a name="profiling-directx-apps"></a>Про приложения DirectX

здесь показано, как измерять некоторые из наиболее важных измерений времени производительности для приложения [DirectX](/previous-versions/windows/apps/jj262109(v=win.10)) с помощью средств **XPerf** и **GPUView** , поставляемых в составе набор средств производительности Windows. Это не исчерпывающее представление о средствах, а об их особенностях для анализа производительности приложений DirectX. Хотя большинство обсуждаемых методик относятся ко всем приложениям DirectX, оно особенно важно для приложений, использующих цепочки подкачки, а не для приложений DirectX, созданных на основе XAML, использующих анимацию SIS/ВСИС и XAML. Мы расскажу вам о ключевых измерениях времени производительности, о том, как получить и установить средства, а затем взять трассировку измерения производительности, а затем проанализировать их, чтобы понять узкие места приложений.

## <a name="about-the-tools"></a>О средствах

### <a name="xperf"></a>**XPerf**

**XPerf** — это набор средств анализа производительности на основе трассировки событий для Windows (ETW), предназначенный для измерения и анализа подробной производительности системы и приложений и использования ресурсов. начиная с Windows 8 это средство командной строки имеет графический пользовательский интерфейс и называется Windowsом средства записи производительности (звч) и Windows performance Analyzer (WPA). дополнительные сведения об этих средствах можно найти на веб-странице для [Windows набор средств производительности](/previous-versions/windows/it-pro/windows-8.1-and-8/hh162945(v=win.10)) (WPT): [Windows набор средств производительности](/previous-versions/windows/it-pro/windows-8.1-and-8/hh162945(v=win.10)).

ETW собирает запрошенные события ядра и сохраняет их в файл, называемый файлом журнала трассировки событий (ETL). Эти события ядра предоставляют подробные сведения о характеристиках приложения и системы при запуске приложения. Сбор данных осуществляется путем включения захвата трассировки, выполнения требуемого сценария приложения, требующего анализа, прекращения записи, которая сохраняет данные в ETL-файле. Затем можно проанализировать файл на том же или на другом компьютере с помощью программы командной строки **xperf.exe** или средства анализа визуальной трассировки **xperfview.exe**.

### <a name="gpuview"></a>GPUView;

**GPUView** — это средство разработки для определения производительности графического процессора и ЦП. Он рассматривает производительность с точки зрения обработки буфера прямого доступа к памяти (DMA) и других видеоматериалов на видеооборудовании.

Для приложений [DirectX](/previous-versions/windows/apps/jj262109(v=win.10)) , которые сильно полагаются на GPU, **GPUView** является мощным средством для понимания отношений между работой, выполненной на ЦП и GPU. Дополнительные сведения о **GPUView** см. [в разделе Использование GPUView](/windows-hardware/drivers/display/using-gpuview).

Как и в случае с **Xperf**, трассировка ETW сначала выполняется запуском службы трассировки, с использованием сценария, который требует анализа для рассматриваемого приложения, и останавливает службу и сохраняет данные в ETL-файле. **GPUView** представляет данные, представленные в ETL-файле в графическом формате.

После установки средства **GPUView** мы рекомендуем ознакомиться с разделом "главное отображение **GPUView**" в меню "Справка"**GPUView** . Он содержит полезную информацию о том, как интерпретировать пользовательский интерфейс **GPUView** .

## <a name="installing-the-tools"></a>Установка средств

как **XPerf** , так и **GPUView** включены в Windows набор средств производительности (WPT).

**XPerf** поставляется в Windows составе пакета средств разработки программного обеспечения (SDK) для Windows. [скачайте Windows SDK](https://dev.windows.com/downloads).

**GPUView** доступен в комплекте средств для развертывания и оценки Windows (Windows ADK). [скачайте Windows ADK](/windows-hardware/get-started/adk-install).

После установки необходимо добавить в системную переменную "Path" каталоги, содержащие **Xperf** и **GPUView** .

Нажмите кнопку "Пуск" и введите "Системные переменные". Откроется системное окно свойств. Щелкните "изменить системные переменные среды". Выберите "переменные среды" в диалоговом окне "Свойства системы". Переменная "Path" находится в разделе "Системные переменные". Добавьте в путь Каталог, содержащий **xperf.exe** и **GPUView.exe** . эти исполняемые файлы находятся в каталоге "Windows производительности набор средств" внутри комплекта Windows. расположение по умолчанию: **C: \\ Program files (x86) \\ Windows kits \\ 10 \\ Windows набор средств производительности**.

## <a name="performance-time-measurements"></a>Измерения времени производительности

Большинство приложений должны работать плавно и реагировать на ввод данных пользователем. Однако в зависимости от нужного сценария один аспект производительности может быть более важным, чем другой. Например, для приложения для чтения новостей, работающего на сенсорном планшетном ПК, наиболее важным аспектом является просмотр одной статьи за раз, а также сдвиг/масштаб и прокрутку одной или другой статьи. В этом сценарии возможность просмотра всего содержимого для каждого кадра не требуется. Однако очень важно иметь возможность плавно прокручивать статью по сенсорному жесту.

В другом экземпляре, в игре или в приложении для отрисовки видео, использующем большое количество анимаций, производятся сбои при удалении кадров. В этом случае очень важно иметь возможность предоставлять содержимое на экране, не интеруптион от вводимых пользователем данных.

Чтобы понять, какая часть приложения является проблематичной, первым шагом является выбор наиболее важных сценариев. После того как основные аспекты приложения понятны и как они будут применяться, поиск проблем с помощью средств становится проще.

Ниже приведены некоторые из наиболее распространенных метрик времени производительности.

### <a name="startup-time"></a>Время запуска

Время от запуска процесса до первого присутствия на экране. Это измерение более полезно, если система является теплой, что означает, что измерение берется после запуска приложения несколько раз.

### <a name="cpu-time-per-frame"></a>Время ЦП на кадр

Время, когда ЦП активно обрабатывает рабочую нагрузку приложения для одного кадра. Если приложение работает без проблем, вся обработка, необходимая для одного кадра, происходит в течение одного интервала v-Sync. При частоте обновления монитора 60 Гц это 16ms на кадр. Если время или кадр ЦП больше 16ms, то для создания безошибочного приложения может потребоваться оптимизация центрального процессора.

### <a name="gpu-time-per-frame"></a>Время GPU на кадр

Время, когда GPU активно обрабатывает рабочую нагрузку приложения для одного кадра. Приложение — это привязка GPU, когда время, затрачиваемое на обработку данных кадра, превышает 16ms.

Возможность понять, является ли приложение привязанным к ЦП или GPU, будет ограничивать проблемную часть кода.

## <a name="taking-performance-time-measurement-trace"></a>Выполняется трассировка измерения времени производительности

Выполните следующие действия, чтобы выполнить трассировку:

1.  Откройте командное окно от имени администратора.
2.  Закройте приложение, если оно уже запущено.
3.  измените каталоги на каталог *gpuview* в папке набор средств производительности Windows.
4.  Введите "log. cmd", чтобы запустить трассировку событий. Этот параметр записывает в журнал наиболее интересные события. Другие доступные параметры регистрируют различные области событий. Для экземпляра ' v ' или режима подробного протоколирования захватываются все события, о которых **GPUView** .
5.  Запустите пример и выполните пример таким образом, который охватывает путь производительности, который необходимо проанализировать.
6.  Вернитесь в окно командной строки и введите "log. cmd" еще раз, чтобы отключить ведение журнала.
7.  В папке *gpuview* будет выводится файл с именем Merged. ETL. Этот файл можно сохранить в другом расположении. его можно проанализировать на том же или на другом компьютере. Чтобы просмотреть сведения о захвате стека, сохраните файл символов (. pdb), связанный с приложением.

## <a name="measurements"></a>Измерения


> [!Note]  
> Пример использования геометрических измерений приведен на четырехъядерном компьютере с интегрированной графической картой DirectX11. Измерения зависят от конфигурации компьютера.

 

В этом разделе показано, как измерять время запуска, ЦП и GPU на единицах измерения кадра. Вы можете записать трассировку производительности для того же примера на компьютере и увидеть различия в различных измерениях.

Чтобы проанализировать трассировку в **GPUView**, откройте файл "Merged. ELT" с помощью **GPUView.exe**.

### <a name="startup-time"></a>Время запуска

Время запуска измеряется общим временем запуска приложения до первого появления содержимого на экране.

Измерения времени запуска лучше использовать, выполнив действия, описанные в предыдущем разделе, с этими вариантами.

-   Если вы задаете измерения запуска при первом запуске приложения, это называется холодный запуском. Это может отличаться от измерений, сделанных после запуска приложения несколько раз в течение небольшого промежутка времени. Это называется горячим запуском. В зависимости от количества ресурсов, создаваемых приложением при запуске, между двумя значениями времени запуска может быть большая разница. В зависимости от целей приложения измерение одного или другого может быть желательным.
-   При регистрации сведений о производительности завершите работу приложения, как только первый кадр появится на экране.

### <a name="calculating-start-up-time-using-gpuview"></a>Вычисление времени запуска с помощью **GPUView**

1.  В **GPUView** прокрутите вниз до соответствующего процесса, в данном случае GeometryRealization.exe.

    ![Снимок экрана, на котором показан пример процессов в GPUView.](images/profile1.png)

2.  Контекстная очередь ЦП представляет рабочую нагрузку графики, поставленную в очередь на оборудование, но не обязательно обрабатывалась оборудованием. При открытии файла трассировки отображаются все события, зарегистрированные между моментом, когда была сделана трассировка. Чтобы вычислить время запуска, выберите нужный регион и перейдите к начальной части очереди ЦП первого контекста (это то, что показывает действие), нажав клавиши CTRL + Z. Дополнительные сведения об элементах управления **GPUView** можно найти в разделе "Сводка по элементам управления **GPUView** " в файле справки **GPUView** . На рисунке ниже показан только GeometryRealization.exe процесс, уменьшенный до первой части очереди ЦП контекста. Цвет очереди ЦП контекста обозначается прямоугольником, расположенным непосредственно под очередью, и теми же пакетами данных в очереди отображать GPU, работающие в очереди на оборудование. Пакет шаблона штриховки в очереди контекста показывает текущий пакет, что означает, что приложение хочет, чтобы оборудование представлю содержимое на экране.

    ![Снимок экрана, на котором показаны примеры контекста C P U Queue.](images/profile2.png)

3.  Время запуска — это время первого запуска приложения (в этом случае модуль точки входа потока пользовательского интерфейса SHCORE.dll) до момента первого отображения контекста (отмеченного пакетом штриховки). На рисунке здесь выделяется Интересующая область.

    > [!Note]  
    > Фактические сведения представлены в очереди перелистывания, поэтому время выполнения увеличивается до тех пор, пока текущий пакет фактически завершается в очереди перелистывания.

     

    Полная строка состояния не отображается на рисунке ниже, где также показано время, прошедшее между выделенными частями. Это время запуска приложения. В этом случае для компьютера, упомянутого выше, 240ms.

    ![Снимок экрана, на котором показаны области, касающиеся времени запуска, в "контексте C P U Queue".](images/profile3.png)

### <a name="cpu-and-gpu-time-per-frame"></a>Время ЦП и GPU на кадр

При измерении времени ЦП необходимо учесть несколько моментов. Найдите области в трассировке, в которых был охвачен сценарий для анализа. Например, в примере реализации Geometry один из сценариев, которые были проанализированы, — это переход между примитивами отрисовки 2048 и 8192, все нереально (как в, геометрия не размещается на каждом кадре). Трассировка четко показывает разницу в действиях ЦП и GPU до и после перехода в количестве примитивов.

Два сценария анализируются для вычисления времени ЦП и GPU на кадр. Они приведены ниже.

-   Переход от подготовки к просмотру 2048 нереализованные примитивы до 8192 нереализованных примитивов.
-   Переход от подготовки к просмотру 8192 реализованные примитивы до 8192 нереализованных примитивов.

В обоих случаях было замечено, что частота кадров была удалена радикально. Измеряя время ЦП и GPU, связь между ними и несколькими другими шаблонами в трассировке может дать полезную информацию о проблемных областях в приложении.

### <a name="calculating-cpu-and-gpu-time-when-2048-primitives-are-being-rendered-unrealized"></a>Вычисление времени ЦП и GPU, когда выводятся нереалны примитивы 2048

1.  Откройте файл трассировки с помощью **GPUView.exe**.
2.  Прокрутите вниз до GeometryRealization.exe процесса.
3.  Выберите область для вычисления времени ЦП и задайте для него масштаб с помощью клавиш CTRL + Z.

    ![Снимок экрана, на котором показана область, выбранная для вычисления времени в C P в "контекстная очередь ЦП".](images/profile4.png)

4.  Отображение данных v-Sync путем переключения между F8. При уменьшении масштаба можно легко увидеть один вертикальной синхронизации данных. Синие линии — это время синхронизации v-Sync. Как правило, они происходят каждые 16 мс (60 кадров/с), но если DWM сталкивается с проблемой с производительностью, она выполняется медленнее, поэтому она будет выполняться каждые 32 мс (30 кадров/с). Чтобы получить представление о времени, выберите одну из синих полосок, а затем посмотрите на число МС в правом нижнем углу окна **GPUView** .

    ![Снимок экрана, на котором показан пример времени v-Sync.](images/profile5.png)

5.  Для измерения времени ЦП на кадр измеряет продолжительность времени, занимаемого всеми потоками, участвующими в подготовке к просмотру. Может быть целесообразно уменьшить ожидаемый поток, который будет наиболее важен с точки зрения производительности. Например, в примере реализации геометрии содержимое является анимацией и должно отображаться на экране каждый кадр, который делает поток пользовательского интерфейса важным. Определив, какой поток следует искать, Измерьте длину столбцов в этом потоке. Усреднение некоторых из них дает время ЦП на кадр. На рисунке ниже показано время, затраченное на поток пользовательского интерфейса. Также показывается, что это время подходит для двух последовательных виртуальных синхронизаций, что означает достижение 60FPS.

    ![Снимок экрана, показывающий время, затраченное на поток U I.](images/profile6.png)

    Можно также проверить, просмотрев очередь перелистывания для соответствующего кадра времени, который показывает, что DWM может представлять каждый кадр.

    ![Снимок экрана, на котором показан пример "очереди перелистывания".](images/profile7.png)

6.  Время GPU можно измерять так же, как и время ЦП. При измерении времени ЦП увеличивайте масштаб соответствующей области. Измеряет длину столбцов в очереди оборудования GPU с тем же цветом, что и цвет очереди ЦП контекста. Если столбцы соответствуют последовательным v-синхронизациям, приложение работает плавно на 60FPS.

    ![Снимок экрана, на котором показан пример использования "очереди оборудования GPU" для отображения информации, выполняемой приложением в 60 F P S.](images/profile8.png)

### <a name="calculating-cpu-and-gpu-time-when-8192-primitives-are-being-rendered-unrealized"></a>Вычисление времени ЦП и GPU, когда выводятся нереалны примитивы 8192

1.  Если выполнить те же действия снова, трассировка показывает, что вся работа ЦП для одного кадра не помещается между одной и той же v-Sync и следующей. Это означает, что приложение привязано к ЦП. Поток пользовательского интерфейса является перегруженным ПРОЦЕССОРом.

    ![Снимок экрана, на котором показан пример потока пользовательского интерфейса с насыщенностью в C P U.](images/profile9.png)

    Просматривая очередь перелистывания, также ясно, что DWM не может представлять каждый кадр.

    ![Снимок экрана, на котором показан пример D W M, который не может представлять каждый кадр.](images/profile10.png)

2.  Чтобы проанализировать, где затратится время, откройте трассировку в **Xperf**. Чтобы проанализировать время запуска в **Xperf**, сначала найдите интервал времени в **GPUView**. Наведите указатель мыши на левую часть интервала и вправо и запишите абсолютное время, показанное в нижней части окна **GPUView** . Затем откройте один и тот же ETL-файл в **Xperf** и прокрутите вниз до диаграммы "Выбор ЦП по ЦП", щелкните правой кнопкой мыши и выберите команду "выбрать интервал...". Это позволяет ввести интересующий вас интервал, который был обнаружен при просмотре трассировки GPU.

    ![снимок экрана, на котором показана выборка c p u в c p u в "Windows анализ производительности".](images/profile11.png)

3.  Перейдите в меню трассировка и убедитесь, что установлен флажок "загрузить символы". Кроме того, перейдите в раздел трассировка — > настройте пути к символам и введите путь к символам приложения. Файл символов содержит отладочную информацию о скомпилированном исполняемом файле в отдельной базе данных (. pdb). Этот файл обычно называют PDB-файлом. Дополнительные сведения о файлах символов можно найти здесь: [файлы символов](/windows/desktop/Debug/symbol-files). Этот файл можно найти в папке "Отладка" каталога приложения.

4.  Чтобы получить сведения о том, где в приложении будет затрачено время, щелкните правой кнопкой мыши интервал, выбранный на предыдущем шаге, и выберите Сводная таблица. Чтобы получить общие сведения о том, сколько времени тратится на каждую библиотеку DLL, снимите флажок "стек" в меню "столбцы". Обратите внимание, что в столбце "число" показано количество выборок в данной библиотеке DLL или функции. Так как на каждую МС берется примерно один пример, этот номер можно использовать в качестве лучшего предположения о том, сколько времени тратится на каждую библиотеку DLL или функцию. При проверке меню "стек" из столбцов будет выдаваться инклюзивное время, затраченное на каждую функцию в графе вызовов. Это поможет далее разорвать проблемные точки.

5.  Информация трассировки стека для 2048 нереализованных примитивов показывает, что 30% времени ЦП затрачены на процесс реализации геометрии. Из этого около 36% времени тратится на тесселяцию геометрии и обводки.

6.  Информация трассировки стека для 8192 нереализованных примитивов показывает, что около 60% времени ЦП (4 ядра) тратится на реализацию геометрии.

    ![Снимок экрана, показывающий сведения о трассировке стека для времени в C P U.](images/profile12.png)

### <a name="calculating-cpu-time-when-8192-primitives-are-being-rendered-realized"></a>Вычисление времени ЦП при отрисовке примитивов 8192

Это ясно из профилей, с которыми приложение привязано к ЦП. Чтобы сократить время, затрачиваемое ЦП, геометрические объекты можно создать один раз и кэшировать. Кэшированное содержимое может подготавливаться к просмотру в каждом кадре без затрат на тесселяцию геометрии для каждого кадра. При просмотре трассировки в **GPUView** для реализованной части приложения ясно, что DWM может представлять каждый кадр, а время ЦП значительно уменьшилось.

![Снимок экрана, на котором показан пример трассировки в GPUView, где D W M может представлять каждый кадр.](images/profile13.png)

В первой части диаграммы показаны реализованные примитивы 8192. Соответствующее время ЦП на кадр может соответствовать двум последовательным v-синхронизациям. В более поздней части графа это не так.

Глядя на **Xperf**, ЦП находится в неактивном состоянии в течение более чем 25% времени ЦП, затраченного на выполнение приложения по реализации геометрии.

![снимок экрана gpuview.](images/profile14.png)

## <a name="summary"></a>Сводка

**GPUView** и **Xperf** и мощные средства для анализа производительности приложений [DirectX](/previous-versions/windows/apps/jj262109(v=win.10)) . Эта статья представляет собой учебник по использованию этих средств и пониманию базовых показателей производительности и характеристик приложений. Помимо понимания использования инструментов, сначала важно понять анализируемое приложение. Начните с поиска ответов на такие вопросы, как приложение, которое пытается достичь? Какие потоки в системе наиболее важны? Какие компромиссы вы желаете сделать? При анализе трассировок производительности Начните с рассмотрения очевидных проблемных мест. Привязан ли процессор приложения или GPU? Может ли приложение представлять каждый кадр? Средства вместе с пониманием приложения могут предоставить очень полезную информацию в понимании, поиске и устранении проблем с производительностью.

 

 