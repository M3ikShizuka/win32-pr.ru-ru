---
title: Повышение производительности приложений Direct2D
description: Описывает методы повышения производительности Direct2D.
ms.assetid: e6b02925-4e75-42b0-b0c4-00f1ddb85e46
keywords:
- Direct2D, производительность
- Direct2D, точечные рисунки
- Direct2D, использование ресурсов
- Direct2D, метод Flush
- Direct2D, статическое содержимое
- производительность Direct2D
- точечные рисунки для Direct2D
- Direct2D, взаимодействие GDI
- Direct2D, взаимодействие
- взаимодействие, Direct2D
- Интерфейс графических устройств (GDI)
- GDI (интерфейс графических устройств)
- взаимодействие, интерфейс графических устройств (GDI)
ms.topic: article
ms.date: 05/31/2018
ms.custom: seodec18
ms.openlocfilehash: 34adfd708ef3c1b8d7a6af145d9d1c9505b01beb1ba9b31834e267123ad05b69
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119641504"
---
# <a name="improving-the-performance-of-direct2d-apps"></a>Повышение производительности приложений Direct2D

Хотя [Direct2D](./direct2d-portal.md) является аппаратным ускорением и предназначен для обеспечения высокой производительности, для повышения пропускной способности необходимо правильно использовать функции. Методы, которые мы здесь демонстрируем, являются производными от описанных выше способов изучения распространенных сценариев и могут не применяться ко всем сценариям приложений. Поэтому внимательное понимание поведения приложения и целей производительности может помочь добиться желаемых результатов.

-   [Использование ресурсов](#resource-usage)
    -   [Повторное использование ресурсов](#reuse-resources)
-   [Ограничение использования записи на диск](#restrict-the-use-of-flush)
-   [Растровые изображения](#create-large-bitmaps)
    -   [Создание крупных точечных рисунков](#create-large-bitmaps)
    -   [Создание Atlas с точечными рисунками](#create-an-atlas-of-bitmaps)
    -   [Создание общих точечных рисунков](#create-shared-bitmaps)
    -   [Копирование растровых изображений](#copying-bitmaps)
-   [Использовать мозаичное растровое изображение над тире](#use-tiled-bitmap-over-dashing)
-   [Общие рекомендации по визуализации сложного статического содержимого](#general-guidelines-for-rendering-complex-static-content)
    -   [Полное кэширование сцены с использованием цветового растрового изображения](#full-scene-caching-using-a-color-bitmap)
    -   [На примитивное кэширование с использованием точечного рисунка A8 и метода ФиллопаЦитимаск](#per-primitive-caching-using-an-a8-bitmap-and-the-fillopacitymask-method)
-   [Кэширование на примитивы с использованием реализаций геометрии](#per-primitive-caching-using-geometry-realizations)
-   [Отрисовка геометрии](#geometry-rendering)
    -   [Использовать конкретный примитив рисования для рисования геометрии](#use-specific-draw-primitive-over-draw-geometry)
    -   [Отображение статической геометрии](#rendering-static-geometry)
    -   [Использовать многопоточный контекст устройства](#use-a-multithreaded-device-context)
-   [Рисование текста с помощью Direct2D](#use-a-multithreaded-device-context)
    -   [Дравтекстлайаут и DrawText](#drawtextlayout-vs-drawtext)
    -   [Выбор режима отображения текста справа](#choosing-the-right-text-rendering-mode)
    -   [Кэширование](#full-scene-caching-using-a-color-bitmap)
-   [Обрезка произвольной фигуры](#clipping-an-arbitrary-shape)
    -   [Пушлайер в Windows 8](#pushlayer-in-windows-8)
    -   [Обрезанные по осям клипы](#axis-aligned-clips)
-   [Взаимодействие с DXGI: предотвращение частого переключения](#dxgi-interoperability-avoid-frequent-switches)
-   [Знакомство с форматом пикселей](#know-your-pixel-format)
-   [Сложность сцены](#scene-complexity)
    -   [Общие сведения о сложности сцены](#understand-scene-complexity)
-   [Повышение производительности для приложений печати Direct2D](#improving-performance-for-direct2d-printing-apps)
    -   [Задание значений свойств справа при создании элемента управления печатью D2D](#set-the-right-property-values-when-you-create-the-d2d-print-control)
    -   [Избегайте использования определенных шаблонов рисования Direct2D](#avoid-using-certain-direct2d-drawing-patterns)
    -   [Рисование текста прямым и обычным способом](#draw-text-in-a-direct-and-plain-way)
    -   [По возможности нарисовать исходные точечные рисунки](#draw-the-original-bitmaps-when-possible)
-   [Заключение](#conclusion)

## <a name="resource-usage"></a>Использование ресурсов

Ресурс — это выделение какого-либо типа в памяти видеоадаптера или системы. Примерами ресурсов являются точечные рисунки и кисти.

В Direct2D ресурсы можно создавать в программном и аппаратном обеспечении. Создание и удаление ресурсов на оборудовании являются дорогостоящими операциями, так как они требуют большого объема издержек при взаимодействии с видеоадаптером. Давайте посмотрим, как Direct2D визуализирует содержимое в целевом объекте.

В Direct2D все команды отрисовки заключаются между вызовом [**бегиндрав**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-begindraw) и вызовом [**EndDraw**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-enddraw). Эти вызовы выполняются для целевого объекта отрисовки. Перед вызовом операций отрисовки необходимо вызвать метод **бегиндрав** . После вызова **бегиндрав** контекст обычно создает пакет команд отрисовки, но откладывает обработку этих команд до тех пор, пока не будет выполнено одно из следующих условий:

-   Произошла [**EndDraw**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-enddraw) . При вызове **EndDraw** вызывает завершение всех пакетных операций рисования и возвращает состояние операции.
-   Вы выполняете явный вызов функции [**flush**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-flush): метод **flush** вызывает обработку пакета и выполнение всех ожидающих команд.
-   Буфер, содержащий команды подготовки к просмотру, заполнен. Если этот буфер заполняется до выполнения предыдущих двух условий, команды подготовки к просмотру очищаются.

До тех пор пока примитивы не будут сброшены, Direct2D сохраняет внутренние ссылки на соответствующие ресурсы, такие как точечные рисунки и кисти.

### <a name="reuse-resources"></a>Повторное использование ресурсов

Как уже упоминалось, создание и удаление ресурсов требуют больших затрат на оборудование. Поэтому используйте ресурсы по возможности. Возьмем пример создания растрового изображения при разработке игр. Как правило, точечные рисунки, составляющие сцену в игре, создаются одновременно с различными вариациями, необходимыми для последующей отрисовки кадров в кадрах. Во время отрисовки и повторной отрисовки этих растровых изображений повторно используются вместо повторного создания.

> [!Note]  
> Нельзя повторно использовать ресурсы для операции изменения размера окна. При изменении размера окна некоторые ресурсы, зависящие от масштабирования, такие как совместимые целевые объекты рендеринга и, возможно, некоторые ресурсы слоя должны быть созданы повторно, так как содержимое окна должно перерисовываться. Это может быть важно для поддержания общего качества отображаемой сцены.

 

## <a name="restrict-the-use-of-flush"></a>Ограничение использования записи на диск

Поскольку метод [**flush**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-flush) вызывает обработку пакетных команд рендеринга, рекомендуется не использовать его. В большинстве распространенных сценариев оставьте управление ресурсами Direct2D.

## <a name="bitmaps"></a>Растровые изображения

Как упоминалось ранее, создание и удаление ресурсов являются очень ресурсоемкими операциями оборудования. Точечный рисунок — это тип ресурса, который часто используется. Создание точечных рисунков на видеоадаптере занимает много ресурсов. Их повторное использование поможет ускорить работу приложения.

### <a name="create-large-bitmaps"></a>Создание крупных точечных рисунков

Видеоадаптеры обычно имеют минимальный размер выделения памяти. Если запрошенное выделение меньше этого значения, выделяется ресурс этого минимального размера, а избыточная память теряется и недоступна для других целей. Если требуется много небольших точечных рисунков, лучше всего выделить один большой точечный рисунок и сохранить все небольшое содержимое растрового изображения в этом большом точечном рисунке. Затем дочерние области более крупного растрового изображения можно считать, где требуются небольшие точечные рисунки. Часто следует включать заполнение (прозрачные черные пиксели) между мелкими точечными рисунками во избежание взаимодействия между мелкими изображениями во время операций. Это также называется *Atlas* и имеет преимущество снижения затрат на создание растровых изображений и нерасходование памяти при небольших выделениях битовых рисунков. Рекомендуется размещать большинство битовых карт размером не менее 64 КБ и ограничивать число битов, размер которых меньше 4 КБ.

### <a name="create-an-atlas-of-bitmaps"></a>Создание Atlas с точечными рисунками

Существуют некоторые распространенные ситуации, в которых точечные рисунки Atlas могут работать очень хорошо. Небольшие растровые изображения можно хранить внутри большого точечного рисунка. Эти небольшие точечные рисунки можно извлечь из большего размера, если они нужны, указав прямоугольник назначения. Например, приложение должно нарисовать несколько значков. Все точечные рисунки, связанные со значками, можно загрузить в большой точечный рисунок. И во время отрисовки их можно получить из большого точечного рисунка.

> [!Note]  
> Точечный рисунок Direct2D, созданный в видеопамяти, ограничен максимальным размером точечного рисунка, поддерживаемым адаптером, на котором он хранится. Создание точечного рисунка, размер которого превышает это, может привести к ошибке.

 

> [!Note]  
> начиная с Windows 8, Direct2D включает в себя [эффекты Atlas](atlas.md) , которые могут упростить этот процесс.

 

### <a name="create-shared-bitmaps"></a>Создание общих точечных рисунков

Создание общих точечных рисунков позволяет расширенным вызывающим объектам создавать объекты Bitmap Direct2D, которые поддерживаются непосредственно существующим объектом, уже совместимым с целью рендеринга. Это позволяет избежать создания нескольких поверхностей и помогает снизить нагрузку на производительность.

> [!Note]  
> Общие точечные рисунки обычно ограничены программными целями или целевыми объектами, взаимодействующими с DXGI. Используйте методы [**креатебитмапфромдксгисурфаце**](/windows/win32/api/d2d1_1/nf-d2d1_1-id2d1devicecontext-createbitmapfromdxgisurface(idxgisurface_constd2d1_bitmap_properties1_id2d1bitmap1)), [**креатебитмапфромвикбитмап**](/windows/win32/api/d2d1_1/nf-d2d1_1-id2d1devicecontext-createbitmapfromwicbitmap(iwicbitmapsource_constd2d1_bitmap_properties1_id2d1bitmap1))и [**креатешаредбитмап**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-createsharedbitmap) для создания общих точечных рисунков.

 

### <a name="copying-bitmaps"></a>Копирование растровых изображений

Создание поверхности DXGI является дорогостоящей операцией, поэтому вы можете повторно использовать существующие поверхности. Даже в программном обеспечении, если точечный рисунок преимущественно используется в форме, за исключением небольшой части, лучше обновить эту часть, чем создавать весь точечный рисунок и заново создать все. Несмотря на то, что можно использовать [**креатекомпатиблерендертаржет**](/windows/desktop/api/d2d1/nf-d2d1-id2d1rendertarget-createcompatiblerendertarget(id2d1bitmaprendertarget)) для достижения одинаковых результатов, отрисовка обычно является гораздо более дорогостоящей операцией, чем копирование. Это связано с тем, что для улучшения локализации кэша оборудование фактически не сохраняет точечный рисунок в том же порядке памяти, что и точечный рисунок. Вместо этого точечный рисунок может быть свиззлед. Группирующие скрывается от ЦП либо драйвером (который работает достаточно долго и используется только в более низких частях), либо диспетчером памяти на GPU. Из-за ограничений на то, как данные записываются в целевой объект отрисовки при подготовке к просмотру, целевые объекты рендеринга обычно либо не свиззлед, либо свиззлед способом, который менее оптимальен, чем может быть достигнут, если известно, что вам никогда не нужно отрисовываться на поверхности. Поэтому [](/windows/desktop/api/d2d1/nn-d2d1-id2d1bitmap) \* для копирования прямоугольников из источника в точечный рисунок Direct2D предоставляются методы CopyFrom.

CopyFrom можно использовать в любой из трех форм:

-   [**копифромбитмап**](/windows/win32/api/d2d1/nf-d2d1-id2d1bitmap-copyfrombitmap)
-   [**копифромрендертаржет**](/windows/win32/api/d2d1/nf-d2d1-id2d1bitmap-copyfromrendertarget)
-   [**копифроммемори**](/windows/win32/api/d2d1/nf-d2d1-id2d1bitmap-copyfrommemory)

## <a name="use-tiled-bitmap-over-dashing"></a>Использовать мозаичное растровое изображение над тире

Отрисовка штриховой линии является очень дорогостоящей операцией из-за высокого качества и точности базового алгоритма. Для большинства вариантов, не включающих геометрические объекты rectilinear, один и тот же результат может быть создан быстрее с помощью мозаичных растровых изображений.

## <a name="general-guidelines-for-rendering-complex-static-content"></a>Общие рекомендации по визуализации сложного статического содержимого

Кэширование содержимого при отрисовке одного фрейма содержимого поверх рамки, особенно в случае сложной сцены.

Существует три метода кэширования, которые можно использовать.

-   Полное кэширование сцены с использованием цветового растрового изображения.
-   На примитивное кэширование с использованием точечного рисунка A8 и метода [**филлопаЦитимаск**](/windows/win32/api/d2d1_1/nf-d2d1_1-id2d1devicecontext-fillopacitymask(id2d1bitmap_id2d1brush_constd2d1_rect_f_constd2d1_rect_f)) .
-   Кэширование на примитивы с использованием реализаций геометрии.

Давайте рассмотрим каждый из них более подробно.

### <a name="full-scene-caching-using-a-color-bitmap"></a>Полное кэширование сцены с использованием цветового растрового изображения

При отрисовке статического содержимого в таких сценариях, как анимация, создайте еще одно цветное битовое изображение вместо записи непосредственно на экран. Сохраните текущий целевой объект, задайте для параметра target значение промежуточное растровое изображение и выводите статическое содержимое. Затем переключитесь обратно на исходное растровое изображение и нарисуйте на нем промежуточное изображение.

Приведем пример:


```C++
// Create a bitmap.
m_d2dContext->CreateBitmap(size, nullptr, 0,
    D2D1::BitmapProperties(
        D2D1_BITMAP_OPTIONS_TARGET,
        D2D1::PixelFormat(
            DXGI_FORMAT_B8G8R8A8_UNORM,
            D2D1_ALPHA_MODE_PREMULTIPLIED),
        dpiX, dpiY),
    &sceneBitmap);

// Preserve the pre-existing target.
ComPtr<ID2D1Image> oldTarget;
m_d2dContext->GetTarget(&oldTarget);

// Render static content to the sceneBitmap.
m_d2dContext->SetTarget(sceneBitmap.Get());
m_d2dContext->BeginDraw();
…
m_d2dContext->EndDraw();

// Render sceneBitmap to oldTarget.
m_d2dContext->SetTarget(oldTarget.Get());
m_d2dContext->DrawBitmap(sceneBitmap.Get());
```



В этом примере используются промежуточные точечные рисунки для кэширования и переключения точечного рисунка, на который указывает контекст устройства при его подготовке. Это позволяет избежать необходимости создавать совместимый целевой объект рендеринга для той же цели.

### <a name="per-primitive-caching-using-an-a8-bitmap-and-the-fillopacitymask-method"></a>На примитивное кэширование с использованием точечного рисунка A8 и метода ФиллопаЦитимаск

Если полная сцена не является статической, но состоит из элементов, таких как геометрия или текст, которые являются статическими, можно использовать метод для каждого примитивного кэширования. Этот метод сохраняет характеристики сглаживания для примитива, который кэшируется, и работает с изменением типов кистей. Он использует точечный рисунок A8, где A8 — это разновидность формата пикселей, представляющая альфа-канал с 8 битами. Точечные рисунки A8 полезны для рисования геометрии или текста в виде маски. Если необходимо управлять прозрачностью статического содержимого, вместо управления самим содержимым можно преобразовать, повернуть, наклон или масштабировать прозрачность маски.

Приведем пример:


```C++
// Create an opacity bitmap.
m_d2dContext->CreateBitmap(size, nullptr, 0,
    D2D1::BitmapProperties(
        D2D1_BITMAP_OPTIONS_TARGET,
        D2D1::PixelFormat(
            DXGI_FORMAT_A8_UNORM,
            D2D1_ALPHA_MODE_PREMULTIPLIED),
        dpiX, dpiY),
    &opacityBitmap);

// Preserve the pre-existing target.
ComPtr<ID2D1Image> oldTarget;
m_d2dContext->GetTarget(&oldTarget);

// Render to the opacityBitmap.
m_d2dContext->SetTarget(opacityBitmap.Get());
m_d2dContext->BeginDraw();
…
m_d2dContext->EndDraw();

// Call the FillOpacityMask method
// Note: for this call to work correctly the anti alias mode must be D2D1_ANTIALIAS_MODE_ALIASED. 
m_d2dContext->SetTarget(oldTarget.Get());
m_d2dContext->FillOpacityMask(
    opacityBitmap.Get(),
    m_contentBrush().Get(),
    D2D1_OPACITY_MASK_CONTENT_GRAPHICS);
```



## <a name="per-primitive-caching-using-geometry-realizations"></a>Кэширование на примитивы с использованием реализаций геометрии

Другой метод кэширования на основе примитивов, называемый реализациями геометрии, обеспечивает большую гибкость при работе с геометрическим объектом. Если необходимо многократно вырисовывать геометрические фигуры с псевдонимами, можно быстрее преобразовать их в реализации геометрии и многократно нарисовать реализации, чем повторять Рисование самих геометрических объектов. Реализации геометрии также обычно потребляют меньше памяти, чем маски непрозрачности (особенно для больших геометрических объектов), и они менее чувствительны к изменениям масштаба. Дополнительные сведения см. в разделе [Общие сведения о реализации геометрических объектов](geometry-realizations-overview.md).

Приведем пример:


```C++
    // Compute a flattening tolerance based on the scales at which the realization will be used.
    float flatteningTolerance = D2D1::ComputeFlatteningTolerance(...);

    ComPtr<ID2D1GeometryRealization> geometryRealization;

    // Create realization of the filled interior of the geometry.
    m_d2dDeviceContext1->CreateFilledGeometryRealization(
        geometry.Get(),
        flatteningTolerance,
        &geometryRealization
        );

    // In your app's rendering code, draw the geometry realization with a brush.
    m_d2dDeviceContext1->BeginDraw();
    m_d2dDeviceContext1->DrawGeometryRealization(
        geometryRealization.Get(),
        m_brush.Get()
        );
    m_d2dDeviceContext1->EndDraw();
```



## <a name="geometry-rendering"></a>Отрисовка геометрии

### <a name="use-specific-draw-primitive-over-draw-geometry"></a>Использовать конкретный примитив рисования для рисования геометрии

Используйте более конкретные *простые* вызовы рисования, такие как [**DrawRectangle**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-drawrectangle(constd2d1_rect_f__id2d1brush_float_id2d1strokestyle)) , через универсальные вызовы [**DrawGeometry**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-drawgeometry) . Это обусловлено тем, что в **DrawRectangle** геометрическая геометрия уже известна, поэтому отрисовка выполняется быстрее.

### <a name="rendering-static-geometry"></a>Отображение статической геометрии

В сценариях, где геометрия является статичной, используйте методы кэширования на основе примитивов, описанные выше. Маски непрозрачности и реализации геометрических объектов могут значительно повысить скорость отрисовки сцен, содержащих статическую геометрию.

### <a name="use-a-multithreaded-device-context"></a>Использовать многопоточный контекст устройства

Приложения, для которых требуется отрисовка значительных объемов сложного геометрического содержимого, следует рассмотреть указание параметра [**\_ контекста устройства D2D1 \_ \_ \_ включить \_ \_ многопотоковую \_ оптимизацию**](/windows/desktop/api/D2d1_1/ne-d2d1_1-d2d1_device_context_options) при создании контекста устройства [Direct2D](./direct2d-portal.md) . Если этот флаг указан, Direct2D будет распределять отрисовку по всем логическим ядрам, присутствующим в системе, что может значительно снизить общее время отрисовки.

Примечания.

-   начиная с Windows 8.1 этот флаг влияет только на отрисовку геометрических контуров. Он не влияет на сцены, содержащие только другие типы-примитивы (например, текст, точечные рисунки или реализации геометрических объектов).
-   Этот флаг также не влияет на отрисовку в программном обеспечении (т. е. при отрисовке с помощью ИСКРИВЛЕНного устройства Direct3D). Чтобы управлять многопоточностью программного обеспечения, вызывающим объектам следует использовать флаг D3D11 Create Device reon \_ \_ \_ \_ internal \_ \_ reoptimization оптимизации при создании устройства, использующего технологию деформации Direct3D.
-   Задание этого флага может увеличить Пиковый рабочий набор во время подготовки к просмотру и также может увеличить состязание за потоки в приложениях, которые уже используют преимущества многопоточной обработки.

## <a name="drawing-text-with-direct2d"></a>Рисование текста с помощью Direct2D

Функция отрисовки текста Direct2D предлагается в двух частях. Первая часть, представленная в виде метода [**ID2D1RenderTarget::D равтекст**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-drawtext(constwchar_uint32_idwritetextformat_constd2d1_rect_f__id2d1brush_d2d1_draw_text_options_dwrite_measuring_mode)) и [**ID2D1RenderTarget::D равтекстлайаут**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-drawtextlayout) , позволяет вызывающему объекту передать либо строковую, либо параметры форматирования, либо объект дврите Text Layout для нескольких форматов. Это должно быть уместно для большинства вызывающих объектов. Второй способ визуализации текста, представленный в виде метода [**ID2D1RenderTarget::D равглифрун**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-drawglyphrun) , обеспечивает растрирование для клиентов, уже знающих расположение глифов, которые они хотят визуализировать. Следующие два общих правила могут помочь улучшить производительность текста при рисовании в Direct2D.

### <a name="drawtextlayout-vs-drawtext"></a>Дравтекстлайаут и DrawText

как [**DrawText**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-drawtext(constwchar_uint32_idwritetextformat_constd2d1_rect_f__id2d1brush_d2d1_draw_text_options_dwrite_measuring_mode)) , так и [**дравтекстлайаут**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-drawtextlayout) позволяют приложению легко отображать текст, отформатированный [DirectWrite](/windows/desktop/DirectWrite/direct-write-portal) API. **дравтекстлайаут** рисует существующий объект [**двритетекстлайаут**](/windows/desktop/api/dwrite/nn-dwrite-idwritetextlayout) в [**рендертаржет**](/windows/win32/api/d2d1/nn-d2d1-id2d1rendertarget), а **DrawText** создает макет DirectWrite для вызывающего объекта на основе переданных параметров. Если один и тот же текст должен отображаться несколько раз, используйте **дравтекстлайаут** вместо **DrawText**, так как **DrawText** создает макет при каждом вызове.

### <a name="choosing-the-right-text-rendering-mode"></a>Выбор режима отображения текста справа

Установите в качестве режима сглаживания текста [**D2D1 в \_ \_ режиме сглаживания текста \_ \_ оттенки серого**](/windows/desktop/api/d2d1/ne-d2d1-d2d1_text_antialias_mode) . Качество визуализации текста в градациях серого сравнимо с ClearType, но выполняется гораздо быстрее.

### <a name="caching"></a>Кэширование

Используйте полную сцену или для каждого примитивного кэширования растрового изображения, как при рисовании других примитивов.

## <a name="clipping-an-arbitrary-shape"></a>Обрезка произвольной фигуры

На рисунке ниже показан результат применения клипа к изображению.

![изображение, в котором показан пример изображения до и после клипа.](images/clip.png)

Этот результат можно получить с помощью слоев с геометрической маской или методом [**филлжеометри**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-fillgeometry) с кистью непрозрачности.

Ниже приведен пример использования слоя.


```C++
// Call PushLayer() and pass in the clipping geometry.
m_d2dContext->PushLayer(
    D2D1::LayerParameters(
        boundsRect,
        geometricMask));
```



Ниже приведен пример использования метода [**филлжеометри**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-fillgeometry) :


```C++
// Create an opacity bitmap and render content.
m_d2dContext->CreateBitmap(size, nullptr, 0,
    D2D1::BitmapProperties(
        D2D1_BITMAP_OPTIONS_TARGET,
        D2D1::PixelFormat(
            DXGI_FORMAT_A8_UNORM,
            D2D1_ALPHA_MODE_PREMULTIPLIED),
        dpiX, dpiY),
    &opacityBitmap);

m_d2dContext->SetTarget(opacityBitmap.Get());
m_d2dContext->BeginDraw();
…
m_d2dContext->EndDraw();

// Create an opacity brush from the opacity bitmap.
m_d2dContext->CreateBitmapBrush(opacityBitmap.Get(),
    D2D1::BitmapBrushProperties(),
    D2D1::BrushProperties(),
    &bitmapBrush);

// Call the FillGeometry method and pass in the clip geometry and the opacity brush
m_d2dContext->FillGeometry( 
    clipGeometry.Get(),
    brush.Get(),
    opacityBrush.Get()); 
```



В этом примере кода при вызове метода Пушлайер вы не передаетесь на слой, созданный приложением. Direct2D создает слой для вас. Direct2D может управлять выделением и уничтожением этого ресурса без участия в приложении. Это позволяет Direct2D использовать слои внутренним образом и применять оптимизации управления ресурсами.

в Windows 8 многие оптимизации используются в уровнях, и мы рекомендуем использовать api слоя вместо [**филлжеометри**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-fillgeometry) , когда это возможно.

### <a name="pushlayer-in-windows-8"></a>Пушлайер в Windows 8

интерфейс [**ID2D1DeviceContext**](/windows/win32/api/d2d1_1/nn-d2d1_1-id2d1devicecontext) является производным от интерфейса [**ID2D1RenderTarget**](/windows/win32/api/d2d1/nn-d2d1-id2d1rendertarget) и является ключом к отображению содержимого Direct2D в Windows 8. дополнительные сведения об этом интерфейсе см. в разделе [устройства и контексты устройств](devices-and-device-contexts.md). С помощью интерфейса контекста устройства можно пропустить вызов метода [**креателайер**](/windows/desktop/api/d2d1/nf-d2d1-id2d1rendertarget-createlayer(id2d1layer)) , а затем передать NULL методу [**ID2D1DeviceContext::P ушлайер**](/windows/win32/api/d2d1_1/nf-d2d1_1-id2d1devicecontext-pushlayer(constd2d1_layer_parameters1_id2d1layer)) . Direct2D автоматически управляет ресурсом слоя и может совместно использовать ресурсы между слоями и графами эффектов.

### <a name="axis-aligned-clips"></a>Обрезанные по осям клипы

Если регион, который будет обрезан, вырезается по оси поверхности рисования, а не произвольно. Этот вариант подходит для использования прямоугольника обрезки вместо слоя. Повышение производительности — это больше для геометрических объектов, чем у сглаженных геометрических объектов. Дополнительные сведения о выровняйте по оси клипов см. в разделе [**пушаксисалигнедклип**](/windows/win32/api/d2d1/nf-d2d1-id2d1rendertarget-pushaxisalignedclip(constd2d1_rect_f__d2d1_antialias_mode)) .

## <a name="dxgi-interoperability-avoid-frequent-switches"></a>Взаимодействие с DXGI: предотвращение частого переключения

Direct2D может беспрепятственно взаимодействовать с областями Direct3D. Это очень полезно для создания приложений, которые отображают смесь 2D-и трехмерного содержимого. Но каждый переход между Drawing Direct2D и содержимым Direct3D влияет на производительность.

При подготовке к просмотру на поверхности DXGI Direct2D сохраняет состояние устройств Direct3D при их визуализации и восстановлении после завершения подготовки к просмотру. Каждый раз при завершении подготовки к просмотру пакета Direct2D затраты на сохранение и восстановление, а также стоимость очистки всех 2D-операций оплачиваются, а устройство Direct3D не очищается. Таким образом, чтобы повысить производительность, ограничьте число переключений отрисовки между Direct2D и Direct3D.

## <a name="know-your-pixel-format"></a>Знакомство с форматом пикселей

При создании целевого объекта рендеринга можно использовать структуру [**\_ \_ формата пикселей D2D1**](/windows/desktop/api/dcommon/ns-dcommon-d2d1_pixel_format) для указания формата пикселей и альфа-режима, используемого целью рендеринга. Альфа-канал является частью формата пикселей, который указывает значение покрытия или сведения о непрозрачности. Если целевой объект прорисовки не использует альфа-канал, он должен быть создан с помощью [**\_ \_ режима \_ альфа**](/windows/desktop/api/dcommon/ne-dcommon-d2d1_alpha_mode) -канала D2D1. Это изменяет время, затраченное на визуализацию альфа-канала, который не требуется.

Дополнительные сведения о форматах пикселей и альфа-режимах см. в разделе [Поддерживаемые форматы пикселей и альфа-режимы](supported-pixel-formats-and-alpha-modes.md).

## <a name="scene-complexity"></a>Сложность сцены

При анализе горячих точек производительности в сцене, которая будет подготовлена к просмотру, убедитесь, что сцена является границей заливки или границей вершин может предоставить полезную информацию.

-   Коэффициент заполнения: скорость заливки — это число пикселей, которое может быть отображено графической картой и записано в видеопамять в секунду.
-   Привязка к вершине: сцена привязана к вершине, если она содержит множество сложных геометрических объектов.

### <a name="understand-scene-complexity"></a>Общие сведения о сложности сцены

Можно проанализировать сложность сцены, изменив размер целевого объекта рендеринга. Если выигрыш в производительности видим для пропорционального уменьшения размера целевого объекта отрисовки, то приложение будет привязано к заливке. В противном случае сложность сцены связана с узким местом производительности.

Если сцена имеет привязку к скорости заполнения, уменьшение размера целевого объекта рендеринга может повысить производительность. Это связано с тем, что количество отображаемых пикселей будет уменьшено пропорционально размеру целевого объекта рендеринга.

Если сцена привязана к вершине, уменьшите сложность геометрии. Но помните, что это делается за счет качества изображения. Поэтому необходимо принять решение о тщательном компромиссе между желаемым качеством и требуемой производительностью.

## <a name="improving-performance-for-direct2d-printing-apps"></a>Повышение производительности для приложений печати Direct2D

[Direct2D](./direct2d-portal.md) обеспечивает совместимость с печатью. Вы можете отправить те же команды рисования Direct2D (в виде списков команд Direct2D) в элемент управления печатью Direct2D для печати, если вы не знакомы, на каких устройствах выполняется рисование, или как документ будет преобразован для печати.

Вы можете более точно настроить использование элемента управления печатью [Direct2D](./direct2d-portal.md) и команд рисования Direct2D для предоставления результатов печати с лучшей производительностью.

Элемент управления печатью [Direct2D](./direct2d-portal.md) выводит сообщения об отладке, когда он видит шаблон кода Direct2D, который ведет к снижению качества печати или производительности (например, шаблоны кода, приведенные ниже в этом разделе), чтобы напомнить, где можно избежать проблем с производительностью. Чтобы просмотреть эти отладочные сообщения, необходимо включить [уровень отладки Direct2D](direct2ddebuglayer-portal.md) в коде. Инструкции по включению вывода отладочных сообщений см. в разделе [Отладка сообщений](direct2ddebuglayer-debugmessages.md) .

### <a name="set-the-right-property-values-when-you-create-the-d2d-print-control"></a>Задание значений свойств справа при создании элемента управления печатью D2D

При создании элемента управления печатью [Direct2D](./direct2d-portal.md) можно задать три свойства. Два из этих свойств влияют на то, как элемент управления печатью Direct2D обрабатывает определенные команды Direct2D и, в свою очередь, влияет на общую производительность.

-   Режим подмножества шрифтов. элемент управления печатью [Direct2D](./direct2d-portal.md) подмножества шрифтов, используемых на каждой странице перед отправкой страницы для печати. Этот режим уменьшает размер страничных ресурсов, необходимых для печати. В зависимости от использования шрифта на странице можно выбрать различные режимы подмножества шрифтов для лучшей производительности.
    -   [**D2D1 \_ \_ \_ Режим подмножества \_ шрифтов \_ по умолчанию**](/windows/desktop/api/d2d1_1/ne-d2d1_1-d2d1_print_font_subset_mode) обеспечивает оптимальную производительность печати в большинстве случаев. При задании этого режима элемент управления печатью [Direct2D](./direct2d-portal.md) использует эвристическую стратегию для принятия решения о подмножестве шрифтов.
    -   Для коротких заданий печати с 1 или 2 страницами рекомендуется [**D2D1 \_ Печать в \_ \_ режиме подмножества шрифтов \_ \_ еачпаже**](/windows/desktop/api/d2d1_1/ne-d2d1_1-d2d1_print_font_subset_mode) , где поднаборы элемента управления печатью [Direct2D](./direct2d-portal.md) и внедряет ресурсы шрифтов на каждой странице, а затем отменяет это подмножество шрифтов после печати страницы. Этот параметр обеспечивает печать каждой страницы сразу после ее создания, но немного увеличивает размер страничных ресурсов, необходимых для печати (с обычно большими подмножествами шрифтов).
    -   Для заданий печати со многими страницами текста и мелкими размерами шрифтов (например, 100 страниц текста, использующих один шрифт), мы рекомендуем [**D2D1 \_ \_ \_ режим печати подмножеств шрифтов \_ \_ None**](/windows/desktop/api/d2d1_1/ne-d2d1_1-d2d1_print_font_subset_mode), где элемент управления печатью [Direct2D](./direct2d-portal.md) не является ни ресурсами подмножества; вместо этого он отправляет исходные ресурсы шрифта вместе со страницей, которая использует шрифт, и повторно использует ресурсы шрифтов для последующих страниц, не передавая их.
-   Масштабирование DPI. Если элементу управления печатью [Direct2D](./direct2d-portal.md) нужно растрировать команды Direct2D во время преобразования DIRECT2D-XPS, он использует это разрешение для растрирования. Иными словами, если на странице нет растрового содержимого, установка любых точек на дюйм не изменит производительность и качество. В зависимости от использования растрирования на странице можно выбрать различные dpi растрирования для наилучшего баланса между точностью и производительностью.
    -   150 — это значение по умолчанию, если не указать значение при создании элемента управления печатью [Direct2D](./direct2d-portal.md) , что является лучшим балансом качества печати и производительности печати в большинстве случаев.
    -   Более высокие значения DPI обычно приводят к увеличению качества печати (как в случае сохранения сведений), но более низкая производительность из-за большего размера создаваемых им растровых изображений. Не рекомендуется использовать значение DPI, превышающее 300, так как это не дает дополнительной информации, визуально воспринимаемого человеческими глазами.
    -   Более низкое значение DPI может означать лучшую производительность, но также может привести к более низкому качеству.

### <a name="avoid-using-certain-direct2d-drawing-patterns"></a>Избегайте использования определенных шаблонов рисования Direct2D

Существуют различия между тем, что [Direct2D](./direct2d-portal.md) может представлять визуальный элемент, а также то, что подсистема печати может поддерживать и передавать в весь конвейер печати. Элемент управления печатью Direct2D связывает эти промежутки с помощью аппроксимации или растрирования Direct2D примитивов, которые не поддерживаются встроенной подсистемой печати. Подобная аппроксимация обычно приводит к более низкой точности печати, более низкой производительности печати или к обоим. Таким образом, несмотря на то, что клиент может использовать одни и те же закономерности для отрисовки экрана и печати, он не идеально подходит во всех случаях. Не рекомендуется использовать такие Direct2D примитивы и закономерности для пути печати, а также выполнять растрирование, когда вы обладаете полным контролем качества и размера растровых изображений.

Ниже приведен список случаев, когда производительность и качество печати не будут идеальными, и вы можете рассмотреть возможность изменения пути кода для оптимальной производительности печати.

-   Избегайте использования простого режима Blend, отличного от [**D2D1- \_ примитивного \_ смешения \_ саурцеовер**](/windows/desktop/api/D2d1_1/ne-d2d1_1-d2d1_primitive_blend).
-   Избегайте использования режимов композиции при рисовании изображения, отличного от [**\_ источника D2D1 составного \_ режима \_ \_**](/windows/desktop/api/D2d1_1/ne-d2d1_1-d2d1_composite_mode) , и **D2D1ного \_ назначения в составном \_ режиме \_ \_**.
-   Избегайте прорисовки мета-файла GDI.
-   Избегайте принудительной отправки ресурса слоя, который копирует исходный фон (вызов [**пушлайер**](/windows/win32/api/d2d1_1/nf-d2d1_1-id2d1commandsink-pushlayer) с передачей [**D2D1 \_ слоя \_ OPTIONS1 \_ инициализировать \_ из \_ фона**](/windows/desktop/api/d2d1_1/ns-d2d1_1-d2d1_layer_parameters1) в структуру **\_ \_ PARAMETERS1 уровня D2D1** ).
-   Избегайте создания растровой кисти или кисти изображения с D2D1ом в \_ \_ режиме расширения \_ . Рекомендуется использовать \_ \_ зеркальное отображение в режиме расширения D2D1, \_ если не важно, чтобы Пиксели за пределами изображения (например, изображение, присоединенное к кисти, было больше, чем закрашенный целевой регион).
-   Избегайте рисования растровых изображений с помощью [преобразований перспективы](3d-perspective-transform.md).

### <a name="draw-text-in-a-direct-and-plain-way"></a>Рисование текста прямым и обычным способом

Direct2D имеет несколько оптимизаций при отрисовке текста для отображения для повышения производительности и/или более качественного визуального элемента. Но не все оптимизации улучшают производительность и качество печати, так как печать на бумаге обычно выполняется значительно быстрее, а печать не требует таких сценариев, как анимация. Поэтому мы рекомендуем рисовать исходный текст или глифы напрямую и избежать любой из следующих оптимизаций при создании списка команд для печати.

-   Избегайте рисования текста с помощью метода [**филлопаЦитимаск**](/windows/win32/api/d2d1_1/nf-d2d1_1-id2d1commandsink-fillopacitymask) .
-   Старайтесь не рисовать текст в режиме с псевдонимами.

### <a name="draw-the-original-bitmaps-when-possible"></a>По возможности нарисовать исходные точечные рисунки

Если целевым точечным рисунком является JPEG, PNG, TIFF или JPEG-XR, можно создать точечный рисунок WIC либо из файла на диске, либо из потока в памяти, а затем создать точечный рисунок [Direct2D](./direct2d-portal.md) из этого растрового изображения WIC с помощью [**ID2D1DeviceContext:: креатебитмапфромвикбитмап**](/windows/win32/api/d2d1_1/nf-d2d1_1-id2d1devicecontext-createbitmapfromwicbitmap(iwicbitmapsource_constd2d1_bitmap_properties1_id2d1bitmap1))и, наконец, передать его непосредственно в элемент управления печатью Direct2D, не изменяя дальнейшую манипуляцию. Таким образом, элемент управления печатью Direct2D может повторно использовать поток растрового изображения, что обычно приводит к повышению производительности печати (пропуская избыточное кодирование и декодирование битовой карты) и улучшает качество печати (при сохранении метаданных, например цветовых профилей, в растровом изображении).

Рисование исходного растрового изображения обеспечивает следующие преимущества для приложений.

-   В целом, [Direct2Dная](./direct2d-portal.md) печать сохраняет исходную информацию (без потерь или шума) до момента опоздания в конвейере, особенно если приложения не известны (или не хотят быть осведомленными) сведения о конвейере печати (например, на принтере, на котором выполняется печать, а также на целевом принтере и т. д.).
-   Во многих случаях задержка растрирования растрового изображения означает лучшую производительность (например, при печати фотографии 96dpi на принтере 600dpi).
-   В некоторых случаях передача исходных изображений является единственным способом обеспечения высокой точности (например, встроенных цветовых профилей).

Однако вы не можете принять такую оптимизацию, поскольку:

-   Запрашивая сведения о принтерах и ранних растрированиях, вы можете разпрограммировать содержимое самостоятельно, используя полный контроль над окончательным внешним видом бумаги.
-   В некоторых случаях раннее растрирование может улучшить производительность комплексного приложения (например, печать фотографий валлетс).
-   В некоторых случаях для передачи исходных битовых рисунков требуется значительное изменение существующей архитектуры кода (например, задержка изображения и пути обновления ресурсов, обнаруженные в некоторых приложениях).

## <a name="conclusion"></a>Заключение

Хотя Direct2D является аппаратным ускорением и предназначен для обеспечения высокой производительности, для повышения пропускной способности необходимо правильно использовать функции. Методы, которые мы рассматривали здесь, являются производными от изучения распространенных сценариев и могут не применяться ко всем сценариям приложений.

 

 
