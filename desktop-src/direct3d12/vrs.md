---
title: Variable-Rate Shading (VRS)
description: Заливка с переменной скоростью &mdash; или грубая заливка пикселя &mdash; — это механизм, позволяющий распределять производительность и степень отрисовки по тарифам, которые зависят от визуализированного изображения.
ms.localizationpriority: high
ms.topic: article
ms.date: 04/08/2019
ms.openlocfilehash: b26d2d67a6e4a5f7b599a9fc65f324b301346fde3170262e80235a25f8cfb88b
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119045331"
---
# <a name="variable-rate-shading-vrs"></a>Variable-Rate Shading (VRS)

## <a name="the-motivation-for-vrs"></a>Мотивация для ВРС
Из-за ограничений производительности графический модуль визуализации не всегда может позволить обеспечить одинаковый уровень качества для каждой части его выходного изображения. Заливка с переменной скоростью &mdash; или грубая заливка пикселя &mdash; — это механизм, позволяющий распределять производительность и степень отрисовки по тарифам, которые зависят от визуализированного изображения.

В некоторых случаях скорость заливки может быть уменьшена с минимальным или без снижения качества вывода. повышение производительности, которое, по сути, предоставляется бесплатно.

## <a name="without-vrsmdashmulti-sample-anti-aliasing-with-supersampling"></a>Без ВРС &mdash; многопримерного сглаживания с помощью ресамплинга
Без заливки с переменными частотами единственным средством управления скоростью заливки является многопримерное сглаживание (MSAA) с выполнением на основе образца (также известное как «ресамплинг»).

MSAA — это механизм уменьшения геометрического псевдонима и улучшения качества отрисовки изображения по сравнению с использованием MSAA. Число выборок в MSAA, которое может иметь значение 1x, 2x, 4X, 8X или 16x, регулирует число выборок, выделенных для каждого целевого пикселя рендеринга. Число выборок MSAA должно быть известно перед выделением целевого объекта и не может быть изменено в дальнейшем.

При интерполяции с помощью ресамплинга пиксельный построитель текстуры вызывается один раз для каждого образца с более высоким качеством, но также повышается стоимость производительности по сравнению с выполнением на пиксель.

Приложение может управлять скоростью заливки, выбирая между выполнением на основе точек или MSAA-with-ресамплинг. Эти два варианта не обеспечивают очень точное управление. Кроме того, может потребоваться уменьшить скорость заливки для определенного класса объектов по сравнению с остальной частью изображения. Такие объекты могут включать объект, лежащий в основе элемента HUD, или прозрачность, размытие (глубину поля, движение и т. д.) или оптическое искажение из-за VR. Но это было бы невозможно, так как качество заливки и затраты зафиксированы для всего изображения.

## <a name="with-variable-rate-shading-vrs"></a>С заливкой с переменной скоростью (ВРС)
Модель заливки с переменным заливке (ВРС) расширяет интерполяцию с помощью-MSAA в противоположную «грубую» точку (направление), добавляя концепцию грубой заливки. В этом случае заливка может выполняться с частотой более крупных, чем на пиксель. Иными словами, группа пикселей может быть закрашена как единое целое, а результат затем будет транслироваться во все примеры в группе.

API грубой заливки позволяет приложению указать число пикселей, принадлежащих к затененной группе, или *грубую точку*. После выделения целевого объекта рендеринга можно изменить размер грубой точки. Таким образом, различные части экрана или разные проходы рисования могут иметь различные скорости заливки.

Ниже приведена таблица, в которой описывается, какой уровень MSAA поддерживается, с крупным размером в пикселях. Некоторые из них не поддерживаются на всех платформах. другие по условию включены в зависимости от возможности (*аддитионалшадингратессуппортед*), обозначенной "Cap".

![В таблице показан негрубый размер для M S A уровней.](images/CoarsePixelSizeSupport.PNG "Размеры грубых пикселей")

Для уровней компонентов, обсуждаемых в следующем разделе, не существует сочетания грубого размера и количества выборок, когда оборудование должно отследить более 16 выборок на каждом вызове шейдера пикселей. Эти сочетания являются полутонами, затененными в таблице выше.

## <a name="feature-tiers"></a>Уровни компонентов
Существует два уровня реализации ВРС и две возможности, которые можно запросить. Каждый уровень описывается более подробно после таблицы.

![В таблице показаны возможности, доступные на уровнях 1 и 2.](images/Tiers.PNG "Уровни ВРС")

### <a name="tier-1"></a>Уровень 1
- Скорость заливки может быть задана только для каждого рисования; не более детально.
- Скорость заливки применяется единообразно для того, что рисуется независимо от того, где он находится внутри целевого объекта отрисовки.

### <a name="tier-2"></a>Уровень 2
- Скорость заливки может быть задана для каждого рисования, как на уровне 1. Его также можно указать с помощью сочетания для отдельных элементов, а из:
  - Семантика каждой вершины заставляющего и
  - изображение пространства экрана.
- Скорости заливки из трех источников объединяются с помощью набора средств комбинирования.
- Размер плитки для изображения на экране: 16x16 или меньше.
- Скорость заливки, запрошенная приложением, гарантированно доставляется в точности (для точности временных и других фильтров реконструкции).
- Поддерживается ввод SV_ShadingRate PS.
- Скорость заливки "на заставляющего вершин" (также известная как примитив) является допустимой, если одно окно просмотра используется и `SV_ViewportArrayIndex` не записывается в.
- Частоту "на заставляющего вершин" можно использовать с более чем одним окном просмотра, если для функции *суппортспервертексшадингратевисмултиплевиевпортс* задано значение `true` . Кроме того, в этом случае эту частоту можно использовать при `SV_ViewportArrayIndex` написании в.

### <a name="list-of-capabilities"></a>Список возможностей
- *аддитионалшадингратессуппортед*
  - Логический тип.
  - Указывает, поддерживаются ли размеры "2x4", "4 экземпляра 2" и 4x4 "грубые Пиксели" для отрисовки с одним образцом. и для двукратного MSAAа поддерживается размер 2x4 по грубой точке.
- *суппортспервертексшадингратевисмултиплевиевпортс*
  - Логический тип.
  - Указывает, можно ли использовать более одного окна просмотра с частотой заливки на вершину (также известной как примитив).

## <a name="specifying-shading-rate"></a>Задание скорости заливки
Для обеспечения гибкости приложений предусмотрено множество механизмов, позволяющих управлять скоростью заливки. В зависимости от уровня компонентов оборудования доступны различные механизмы.

### <a name="command-list"></a>Список команд
Это самый простой механизм для настройки скорости заливки. Он доступен на всех уровнях.

Приложение может указать размер грубой точки с помощью метода [ **ID3D12GraphicsCommandList5:: рссетшадинграте**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist5-rssetshadingrate). Этот API принимает один аргумент Enum. API предоставляет общий контроль над уровнем качества для отрисовки &mdash; возможности установить скорость заливки для каждого рисования.

Значения для этого состояния выражаются в перечислении [**D3D12_SHADING_RATE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_shading_rate) .

#### <a name="coarse-pixel-size-support"></a>Поддержка размера грубой точки
Скорости заливки 1x1, 1 экземпляр 2, 2x2 и 2x2 поддерживаются на всех уровнях.

Существует возможность, *аддитионалшадингратессуппортед*, чтобы указать, поддерживаются ли на устройстве устройства 2x4, 4 экземпляра 2 и 4x4.

### <a name="screen-space-image-image-based"></a>Изображение пространства экрана (на основе изображений)
На уровнях 2 и выше можно указать скорость заливки пикселов с помощью изображения на экране.

Изображение пространства экрана позволяет приложению создать изображение "уровень детализации (ЛОДа)", указывающее области с различным качеством, такие как области, на которые распространяется размытие движения, Размытие по глубине поля, прозрачные объекты или элементы пользовательского интерфейса HUD. Разрешение образа находится в макроблоккс; Он не находится в разрешении целевого объекта отрисовки. Иными словами, данные о скорости заливки задаются на уровне гранулярности 8x8 или 16x16 пикселей, как показано размером плитки ВРС.

#### <a name="tile-size"></a>Размер плитки
Приложение может запрашивать API для получения поддерживаемого размера плитки ВРС для устройства.

Плитки являются квадратными, а размер — ширина или высота плитки в пикселей текстуры.

Если оборудование не поддерживает заливку переменной уровня 2, то запрос возможности для размера плитки возвращает значение 0.

Если *оборудование поддерживает* заливку переменного уровня 2, то размер плитки будет одним из этих значений.

- 8
- 16
- 32

#### <a name="screen-space-image-size"></a>Размер изображения на экране
Для целевого объекта отрисовки размером {Ртвидс, Рсеигхт}, используя заданный размер плитки с именем **врстилесизе**, изображение пространства экрана, которое будет охватывать эти измерения.

```cpp
{ ceil((float)rtWidth / VRSTileSize), ceil((float)rtHeight / VRSTileSize) }
```

Левый верхний край изображения на экране (0, 0) заблокирован для верхнего левого угла рендеринга (0, 0).

Чтобы найти координату (x, y) плитки, которая соответствует определенному положению в целевом объекте рендеринга, разделите координаты пространства окна (x, y) на размер плитки, игнорируя дробные разряды.

Если размер изображения на экране больше, чем требуется для данного целевого объекта рендеринга, дополнительные фрагменты справа и (или) снизу не используются.

Если изображение на экране слишком мало для данного целевого объекта рендеринга, все попытки чтения из изображения за пределами фактических экстентов приводят к заливке по умолчанию 1x1. Это связано с тем, что верхний левый рисунок на экране (0, 0) заблокирован для верхнего левого угла рендеринга (0, 0), а «чтение за пределами целевого объекта рендеринга» означает слишком много значений для x и y.

#### <a name="format-layout-resource-properties"></a>Формат, макет, свойства ресурса
Формат этой поверхности — 8-разрядная поверхность с одним каналом ([**DXGI_FORMAT_R8_UINT**](/windows/desktop/api/dxgiformat/ne-dxgiformat-dxgi_format)).

Ресурс является **TEXTURE2D** измерения.

Он не может быть массивом или миппед. Он должен иметь один уровень MIP.

Он содержит число выборок 1 и пример качества 0.

Неизвестный макет текстуры . Он неявно не может быть разметкой по строкам, так как перекрестные адаптеры не допускаются.

Ожидаемый способ заполнения данных изображения экранного пространства — либо
1. Запись данных с помощью шейдера вычислений; изображение пространства экрана привязано как UAV или
2. Скопируйте данные в изображение пространства экрана.

При создании изображения пространства экрана эти флаги разрешены.

- None
- ALLOW_UNORDERED_ACCESS
- DENY_SHADER_RESOURCE

Эти флаги не допускаются.

- ALLOW_RENDER_TARGET
- ALLOW_DEPTH_STENCIL
- ALLOW_CROSS_ADAPTER
- ALLOW_SIMULTANEOUS_ACCESS
- VIDEO_DECODE_REFERENCE_ONLY

Тип кучи ресурса не может быть UPLOAD или РЕАДБАКК.

Не удается SIMULTANEOUS_ACCESS ресурс. Ресурс не может быть перекрестным адаптером.

#### <a name="data"></a>Данные
Каждый байт изображения на экране соответствует значению перечисления [**D3D12_SHADING_RATE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_shading_rate)  .

#### <a name="resource-state"></a>Состояние ресурса
Ресурс необходимо перевести в состояние только для чтения при использовании в качестве изображения пространства экрана. Для этой цели определено состояние "только для чтения", [**D3D12_RESOURCE_STATE_SHADING_RATE_SOURCE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_states).

Ресурс изображения перейдет из этого состояния, чтобы снова сделать запись доступным для записи.

#### <a name="setting-the-image"></a>Настройка образа
Изображение пространства экрана для указания скорости шейдера задается в списке команд.

Ресурс, заданный в качестве источника скорости заливки, не может быть считан или записан на любом этапе шейдера.

`null`Для указания скорости шейдера можно задать изображение пространства экрана. Это влияет на то, что 1x1 постоянно используется в качестве вклада из изображения экранного пространства. Изначально можно считать, что образ пространства экрана имеет значение `null` .

#### <a name="promotion-and-decay"></a>Продвижение и Decay
Ресурс изображения на экране не имеет каких-либо специальных последствий в отношении продвижения или Decay.

### <a name="per-primitive-attribute"></a>Атрибут для каждого примитива
Атрибут «на примитив» добавляет возможность указания Терма скорости заливки в виде атрибута из вершины заставляющего. Этот атрибут имеет плоский цвет, &mdash; т. е. он распространяется на все пиксели в текущем треугольнике или примитиве линии. Использование атрибута для каждого примитива может обеспечить более детализированный контроль качества изображения по сравнению с другими описателями скорости заливки.

Атрибут для каждого примитива является настраиваемой семантикой с именем `SV_ShadingRate` . `SV_ShadingRate` существует как часть [модели шейдера HLSL 6,4](/windows/desktop/direct3dhlsl/hlsl-shader-model-6-4-features-for-direct3d-12).

Если набор VS или GS `SV_ShadingRate` установлен, но ВРС не включен, семантический параметр не действует. Если для `SV_ShadingRate` одного примитива не указано значение, то значение скорости заливки 1x1 принимается в качестве вклада для каждого примитива.

### <a name="combining-shading-rate-factors"></a>Объединение факторов скорости заливки
Различные источники скорости заливки применяются в последовательности с помощью этой схемы.

![На диаграмме показано состояние конвейера с пометкой с заголовком заставляющего вершиной заливки с меткой B, примененной в сочетании, а затем скорость затенения на основе изображений, помеченная буквой B, применена в средстве объединения.](images/Combiners.PNG "Комбинированные шейдеры")

Каждая пара A и B объединяется с помощью средства объединения.

\* При указании скорости шейдера по атрибуту вершины.

- При использовании шейдера Geometry можно указать скорость заливки.
- Если шейдер geometry не используется, то скорость заливки задается вершиной заставляющего.

#### <a name="list-of-combiners"></a>Список комбинированных элементов
Поддерживаются следующие комбинирования. Использование средства объединения (C) и двух входных данных (A и B).

- **Транзитный**. В. XY = A. XY.
- **Переопределить**. C. XY = B. XY.
- **Более высокое качество**. C. XY = min (A. XY, B. XY).
- **Более низкое качество**. В. XY = Max (A. XY, B. XY).
- **Примените стоимость B относительно**. C. XY = min (Максрате, A. XY + B. XY).

где `maxRate` — это самая крупная допустимая аналитика грубого пикселя на устройстве. Это будет

- **D3D12_AXIS_SHADING_RATE_2X** (то есть значение 1), если аддитионалшадингратессуппортед — `false` .
- **D3D12_AXIS_SHADING_RATE_4X** (то есть значение 2), если аддитионалшадингратессуппортед — `true` .

Выбор средства объединения для заливки переменной скорости задается в списке команд с помощью [**ID3D12GraphicsCommandList5:: рссетшадинграте**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist5-rssetshadingrate).

Если параметры не заданы, то они остаются в расположении по умолчанию, которое является ТРАНЗИТным.

Если источником для объединения является [**D3D12_AXIS_SHADING_RATE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_axis_shading_rate), который не допускается в таблице поддержки, входные данные исключены *в поддерживаемую* частоту заливки.

Если выходные данные средства объединения не соответствуют скорости затенения, поддерживаемой на платформе, то результат будет исключен *до поддерживаемой* скорости заливки.

### <a name="default-state-and-state-clearing"></a>Состояние по умолчанию и очистка состояния
Все источники скорости заливки, а именно

- скорость указанного состояния конвейера (указана в списке команд)
- Заданная скорость изображения на экране и
- атрибут для каждого примитива

по умолчанию имеет значение **D3D12_SHADING_RATE_1X1**. По умолчанию используются значения {PASSTHROUGH, PASSTHROUGH}.

Если изображение пространства экрана не указано, то скорость заливки 1x1 выводится из этого источника.

Если не указано ни одного примитивного атрибута, то скорость заливки 1x1 выводится из этого источника.

[ID3D12CommandList:: клеарстате](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-clearstate) сбрасывает скорость, указанную для состояния конвейера, на значение по умолчанию, а изображение пространства экрана — в значение по умолчанию "нет изображения на экране".

## <a name="querying-shading-rate-by-using-sv_shadingrate"></a>Запрос скорости заливки с помощью SV_ShadingRate
Полезно определить, какая скорость заливки была выбрана оборудованием при любом вызове шейдера пикселей. Это может обеспечить разнообразные оптимизации в коде PS. Системная переменная только для PS `SV_ShadingRate` предоставляет сведения о скорости заливки.

### <a name="type"></a>Тип
Тип этой семантики — uint.

### <a name="data-interpretation"></a>Интерпретация данных
Данные интерпретируется как значение перечисления [**D3D12_SHADING_RATE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_shading_rate) .

### <a name="if-vrs-is-not-being-used"></a>Если ВРС не используется
Если некрупная заливка пикселей не используется, то `SV_ShadingRate` считывается в виде значения 1x1, что означает, что пикселы задаются нормально.

### <a name="behavior-under-sample-based-execution"></a>Поведение при выполнении на основе образца
Шейдер пикселей завершается сбоем при компиляции, если он выполняет вход `SV_ShadingRate` , а также использует пример выполнения &mdash; , например, путем вывода `SV_SampleIndex` или использования ключевого слова интерполяции Sample.

> ### <a name="remarks-on-deferred-shading"></a>Примечания для отложенной заливки
>
> Проходам освещения приложения с отложенной заливкой может потребоваться знать, какой уровень заливки использовался для какой области экрана. Это значит, что диспетчеризации передачи освещения могут быть запущены с более крупной ставкой. `SV_ShadingRate`Переменная может использоваться для выполнения этой задачи, если она записывается в гбуффер.

## <a name="depth-and-stencil"></a>Глубина и трафарет
Когда используется грубая заливка пикселей, глубина и трафарет и покрытие всегда вычисляются и выдаются в полном разрешении выборки.

## <a name="using-the-shading-rate-requested"></a>Использование запрошенной скорости заливки
Для всех уровней предполагается, что если запрашивается скорость заливки и она поддерживается в сочетании Device-and-MSAA-Level, то это — скорость заливки, предоставляемая оборудованием.

Запрошенная скорость заливки означает, что скорость заливки, вычисленная как результат работы средств объединения (см. в разделе [объединение факторов скорости заливки](#combining-shading-rate-factors) в этом разделе).

Поддерживаемая скорость заливки — 1x1, 1 экземпляр 2, 2x1 или 2x2 в операции визуализации, где количество выборок меньше или равно 4. Если функция *аддитионалшадингратессуппортед* имеет значение `true` , то для некоторых выборок также поддерживаются скорости заливки (2x4, 4 экземпляра 2 и 4x4) (см. таблицу в подразделе [with переменная с заливкой (ВРС)](#with-variable-rate-shading-vrs) этой статьи).

## <a name="screen-space-derivatives"></a>Производные пространства экрана
Вычисление градиентов с точки на смежные пиксели зависит от грубой заливки пикселей. Например, при использовании 2x2 грубых пикселов размер градиента будет вдвое больше, чем в случае, когда грубые Пиксели не используются. Вашему приложению может потребоваться настроить шейдеры для компенсации этого &mdash; или нет, в зависимости от требуемых функций.

Поскольку MIPS выбираются на основе производного пространства на экране, использование заливки грубой области влияет на выбор MIP. Использование затенения грубого пикселя приводит к тому, что по сравнению с грубыми пикселями будет выбираться менее подробное значение MIPS.

## <a name="attribute-interpolation"></a>Интерполяция атрибута
Входные данные для шейдера пикселей могут быть интерполяции на основе их исходных вершин. Поскольку заливка переменной скорости влияет на области целевого объекта, написанного при каждом вызове шейдера пикселей, он взаимодействует с интерполяцией атрибута. Три типа интерполяции — Center, центроид и Sample.

### <a name="center"></a>Center
Центральная часть интерполяции для грубой точки — это геометрический центр полной грубой области. `SV_Position` всегда интерполируются в центре области грубой точки.

### <a name="centroid"></a>Центроид
При использовании в MSAA грубой заливки пикселей для каждого тонкого пикселя все равно будет выполняться запись в полное число выборок, выделенных для уровня MSAA целевого объекта. Таким образом, расположение интерполяции центроид будет рассматривать все примеры для тонких точек в пределах грубых пикселов. С другой стороны, расположение интерполяции центроид определяется в качестве первого охваченного примера в порядке возрастания индекса выборки. Этот пример действительного покрытия — и-ED с соответствующим битом состояния средства растеризации Самплемаск.

> [!NOTE]
> Если на уровне 1 используется штриховка «грубая пиксельная заливка», Самплемаск всегда является полной маской. Если для Самплемаск не задана полная маска, то на уровне 1 отключается грубая заливка пикселей.

### <a name="sample-based-execution"></a>Выполнение на основе образца
Выполнение на основе выборки или *ресамплинг*, который вызывается с &mdash; помощью функции интерполяции образцов, &mdash; можно использовать с грубой заливкой пикселей и приводить к вызову шейдера пикселей для каждого образца. Для целевых объектов счетчика выборки N построитель текстуры вызывается N раз в каждом пикселе.

### <a name="evaluateattributesnapped"></a>евалуатеаттрибутеснаппед
Встроенные функции модели извлечения не совместимы с грубой заливкой пикселов на уровне 1. При попытке использовать внутренние объекты модели с грубой заливкой на уровне 1 грубая заливка пикселей автоматически отключается.

Встроенная функция может `EvaluateAttributeSnapped` использоваться с затенением грубых пикселей на уровне 2. Его синтаксис такой же, как и всегда.

```hlsl
numeric EvaluateAttributeSnapped(   
    in attrib numeric value, 
    in int2 offset);
```

Для context `EvaluateAttributeSnapped` имеет параметр offset с двумя полями. Если используется без грубой заливки пикселей, используются только четыре бита нижнего порядка из полного 32. Эти четыре бита представляют диапазон [-8, 7]. Этот диапазон охватывает сетку размером 16 x в пикселе. Диапазон состоит в том, что верхний и левый края пикселя включены, а нижняя и правая границы — нет. Offset (-8,-8) находится в левом верхнем углу, а смещение (7, 7) — в правом нижнем углу. Смещение (0,0) является центром пикселя.

При использовании с грубой заливкой пикселей `EvaluateAttributeSnapped` параметр offset может указывать более широкий диапазон расположений. Параметр offset выбирает сетку 16x16 для каждого тонкого пикселя и несколько точек подточки. Числовой диапазон и последующий число используемых битов зависят от размера грубой точки. Верхний и левый края грубой точки включаются, а нижний и правый края — нет.

В следующей таблице описывается интерпретация `EvaluateAttributeSnapped` параметра offset для каждого грубого размера в пикселях.

#### <a name="evaluateattributesnappeds-offset-range"></a>Диапазон смещения Евалуатеаттрибутеснаппед

|Грубый размер пикселя  |Индексируемый диапазон             |Выступающий размер диапазона  |Требуемое число битов {x, y}  |Двоичная маска пригодных для использования битов          |    
|------------------:|---------------------------:|-------------------------:|-----------------------------:|-----------------------------------:|    
|1x1 (хорошо)         |{ \[ -8, 7 \] , \[ -8, 7 \] }      |{16, 16}                  |{4, 4}                        |{000000000000xxxx, 000000000000xxxx}|    
|1 экземпляр 2                |{ \[ -8, 7 \] , \[ -16, 15 \] }    |{16, 32}                  |{4, 5}                        |{000000000000xxxx, 00000000000xxxxx}|    
|2x1                |{ \[ -16, 15 \] , \[ -8, 7 \] }    |{32, 16}                  |{5, 4}                        |{00000000000xxxxx, 000000000000xxxx}|    
|2x2                |{ \[ -16, 15 \] , \[ -16, 15 \] }  |{32, 32}                  |{5, 5}                        |{00000000000xxxxx, 00000000000xxxxx}|    
|коннектор                |{ \[ -16, 15 \] , \[ -32, 31 \] }  |{32, 64}                  |{5, 6}                        |{00000000000xxxxx, 0000000000xxxxxx}|    
|4x2                |{ \[ -32, 31 \] , \[ -16, 15 \] }  |{64, 32}                  |{6, 5}                        |{0000000000xxxxxx, 00000000000xxxxx}|    
|4x4                |{ \[ -32, 31 \] , \[ -32, 31 \] }  |{64, 64}                  |{6, 6}                        |{0000000000xxxxxx, 0000000000xxxxxx}|   

Приведенные ниже таблицы представляют собой инструкции по преобразованию из с фиксированной точкой в десятичное и дробное представление. Первый используемый бит в двоичной маске является битом знака, а остальная часть двоичной маски состоит из числовой части.

Числовая схема для четырех-разрядных значений, передаваемых в `EvaluateAttributeSnapped` , не зависит от заливки переменной скорости. Он перебирается здесь для полноты.

Для четырех битовых значений.

| Двоичное значение | Decimal  | Дробная часть |
|-------------:|---------:|-----------:|
|         1000 |-0,5 f     |— 8/16     |
|         1001 |-0.4375 f  |— 7/16|    |
|         1010 |-0.375 f   |— 6/16|    |
|         1011 |-0.3125 f  |— 5/16     |
|         1100 |-0.25 f    |— 4/16     |
|         1101 |-0.1875 f  |— 3/16     |
|         1110 |-0,125 f   |— 2/16     |
|         1111 |-0.0625 f  |— 1/16      |
|         0000 |указано      |0 / 16      |
|         0001 |-0.0625 f  |1 / 16      |
|         0010 |-0,125 f   |2 / 16      |
|         0011 |-0.1875 f  |3 / 16      |
|         0100 |-0.25 f    |4 / 16      |
|         0101 |-0.3125 f  |5 / 16      |
|         0110 |-0.375 f   |6 / 16      |
|         0111 |-0.4375 f  |7 / 16      |

Для пяти-разрядных значений.

| Двоичное значение | Decimal  | Дробная часть |
|-------------:|---------:|-----------:|
|        10000 |–1        |— 16/16    |
|        10001 |— 0,9375   |— 15/16    |
|        10010 |— 0,875    |— 14/16    |
|        10011 |— 0,8125   |— 13/16    |
|        10100 |-0.75     |— 12/16    |
|        10101 |— 0,6875   |— 11/16    |
|        10110 |— 0,625    |— 10/16    |
|        10111 |— 0,5625   |— 9/16     |
|        11000 |-0,5      |— 8/16     |
|        11001 |— 0,4375   |— 7/16     |
|        11010 |— 0,375    |— 6/16     |
|        11011 |— 0,3125   |— 5/16     |
|        11100 |-0.25     |— 4/16     |
|        11101 |— 0,1875   |— 3/16     |
|        11110 |— 0,125    |— 2/16     |
|        11111 |— 0,0625   |— 1/16     |
|        00000 |0         |0 / 16      |
|        00001 |0,0625    |1 / 16      |
|        00010 |0.125     |2 / 16      |
|        00011 |0,1875    |3 / 16      |
|        00100 |0,25      |4 / 16      |
|        00101 |0,3125    |5 / 16      |
|        00110 |0,375     |6 / 16      |
|        00111 |0,4375    |7 / 16      |
|        01000 |0,5       |8 / 16      |
|        01001 |0,5625    |9 / 16      |
|        01010 |0,625     |10 / 16     |
|        01011 |0,6875    |11 / 16     |
|        01100 |0,75      |12 / 16     |
|        01101 |0,8125    |13 / 16     |
|        01110 |0,875     |14 / 16     |
|        01111 |0,9375    |15 / 16     |

Для шести-разрядных значений.

| Двоичное значение | Decimal  | Дробная часть |
|-------------:|---------:|-----------:|
|       100 000 |–2        |-32/16    |
|       100001 |— 1,9375   |— 31/16    |
|       100010 |— 1,875    |— 30/16    |
|       100011 |— 1,8125   |— 29/16    |
|       100100 |— 1,75     |— 28/16    |
|       100101 |— 1,6875   |— 27/16    |
|       100110 |— 1,625    |— 26/16    |
|       100111 |— 1,5625   |— 25/16    |
|       101000 |— 1,5      |— 24/16    |
|       101001 |— 1,4375   |— 23/16    |
|       101010 |— 1,375    |— 22/16    |
|       101011 |— 1,3125   |— 21/16    |
|       101100 |-1.25     |— 20/16    |
|       101101 |— 1,1875   |— 19/16    |
|       101110 |— 1,125    |— 18/16    |
|       101111 |— 1,0625   |— 17/16    |
|       110000 |–1        |— 16/16    |
|       110001 |— 0,9375   |— 15/16    |
|       110010 |— 0,875    |— 14/16    |
|       110011 |— 0,8125   |— 13/16    |
|       110100 |-0.75     |— 12/16    |
|       110101 |— 0,6875   |— 11/16    |
|       110110 |— 0,625    |— 10/16    |
|       110111 |— 0,5625   |— 9/16     |
|       111000 |-0,5      |— 8/16     |
|       111001 |— 0,4375   |— 7/16     |
|       111010 |— 0,375    |— 6/16     |
|       111011 |— 0,3125   |— 5/16     |
|       111100 |-0.25     |— 4/16     |
|       111101 |— 0,1875   |— 3/16     |
|       111110 |— 0,125    |— 2/16     |
|       111111 |— 0,0625   |— 1/16     |
|       000000 |0         |0 / 16      |
|       000001 |0,0625    |1 / 16      |
|       000010 |0.125     |2 / 16      |
|       000011 |0,1875    |3 / 16      |
|       000100 |0,25      |4 / 16      |
|       000101 |0,3125    |5 / 16      |
|       000110 |0,375     |6 / 16      |
|       000111 |0,4375    |7 / 16      |
|       001000 |0,5       |8 / 16      |
|       001001 |0,5625    |9 / 16      |
|       001010 |0,625     |10 / 16     |
|       001011 |0,6875    |11 / 16     |
|       001100 |0,75      |12 / 16     |
|       001101 |0,8125    |13 / 16     |
|       001110 |0,875     |14 / 16     |
|       001111 |0,9375    |15 / 16     |
|       010000 |1         |16 / 16     |
|       010001 |1,0625    |17 / 16     |
|       010010 |1,125     |18 / 16     |
|       010011 |1,1875    |19 / 16     |
|       010100 |1,25      |20 / 16     |
|       010101 |1,3125    |21 / 16     |
|       010110 |1,375     |22 / 16     |
|       010111 |1,4375    |23 / 16     |
|       011000 |1.5       |24 / 16     |
|       011001 |1,5625    |25 / 16     |
|       011010 |1,625     |26 / 16     |
|       011011 |1,6875    |27 / 16     |
|       011100 |1,75      |28 / 16     |
|       011101 |1,8125    |29 / 16     |
|       011110 |1,875     |30 / 16     |
|       011111 |1,9375    |31 / 16     |

Точно так же, как и в случае с тонкими пикселями, `EvaluateAttributeSnapped` Сетка вычисляемых расположений выравнивается по центру в грубой точке, когда используется грубая заливка пикселей.

## <a name="setsamplepositions"></a>SetSamplePositions
Если API [**ID3D12GraphicsCommandList1:: сетсамплепоситионс**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist1-setsamplepositions) используется с грубой заливкой, API задает позиции выборки для тонкого пикселя.

## <a name="sv_coverage"></a>SV_Coverage
Если `SV_Coverage` объявляется как входные или выходные данные шейдера на уровне 1, то отключается грубая заливка пикселей.

Вы можете использовать `SV_Coverage` семантику с грубой заливкой на уровне 2, и она отражает, какие образцы целевого объекта MSAA записываются.

Когда используется грубая заливка пикселей, &mdash; позволяя нескольким исходным пикселам &mdash; составлять плитку, маска покрытия представляет все выборки из этой плитки.

Учитывая совместимость с MSAA, количество битов покрытия, которые необходимо указать, может различаться. Например, при использовании ресурса 4X MSAA с использованием [**D3D12_SHADING_RATE_2x2**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_shading_rate)каждый грубый пиксель записывается в четыре пикселя, и каждый тонкая точка имеет четыре образца. Это означает, что каждый грубый пиксель записывается в общую сумму 4 * 4 = 16 выборок.

### <a name="number-of-coverage-bits-needed"></a>Необходимое количество битов покрытия
В следующей таблице показано, сколько битов покрытия требуется для каждого сочетания грубого размера и уровня MSAA.

![В таблице показан грубый размер пикселя, количество тонких точек и M единиц на уровнях.](images/NumberOfCoverageBits.PNG "Биты покрытия")

Как указано в таблице, нельзя использовать грубые Пиксели для записи более чем 16 выборок за раз, используя функцию заливки переменной скорости, доступную через Direct3D 12. Это ограничение обусловлено ограничениями Direct3D 12, связанными с тем, какие уровни MSAA разрешены, с размером грубой точки (см. таблицу в разделе [with ВРС (заливка переменной)](#with-variable-rate-shading-vrs) этой статьи).

### <a name="ordering-and-format-of-bits-in-the-coverage-mask"></a>Упорядочивание и форматирование битов в маске покрытия
Биты маски покрытия соответствуют четко определенному заказу. Маска состоит из покрытия пикселов слева направо, а затем сверху вниз (столбец — основной). Биты покрытия являются младшими битами семантики покрытия и сжимаются вместе.

В таблице ниже показан формат маски покрытия для поддерживаемых комбинаций грубого размера и уровня MSAA.

![В таблице показан объем некрупных пикселей, грубая диаграмма и 1 x M S бит покрытия.](images/Coverage1x.PNG "Покрытие на 1x")

В следующей таблице портрайс 2x MSAAs, где каждый пиксель имеет два образца индексов 0 и 1.

Расположение меток выборок в пикселях предназначено для наглядных целей и не обязательно приводить к пространственному положению {X, Y} образцов на этом пикселе; особенно учитывая, что позиции выборки можно изменить программным способом. На примеры ссылаются их индексы (от 0).

![В таблице показан объем некрупных пикселей, грубая диаграмма и 2 x M S.](images/Coverage2x.PNG "Покрытие на 2x")

В следующей таблице показаны пикселы 4X MSAA, где каждый пиксель имеет четыре выборки индексов 0, 1, 2 и 3.

![В таблице показан объем некрупных пикселей, грубая диаграмма и 4 x M S.](images/Coverage4x.PNG "Покрытие с частотой 4X")

## <a name="discard"></a>Игнорировать
Если используется семантика HLSL `discard` с грубой заливкой пикселей, то грубые пикселы отбрасываются.

## <a name="target-independent-rasterization-tir"></a>Независимая от целевого объекта растрирование (Тир)
Тир не поддерживается, когда используется грубая заливка пикселей.

## <a name="raster-order-views-rovs"></a>Представления растрового порядка (РОВС)
РОВ взаимоблокировки задаются как работа с тонкой гранулярностью пикселя. Если заливка выполняется для каждого образца, то подблокировки работают при детализации выборки.

## <a name="conservative-rasterization"></a>Консервативная растрирование
Вы можете использовать консервативную растрирование с заливкой переменной скорости. При использовании консервативной растеризации с грубой заливкой пикселов, тонко разкраска пикселов в грубых пикселях с использованием полного покрытия.

### <a name="coverage"></a>Покрытие
При использовании консервативной растеризации семантика покрытия содержит полные маски для тонких пикселов, а 0 — для тонких пикселов, которые не охватываются.

## <a name="bundles"></a>Пакеты
В пакете можно вызывать API-интерфейсы заливки с переменными частотами.

## <a name="render-passes"></a>Проходы визуализации
Вы можете вызывать API-интерфейсы заливки с переменными частотами в [ходе подготовки к просмотру](/windows/desktop/direct3d12/direct3d-12-render-passes).

## <a name="calling-the-vrs-apis"></a>Вызов интерфейсов API ВРС
В следующем разделе описывается способ, с помощью которого можно получить доступ к заливке переменной с применением Direct3D 12.

### <a name="capability-querying"></a>Запросы возможностей

Чтобы запросить возможность заливки с переменным адаптером, вызовите метод [**ID3D12Device:: чеккфеатуресуппорт**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-checkfeaturesupport) с [**D3D12_FEATURE::D 3D12_FEATURE_D3D12_OPTIONS6**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_feature)и предоставьте [структуру **D3D12_FEATURE_DATA_D3D12_OPTIONS6**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_d3d12_options6) для заполнения функцией. Структура **D3D12_FEATURE_DATA_D3D12_OPTIONS6** содержит несколько элементов, включая один из перечисляемых типов [**D3D12_VARIABLE_SHADING_RATE_TIER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_variable_shading_rate_tier) (D3D12_FEATURE_DATA_D3D12_OPTIONS6:: вариаблешадингратетиер) и один, который указывает, поддерживается ли фоновая обработка (D3D12_FEATURE_DATA_D3D12_OPTIONS6:: баккграундпроцессингсуппортед).

Например, для запроса возможности уровня 1 это можно сделать.

```cpp
D3D12_FEATURE_DATA_D3D12_OPTIONS6 options;
return 
    SUCCEEDED(m_device->CheckFeatureSupport(
        D3D12_FEATURE_D3D12_OPTIONS6, 
        &options, 
        sizeof(options))) && 
    options.ShadingRateTier == D3D12_VARIABLE_SHADING_RATE_TIER_1;
```

### <a name="shading-rates"></a>Скорости заливки

Значения в [перечислении **D3D12_SHADING_RATE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_shading_rate) организованы таким образом, что скорость заливки легко делимыми на две оси, где значения каждой оси сжимаются в виде логарифмического пробела в соответствии с [перечислением **D3D12_AXIS_SHADING_RATE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_axis_shading_rate).

Можно создать макрос для объединения двух ставок заливки осей в скорость заливки, подобную этой.

```cpp
#define D3D12_MAKE_COARSE_SHADING_RATE(x,y) ((x) << 2 | (y))
D3D12_MAKE_COARSE_SHADING_RATE(
    D3D12_AXIS_SHADING_RATE_2X, 
    D3D12_AXIS_SHADING_RATE_1X)
```

Платформа также предоставляет эти макросы, определенные в `d3d12.h` .

```cpp
#define D3D12_GET_COARSE_SHADING_RATE_X_AXIS(x) ((x) >> 2 )
#define D3D12_GET_COARSE_SHADING_RATE_Y_AXIS(y) ((y) & 3 )
```

Их можно использовать для закрепить и понимания `SV_ShaderRate` .

> [!NOTE]
> Эта интерпретация данных нацелена на описание изображения пространства экрана, которое может быть обработано шейдерами. Это обсуждается далее в разделах, приведенных выше. Но нет никакой причины не иметь единообразного определения размеров грубых пикселов, используемых везде, в том числе при задании скорости заливки на уровне команд.

### <a name="setting-command-level-shading-rate-and-combiners"></a>Задание скорости и параметров затенения на уровне команд
Скорость заливки и, при необходимости, методы комбинирования задаются с помощью метода [**ID3D12GraphicsCommandList5:: рссетшадинграте**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist5-rssetshadingrate) . Вы передаете [**D3D12_SHADING_RATE**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_shading_rate) значение для базовой скорости заливки и необязательный массив значений [D3D12_SHADING_RATE_COMBINER](/windows/desktop/api/d3d12/ne-d3d12-d3d12_shading_rate_combiner) .

### <a name="preparing-the-screen-space-image"></a>Подготовка изображения пространства экрана
Состояние ресурса только для чтения, обозначающее пригодное для использования значение скорости заливки, определяется как [D3D12_RESOURCE_STATES::D 3D12_RESOURCE_STATE_SHADING_RATE_SOURCE](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_states).

### <a name="setting-the-screen-space-image"></a>Настройка изображения пространства экрана
Изображение пространства экрана указывается с помощью метода [**ID3D12GraphicsCommandList5:: рссетшадингратеимаже**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist5-rssetshadingrateimage) .

```cpp
m_commandList->RSSetShadingRateImage(screenSpaceImage);
```

### <a name="querying-the-tile-size"></a>Запрос размера плитки
Можно запросить размер плитки из элемента [**D3D12_FEATURE_DATA_D3D12_OPTIONS6:: шадингратеимажетилесизе**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_d3d12_options6) . См. раздел [запросы возможностей](#capability-querying) выше.

Одно измерение извлекается, поскольку горизонтальные и вертикальные измерения всегда одинаковы. Если возможности системы [**D3D12_SHADING_RATE_TIER_NOT_SUPPORTED**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_variable_shading_rate_tier), возвращается размер плитки 0.
