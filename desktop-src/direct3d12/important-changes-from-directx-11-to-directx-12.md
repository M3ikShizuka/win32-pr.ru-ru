---
title: Важные изменения в Direct3D 12 по сравнению с Direct3D 11
description: Direct3D 12 представляет значительный уход с модели программирования Direct3D 11. Direct3D 12 позволяет приложениям ближе к оборудованию, чем когда-либо ранее.
ms.assetid: CE5066C9-7EA6-437D-9EB0-AACFB6CFAD9E
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3afc5fe9a451addf1d1f7b9aeddf1f55ca40a22db99134ba71d8195c72ad2b13
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119123837"
---
# <a name="important-changes-from-direct3d-11-to-direct3d-12"></a>Важные изменения в Direct3D 12 по сравнению с Direct3D 11

Direct3D 12 представляет значительный уход с модели программирования Direct3D 11. Direct3D 12 позволяет приложениям ближе к оборудованию, чем когда-либо ранее. Чем ближе к оборудованию, Direct3D 12 быстрее и эффективнее. Но при этом при использовании Direct3D 12 Вы несете ответственность за выполнение большего числа задач, чем при использовании Direct3D 11.

-   [Явная синхронизация](#explicit-synchronization)
-   [Управление местонахождение физической памяти](#physical-memory-residency-management)
-   [Объекты состояния конвейера](#pipeline-state-objects)
-   [Списки команд и пакеты](#command-lists-and-bundles)
-   [Кучи дескрипторов и таблицы](#descriptor-heaps-and-tables)
-   [Перенос с Direct3D 11](#porting-from-direct3d-11)
-   [Связанные темы](#related-topics)

Direct3D 12 является возвратом к программированию низкого уровня; Он обеспечивает более полный контроль над графическими элементами игр и приложений, представляя следующие новые функции: объекты для представления общего состояния конвейера, списки команд и пакеты для отправки работы, а также кучи дескрипторов и таблицы для доступа к ресурсам.

Производительность и эффективность приложения увеличились с помощью Direct3D 12, но вы несете ответственность за выполнение большего числа задач, чем при использовании Direct3D 11.

## <a name="explicit-synchronization"></a>Явная синхронизация

-   В Direct3D 12 синхронизация GPU теперь является явной обязанностью приложения и больше не выполняется неявным образом средой выполнения, как в Direct3D 11. Это также означает, что автоматическая проверка на наличие угроз конвейера не выполняется Direct3D 12, поэтому это несет ответственность за приложения.
-   В Direct3D 12 приложения отвечают за обновление конвейерных данных. То есть шаблон "Map/Lock-DISCARD" в Direct3D 11 необходимо выполнять вручную в Direct3D 12. В Direct3D 11, если графический процессор по-прежнему использует буфер при вызове [**ссылку ID3D11DeviceContext:: Map**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-map) с [**D3D11ной \_ \_ записью \_ в Map**](/windows/desktop/api/d3d11/ne-d3d11-d3d11_map), среда выполнения возвращает указатель на новый регион памяти вместо старых данных буфера. Это позволяет GPU продолжать использовать старые данные, пока приложение помещает данные в новый буфер. В приложении не требуется дополнительное управление памятью; Старый буфер повторно используется или уничтожается автоматически после завершения работы графического процессора.
-   В Direct3D 12 все динамические обновления (включая буферы констант, динамические буферы вершин, динамические текстуры и т. д.) явным образом управляются приложением. Эти динамические обновления включают в себя все необходимые временные границы GPU или буферизацию. Приложение несет ответственность за хранение доступной памяти, пока она больше не нужна.
-   Direct3D 12 использует подсчет ссылок в стиле COM только для времени существования интерфейсов (с использованием модели слабых ссылок Direct3D, привязанной к времени существования устройства). Все время существования памяти и описания ресурсов — это единственная ответственность за то, что приложение должно поддерживаться в течение нужного времени и не подсчитывается по ссылке. В Direct3D 11 для управления жизненным циклом зависимостей интерфейса также используется подсчет ссылок.

## <a name="physical-memory-residency-management"></a>Управление местонахождение физической памяти

Приложение Direct3D 12 должно предотвращать состояния гонки между несколькими очередями, несколькими адаптерами и потоками ЦП. D3D12 больше не синхронизирует ЦП и GPU, а также не поддерживает удобные механизмы переименования ресурсов и создания нескольких буферов. Границы должны использоваться во избежание нескольких единиц обработки из-за нехватки памяти, прежде чем другой модуль обработки завершит его использование.

Приложение Direct3D 12 должно обеспечить, чтобы данные находились в памяти во время считывания GPU. Память, используемая каждым объектом, становится резидентной во время создания объекта. Приложения, вызывающие эти методы, должны использовать ограждения, чтобы убедиться, что GPU не обращается к удаленным объектам.

Барьеры ресурсов — это еще один тип синхронизации, используемый для синхронизации изменений ресурсов и подресурсов на очень детализированном уровне.

См. сведения об [управлении памятью в Direct3D 12](memory-management.md).

## <a name="pipeline-state-objects"></a>Объекты состояния конвейера

Direct3D 11 позволяет управлять состоянием конвейера с помощью большого набора независимых объектов. Например, состояние входного ассемблера, состояние шейдера пикселей, состояние средства прорисовки и состояние слияния вывода могут быть изменены независимо друг от друга. Такая схема обеспечивает удобное и относительно высокоуровневое представление графического конвейера, но не использует возможности современного оборудования, в основном потому, что различные состояния часто являются взаимозависимыми. Например, многие GPU объединяют пиксельный шейдер и выходное состояние слияния в одно аппаратное представление. Но поскольку API Direct3D 11 позволяет устанавливать эти этапы конвейера отдельно, драйвер экрана не может разрешить проблемы состояния конвейера до тех пор, пока состояние не будет завершено, что не превышает время рисования. Эта схема задерживает настройку состояния оборудования, что означает дополнительные издержки и меньшее число вызовов Draw на кадр.

Direct3D 12 решает эту схему, объединяя большую часть состояния конвейера с неизменяемыми объектами состояния конвейера (псос), которые завершаются после создания. После этого оборудование и драйверы могут немедленно преобразовать PSO в любую аппаратную собственную инструкцию и состояние, необходимые для выполнения работы GPU. Вы по-прежнему можете динамически изменять используемые PSO, но для этого оборудование должно скопировать минимальный объем предварительно вычисленного состояния непосредственно в регистры оборудования, а не считать состояние оборудования на лету. С помощью псос накладные расходы на вызываемые объекты значительно сокращаются, и для каждого кадра может выполняться множество вызовов Draw. Дополнительные сведения о псос см. [в разделе Управление состоянием графического конвейера в Direct3D 12](managing-graphics-pipeline-state-in-direct3d-12.md).

## <a name="command-lists-and-bundles"></a>Списки команд и пакеты

В Direct3D 11 все операции отправки выполняются через [непосредственный контекст](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render), представляющий один поток команд, которые переходят на GPU. Для обеспечения многопоточного масштабирования игры также имеют доступ к [отложенным контекстам](/windows/desktop/direct3d11/overviews-direct3d-11-render-multi-thread-render) . Отложенные контексты в Direct3D 11 не соответствуют идеальному оборудованию, поэтому в них можно выполнять сравнительно мало работы.

В Direct3D 12 появилась новая модель для отправки работ на основе списков команд, содержащих все сведения, необходимые для выполнения определенной рабочей нагрузки на GPU. Каждый новый список команд содержит такие сведения, как PSO для использования, необходимые ресурсы текстуры и буфера, а также аргументы для всех вызовов рисования. Поскольку каждый список команд является автономным и не наследует состояние, драйвер может предварительно вычислить все необходимые команды GPU в режиме готовности к началу и беспроблемному потоку. Единственным последовательным процессом является окончательное отправление списков команд GPU с помощью очереди команд.

Помимо списков команд, Direct3D 12 также вводит еще один уровень работы предварительное вычисление: *пакеты*. В отличие от списков команд, которые являются полностью автономными и обычно создаются, отправляются один раз и отбрасываются, пакеты предоставляют форму наследования состояния, допускающую повторное использование. Например, если в игре требуется нарисовать две модели символов с разными текстурами, одним из подходов является запись списка команд с двумя наборами идентичных вызовов рисования. Но другим подходом является «запись» одного пакета, который рисует одну модель символов, затем «воспроизводить» пакет дважды в списке команд, используя разные ресурсы. В последнем случае драйверу экрана требуется лишь один раз вычислить соответствующие инструкции, а создание списка команд фактически сводится к двум недорогихм вызовам функций.

Дополнительные сведения о списках команд и пакетов см. в разделе [Отправка рабочих данных в Direct3D 12](command-queues-and-command-lists.md).

## <a name="descriptor-heaps-and-tables"></a>Кучи дескрипторов и таблицы

Привязка ресурсов в Direct3D 11 очень абстрактна и удобна, но оставляет многие современные аппаратные возможности недостаточными. В Direct3D 11 игры создают объекты *представления* ресурсов, а затем привязывают эти представления к нескольким *слотам* на различных стадиях шейдера в конвейере. Шейдеры, в свою очередь, считывают данные из этих явных слотов привязки, которые фиксируются во время рисования. Эта модель означает, что каждый раз, когда игра будет рисовать с использованием различных ресурсов, она должна повторно привязать различные представления к разным слотам и снова вызвать Draw. Этот вариант также представляет издержки, которые можно устранить, полностью используя современные аппаратные возможности.

Direct3D 12 изменяет модель привязки в соответствии с современным оборудованием и значительно повышает производительность. Вместо использования автономных представлений ресурсов и явного сопоставления с слотами Direct3D 12 предоставляет кучу дескрипторов, в которой игры создают различные представления ресурсов. Эта схема предоставляет механизм GPU для непосредственного создания аппаратно-машинного описания ресурса (дескриптора) в оперативной памяти. Чтобы объявить, какие ресурсы должны использоваться конвейером для конкретного вызова Draw, игры указывают одну или несколько таблиц дескрипторов, представляющих поддиапазоны полной кучи дескрипторов. Так как куча дескрипторов уже заполнена соответствующими данными дескрипторов конкретного оборудования, изменение таблиц дескрипторов является чрезвычайно экономичной операцией.

В дополнение к повышению производительности, обеспечиваемой кучами и таблицами дескрипторов, Direct3D 12 также позволяет динамически индексировать ресурсы в шейдерах, что обеспечивает беспрецедентную гибкость и разблокировку новых методов отрисовки. В качестве примера современные обработчики отложенной отрисовки обычно задают в промежуточный g-buffer идентификатор материала или объекта некоторого типа. В Direct3D 11 эти механизмы должны быть осторожными, чтобы не использовать слишком много материалов, так как в одном g-буфере может значительно замедлиться выполнение окончательного прохода визуализации. С динамически индексируемыми ресурсами можно окончательно завершить сцену с тысячами материалов так же быстро, как и с десятью единицами.

Дополнительные сведения о кучах дескрипторов и таблицах см. в разделе [Привязка ресурсов](resource-binding.md)и [различия в модели привязки от Direct3D 11](binding-model.md).

## <a name="porting-from-direct3d-11"></a>Перенос с Direct3D 11

Перенос из Direct3D 11 является вовлеченным процессом, описанным в разделе [Перенос с Direct3D 11 на Direct3D 12](porting-from-direct3d-11-to-direct3d-12.md). Также ознакомьтесь с диапазоном вариантов [работы с Direct3D 11, Direct3D 10 и Direct2D](direct3d-12-interop.md).

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Основные сведения о Direct3D 12](directx-12-getting-started.md)
</dt> </dl>

 

 