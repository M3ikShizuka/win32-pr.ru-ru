---
title: UAV барьеры и барьеры состояния ресурсов в Директмл
description: Описываются преимущества барьеров и способы работы с ними в Директмл.
ms.custom: Windows 10 May 2019 Update
ms.localizationpriority: high
ms.topic: article
ms.date: 04/19/2019
ms.openlocfilehash: 9bfc93d4fb28cff5d7d196287c6573e3e494d1d5
ms.sourcegitcommit: cba7f424a292fd7f3a8518947b9466439b455419
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/23/2019
ms.locfileid: "104548975"
---
# <a name="uav-barriers-and-resource-state-barriers-in-directml"></a>UAV барьеры и барьеры состояния ресурсов в Директмл

## <a name="unordered-access-view-uav-barrier-requirements"></a>Требования к барьеру неупорядоченного представления доступа (UAV)

### <a name="uav-barriers-in-direct3d-12"></a>UAV барьеры в Direct3D 12

В Direct3D 12 смежные выходящие от вычислений шейдеры в одном и том же списке команд могут выполняться параллельно на GPU, если они не синхронизированы с промежуточным барьером неупорядоченного представления доступа (UAV). Это может повысить производительность, увеличивая использование оборудования GPU. Однако по умолчанию без UAV барьера параллельное выполнение двух смежных отправок может вызвать состояние гонки, если существует зависимость данных между двумя отправкой. или, если обе диспетчеризации выполняют UAV запись в одни и те же области памяти.

UAV барьер принудительно записывает все ранее отправленные диспетчеризации для завершения выполнение на GPU, прежде чем могут начаться последующие диспетчеризации. UAV барьеры используются для синхронизации отправок в одном списке команд во избежание состязания данных. UAV барьер можно выдать с помощью [метода **ID3D12GraphicsCommandList:: ресаурцебарриер**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-resourcebarrier).

### <a name="uav-barriers-in-directml"></a>UAV барьеры в Директмл

В Директмл операторы отправляются способом, похожим на способ отправки шейдеров вычислений в Direct3D 12. То есть смежные диспетчеризации операторов могут выполняться параллельно на GPU, если между ними не существует промежуточного барьера UAV. Типичная модель машинного обучения содержит зависимости данных между операторами. Например, выходные данные одного оператора поступают на вход другого. Поэтому важно использовать UAV барьеры для правильной синхронизации диспетчеризации.

Директмл гарантирует, что он будет только читать из входных десятков (и никогда не записывать в него). Также гарантируется, что он никогда не будет производить запись в выходной тензорные вне диапазона тензорные элемента [**DML_BUFFER_TENSOR_DESC:: тоталтенсорсизеинбитес**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) . Это означает, что зависимости данных между операторами в Директмл можно получить, изучив только входные и выходные привязки оператора.

Например, эти гарантии позволяют отправлять два оператора, связывающих один и тот же регион ресурса в качестве входных данных, без необходимости выдавать промежуточный барьер UAV. Это всегда является надежным, так как Директмл никогда не выполняет запись в десятки входных данных. В качестве другого примера можно всегда привязывать выходные десятки двух параллельных операторов к одному и тому же ресурсу Direct3D 12 (если их десятки не пересекаются), так как Директмл никогда не выполняет запись вне границ тензорные (как определено в тензорные **DML_BUFFER_TENSOR_DESC:: тоталтенсорсизеинбитес**).

Так как UAV барьеры — это форма синхронизации, необязательное использование UAV барьеров может негативно сказаться на производительности. Поэтому лучше использовать минимальное количество UAV барьеров, необходимых для правильной синхронизации расотправлений в списке команд.

### <a name="example-1"></a>Пример 1

В следующем примере выходные данные оператора свертки поступают в Релуную активацию, за которой следует нормализация пакета.

```console
    CONVOLUTION (conv1)
         |
  ACTIVATION_RELU (relu1)
         |
BATCH_NORMALIZATION (batch1)
```

Поскольку между всеми тремя операторами существует зависимость данных, вам потребуется UAV барьер между каждой последующей отправкой (см. [**идмлкоммандрекордер:: рекорддиспатч**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch)).

1. `dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`
2. `d3d12CommandList->ResourceBarrier(`**UAV барьер**`)`
3. `dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**relu1**`)`
4. `d3d12CommandList->ResourceBarrier(`**UAV барьер**`)`
5. `dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**batch1**`)`

### <a name="example-2"></a>Пример 2

```console
     MAX_POOLING (pool1)
        /    \
CONVOLUTION  CONVOLUTION
  (conv1)      (conv2)
        \    /
         JOIN (join1)
```

Здесь выходные данные пула передаются в два свертки, выходные данные которых затем объединяются с помощью оператора JOIN. Зависимость данных существует между `pool1` и `conv1` и, и `conv2` ;, а также между `conv1` и и `conv2` `join1` . Вот один из допустимых способов выполнения этого графа.

1. `dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**pool1**`)`
2. `d3d12CommandList->ResourceBarrier(`**UAV барьер**`)`
3. `dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv1**`)`
4. `dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**conv2**`)`
5. `d3d12CommandList->ResourceBarrier(`**UAV барьер**`)`
6. `dmlCommandRecorder->RecordDispatch(d3d12CommandList, `**join1**`)`

В этом случае `conv1` и `conv2` могут одновременно выполняться на GPU, что может повысить производительность.

## <a name="resource-barrier-state-requirements"></a>Требования к состоянию барьера ресурсов

Как вызывающий объект, вы обязаны убедиться, что все ресурсы Direct3D 12 находятся в правильном состоянии барьера ресурсов перед выполнением Директмл диспетчеризации на GPU. Директмл не выполняет никаких препятствий перехода от вашего имени.

Перед выполнением [**идмлкоммандрекордер:: рекорддиспатч**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) на GPU необходимо перевести все привязанные ресурсы в состояние **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** или в состояние, неявное повышение до **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, например **D3D12_RESOURCE_STATE_COMMON**. После завершения этого вызова ресурсы остаются в состоянии **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** . Дополнительные сведения см. [в разделе Привязка в директмл](dml-binding.md).

## <a name="see-also"></a>См. также раздел

* [Использование барьеров ресурсов для синхронизации состояний ресурсов в Direct3D 12](/windows/desktop/direct3d12/using-resource-barriers-to-synchronize-resource-states-in-direct3d-12)
* [Привязывание в DirectML](dml-binding.md)
