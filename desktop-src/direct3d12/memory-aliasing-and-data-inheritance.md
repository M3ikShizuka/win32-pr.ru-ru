---
title: Присвоение псевдонимов памяти и наследование данных
description: Размещенный и зарезервированный ресурс может быть псевдонимом физической памяти в куче. Размещенные ресурсы обеспечивают дополнительные сценарии наследования данных, чем зарезервированные ресурсы, если в куче установлен общий флаг или если ресурсы с псевдонимами имеют полностью определенные макеты памяти.
ms.assetid: 53C5804B-0F81-41AF-83D2-A96DCDFDC94A
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: cace5b5997e2a460406ae72abb247224886f3926
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "74104416"
---
# <a name="memory-aliasing-and-data-inheritance"></a>Присвоение псевдонимов памяти и наследование данных

Размещенный и зарезервированный ресурс может быть псевдонимом физической памяти в куче. Размещенные ресурсы обеспечивают дополнительные сценарии наследования данных, чем зарезервированные ресурсы, если в куче установлен общий флаг или если ресурсы с псевдонимами имеют полностью определенные макеты памяти.

-   [Псевдонимы](#memory-aliasing-and-data-inheritance)
-   [Наследование данных](#data-inheritance)
-   [Связанные темы](#related-topics)

## <a name="aliasing"></a>Псевдонимы

Для использования двух ресурсов, использующих общую физическую память, необходимо выдать барьер псевдонимов, даже если наследование данных нежелательно. Простые модели использования должны отметьте, по крайней мере, целевой ресурс, вовлеченный в такую операцию. Дополнительные сведения и модели расширенного использования см. в разделе [**креатеплацедресаурце**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createplacedresource) .

После доступа к ресурсу все ресурсы, которые совместно используют физическую память с этим ресурсом, становятся недействительными, пока не будет разрешено наследование данных. Чтение недействительных ресурсов приводит к неопределенному содержимому ресурса. Операции записи в недействительные ресурсы также приводят к неопределенному содержимому ресурса, если не выполняются два условия:

-   Ресурс не имеет \_ флаг ресурса D3D12 \_ \_ Разрешить \_ \_ целевой объект прорисовки или \_ флаг ресурса D3D12 \_ \_ Разрешить \_ \_ набор элементов глубины.
-   Запись является операцией копирования или очистки во всем подресурсе или плитке. Инициализация плиток доступна только для ресурсов с плиткой "64 КБ" \_ \_ неопределенные плитки \_ свиззле и 64 КБ \_ \_ стандартного \_ свиззле.

Перекрывающиеся проверки ограничены более низкими уровнями детализации, когда макеты предоставляют сведения о расположении шаг текселя данных и о том, когда ресурсы находятся в определенных состояниях барьера переходов. Но недействительность не может быть меньше детализации выравнивания ресурсов.

Степень детализации выравнивания буфера составляет 64 КБ, и приоритет имеет более высокий уровень детализации выравнивания. Это важно при рассмотрении 4-кратных текстур, так как несколько таких текстур могут находиться в области 64 КБ без перекрытия друг друга. Однако псевдонимы буфера для одного и того же региона 64 КБ нельзя использовать в сочетании с этими недопустимыми текстурами. Приложение не может надежно защитить доступ к буферу от пересекающихся текстур размером 4 КБ, так как GPU разрешается свиззле 4 КБ данных текстуры в области 64 КБ в неопределенном шаблоне.

элемент 64 КБ \_ \_ неопределенный элемент \_ свиззле, \_ свиззле "Стандартный плитка" в 64 КБ \_ \_ , а также \_ Основные макеты текстур строк сообщают приложению, что перекрывающиеся гранулярности выравнивания стали недействительными. Например, приложение может создать двумерный массив текстуры целевого объекта отрисовки с двумя срезами массива, одним уровнем MIP и \_ плиткой 64 КБ \_ undefine \_ свиззле Layout. Предположим, что приложение понимает, что каждый срез массива занимает 100 64 КБ. Приложение может отказаться от с помощью среза массива 0 и повторно использовать эту память для буфера ~ 6 МБ, текстуры ~ 6 МБ с неопределенным макетом и т. д. В дальнейшем Предположим, что приложение больше не требует первого элемента среза массива 1. После этого приложение может также располагаться в 64-буфере до тех пор, пока отрисовка еще не потребует первого элемента среза массива 1. Чтобы повторно использовать первую плитку с массивом текстур, приложению потребуется выполнить полную очистку или копирование.

Однако даже текстуры с определенными макетами по-прежнему имеют проблемные ситуации. Размеры ресурсов текстуры могут значительно отличаться от того, что может вычислить приложение, так как некоторые архитектуры адаптеров выделяют дополнительную память для текстур, чтобы уменьшить эффективность работы в ходе распространенных сценариев визуализации. Любые недействительности в этой дополнительной области памяти приводят к тому, что весь ресурс становится недействительным. Дополнительные сведения см. в разделе [**жетресаурцеаллокатионинфо**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-getresourceallocationinfo) .

## <a name="data-inheritance"></a>Наследование данных

Размещенные ресурсы обеспечивают наибольшее наследование данных для текстур, даже с неопределенными макетами памяти. Приложения могут имитировать возможности наследования данных, предоставляемые общими фиксируемыми ресурсами, путем обнаружения двух текстур с одинаковыми свойствами ресурса с одинаковым смещением в общей куче. Полное описание ресурса должно быть идентичным, включая оптимизированное значение и тип метода создания ресурсов (помещенные или зарезервированные). Но у обоих ресурсов могут быть разные состояния начального барьера перехода.

Зарезервированные ресурсы позволяют использовать наследование данных на плитке; Однако для состояний барьера переключения ресурсов обычно существуют ограничения.

Для наследования данных оба ресурса должны находиться в совместимом состоянии барьера переключения ресурсов:

-   Для буферов, одновременных текстур доступа и текстур перекрестных адаптеров состояние смены ресурсов не имеет значения, а все состояния являются "совместимыми".
-   Для зарезервированных текстур без предыдущих свойств или другого наследования данных на плитке до 64 КБ \_ \_ неопределенное значение \_ свиззле или 64 КБ \_ \_ \_ . состояние барьера перехода ресурсов, включая плитку, должно быть в общем состоянии.
-   Для всех остальных текстур, в которых описания ресурсов точно соответствуют друг другу, состояние барьера переключения ресурсов для каждой соответствующей пары подресурсов должно:
    -   Быть в общем состоянии.
    -   Должно быть равно, если в этих состояниях есть один и тот же флаг записи GPU.

Если GPU поддерживает стандартные свиззле, то буферы и стандартные текстуры свиззле могут быть псевдонимами для одной и той же памяти и наследовать данные между ними. Приложение может манипулировать пикселей текстуры из буферного представления, поскольку стандартный шаблон свиззле описывает, как пикселей текстуры размещается в памяти. Шаблон свиззле, видимый для ЦП, эквивалентен шаблону свиззле, видимому в буферах.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Подраспределение в кучах](suballocation-within-heaps.md)
</dt> </dl>

 

 




