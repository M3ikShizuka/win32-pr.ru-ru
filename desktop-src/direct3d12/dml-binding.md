---
title: Привязывание в DirectML
description: В Директмл привязка относится к присоединению ресурсов к конвейеру для использования GPU во время инициализации и выполнения операторов машинного обучения.
ms.custom: Windows 10 May 2019 Update
ms.localizationpriority: high
ms.topic: article
ms.date: 04/19/2019
ms.openlocfilehash: a04bf0bcc63fff810604e3db72fe507cc10040f5
ms.sourcegitcommit: db89157e3be911fdce2e543e99faa31fb2403bc8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/18/2020
ms.locfileid: "104548974"
---
# <a name="binding-in-directml"></a>Привязывание в DirectML

В Директмл *Привязка* относится к присоединению ресурсов к конвейеру для использования GPU во время инициализации и выполнения операторов машинного обучения. Эти ресурсы могут быть входными и выходными десятками, например, а также временными или постоянными ресурсами, которые требуются оператору.

В этом разделе рассматриваются концептуальные и процедурные сведения о привязке. Рекомендуется также полностью прочитать документацию по вызываемым API-интерфейсам, включая параметры и примечания.

## <a name="important-ideas-in-binding"></a>Важные идеи в привязке

Приведенный ниже список шагов содержит подробное описание задач, связанных с привязкой. Эти шаги необходимо выполнять каждый раз при выполнении диспетчеризации [, который можно](/windows/desktop/api/directml/nn-directml-idmldispatchable)отправить, &mdash; либо инициализатором оператора, либо скомпилированным оператором. Эти шаги представляют важные идеи, структуры и методы, задействованные в привязке Директмл.

В последующих разделах этого раздела более подробно описаны эти задачи привязки, а также приведены примеры фрагментов кода, взятых из примера кода [приложения с минимальным директмлм](dml-min-app.md) .

- Вызовите [**идмлдиспатчабле:: жетбиндингпропертиес**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) для диспетчеризации, чтобы определить, сколько дескрипторов требуется, а также каковы временные и постоянные потребности в ресурсах.
- Создайте кучу дескрипторов Direct3D 12 достаточно большой для дескрипторов и привяжите ее к конвейеру.
- Вызовите метод [**идмлдевице:: креатебиндингтабле**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) , чтобы создать таблицу привязки директмл для представления ресурсов, привязанных к конвейеру. Используйте структуру [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) для описания таблицы привязки, включая подмножество дескрипторов, на которые она указывает в куче.
- Создавайте временные и постоянные ресурсы в виде буферных ресурсов Direct3D 12, опишите их с помощью структур [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) и [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) и добавляйте их в таблицу привязки.
- Если диспетчеризации является скомпилированным оператором, создайте буфер элементов тензорные в качестве ресурса буфера Direct3D 12. Заполните или отправьте его, опишите с помощью структур **DML_BUFFER_BINDING** и **DML_BINDING_DESC** и добавьте его в таблицу привязки.
- Передайте таблицу привязки в качестве параметра при вызове [**идмлкоммандрекордер:: рекорддиспатч**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).

## <a name="retrieve-the-binding-properties-of-a-dispatchable"></a>Получение свойств привязки для диспетчеризации

Структура [**DML_BINDING_PROPERTIES**](/windows/desktop/api/directml/ns-directml-dml_binding_properties) описывает потребности привязки для диспетчеризации (инициализатор оператора или скомпилированного оператора). Эти свойства, связанные с привязкой, включают число дескрипторов, которые следует привязать к диспетчеризации, а также размер в байтах любого временного или постоянного ресурса, который ему необходим.

> [!NOTE]
> Даже для нескольких операторов одного типа не следует делать предположения о том, что они имеют одинаковые требования к привязке. Запросите свойства привязки для каждого создаваемого инициализатора и оператора.

Вызовите метод [**идмлдиспатчабле:: жетбиндингпропертиес**](/windows/desktop/api/directml/nf-directml-idmldispatchable-getbindingproperties) , чтобы получить **DML_BINDING_PROPERTIES**.

```cppwinrt
winrt::com_ptr<::IDMLCompiledOperator> dmlCompiledOperator;
// Code to create and compile a DirectML operator goes here.

DML_BINDING_PROPERTIES executeDmlBindingProperties{
    dmlCompiledOperator->GetBindingProperties()
};

winrt::com_ptr<::IDMLOperatorInitializer> dmlOperatorInitializer;
// Code to create a DirectML operator initializer goes here.

DML_BINDING_PROPERTIES initializeDmlBindingProperties{
    dmlOperatorInitializer->GetBindingProperties()
};

UINT descriptorCount = ...
```

`descriptorCount`Получаемое здесь значение определяет (минимальный) размер кучи дескрипторов и таблицы привязки, создаваемой в следующих двух шагах.

**DML_BINDING_PROPERTIES** также содержит `TemporaryResourceSize` элемент, который является минимальным размером в байтах временного ресурса, который должен быть привязан к таблице привязки для этого подготовленного объекта. Нулевое значение означает, что временный ресурс не требуется.

И `PersistentResourceSize` элемент, который является минимальным размером в байтах постоянного ресурса, который должен быть привязан к таблице привязки для этого подготовленного объекта. Нулевое значение означает, что постоянный ресурс не требуется. Постоянный ресурс, если он необходим, должен быть указан во время инициализации скомпилированного оператора (где он привязан как результат инициализатора оператора), а также во время выполнения. Дополнительные сведения об этом приведены далее в этом разделе. Только скомпилированные операторы имеют постоянные ресурсы — инициализаторы операторов всегда возвращают значение 0 для этого элемента.

При вызове **идмлдиспатчабле:: жетбиндингпропертиес** в инициализаторе оператора как до, так и после вызова [**Идмлоператоринитиализер:: Reset**](/windows/desktop/api/directml/nf-directml-idmloperatorinitializer-reset), два набора возвращаемых свойств привязки не гарантировано идентичны.

## <a name="describe-create-and-bind-a-descriptor-heap"></a>Описание, создание и привязка кучи дескрипторов

В терминах дескрипторов ответственность начинается и заканчивается в куче дескрипторов. Директмл сам по себе создает дескрипторы в пределах предоставляемой кучи и управляет ими.

Поэтому используйте структуру [**D3D12_DESCRIPTOR_HEAP_DESC**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_descriptor_heap_desc) , чтобы описать кучу, достаточно большую для числа дескрипторов, которые нужны для диспетчеризации. Затем создайте его с помощью [**ID3D12Device:: креатедескрипторхеап**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-createdescriptorheap). И, наконец, вызовите [**ID3D12GraphicsCommandList:: сетдескрипторхеапс**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-setdescriptorheaps) , чтобы привязать кучу дескрипторов к конвейеру.

```cppwinrt
winrt::com_ptr<::ID3D12DescriptorHeap> d3D12DescriptorHeap;

D3D12_DESCRIPTOR_HEAP_DESC descriptorHeapDescription{};
descriptorHeapDescription.Type = D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV;
descriptorHeapDescription.NumDescriptors = descriptorCount;
descriptorHeapDescription.Flags = D3D12_DESCRIPTOR_HEAP_FLAG_SHADER_VISIBLE;

winrt::check_hresult(
    d3D12Device->CreateDescriptorHeap(
        &descriptorHeapDescription,
        _uuidof(d3D12DescriptorHeap),
        d3D12DescriptorHeap.put_void()
    )
);

std::array<ID3D12DescriptorHeap*, 1> d3D12DescriptorHeaps{ d3D12DescriptorHeap.get() };
d3D12GraphicsCommandList->SetDescriptorHeaps(
    static_cast<UINT>(d3D12DescriptorHeaps.size()),
    d3D12DescriptorHeaps.data()
);
```

## <a name="describe-and-create-a-binding-table"></a>Описание и создание таблицы привязки

Таблица привязки Директмл представляет ресурсы, привязанные к конвейеру для использования для диспетчеризации. Эти ресурсы могут быть входными и выходными десятками (или другими параметрами) для оператора или могут быть различными постоянными и временными ресурсами, с которыми работает диспетчеризации.

Используйте структуру [**DML_BINDING_TABLE_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_table_desc) для описания таблицы привязки, включая диспетчеризации, для которой таблица привязки будет представлять привязки, и диапазон дескрипторов (из только что созданной кучи дескрипторов), на которые должна ссылаться таблица привязки (и в которую директмл может записывать дескрипторы). `descriptorCount`Значение (одно из свойств привязки, полученных на первом шаге) указывает, какой минимальный размер (в дескрипторах) таблицы привязки, необходимой для подготовленного объекта. Здесь мы используем это значение, чтобы указать максимальное число дескрипторов, которые Директмл разрешается записывать в нашу кучу, начиная с начала и от предоставленных дескрипторов ЦП и GPU.

Затем вызовите [**идмлдевице:: креатебиндингтабле**](/windows/desktop/api/directml/nf-directml-idmldevice-createbindingtable) , чтобы создать таблицу привязки директмл. В последующих шагах после создания дополнительных ресурсов для диспетчеризации мы добавим эти ресурсы в таблицу привязки.

Вместо передачи **DML_BINDING_TABLE_DESC** этому вызову можно передать `nullptr` , указав пустую таблицу привязки.

```cppwinrt
DML_BINDING_TABLE_DESC dmlBindingTableDesc{};
dmlBindingTableDesc.Dispatchable = dmlOperatorInitializer.get();
dmlBindingTableDesc.CPUDescriptorHandle = d3D12DescriptorHeap->GetCPUDescriptorHandleForHeapStart();
dmlBindingTableDesc.GPUDescriptorHandle = d3D12DescriptorHeap->GetGPUDescriptorHandleForHeapStart();
dmlBindingTableDesc.SizeInDescriptors = descriptorCount;

winrt::com_ptr<::IDMLBindingTable> dmlBindingTable;
winrt::check_hresult(
    dmlDevice->CreateBindingTable(
        &dmlBindingTableDesc,
        __uuidof(dmlBindingTable),
        dmlBindingTable.put_void()
    )
);
```

Порядок, в котором Директмл записывает дескрипторы в кучу, не определен, поэтому приложение должно не перезаписывать дескрипторы, инкапсулированные таблицей привязки. Предоставленные дескрипторы ЦП и GPU могут поступать из разных куч, однако ответственность за то, чтобы весь диапазон дескрипторов, на который ссылается дескриптор дескриптора ЦП, копируется в диапазон, на который ссылается дескриптор GPU, перед выполнением с помощью этой таблицы привязки. Куча дескрипторов, из которой предоставляются дескрипторы, должна иметь тип **D3D12_DESCRIPTOR_HEAP_TYPE_CBV_SRV_UAV**. Кроме того, куча, на которую ссылается, `GPUDescriptorHandle` должна представлять собой кучу дескрипторов, видимую в шейдере.

Можно сбросить таблицу привязки, чтобы удалить все добавленные в нее ресурсы, в то же время изменив любое свойство, заданное на начальном **DML_BINDING_TABLE_DESC** (чтобы создать оболочку для нового диапазона дескрипторов или повторно использовать его для другой диспетчеризации). Просто внесите изменения в структуру Description и вызовите [**идмлбиндингтабле:: Reset**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-reset).

```cppwinrt
dmlBindingTableDesc.Dispatchable = pIDMLCompiledOperator.get();

winrt::check_hresult(
    pIDMLBindingTable->Reset(
        &dmlBindingTableDesc
    )
);
```

## <a name="describe-and-bind-any-temporarypersistent-resources"></a>Опишите и привяжите временные или постоянные ресурсы

Структура **DML_BINDING_PROPERTIES** , заполняемая при [извлечении свойств привязки](#retrieve-the-binding-properties-of-a-dispatchable) для диспетчеризации, содержит размер в байтах всех временных и (или) постоянных ресурсов, которые должны быть подготовлены к отправке. Если один из этих размеров не равен нулю, создайте буферный ресурс Direct3D 12 и добавьте его в таблицу привязки.

В приведенном ниже примере кода мы создаем временный ресурс ( `temporaryResourceSize` Размер в байтах) для диспетчеризации. Мы описываем, как привязать ресурс, а затем добавим эту привязку к таблице привязки.

Поскольку мы привязываете один буферный ресурс, мы описываем привязку к структуре [**DML_BUFFER_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_binding) . В этой структуре мы указываем буферный ресурс Direct3D 12 (ресурс должен иметь измерение [**D3D12_RESOURCE_DIMENSION_BUFFER**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_dimension)), а также смещение и размер в буфере. Также можно описать привязку для массива буферов (а не для одного буфера), и для этой цели существует структура [**DML_BUFFER_ARRAY_BINDING**](/windows/desktop/api/directml/ns-directml-dml_buffer_array_binding) .

Для абстракции различий между буферной привязкой и привязкой массива буфера используется структура  [**DML_BINDING_DESC**](/windows/desktop/api/directml/ns-directml-dml_binding_desc) . Можно задать `Type` для члена **DML_BINDING_DESC** значение [**DML_BINDING_TYPE_BUFFER**](/windows/desktop/api/directml/ne-directml-dml_binding_type) или **DML_BINDING_TYPE_BUFFER_ARRAY**. Затем можно установить `Desc` элемент, указывающий либо на **DML_BUFFER_BINDING** , либо на **DML_BUFFER_ARRAY_BINDING** в зависимости от `Type` .

В этом примере мы работаем с временным ресурсом, поэтому мы добавим его в таблицу привязки с помощью вызова [**идмлбиндингтабле:: биндтемпорариресаурце**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindtemporaryresource).

```cppwinrt
D3D12_HEAP_PROPERTIES defaultHeapProperties{ CD3DX12_HEAP_PROPERTIES(D3D12_HEAP_TYPE_DEFAULT) };
winrt::com_ptr<::ID3D12Resource> temporaryBuffer;

D3D12_RESOURCE_DESC temporaryBufferDesc{ CD3DX12_RESOURCE_DESC::Buffer(temporaryResourceSize) };
winrt::check_hresult(
    d3D12Device->CreateCommittedResource(
        &defaultHeapProperties,
        D3D12_HEAP_FLAG_NONE,
        &temporaryBufferDesc,
        D3D12_RESOURCE_STATE_COMMON,
        nullptr,
        __uuidof(temporaryBuffer),
        temporaryBuffer.put_void()
    )
);

DML_BUFFER_BINDING bufferBinding{ temporaryBuffer.get(), 0, temporaryResourceSize };
DML_BINDING_DESC bindingDesc{ DML_BINDING_TYPE_BUFFER, &bufferBinding };
dmlBindingTable->BindTemporaryResource(&bindingDesc);
```

Временный ресурс (если он необходим) — это вспомогательная память, которая используется внутренним образом во время выполнения оператора, поэтому вам не нужно беспокоиться о его содержимом. Кроме того, не нужно размещайте его после вызова [**идмлкоммандрекордер:: рекорддиспатч**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) на GPU. Это означает, что приложение может освободить или перезаписать временный ресурс в между отправками скомпилированного оператора. Предоставленный диапазон буфера должен быть привязан как временный ресурс, чтобы его начальное смещение совпадало с [**DML_TEMPORARY_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md). Тип кучи, лежащий в основе буфера, должен быть **D3D12_HEAP_TYPE_DEFAULT**.

Если отправляемый отчет сообщает ненулевой размер для более длительного постоянного ресурса, то процедура немного отличается. Необходимо создать буфер и описать привязку, следуя той же схеме, что показано выше. Но добавьте его в таблицу привязки инициализатора оператора с помощью вызова [**идмлбиндингтабле:: биндаутпутс**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs), так как это задание инициализатора оператора для инициализации постоянного ресурса. Затем добавьте его в таблицу привязки скомпилированного оператора с помощью вызова [**идмлбиндингтабле:: биндперсистентресаурце**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindpersistentresource). См. пример кода [приложения с минимальным директмл](dml-min-app.md) , чтобы увидеть этот рабочий процесс в действии. Содержимое и время существования постоянного ресурса должны сохраняться при условии, что скомпилированный оператор выполняет. То есть если оператору требуется постоянный ресурс, приложение должно предоставить его во время инициализации, а затем указать его для всех последующих выполнений оператора, не изменяя его содержимое. Постоянный ресурс обычно используется Директмл для хранения таблиц подстановки или других долгосрочных данных, которые вычисляются во время инициализации оператора и повторно используются при последующих выполнениях этого оператора. Заданный буферный диапазон, который должен быть привязан как постоянный буфер, должно быть согласованным со смещением начала до [**DML_PERSISTENT_BUFFER_ALIGNMENT**](./direct3d-directml-constants.md). Тип кучи, лежащий в основе буфера, должен быть **D3D12_HEAP_TYPE_DEFAULT**.

## <a name="describe-and-bind-any-tensors"></a>Описание и привязка любых десятков

Если вы работаете с скомпилированным оператором (а не с инициализатором оператора), необходимо привязать входные и выходные ресурсы (для десятков и других параметров) к таблице привязки оператора. Количество привязок должно точно соответствовать числу входных данных оператора, включая дополнительные десятки. Некоторые десятки входных и выходных данных и другие параметры, которые принимает оператор, описаны в разделе этого оператора (например, [**DML_ELEMENT_WISE_IDENTITY_OPERATOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_element_wise_identity_operator_desc)).

Ресурс тензорные — это буфер, содержащий отдельные значения элементов тензорные. Вы передаете и считываете такой буфер в GPU с помощью регулярных методик Direct3D 12 ([Загрузка ресурсов](/windows/desktop/direct3d12/uploading-resources) и [считывание данных через буфер](/windows/desktop/direct3d12/readback-data-using-heaps)). См. пример кода [приложения с минимальными директмлми](dml-min-app.md) , чтобы увидеть эти приемы в действии.

Наконец, опишите входные и выходные привязки ресурсов с структурами **DML_BUFFER_BINDING** и **DML_BINDING_DESC** , а затем добавьте их в таблицу привязки скомпилированного оператора с вызовами [**Идмлбиндингтабле:: Биндинпутс**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) и [**идмлбиндингтабле:: биндаутпутс**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs). При вызове метода **идмлбиндингтабле:: BIND \** _ директмл записывает один или несколько дескрипторов в диапазон дескрипторов ЦП.

```cppwinrt
DML_BUFFER_BINDING inputBufferBinding{ inputBuffer.get(), 0, tensorBufferSize };
DML_BINDING_DESC inputBindingDesc{ DML_BINDING_TYPE_BUFFER, &inputBufferBinding };
dmlBindingTable->BindInputs(1, &inputBindingDesc);

DML_BUFFER_BINDING outputBufferBinding{ outputBuffer.get(), 0, tensorBufferSize };
DML_BINDING_DESC outputBindingDesc{ DML_BINDING_TYPE_BUFFER, &outputBufferBinding };
dmlBindingTable->BindOutputs(1, &outputBindingDesc);
```

Одним из этапов создания оператора директмл (см. [_ *идмлдевице:: креатеоператор* *](/windows/desktop/api/directml/nf-directml-idmldevice-createoperator)) является объявление одной или нескольких структур [**DML_BUFFER_TENSOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) для описания буферов данных тензорные, которые оператор принимает и возвращает. А также тип и размер буфера тензорные можно дополнительно указать флаг [**DML_TENSOR_FLAG_OWNED_BY_DML**](/windows/desktop/api/directml/ne-directml-dml_tensor_flags) .

**DML_TENSOR_FLAG_OWNED_BY_DML** указывает, что данные тензорные должны принадлежать и управляются директмл. Директмл создает копию данных тензорные во время инициализации оператора и сохраняет их в постоянном ресурсе. Это позволяет Директмл выполнять переформатирование данных тензорные в другие, более эффективные формы. Установка этого флага может повысить производительность, но обычно она полезна только для десятков, данные которых не меняются в течение времени существования оператора (например, весовых десятков). И флаг можно использовать только для входных десятков. Если флаг установлен для конкретного описания тензорные, то соответствующий тензорные должен быть привязан к таблице привязки во время инициализации оператора, а не во время выполнения (что приведет к ошибке). Это отличается от поведения по умолчанию (поведение без флага DML_TENSOR_FLAG_OWNED_BY_DML), где тензорные должен быть привязан во время выполнения, а не во время инициализации. При вводе данных тензорные в инициализатор оператора можно привязать отправку, а не кучу по УМОЛЧАНИю, так как Директмл создает копию данных. Во всех остальных случаях все ресурсы, привязанные к Директмл, должны быть ресурсами кучи по УМОЛЧАНИю.

Дополнительные сведения см. в разделе [**идмлбиндингтабле:: биндинпутс**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindinputs) and [**Идмлбиндингтабле:: биндаутпутс**](/windows/desktop/api/directml/nf-directml-idmlbindingtable-bindoutputs).

## <a name="execute-the-dispatchable"></a>Выполнение диспетчеризации

Передайте таблицу привязки в качестве параметра при вызове [**идмлкоммандрекордер:: рекорддиспатч**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch).

При использовании таблицы привязки во время вызова **идмлкоммандрекордер:: рекорддиспатч** директмл привязывает соответствующие дескрипторы GPU к конвейеру. Дескрипторы ЦП и GPU не обязательно должны указывать на одни и те же записи в куче дескрипторов, однако это позволяет приложению гарантировать, что весь диапазон дескрипторов, на который ссылается дескриптор дескриптора ЦП, копируется в диапазон, на который ссылается дескриптор GPU, перед выполнением с помощью этой таблицы привязки.

```cppwinrt
winrt::com_ptr<::ID3D12GraphicsCommandList> d3D12GraphicsCommandList;
// Code to create a Direct3D 12 command list goes here.

winrt::com_ptr<::IDMLCommandRecorder> dmlCommandRecorder;
// Code to create a DirectML command recorder goes here.

dmlCommandRecorder->RecordDispatch(
    d3D12GraphicsCommandList.get(),
    dmlOperatorInitializer.get(),
    dmlBindingTable.get()
);
```

Наконец, закройте список команд Direct3D 12 и отправьте его для выполнения так же, как любой другой список команд.

Перед выполнением **рекорддиспатч** на GPU необходимо перевести все привязанные ресурсы в состояние **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** или в состояние неявного продвижения на **D3D12_RESOURCE_STATE_UNORDERED_ACCESS**, например **D3D12_RESOURCE_STATE_COMMON**. После завершения этого вызова ресурсы остаются в состоянии **D3D12_RESOURCE_STATE_UNORDERED_ACCESS** . Единственным исключением из этого является привязка куч для отправки, связанная при выполнении инициализатора операторов, а для одного или нескольких десятков установлен флаг **DML_TENSOR_FLAG_OWNED_BY_DML** . В этом случае любые кучи передачи, привязанные для входных данных, должны находиться в состоянии **D3D12_RESOURCE_STATE_GENERIC_READ** и остаться в этом состоянии, как это требуется для всех куч передачи. Если **DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE** не был задан при компиляции оператора, то все привязки должны быть установлены в таблице привязки перед вызовом **рекорддиспатч** , в противном случае поведение не определено. В противном случае, если оператор поддерживает [позднее связывание](#optionally-specify-late-bound-operator-bindings), привязка ресурсов может быть отложена до тех пор, пока список команд Direct3D 12 не будет отправлен в очередь команд для выполнения.

**Рекорддиспатч** действует логически так же, как вызов [**ID3D12GraphicsCommandList::D Patch**](/windows/desktop/api/d3d12/nf-d3d12-id3d12graphicscommandlist-dispatch). Таким образом, барьеры неупорядоченного представления доступа (UAV) необходимы для обеспечения правильного упорядочения при наличии зависимостей данных между диспетчеризации. Этот метод не вставляет UAV барьеры на входные и выходные ресурсы. Приложение должно обеспечить выполнение правильных UAV барьеров на входных данных, если их содержимое зависит от вышестоящей диспетчеризации, а также от всех выходов, если имеются нисходящие диспетчеризации, зависящие от этих выходов.

## <a name="lifetime-and-synchronization-of-descriptors-and-binding-table"></a>Время существования и синхронизация дескрипторов и таблицы привязки

Хорошей моделью привязки в Директмл является то, что в фоновом режиме сама таблица привязки Директмл создает дескрипторы неупорядоченного представления доступа (UAV) в пределах предоставляемой кучи дескрипторов и управляет ими. Таким образом, все обычные правила Direct3D 12 применяются к синхронизации доступа к этой куче и ее дескрипторам. Это приложение отвечает за правильную синхронизацию между работой ЦП и GPU, использующей таблицу привязки.

Таблица привязки не может перезаписать дескриптор во время использования дескриптора (например, в предыдущем кадре). Таким образом, если вы хотите повторно использовать уже ограниченную кучу дескрипторов (например, вызвав BIND * снова в связанной таблице привязки или перезаписав кучу дескрипторов вручную), следует подождать, пока диспетчер, использующий кучу дескрипторов, завершит выполнение на GPU. В таблице привязки не поддерживается строгая ссылка на кучу дескрипторов, в которую он записывается, поэтому вы не должны выпустить резервную кучу дескрипторов, пока вся работа, использующая эту таблицу привязки, не завершит выполнение на GPU.

С другой стороны, в то время как в таблице привязки указывается и управляется куча дескрипторов, таблица сама по себе не *содержит* такой памяти. Таким образом, вы можете освободить или сбросить таблицу привязки в любое время после вызова [**идмлкоммандрекордер:: рекорддиспатч**](/windows/desktop/api/directml/nf-directml-idmlcommandrecorder-recorddispatch) (вам не нужно ждать завершения этого вызова на GPU, если базовые дескрипторы остаются действительными).

В таблице привязки не сохраняются строгие ссылки на ресурсы, привязанные к ним &mdash; . приложение должно гарантировать, что ресурсы не будут удалены, пока они все еще используются графическим процессором. Кроме того, таблица привязки не является потокобезопасной, так как &mdash; приложение не должно вызывать методы в таблице привязки одновременно из разных потоков без синхронизации.

И учтите, что в любом случае повторная привязка необходима только при изменении привязанных ресурсов. Если не требуется изменять привязанные ресурсы, то можно выполнить привязку один раз при запуске и передать одну и ту же таблицу привязки каждый раз при вызове **рекорддиспатч**.

Для вывода рабочих нагрузок машинного обучения и подготовки к просмотру достаточно убедиться, что таблицы привязки каждого кадра указывают на диапазоны кучи дескрипторов, которые еще не используются в GPU.

## <a name="optionally-specify-late-bound-operator-bindings"></a>При необходимости укажите привязки операторов с поздним связыванием

Если вы работаете с скомпилированным оператором (а не с инициализатором оператора), то у вас есть возможность указать позднее связывание для оператора. Без позднего связывания перед записью оператора в список команд необходимо установить все привязки в таблице привязки. С помощью позднего связывания можно задать (или изменить) привязки для операторов, которые уже записаны в список команд до отправки в очередь команд.

Чтобы указать позднее связывание, вызовите [**идмлдевице:: компилеоператор**](/windows/win32/api/directml/nf-directml-idmldevice-compileoperator) с `flags` аргументом [**DML_EXECUTION_FLAG_DESCRIPTORS_VOLATILE**](/windows/desktop/api/directml/ne-directml-dml_execution_flags).