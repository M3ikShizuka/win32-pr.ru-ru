---
title: Использование STRIDE для выражения заполнения и макета памяти
description: Директмлные десятки описываются свойствами, которые называются *размерами* и *шагами* тензорные.
ms.custom: Windows 10 May 2019 Update
ms.localizationpriority: high
ms.topic: article
ms.date: 04/19/2019
ms.openlocfilehash: b944b1a2600febe27f209bffcc0e355c6a9fc7db
ms.sourcegitcommit: cba7f424a292fd7f3a8518947b9466439b455419
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/23/2019
ms.locfileid: "104548968"
---
# <a name="using-strides-to-express-padding-and-memory-layout"></a>Использование STRIDE для выражения заполнения и макета памяти

Директмлные десятки, которые поддерживаются &mdash; буферами Direct3D 12 &mdash; , описываются свойствами, которые называются *размерами* и *шагами* тензорные. *Размеры* тензорные описывают логические измерения тензорные. Например, 2D-тензорные может иметь высоту 2 и ширину 3. Логически тензорные имеет 6 различных элементов, хотя размеры не указывают, как эти элементы хранятся в памяти. В *шагах* тензорные описывается структура физической памяти элементов тензорные.

## <a name="two-dimensional-2d-arrays"></a>Двухмерные массивы (2D)

Рассмотрим двумерный тензорные с высотой 2 и шириной 3. данные состоят из текстовых символов. В C/C++ это может быть выражено с помощью многомерного массива.

```cpp
constexpr int rows = 2;
constexpr int columns = 3;
char tensor[rows][columns];
tensor[0][0] = 'A';
tensor[0][1] = 'B';
tensor[0][2] = 'C';
tensor[1][0] = 'D';
tensor[1][1] = 'E';
tensor[1][2] = 'F';
```

Логическое представление приведенной выше тензорные визуализации показано ниже.

```console
A B C
D E F
```

В C/C++ многомерный массив хранится в основном порядке строк. Иными словами, последовательные элементы в измерении Width хранятся непрерывно в линейной области памяти.

Offset:|0|1|2|3|4|5
-|-|-|-|-|-|-
Значение:|Объект|B|C|D|E|F

*Шаг* измерения — это число пропускаемых элементов для доступа к следующему элементу в этом измерении. Шаг представляет макет тензорные в памяти. При использовании строкового порядка шаг измерения «ширина» всегда равен 1, так как соседние элементы в измерении хранятся непрерывно. Шаг измерения высоты зависит от размера измерения Width. в приведенном выше примере расстояние между последовательными элементами в измерении высоты (например, A до D) равно ширине тензорные (то есть 3 в этом примере).

Чтобы проиллюстрировать другой макет, рассмотрим основной порядок столбцов. Иными словами, последовательные элементы вдоль измерения высоты хранятся непрерывно в линейной области памяти. В этом случае шаг с высоты всегда равен 1, а шаг с шириной — 2 (размер измерения высоты).

Offset:|0|1|2|3|4|5
-|-|-|-|-|-|-
Значение:|A|D|B|E|C|F

## <a name="higher-dimensions"></a>Более высокие размеры

Когда речь идет о более чем двух измерениях, неудобно ссылаться на макет как на строку, так и на основной столбец. Итак, в оставшейся части этого раздела используются термины и метки, такие как.

- 2D: высота "HW" &mdash; — это измерение высшего порядка (Главная строка).
- 2D: «чем» &mdash; Ширина — это измерение высшего порядка (основной столбец).
- 3D: глубина "ДХВ" &mdash; — это измерение высшего порядка, за которым следует высота, а затем ширина.
- 3D: ширина "ВХД" &mdash; — это измерение высшего порядка, за которым следует высота, а затем глубина.
- 4D: "НЧВ" &mdash; число образов (размер пакета), число каналов, высота и ширина.

Как правило, *упакованный* шаг измерения равен произведению размеров измерений нижнего порядка. Например, при использовании макета "ДХВ" D-STRIDE равен H * W; H-шаг равен W; и W-STRIDE равен 1. Считается, что шаг *упакован* , если общий физический размер тензорные равен общему логическому размеру тензорные. Иными словами, не существует дополнительного пространства и перекрывающихся элементов.

Добавим 2D-пример к трем измерениям, чтобы у нас был тензорные с глубиной 2, высота 2 и ширина 3 (для всего 12 логических элементов).

```console
A B C
D E F

G H I
J K L
```

При использовании макета "ДХВ" Этот тензорные сохраняется следующим образом.

Offset:|0|1|2|3|4|5|6|7|8|9|10|11|
-|-|-|-|-|-|-|-|-|-|-|-|-|
Значение:|Объект|B|C|D|E|F|G|H|I|J|K|L|

- D-STRIDE = высота (2) * Ширина (3) = 6 (например, расстояние между "A" и "G").
- H-STRIDE = ширина (3) = 3 (например, расстояние между "A" и "d").
- W-STRIDE = 1 (например, расстояние между "A" и "B").

Скалярное произведение индексов и координат элемента, а также шаг предоставляет смещение для этого элемента в буфере. Например, смещение элемента H (d = 1, H = 0, w = 1) равно 7.

{1, 0, 1} ⋅ {6, 3, 1} = 1 * 6 + 0 * 3 + 1 * 1 = 7

## <a name="packed-tensors"></a>Упакованные десятки

В приведенных выше примерах проиллюстрированы *Упакованные* десятки. Тензорные называется *упаковкой* , если логический размер тензорные (в элементах) равен физическому размеру буфера (в элементах), а каждый элемент имеет уникальный адрес или смещение. Например, 2x2x3 тензорные упаковывается, если буфер состоит из 12 элементов, а ни одна пара элементов не имеет одинакового смещения в буфере. Упакованные десятки являются наиболее распространенным вариантом. Однако шаг позволяет использовать более сложные макеты памяти.

## <a name="broadcasting-with-strides"></a>Вещание с шагом

Если размер буфера тензорные (в элементах) меньше, чем произведение его логических измерений, то следует перекрывать элементы. Обычно такая ситуация называется *вещание*; , где элементы измерения являются дубликатами другого измерения. Например, давайте вернемся к примеру 2D. Предположим, что нам нужен тензорные, который логически 2, но вторая строка идентична первой строке. Вот как это выглядит.

```console
A B C
A B C
```

Это можно сохранить в виде упакованного тензорные оборудования или строки. Но более компактное хранилище будет содержать только 3 элемента (A, B и C) и использовать шаг высоты 0 вместо 3. В этом случае физический размер тензорные — 3 элемента, а логический размер — 6 элементов.

Как правило, если шаг измерения равен 0, то все элементы в измерениях нижнего порядка повторяются в широковещательном измерении. Например, если тензорные имеет значение НЧВ и C-STRIDE имеет значение 0, то каждый канал имеет одинаковые значения в H и W.

## <a name="padding-with-strides"></a>Заполнение с шагом

Тензорные считается *заполненным* , если его физический размер превышает минимальный размер, необходимый для размещения его элементов. Если нет широковещательных или перекрывающихся элементов, минимальный размер тензорные (в элементах) — это просто произведение его измерений. Для `DMLCalcBufferTensorSize` вычисления *минимального* размера буфера для директмлных десятков можно использовать вспомогательную функцию (см. [вспомогательные функции директмл](dml-helper-functions.md) для получения списка этой функции).

Предположим, что буфер содержит следующие значения (элементы "x" обозначают значения заполнения).

0|1|2|3|4|5|6|7|8|9|
-|-|-|-|-|-|-|-|-|-|
Объект|B|C|x|x|D|E|F|x|x

Заполненный тензорные можно описать с помощью параметра height-STRIDE 5 вместо 3. Вместо пошагового выполнения 3 элементов для перехода к следующей строке шаг состоит из 5 элементов (3 *реальных* элемента плюс 2 элемента заполнения). Заполнение является общим в компьютерных графиках, например, чтобы гарантировать, что изображение имеет два выравнивания.

```console
A B C
D E F
```

## <a name="directml-buffer-tensor-descriptions"></a>Описания тензорные буфера Директмл

Директмл может работать с различными физическими макетами тензорные, так как [структура **DML_BUFFER_TENSOR_DESC**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) имеет `Sizes` и элементы, и `Strides` . Некоторые реализации операторов могут быть более эффективны с конкретным макетом, поэтому нередко меняется способ хранения тензорные данных для повышения производительности.

Большинству операторов Директмл требуются десятки или 5D, а порядок значений размера и шага фиксирован. Исправив порядок размеров и значений STRIDE в описании тензорные, Директмл может вычислять различные физические макеты.

**4D**
- [**DML_BUFFER_TENSOR_DESC:: sizes**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) = {N-size, C-size, H-size, W-size}
- [**DML_BUFFER_TENSOR_DESC:: STRIDE**](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc) = {N-STRIDE, C-STRIDE, H-STRIDE, W-STRIDE}

**d**
- **DML_BUFFER_TENSOR_DESC:: sizes** = {N-size, C — размер, D-размер, H-размер, W-size}
- **DML_BUFFER_TENSOR_DESC:: STRIDE** = {N-STRIDE, C-STRIDE, D-STRIDE, H-STRIDE, W-STRIDE}

Если оператору Директмл требуется объект 4D или a 5D тензорные, но фактические данные имеют меньший ранг (например, 2D), то ведущие измерения должны быть заполнены единицами. Например, "HW" тензорные задается с помощью **DML_BUFFER_TENSOR_DESC:: sizes** = {1, 1, H, W}.

Если данные тензорные хранятся в НЧВ/НКДХВ, то нет необходимости задавать **DML_BUFFER_TENSOR_DESC:: STRIDE**, если только не требуется вещание или заполнение. Можно задать для поля STRIDE значение `nullptr` . Однако если данные тензорные хранятся в другом макете, например НХВК, то для выражения преобразования из НЧВ в этот макет необходимо выполнить шаг.

Для простого примера рассмотрим описание 2D-тензорные с высотой 3 и шириной 5.

**Упакованный НЧВ (неявный шаг)**
- **DML_BUFFER_TENSOR_DESC:: sizes** = {1, 1, 3, 5}
- **DML_BUFFER_TENSOR_DESC:: STRIDE** = `nullptr`

**Упакованный НЧВ (явный шаг)**
- N-STRIDE = C-size * H-Размер * W-size = 1 * 3 * 5 = 15
- C-STRIDE = H-size * W-size = 3 * 5 = 15
- H-STRIDE = W-size = 5
- W-STRIDE = 1
- **DML_BUFFER_TENSOR_DESC:: sizes** = {1, 1, 3, 5}
- **DML_BUFFER_TENSOR_DESC:: STRIDE** = {15, 15, 5, 1}

**Упакованная НХВК**
- N-STRIDE = H-Размер * W-size * C-size = 3 * 5 * 1 = 15
- H-STRIDE = W-size * C-size = 5 * 1 = 5
- W-STRIDE = C-size = 1
- C-STRIDE = 1
- **DML_BUFFER_TENSOR_DESC:: sizes** = {1, 1, 3, 5}
- **DML_BUFFER_TENSOR_DESC:: STRIDE** = {15, 1, 5, 1}

## <a name="see-also"></a>См. также раздел

* [Вспомогательные функции Директмл](dml-helper-functions.md)
* [Структура DML_BUFFER_TENSOR_DESC](/windows/desktop/api/directml/ns-directml-dml_buffer_tensor_desc)
