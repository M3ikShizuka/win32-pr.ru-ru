---
title: Местонахождение
description: Объект считается резидентным, когда он доступен для GPU.
ms.assetid: 956F80D7-EEC8-4D88-B251-EE325614F31E
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6b842ce5b3e89c3877f50036e747a90f14104bce
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104549002"
---
# <a name="residency"></a>Местонахождение

Объект считается *резидентным* , когда он доступен для GPU.

-   [Бюджет местонахождение](#residency-budget)
-   [Ресурсы кучи](#heap-resources)
-   [Приоритеты местонахождение](#residency-priorities)
    -   [Алгоритм приоритета по умолчанию](#default-priority-algorithm)
-   [Программирование управления местонахождение](#programming-residency-management)
-   [Связанные темы](#related-topics)

## <a name="residency-budget"></a>Бюджет местонахождение

GPU пока не поддерживает сбои страниц, поэтому приложения должны зафиксировать данные в физической памяти, пока GPU сможет получить к ним доступ. Этот процесс известен как «делая что-то резидентным» и должен выполняться как для физической системной памяти, так и для физической отдельной видеопамяти. В D3D12 большинство объектов API инкапсулируют некоторый объем доступной памяти GPU. Эта память, доступная GPU, становится резидентной во время создания объекта API и удалена при уничтожении объекта API.

Объем физической памяти, доступной для процесса, называется бюджетом видеопамяти. Бюджет может заметно изменяться в фоновом режиме и выходом из спящего режима; и при переключении пользователя на другое приложение оно будет заметно меняться. Приложение может получать уведомления при изменении бюджета и опрашивать как текущий, так и потребляемый в данный момент объем памяти. Если приложение не остается в пределах своего бюджета, процесс будет периодически заморожен, чтобы другие приложения выполнялись и (или) API-интерфейсы создания возвращали ошибку. Интерфейс [**IDXGIAdapter3**](/windows/desktop/api/dxgi1_4/nn-dxgi1_4-idxgiadapter3) предоставляет методы, относящиеся к этой функции, в частности [**куеривидеомеморинфо**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-queryvideomemoryinfo) и [**регистервидеомеморибуджетчанженотификатионевент**](/windows/desktop/api/dxgi1_4/nf-dxgi1_4-idxgiadapter3-registervideomemorybudgetchangenotificationevent).

Приложениям рекомендуется использовать резервирование для обозначения объема памяти, который они не могут проделать. В идеале для такого резервирования подходит значение "низкая" графика, заданное пользователем, или что-то еще меньше. Настройка резервирования никогда не придает приложению более высокий бюджет по сравнению с обычным получением. Вместо этого сведения о резервировании помогают ядру ОС быстро уменьшить влияние больших случаев нехватки памяти. Даже резервирование не гарантирует доступность приложения, если приложение не является приложением переднего плана.

## <a name="heap-resources"></a>Ресурсы кучи

Несмотря на то, что многие объекты API инкапсулируют память, доступную для GPU, кучи, & ресурсы, должны быть наиболее значимыми способами потребления и управления физической памятью приложениями. Куча — это единица самого низкого уровня для управления физической памятью, поэтому лучше иметь некоторые знания с их свойствами местонахождение.

-   Кучи нельзя сделать частично резидентным, но в зарезервированных ресурсах Существуют обходные пути.
-   Кучи должны быть включены в бюджет как часть определенного пула. Адаптеры памяти имеют один пул, тогда как дискретные адаптеры имеют два пула. Несмотря на то, что ядро может переносить некоторые кучи на дискретные адаптеры из видеопамяти в системную память, это делает это только крайне крайнее самое последнее средство. Приложения не должны полагаться на поведение ядра сверх бюджета и должны сосредоточиться на хорошем управлении бюджетом.
-   Кучи могут быть исключены из местонахождение, что позволяет разносить их содержимое на диск. Но уничтожение куч является более надежным методом для высвобождения местонахождение на всех архитектурах адаптеров. В адаптерах, где поле *семаксгпувиртуаладдрессбитсперпроцесс* [**функции D3D12 с \_ \_ \_ \_ виртуальным \_ адресом \_ GPU**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support) приближается к размеру бюджета, [**исключение**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device-evict) не гарантирует надежное освобождение местонахождение.
-   Создание кучи может выполняться очень часто; но он оптимизирован для фоновой обработки потока. Рекомендуется создавать кучи в фоновых потоках, чтобы избежать сбоев потока отрисовки. В D3D12 несколько потоков могут безопасно вызывать вызовы Create подпрограмм параллельно.

D3D12 предоставляет большую гибкость и ортогональность в своей модели ресурсов, чтобы обеспечить дополнительные возможности для приложений. В D3D12 есть три высокоуровневые типа ресурсов: зафиксированные, размещенные и зарезервированные.

-   Зафиксированные ресурсы одновременно создают как ресурс, так и кучу. Куча является неявной и недоступен напрямую. Размер кучи подходит для размещения всего ресурса в куче.
-   Размещенные ресурсы позволяют размещать ресурс с ненулевым смещением в куче. Смещения обычно должны быть выравны 64 КБ; но некоторые исключения существуют в обоих направлениях. Для ресурсов MSAA требуется выравнивание в 4-ем смещении и выравнивание по горизонтали для мелких текстур. Размещенные ресурсы не могут быть перемещены или повторно сопоставлены с другой кучей напрямую; но они обеспечивают простое перемещение данных ресурсов между кучами. После создания нового размещенного ресурса в другой куче и копирования данных ресурсов для нового расположения данных ресурса потребуется использовать новые дескрипторы ресурсов.
-   Зарезервированные ресурсы доступны только в том случае, если адаптер поддерживает мозаичный уровень ресурсов 1 или более. Если они доступны, они предлагают наиболее широкие доступные методы управления местонахождение. но не все адаптеры сейчас поддерживают их. Они позволяют повторно сопоставить ресурс, не требуя повторного создания дескрипторов ресурсов, частичного MIP уровня местонахождение, сценариев разреженных текстур и т. д. Не все типы ресурсов поддерживаются даже в том случае, если доступны зарезервированные ресурсы, поэтому полностью общий местонахождение Manager на основе страниц пока неосуществим.

## <a name="residency-priorities"></a>Приоритеты местонахождение

Обновление Windows 10 Creators Update позволяет разработчикам влиять на то, какие кучи и ресурсы будут предпочтительнее оставаться резидентными, когда для нехватки памяти требуется понизить уровень некоторых его ресурсов. Это помогает разработчикам создавать более эффективные приложения, используя знания о том, что среда выполнения не может вычислять данные об использовании API. Ожидалось, что разработчики станут более удобными и способны определять приоритеты при переходе с использования зафиксированных ресурсов на зарезервированным и мозаичные ресурсы.

Применение этих приоритетов должно быть проще, чем управление двумя динамическими бюджетами памяти, их понижение и продвижение ресурсов вручную беттвин их, так как приложения уже могут это сделать. Таким образом, структура API приоритета местонахождение размещается с учетом разумных приоритетов по умолчанию, назначаемых каждой куче или ресурсу по мере его создания. Дополнительные сведения см. в разделе [**ID3D12Device1:: сетресиденциприорити**](/windows/desktop/api/d3d12/nf-d3d12-id3d12device1-setresidencypriority) и перечисление [**\_ \_ приоритетов D3D12 местонахождение**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_residency_priority) .

При использовании приоритетов разработчики должны быть:

-   Повысьте приоритет нескольких исключительных куч, чтобы лучше уменьшить влияние на производительность этих куч на более ранних или более часто, чем понизить их естественные шаблоны доступа. Этот подход предполагается использовать в приложениях, переданных из графических интерфейсов API, таких как Direct3D 11 или OpenGL, которые значительно отличаются от модели управления ресурсами, чем Direct3D 12.
-   Переопределяйте почти все приоритеты кучи с помощью собственной схемы сегментации приложения, фиксированной на основе знаний частоты доступа или динамической работы программиста. Фиксированная схема проще в управлении, чем на динамическую, но может быть менее эффективной и требует от программиста вмешательство по мере изменения использования шаблонов в процессе разработки. Этот подход предполагается использовать в приложениях, созданных с помощью управления ресурсами в стиле Direct3D 12, например тех, которые используют библиотеку местонахождение (особенно динамические схемы).

### <a name="default-priority-algorithm"></a>Алгоритм приоритета по умолчанию

Приложение не может задавать полезные приоритеты для любой кучи, которой он пытается управлять, без предварительного ундерстанинг алгоритма приоритета по умолчанию. Это обусловлено тем, что значение назначения определенного приоритета для кучи является производным от его относительного приоритета для других куч с приоритетом, которые конкурируют за ту же память.

Стратегия, выбранная для создания приоритетов по умолчанию, состоит в том, чтобы классифицировать кучи в два сегмента, отпользуясь (с более высоким приоритетом) кучами, которые предположительно часто записываются GPU на кучи, которые не являются.

Контейнер с высоким приоритетом содержит кучи и ресурсы, созданные с помощью флагов, которые определяют их как целевые объекты отрисовки, буферы трафаретов глубины или неупорядоченные представления доступа (Уавс). Им присваиваются значения приоритета в диапазоне, начиная с **D3D12 \_ местонахождение \_ Priority \_**. для дальнейшего определения приоритета между этими кучами и ресурсами наименьшие 16 бит приоритета устанавливаются в размер кучи или ресурса, деленный на 10 МБ (с насыщением до 0xFFFF для очень больших куч). Это дополнительное определение приоритета увеличивает кучу и ресурсы.

Контейнер с низким приоритетом содержит все другие кучи и ресурсы, которым назначено значение приоритета **D3D12 \_ местонахождение \_ Priority \_ Обычная**. Дальнейшее определение приоритетов между этими кучами и ресурсами не выполняется.

## <a name="programming-residency-management"></a>Программирование управления местонахождение

Простые приложения могут получить, просто создав выделенные ресурсы, пока не наблюдаются сбои памяти. При сбое приложение может уничтожить другие зафиксированные ресурсы или объекты API, чтобы обеспечить успешное создание ресурсов. Однако даже простые приложения настоятельно рекомендуют отслеживать отрицательные изменения бюджета и уничтожать неиспользуемые объекты API примерно один раз в кадре.

Сложность структуры управления местонахождение будет возобновлена при попытке оптимизировать архитектуру адаптеров или внедрять приоритеты местонахождение. Дискретными бюджетирование и управление двумя пулами дискретной памяти будут более сложными, чем управление только одним, и назначение фиксированных приоритетов в масштабе может стать недоступным при развитии использования шаблонов. Избыточное перенаправление текстур в системную память увеличивает сложность, так как неверный ресурс в системной памяти может значительно повлиять на частоту кадров. И не существует простых функциональных возможностей, позволяющих определить ресурсы, которые могут либо выиграть от более высокой пропускной способности GPU, либо допускать более низкую пропускную способность GPU.

Даже более сложные конструкции запрашивают функции текущего адаптера. Эта информация доступна в [**D3D12, \_ \_ \_ \_ \_ \_ Поддержка виртуальных адресов графического процессора Data GPU**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_gpu_virtual_address_support), [**\_ \_ \_ архитектура данных компонентов D3D12**](/windows/desktop/api/d3d12/ns-d3d12-d3d12_feature_data_architecture), [**\_ \_ \_ уровень мозаичных ресурсов D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_tiled_resources_tier)и [**\_ \_ \_ уровень кучи ресурсов D3D12**](/windows/desktop/api/d3d12/ne-d3d12-d3d12_resource_heap_tier).

Несколько частей приложения, скорее всего, будут использовать разные методы. Например, некоторые крупные текстуры и редко используемые пути кода могут использовать зафиксированные ресурсы, в то время как многие текстуры могут быть назначены свойством потоковой передачи и использовать общий метод размещения ресурсов.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[**ID3D12Heap**](/windows/desktop/api/d3d12/nn-d3d12-id3d12heap)
</dt> <dt>

[Управление памятью](memory-management.md)
</dt> </dl>

 

 