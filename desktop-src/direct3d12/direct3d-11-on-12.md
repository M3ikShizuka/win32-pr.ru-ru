---
title: Direct3D 11 на 12
description: D3D11On12 — это механизм, с помощью которого разработчики могут использовать интерфейсы и объекты D3D11 для управления API D3D12.
ms.assetid: 8412D8BB-B6DD-471E-AAB2-A81121FB0FFA
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 62816ea0d7d7969cd56e0a9f525b2c412c8da182
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104548931"
---
# <a name="direct3d-11-on-12"></a>Direct3D 11 на 12

D3D11On12 — это механизм, с помощью которого разработчики могут использовать интерфейсы и объекты D3D11 для управления API D3D12. D3D11on12 позволяет компонентам, написанным с помощью D3D11 (например, к тексту и пользовательскому интерфейсу D2D), работать вместе с компонентами, предназначенными для API D3D12. D3D11on12 также позволяет выполнять добавочное перенос приложения из D3D11 в D3D12, позволяя частям приложения продолжить нацеливание на D3D11 для простоты, в то время как другие нацелены на D3D12 для повышения производительности, в то же время всегда Завершая и исправлять отрисовку. D3D11On12 делает его проще, чем использование методов взаимодействия для совместного использования ресурсов и синхронизации работы между двумя API.

-   [Инициализация D3D11On12](#initializing-d3d11on12)
-   [Пример использования](#example-usage)
-   [Фон](#background)
-   [Очистка](#cleaning-up)
-   [Ограничения](#limitations)
-   [Программные интерфейсы](#apis)
-   [Связанные темы](#related-topics)

## <a name="initializing-d3d11on12"></a>Инициализация D3D11On12

Чтобы начать использовать D3D11On12, сначала необходимо создать устройство D3D12 и очередь команд. Эти объекты предоставляются в качестве входных данных для метода инициализации [**D3D11On12CreateDevice**](/windows/desktop/api/d3d11on12/nf-d3d11on12-d3d11on12createdevice). Этот метод можно рассматривать как создание устройства D3D11 с типом драйвера D3D типа \_ \_ \_ 11ON12, где драйвер D3D11 отвечает за создание объектов и передачу СПИСКОВ команд в API D3D12.

После создания устройства D3D11 и немедленного контекста можно `QueryInterface` отключить устройство для интерфейса [**ID3D11On12Device**](/windows/desktop/api/d3d11on12/nn-d3d11on12-id3d11on12device) . Это основной интерфейс, используемый для взаимодействия между D3D11 и D3D12. Чтобы D3D11 как контекст устройства, так и команда D3D12 работают с одними и теми же ресурсами, необходимо создать "Упакованные ресурсы" с помощью API [**креатевраппедресаурце**](/windows/desktop/api/d3d11on12/nf-d3d11on12-id3d11on12device-createwrappedresource) . Этот метод "способствует" D3D12 ресурсу для понимания в D3D11. Упакованный ресурс начинается в состоянии "получено", свойство которого управляется методами [**аккуиревраппедресаурцес**](/windows/desktop/api/d3d11on12/nf-d3d11on12-id3d11on12device-acquirewrappedresources) и [**релеасевраппедресаурцес**](/windows/desktop/api/d3d11on12/nf-d3d11on12-id3d11on12device-releasewrappedresources) .

## <a name="example-usage"></a>Example Usage (Пример использования)

Типичное использование D3D11On12 заключается в использовании D2D для отрисовки текста или изображений поверх буфера D3D12. Пример кода см. в образце D3D11On12. Ниже приведен примерная структура действий, которые необходимо выполнить.

-   Создайте устройство D3D12 ([**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice)) и цепочку подкачки D3D12 ([**креатесвапчаин**](/windows/desktop/api/dxgi/nf-dxgi-idxgifactory-createswapchain) с [**ID3D12CommandQueue**](/windows/desktop/api/d3d12/nn-d3d12-id3d12commandqueue) в качестве входных данных).
-   Создайте устройство D3D11On12 с помощью устройства D3D12 и той же очереди команд, что и входные данные.
-   Извлеките задние буферы цепочки подкачки и создайте для каждого из них ресурсы с оболочкой D3D11. Используемое входное состояние должно быть последним способом, которое D3D12 использовало его (например, цель РЕНДЕРИНГа \_ ), а выходное состояние должно быть способом, который D3D12 будет использовать после завершения D3D11 (например, present).
-   Инициализируйте D2D и предоставьте D3D11 Упакованные ресурсы D2D, чтобы подготовиться к отрисовке.

Затем в каждом кадре выполните следующие действия.

-   Выполните визуализацию в текущем обратном буфере цепочки подкачки с помощью списка команд D3D12 и запустите его.
-   Получение ресурса, упакованного в текущий задний буфер ([**аккуиревраппедресаурцес**](/windows/desktop/api/d3d11on12/nf-d3d11on12-id3d11on12device-acquirewrappedresources)).
-   Выдача команд рендеринга D2D.
-   Освободите ресурс с оболочкой ([**релеасевраппедресаурцес**](/windows/desktop/api/d3d11on12/nf-d3d11on12-id3d11on12device-releasewrappedresources)).
-   Очистите немедленный контекст D3D11.
-   Present ([**IDXGISwapChain1::P resent1**](/windows/desktop/api/dxgi1_2/nf-dxgi1_2-idxgiswapchain1-present1)).

## <a name="background"></a>Историческая справка

D3D11On12 работает систематически. Каждый вызов API D3D11 проходит через типичную проверку среды выполнения и делает свой путь к драйверу. На уровне драйвера особый драйвер 11on12 записывает состояние и выдает операции визуализации в списки команд D3D12. При необходимости эти списки команд отправляются (например, запрос `GetData` или ресурс `Map` могут требовать сброса команд) или по запросу сброса. Создание объекта D3D11 обычно приводит к созданию соответствующего объекта D3D12. Некоторые операции визуализации с фиксированными функциями в D3D11 `GenerateMips` , такие как или `DrawAuto` , не поддерживаются в D3D12, поэтому D3D11On12 эмулирует их с помощью шейдеров и дополнительных ресурсов.

Для взаимодействия важно понимать, как D3D11On12 взаимодействует с объектами D3D12, созданными и предоставленными приложением. Чтобы убедиться в том, что работа выполняется в правильном порядке, немедленный контекст D3D11 должен быть сброшен, прежде чем в эту очередь можно будет отправить дополнительную D3D12 работу. Также важно убедиться, что очередь, переданная в D3D11On12, должна быть постоянно остановлена. Это означает, что все ожидания в очереди должны быть удовлетворены, даже если поток прорисовки D3D11 блокируется неограниченно долго. Будьте осторожны, чтобы не зависеть от того, когда D3D11On12 вставляет записи или ждет, так как это может измениться в будущих выпусках. Кроме того, D3D11On12 отслеживает и манипулирует состояниями ресурсов самостоятельно. Единственный способ обеспечить согласованность переходов между состояниями заключается в использовании API-интерфейсов получения и выпуска для управления отслеживанием состояния в соответствии с потребностями приложения.

## <a name="cleaning-up"></a>Очистка

Чтобы освободить ресурс с оболочкой D3D11On12, необходимо выполнить две вещи в следующем порядке:

-   Все ссылки на ресурс, включая все представления ресурса, необходимо освободить.
-   Должна выполняться Отложенная обработка уничтожения. Самый простой способ убедиться, что это происходит, — вызвать API непосредственных контекстов `Flush` .

После завершения обоих этих действий все ссылки, созданные ресурсом в оболочке, должны быть освобождены, а ресурс D3D12 будет монопольно принадлежать компоненту D3D12. Имейте в виду, что D3D12 по-прежнему требует ожидания завершения GPU перед тем, как полностью освободить ресурс, поэтому обязательно держите ссылку на ресурс перед выполнением двух описанных выше действий, если вы еще не подтвердили, что GPU больше не использует этот ресурс.

Все другие ресурсы или объекты, созданные D3D11On12, будут очищены в соответствующее время, когда GPU завершит их использование, используя механизм отложенного уничтожения D3D11's. Однако при попытке освободить устройство D3D11On12, когда GPU все еще выполняется, уничтожение может блокироваться до завершения GPU.

## <a name="limitations"></a>Ограничения

Слой D3D11On12 реализует очень большое подмножество API D3D11, но есть некоторые известные промежутки (в дополнение к ошибкам в реализации, которые могут привести к неправильной отрисовке).

Начиная с Windows 10, версия 1809 (10,0; Сборка 17763) при условии, что D3D11On12 работает на драйвере, поддерживающем модель шейдера 6,0 или более поздней версии, он может запускать шейдеры, использующие интерфейсы. В более ранних версиях Windows функция интерфейсов шейдеров не реализована в D3D11On12, и попытка использовать эту функцию приведет к ошибкам и отладке сообщений.

Начиная с Windows 10, версия 1803 (10,0; Сборка 17134), цепочки обмена поддерживаются на устройствах D3D11On12. В более ранних версиях Windows это не так.

D3D11On12 не оптимизирована для повышения производительности. По сравнению со стандартным драйвером D3D11, скорее всего, будут иметься умеренные нагрузки на ЦП, минимальные издержки на GPU, и известно, что они могут значительно издержки памяти. Поэтому не рекомендуется использовать D3D11On12 для сложных трехмерных сцен, и вместо этого он рекомендуется для простых сцен или для двухмерной отрисовки.

## <a name="apis"></a>API-интерфейсы

API-интерфейсы, составляющие слой 11on12, описаны в [справочнике по 11on12](direct3d-11on12-reference.md).

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Пошаговое руководство по использованию ПРЕОБРАЗОВАТЕЛЕй D3D11on12](d2d-using-d3d11on12.md)
</dt> <dt>

[Основные сведения о Direct3D 12](directx-12-getting-started.md)
</dt> <dt>

[Работа с Direct3D 11, Direct3D 10 и Direct2D](direct3d-12-interop.md)
</dt> </dl>

 

 