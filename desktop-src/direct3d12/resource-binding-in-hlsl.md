---
title: Привязка ресурсов в HLSL
description: В этом разделе описываются некоторые особенности использования модели шейдера высокого уровня Shader (HLSL) 5,1 с Direct3D 12.
ms.assetid: 3CD4BDAD-8AE3-4DE0-B3F8-9C9F9E83BBE9
ms.localizationpriority: high
ms.topic: article
ms.date: 08/27/2019
ms.openlocfilehash: 711ccdee71ff916445be68d03b84b7621aa04cf3
ms.sourcegitcommit: f848119a8faa29b27585f4df53f6e50ee9666684
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/27/2021
ms.locfileid: "110550389"
---
# <a name="resource-binding-in-hlsl"></a>Привязка ресурсов в HLSL

В этом разделе описываются некоторые особенности использования [модели шейдера](/windows/desktop/direct3dhlsl/shader-model-5-1) высокого уровня Shader (HLSL) 5,1 с Direct3D 12. Все оборудование Direct3D 12 поддерживает модель шейдера 5,1, поэтому поддержка этой модели не зависит от уровня компонентов оборудования.

## <a name="resource-types-and-arrays"></a>Типы ресурсов и массивы

Синтаксис ресурсов Shader Model 5 (SM 5.0) использует `register` ключевое слово для ретрансляции важной информации о ресурсе в КОМПИЛЯТОР HLSL. Например, следующая инструкция объявляет массив из четырех текстур, привязанных к разъемам T3, T4, T5 и T6. T3 — единственный слот регистров, отображаемый в операторе, просто первый в массиве из четырех.

``` syntax
Texture2D<float4> tex1[4] : register(t3)
```

Синтаксис ресурсов в модели шейдеров 5,1 (SM 5.1) в HLSL основан на существующем синтаксисе ресурсов регистров, что позволяет упростить перенос. Ресурсы Direct3D 12 в HLSL привязаны к виртуальным регистрам в логических пространствах регистров:

-   t — для представлений ресурсов шейдера (SRV)
-   s — для проб
-   u — для неупорядоченных представлений доступа (UAV)
-   b — для представлений буфера констант (CBV)

Корневая подпись, ссылающаяся на шейдер, должна быть совместима с объявленными слотами регистров. Например, следующая часть корневой сигнатуры будет совместима с использованием слотов текстур с T3 до T6, так как в нем описывается таблица дескрипторов с слотами, t0 через T98.

``` syntax
DescriptorTable( CBV(b1), SRV(t0,numDescriptors=99), CBV(b2) )
```

Объявление ресурса может быть скалярным, массивом 1D или многомерным массивом.

``` syntax
Texture2D<float4> tex1 : register(t3,  space0)
Texture2D<float4> tex2[4] : register(t10)
Texture2D<float4> tex3[7][5][3] : register(t20, space1)
```

В SM 5.1 используются те же типы ресурсов и типы элементов, что и в SM 5.0. Ограничения объявления SM 5.1 более гибкие и ограничены только ограничениями среды выполнения и оборудования. `space`Ключевое слово указывает, к какому пространству логических регистров привязана объявленная переменная. Если `space` ключевое слово опущено, то индекс пространства по умолчанию, равный 0, неявно присваивается диапазону (так что `tex2` диапазон выше находится в `space0` ). `register(t3,  space0)` никогда не будет конфликтовать с `register(t3,  space1)` или с любым массивом в другом пространстве, который может включать T3.

Ресурс массива может иметь неограниченный размер, который объявляется с помощью указания первого измерения, который должен быть пустым, или 0:

``` syntax
Texture2D<float4> tex1[] : register(t0)
```

Соответствующая таблица дескрипторов может быть:

``` syntax
DescriptorTable( CBV(b1), UAV(u0, numDescriptors = 4), SRV(t0, numDescriptors=unbounded)
```

Неограниченный массив в HLSL соответствует фиксированному числу, заданному `numDescriptors` в таблице дескрипторов, и фиксированный размер в HLSL соответствует неограниченному объявлению в таблице дескрипторов.

Многомерные массивы допускаются, включая неограниченный размер. Эти многомерные массивы выравниваются из пространства регистров.

``` syntax
Texture2D<float4> tex2[3000][10] : register(t0, space0); // t0-t29999 in space0
Texture2D<float4> tex3[0][5][3] : register(t5, space1)
```

Использование псевдонимов диапазонов ресурсов не допускается. Иными словами, для каждого типа ресурса (t, s, u, b) объявленные диапазоны регистров не должны перекрываются. Это также относится и к неограниченным диапазонам. Диапазоны, объявленные в разных пространствах регистра, никогда не перекрываются. Обратите внимание, что неограниченное `tex2` (выше) размещается в `space0` , а непривязанных `tex3` — в `space1` , так что они не перекрываются.

Для доступа к ресурсам, объявленным как массивы, достаточно просто индексировать их.

``` syntax
Texture2D<float4> tex1[400] : register(t3);
sampler samp[7] : register(s0);
tex1[myMaterialID].Sample(samp[samplerID], texCoords);
```

Существует важное ограничение по умолчанию для использования индексов ( `myMaterialID` и `samplerID` в приведенном выше коде) тем, что они не могут быть разными в [волне](../direct3dhlsl/hlsl-shader-model-6-0-features-for-direct3d-12.md#terminology). Даже изменение индекса на основе количества экземпляров.

Если требуется изменение индекса, укажите в `NonUniformResourceIndex` индексе квалификатор, например:

``` syntax
tex1[NonUniformResourceIndex(myMaterialID)].Sample(samp[NonUniformResourceIndex(samplerID)], texCoords);
```

На некоторых устройствах использование этого квалификатора создает дополнительный код для обеспечения правильности (включая потоки), но при незначительной стоимости производительности. Если индекс изменяется без квалификатора и в процессе рисования/отправки результаты не определены.

## <a name="descriptor-arrays-and-texture-arrays"></a>Массивы дескрипторов и массивы текстур

С момента выпуска DirectX 10 были доступны массивы текстур. Для массивов текстуры требуется один дескриптор, однако все срезы массива должны иметь одинаковый формат, ширину, высоту и число MIP. Кроме того, массив должен занимать непрерывный диапазон в виртуальном адресном пространстве. В следующем коде показан пример доступа к массиву текстуры из шейдера.

``` syntax
Texture2DArray<float4> myTex2DArray : register(t0); // t0
float3 myCoord(1.0f,1.4f,2.2f); // 2.2f is array index (rounded to int)
color = myTex2DArray.Sample(mySampler, myCoord);
```

В массиве текстур индекс может свободно изменяться без каких-либо необходимых квалификаторов, таких как `NonUniformResourceIndex` .

Эквивалентный массив дескрипторов будет следующим:

``` syntax
Texture2D<float4> myArrayOfTex2D[] : register(t0); // t0+
float2 myCoord(1.0f, 1.4f);
color = myArrayOfTex2D[2].Sample(mySampler,myCoord); // 2 is index
```

Обратите внимание, что неудобное использование float для индекса массива заменяется на `myArrayOfTex2D[2]` . Кроме того, массивы дескрипторов обеспечивают большую гибкость при использовании измерений. Тип `Texture2D` — это пример, который не может быть разным, но формат, ширина, высота и число MIP могут различаться в зависимости от каждого дескриптора.

В качестве дескриптора можно использовать массив массивов текстур:

``` syntax
Texture2DArray<float4> myArrayOfTex2DArrays[2] : register(t0);
```

Незаконно объявлять массив структур, каждая структура, содержащая дескрипторы, например следующий код, не поддерживается.

``` syntax
struct myStruct {
    Texture2D                    a; 
    Texture2D                    b;
    ConstantBuffer<myConstants>  c;
};
myStruct foo[10000] : register(....);
```

Это позволило бы abcabcabc макет памяти **....**, но является ограничением языка и не поддерживается. Ниже приведен один из поддерживаемых методов выполнения этой операции, хотя в этом случае в качестве структуры памяти используется **AAA... BBB... CCC**....

``` syntax
Texture2D                     a[10000] : register(t0);
Texture2D                     b[10000] : register(t10000);
ConstantBuffer<myConstants>   c[10000] : register(b0);
```

Чтобы получить макет памяти **abcabcabc....** , используйте таблицу дескрипторов без использования `myStruct` структуры.

## <a name="resource-aliasing"></a>Присвоение псевдонимов ресурсам

Диапазоны ресурсов, указанные в шейдерах HLSL, являются логическими диапазонами. Они привязаны к конкретным диапазонам кучи во время выполнения через механизм корневой подписи. Как правило, логический диапазон сопоставляется с диапазоном кучи, который не перекрывается с другими диапазонами кучи. Однако механизм корневой подписи делает возможным псевдонимы диапазонов кучи совместимых типов. Например, `tex2` и `tex3` диапазоны из приведенного выше примера могут быть сопоставлены с одним (или перекрывающим) диапазоном кучи, в котором действует псевдоним текстур в программе HLSL. Если требуется такое присвоение псевдонимов, шейдер должен быть скомпилирован с использованием \_ ресурсов шейдера \_ D3D10 \_ \_ , которые задаются с помощью параметра */RES может быть \_ \_ псевдонимом* для [средства компилятора Effect](../direct3dtools/fxc.md) (FXC). Параметр позволяет компилятору создавать правильный код, предотвращая определенные оптимизации нагрузки и хранения в соответствии с предположением, что ресурсы могут быть псевдонимами.

## <a name="divergence-and-derivatives"></a>Расхождение и производные

SM 5.1 не накладывает ограничений на индекс ресурсов; т. е. ` tex2[idx].Sample(…)` индекс idx может быть литеральной константой, константой кбуффер или интерполяцией значения. Хотя модель программирования обеспечивает такую высокую гибкость, существуют проблемы, которые следует учитывать:

-   Если индекс рассходится по четырем, то вычисленное оборудованием производные и производные количества, например Лод, могут быть неопределенными. Компилятор HLSL делает лучшие усилия для выдачи предупреждения в этом случае, но не помешает компиляции шейдера. Такое поведение аналогично вычислению производных элементов в последовательном потоке управления.
-   Если индекс ресурсов отличается, производительность уменьшается по сравнению с вариантом универсального индекса, так как оборудование должно выполнять операции с несколькими ресурсами. Индексы ресурсов, которые могут быть иными, должны быть помечены `NonUniformResourceIndex` функцией в коде HLSL. В противном случае результаты не определены.

## <a name="uavs-in-pixel-shaders"></a>Уавс в шейдере пикселей

SM 5.1 не накладывает ограничений на диапазоны UAV в шейдерах пикселей, как это было в случае SM 5.0.

## <a name="constant-buffers"></a>Буферы констант

Синтаксис для константных буферов SM 5.1 (кбуффер) изменился с SM 5.0, чтобы позволить разработчикам индексировать буферы констант. Чтобы включить индексируемые буферы констант, SM 5.1 вводит `ConstantBuffer` конструкцию "Template":

``` syntax
struct Foo
{
    float4 a;
    int2 b;
};
ConstantBuffer<Foo> myCB1[2][3] : register(b2, space1);
ConstantBuffer<Foo> myCB2 : register(b0, space1);
```

Приведенный выше код объявляет переменную буфера константы `myCB1` типа `Foo` и размера 6, а также скалярную переменную буфера `myCB2` . Переменная буфера константы теперь может индексироваться в шейдере следующим образом:

``` syntax
myCB1[i][j].a.xyzw
myCB2.b.yy
```

Поля "a" и "b" не становятся глобальными переменными, а должны рассматриваться как поля. Для обеспечения обратной совместимости SM 5.1 поддерживает старую концепцию кбуффер для скалярного cbuffer. Следующая инструкция делает глобальные переменные «a» и «b» только для чтения, как в SM 5.0. Однако такие кбуффер не могут индексироваться.

``` syntax
cbuffer : register(b1)
{
    float4 a;
    int2 b;
};
```

В настоящее время компилятор шейдеров поддерживает `ConstantBuffer` шаблон только для определяемых пользователем структур.

В целях совместимости компилятор HLSL может автоматически назначать регистры ресурсов для диапазонов, объявленных в `space0` . Если в предложении Register не указан пробел, используется значение по умолчанию `space0` . Для назначения регистров компилятор использует эвристический метод "первый-дыра". Назначение можно получить с помощью API отражения, который был расширен для добавления поля *пробела* , а поле *биндпоинт* — нижнюю границу диапазона регистров ресурсов.

## <a name="bytecode-changes-in-sm51"></a>Изменения байтового кода в SM 5.1

SM 5.1 изменяет объявление регистров ресурсов и ссылки в инструкциях. Синтаксис включает объявление переменной Register, аналогично тому, как это делается для групповых регистров общей памяти:

``` syntax
Texture2D<float4> tex0          : register(t5,  space0);
Texture2D<float4> tex1[][5][3]  : register(t10, space0);
Texture2D<float4> tex2[8]       : register(t0,  space1);
SamplerState samp0              : register(s5, space0);

float4 main(float4 coord : COORD) : SV_TARGET
{
    float4 r = coord;
    r += tex0.Sample(samp0, r.xy);
    r += tex2[r.x].Sample(samp0, r.xy);
    r += tex1[r.x][r.y][r.z].Sample(samp0, r.xy);
    return r;
}
```

Будет разбираться в:

``` syntax
// Resource Bindings:
//
// Name                                 Type  Format         Dim    ID   HLSL Bind     Count
// ------------------------------ ---------- ------- ----------- -----   --------- ---------
// samp0                             sampler      NA          NA     S0    a5            1
// tex0                              texture  float4          2d     T0    t5            1
// tex1[0][5][3]                     texture  float4          2d     T1   t10        unbounded
// tex2[8]                           texture  float4          2d     T2    t0.space1     8
//
//
//
// Input signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// COORD                    0   xyzw        0     NONE   float   xyzw
//
//
// Output signature:
//
// Name                 Index   Mask Register SysValue  Format   Used
// -------------------- ----- ------ -------- -------- ------- ------
// SV_TARGET                0   xyzw        0   TARGET   float   xyzw
//
ps_5_1
dcl_globalFlags refactoringAllowed
dcl_sampler s0[5:5], mode_default, space=0
dcl_resource_texture2d (float,float,float,float) t0[5:5], space=0
dcl_resource_texture2d (float,float,float,float) t1[10:*], space=0
dcl_resource_texture2d (float,float,float,float) t2[0:7], space=1
dcl_input_ps linear v0.xyzw
dcl_output o0.xyzw
dcl_temps 2
sample r0.xyzw, v0.xyxx, t0[0].xyzw, s0[5]
add r0.xyzw, r0.xyzw, v0.xyzw
ftou r1.x, r0.x
sample r1.xyzw, r0.xyxx, t2[r1.x + 0].xyzw, s0[5]
add r0.xyzw, r0.xyzw, r1.xyzw
ftou r1.xyz, r0.zyxz
imul null, r1.yz, r1.zzyz, l(0, 15, 3, 0)
iadd r1.y, r1.z, r1.y
iadd r1.x, r1.x, r1.y
sample r1.xyzw, r0.xyxx, t1[r1.x + 10].xyzw, s0[5]
add o0.xyzw, r0.xyzw, r1.xyzw
ret
// Approximately 12 instruction slots are used.
```

Каждый диапазон ресурсов шейдера теперь имеет идентификатор (имя), уникальный для байт-кода шейдера. Например, массив текстуры Tex1 (T10) превращается в "1" в байт-код шейдера. Присвоение уникальных идентификаторов каждому диапазону ресурсов позволяет выполнить два действия:

-   Однозначно определяет, какой диапазон ресурсов (см. дкл \_ Resource \_ Texture2D) индексируется в инструкции (см. пример инструкции).
-   Присоединение набора атрибутов к объявлению, например, тип элемента, размер шага, режим растровой операции и т. д.

Обратите внимание, что идентификатор диапазона не связан с объявлением HLSL нижней границы.

Порядок привязок ресурсов отражения (сверху) и инструкций объявлений шейдера (дкл \_ \* ) аналогичен, чтобы помочь в определении соответствия между переменными HLSL и идентификаторами байт-кода.

Каждая инструкция объявления в SM 5.1 использует трехмерный операнд для определения: идентификатор диапазона, Нижняя и верхняя границы. Для указания пространства регистра создается дополнительный токен. Также могут выдаваться другие токены для передачи дополнительных свойств диапазона, например кбуффер или инструкция объявления буфера, выдает размер кбуффер или структуры. Точные сведения о кодировке можно найти в d3d12TokenizedProgramFormat. h и **D3D10ShaderBinary:: кшадеркодепарсер**.

Инструкции SM 5.1 не будут выдавать дополнительные сведения о операндах ресурсов в рамках инструкции (как в SM 5.0). Эти сведения теперь приведены в инструкциях по объявлению. В SM 5.0 приведены инструкции по индексированию ресурсов, необходимых атрибутам ресурсов, которые должны быть описаны в маркерах расширенного кода операции, поскольку индексирование замаскировано к объявлению. В SM 5.1 Каждый идентификатор (например, "'t 1") однозначно связан с одним объявлением, описывающим необходимые сведения о ресурсах. Поэтому маркеры расширенного кода операций, используемые в инструкциях для описания сведений о ресурсах, больше не создаются.

В инструкциях без объявления операнд ресурса для образцов, СРВС и Уавс является 2D-операндом. Первый индекс представляет собой литеральную константу, указывающую идентификатор диапазона. Второй индекс представляет линейное значение индекса. Значение высчитывается относительно начала соответствующего пространства регистра (не относительно начала логического диапазона) для лучшего сопоставления с корневой подписью и для уменьшения количества погрузок компилятора драйвера на настройку индекса.

Операнд ресурса для КБВС является трехмерным операндом, содержащим: литеральный идентификатор диапазона, индекс буфера константы и смещение в определенном экземпляре буфера констант.

## <a name="example-hlsl-declarations"></a>Примеры объявлений HLSL

Программам HLSL не нужно ничего знать о корневых сигнатурах. Они могут назначать привязки к виртуальному пространству привязки "Register", t \# для СРВС, u \# для уавс, b \# для КБВС, s для \# проб или использовать компилятор для выбора назначений (и запрашивать полученные сопоставления с помощью отражения шейдера). Корневой узел подписи сопоставляет таблицы дескрипторов, корневые дескрипторы и корневые константы с этим виртуальным пространством регистра.

Ниже приведены примеры объявлений, которые может иметь Шейдер HLSL. Обратите внимание, что отсутствуют ссылки на корневые сигнатуры или таблицы дескрипторов.

``` syntax
Texture2D foo[5] : register(t2);
Buffer bar : register(t7);
RWBuffer dataLog : register(u1);

Sampler samp : register(s0);

struct Data
{
    UINT index;
    float4 color;
};
ConstantBuffer<Data> myData : register(b0);

Texture2D terrain[] : register(t8); // Unbounded array
Texture2D misc[] : register(t0,space1); // Another unbounded array 
                                        // space1 avoids overlap with above t#

struct MoreData
{
    float4x4 xform;
};
ConstantBuffer<MoreData> myMoreData : register(b1);

struct Stuff
{
    float2 factor;
    UINT drawID;
};
ConstantBuffer<Stuff> myStuff[][3][8]  : register(b2, space3)
```

## <a name="related-topics"></a>Связанные темы

* [Динамическое индексирование с помощью HLSL 5.1](dynamic-indexing-using-hlsl-5-1.md)
* [Effect — средство компилятора](../direct3dtools/fxc.md)
* [Функции HLSL Shader Model 5,1 для Direct3D 12](../direct3dhlsl/hlsl-shader-model-5-1-features-for-direct3d-12.md)
* [Упорядоченные представления средства программной прорисовки](rasterizer-order-views.md)
* [Привязка ресурсов](resource-binding.md)
* [Корневые подписи](root-signatures.md)
* [Модель шейдера 5,1](../direct3dhlsl/shader-model-5-1.md)
* [Контрольное значение трафарета в шейдере](shader-specified-stencil-reference-value.md)
* [Определение корневых подписей в HLSL](specifying-root-signatures-in-hlsl.md)