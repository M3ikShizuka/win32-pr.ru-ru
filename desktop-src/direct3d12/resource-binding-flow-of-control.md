---
title: Общие сведения о привязке ресурсов
description: Ключами для понимания привязки ресурсов в DirectX 12 являются понятия дескрипторов, таблиц, куч дескрипторов и корневых подписей.
ms.assetid: 92E100CA-822D-46B1-BD37-FF57C3FB703D
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 657e380c58182fee8ad2c82f3af0c6fdd5ffec76
ms.sourcegitcommit: 8a211d404470a6a2790733ed2894cfaf92bddd70
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/03/2021
ms.locfileid: "123464107"
---
# <a name="resource-binding-overview"></a>Общие сведения о привязке ресурсов

Ключами для понимания привязки ресурсов в DirectX 12 являются понятия дескрипторов, таблиц, куч дескрипторов и корневых подписей.

## <a name="resources-and-the-graphics-pipeline"></a>Ресурсы и графический конвейер

Ресурсы шейдера (например, текстуры, константные таблицы, изображения, буферы и т. д.) не привязываются непосредственно к конвейеру шейдера; Вместо этого они ссылаются с помощью *дескриптора*. Дескриптор — это небольшой объект, содержащий сведения об одном ресурсе.

Дескрипторы группируются вместе для формирования *таблиц дескрипторов*. Каждая таблица дескрипторов хранит сведения об одном диапазоне типов ресурсов. Существует много различных типов ресурсов. Ниже перечислены наиболее распространенные ресурсы.

-   Представления буфера констант (КБВС)
-   Неупорядоченные представления доступа (Уавс)
-   Представления ресурсов шейдера (СРВС)
-   Образцы.

Дескрипторы SRV, UAV и КБВС могут быть объединены в одну и ту же таблицу дескрипторов.

Конвейеры графики и вычислений получают доступ к ресурсам, ссылаясь на таблицы дескрипторов по индексу.

Таблицы дескрипторов хранятся в *куче дескрипторов*. В идеале кучи дескрипторов будут содержать все дескрипторы (в таблицах дескрипторов) для одного или нескольких кадров для подготовки к просмотру. Все ресурсы будут храниться в кучах пользовательского режима.

Еще одна концепция состоит из *корневой сигнатуры*. Корневая подпись — это соглашение о привязке, определяемое приложением, которое используется шейдером для определения местоположения ресурсов, к которым им требуется доступ. Корневая подпись может хранить:

-   Индексы для таблиц дескрипторов в куче дескрипторов, где макет таблицы дескрипторов был предварительно определен.
-   Константы, так что приложения могут привязывать определяемые пользователем константы (называемые *корневыми константами*) непосредственно к шейдерам без необходимости проходить через дескрипторы и таблицы.
-   Очень небольшое число дескрипторов непосредственно внутри корневой сигнатуры, например представление константного буфера (CBV), которое изменяется на рисование, тем самым сохраняя приложение от необходимости размещения этих дескрипторов в куче дескрипторов.

Иными словами, корневая подпись обеспечивает оптимизацию производительности, подходящую для небольших объемов данных, которые изменяются на рисование.

Конструкция Direct3D 12 для привязки разделяет его от других задач, таких как управление памятью, управление жизненным циклом объектов, отслеживание состояния и синхронизация памяти (см. раздел [различия в модели привязки от Direct3D 11](binding-model.md)). Привязка Direct3D 12 разработана с низкой нагрузкой и оптимизирована для вызовов API, которые выполняются наиболее часто. Она также масштабируется от низкого до высокопроизводительного оборудования и масштабируется с более высокого (более линейного конвейера Direct3D 11) до более новых (более параллельных) подходов к программированию графических модулей.

## <a name="resource-types-and-views"></a>Типы ресурсов и представления

Типы ресурсов совпадают с Direct3D 11, а именно:

-   Texture1D и Texture1DArray
-   Texture2D, Texture2DArray, Texture2DMS, Texture2DMSArray
-   Texture3D
-   Буферы (типизированные, структурированные и необработанные)

Представления ресурсов похожи, но немного отличаются от представлений в Direct3D 11, вершин и буферов индексов.

-   Представление буфер констант (CBV)
-   Представление неупорядоченного доступа (UAV)
-   Представление ресурсов шейдера (SRV)
-   Образцы.
-   Представление целевого объекта прорисовки (РТВ)
-   Представление трафарета глубины (DSV)
-   Представление буфера индекса (ИБВ)
-   Представление буфера вершин (ВБВ)
-   Представление потока вывода (сов)

Только первые четыре из этих представлений на самом деле видимы для шейдеров, см. [видимые кучи дескрипторов шейдеров](shader-visible-descriptor-heaps.md) и [видимые кучи дескрипторов без шейдера](non-shader-visible-descriptor-heaps.md).

## <a name="resource-binding-flow-of-control"></a>Поток привязки ресурсов — Управление

Основное внимание уделяется только корневым сигнатурам, корневым дескрипторам, корневым константам, таблицам дескрипторов и кучам дескрипторов. поток логики отрисовки для приложения должен выглядеть следующим образом:

-   Создайте один или несколько объектов корневой подписи — по одному для каждой конфигурации привязки, которая требуется приложению.
-   Создайте шейдеры и состояние конвейера с помощью объектов корневой сигнатуры, с которыми они будут использоваться.
-   Создайте одну (или, если необходимо, больше) кучу дескрипторов, которая будет содержать все описания UAV и CBV для каждого кадра отрисовки.
-   Инициализируйте кучи дескрипторов с помощью дескрипторов, где это возможно для наборов дескрипторов, которые будут повторно использоваться во многих кадрах.
-   Для каждого отображаемого кадра:
    -   Для каждого списка команд:
        -   Задайте текущую корневую подпись для использования (и при необходимости измените ее при подготовке к просмотру, что является редко необходимым).
        -   Обновите некоторые константы корневой сигнатуры и (или) дескрипторы корневой подписи для нового представления (например, проекции мира или представления).
        -   Для каждого рисуемого элемента:
            -   Определите новые дескрипторы в кучах дескрипторов, необходимые для отрисовки каждого объекта. Для кучи дескрипторов, видимых шейдером, приложение должно использовать пространство кучи дескрипторов, на которое еще не ссылается визуализация, которая может быть в полете, например, линейное выделение пространства через кучу дескрипторов во время подготовки к просмотру.
            -   Обновите корневую подпись с помощью указателей на требуемые регионы куч дескриптора. Например, одна таблица дескрипторов может указывать на некоторые статические (неизменяемые) дескрипторы, инициализированные ранее, а другая таблица дескрипторов может указывать на некоторые динамические дескрипторы, настроенные для текущей отрисовки.
            -   Обновите некоторые константы корневой подписи и (или) дескрипторы корневой подписи для отрисовки на уровне элементов.
            -   Задать для элемента состояние конвейера (только при необходимости изменения), совместимое с корневой подписью, привязанной к текущему объекту.
            -   Draw
        -   Повторить (следующий элемент)
    -   Повтор (следующий список команд)
    -   Только после завершения работы GPU с любой памятью, которая больше не будет использоваться, ее можно освободить. Ссылки дескрипторов на него не нужно удалять, если не отправляется дополнительная визуализация, использующая эти дескрипторы. Таким образом, последующая отрисовка может указывать на другие области в кучах дескрипторов, или устаревшие дескрипторы могут быть перезаписаны допустимыми дескрипторами для повторного использования пространства кучи дескрипторов.
-   Повторить (следующий кадр)

Обратите внимание, что другие типы дескрипторов, представления целевого объекта отрисовки (RTVs), представления трафарета глубины (DSV), представления буферов вершин (Ибвс), представления буфера вершины (Вбвс) и представления объектов шейдера (сов) управляются по-разному. Драйвер обрабатывает управление версиями набора дескрипторов, привязанных к каждому элементу Draw во время записи списка команд (аналогично тому, как задаются сведения об оборудовании и драйвере версии привязки корневой сигнатуры). Это отличается от содержимого куч-видимых дескрипторов шейдера, для которых приложение должно вручную выделить кучу, так как она ссылается на разные дескрипторы рисования. Управление версиями содержимого кучи, которое является видимым шейдером, оставлено приложению, так как оно позволяет приложениям выполнять такие действия, как повторное использование дескрипторов, которые не изменяются или используют большие статические наборы дескрипторов, и использовать индексацию шейдера (например, по ИДЕНТИФИКАТОРу материала) для выбора дескрипторов из кучи дескрипторов или использовать сочетания методов для различных наборов дескрипторов. Оборудование не оборудовано для поддержки такого типа гибкости для других типов дескрипторов (РТВ, DSV, ИБВ, ВБВ, сов).

## <a name="suballocation"></a>Выделено

В Direct3D 12 приложение имеет низкий уровень контроля над управлением памятью. В более ранних версиях Direct3D, включая Direct3D 11, выделено одно выделение для каждого ресурса. В Direct3D 12 приложение может использовать API для выделения большого блока памяти, чем требуется для одного объекта. После этого приложение может создавать дескрипторы, указывающие на разделы этого большого блока памяти. Этот процесс решает, что следует разместить, где (меньшие блоки внутри большого блока) называется *подраспределением*. Включение этого приложения может привести к повышению эффективности использования вычислений и памяти. Например, переименование ресурсов отрисовывается как устаревшее. Вместо этого приложения могут использовать ограждения, чтобы определить, когда используется определенный ресурс, и когда он не является ограждением при выполнении списка команд, где список команд требует использования этого конкретного ресурса.

## <a name="freeing-resources"></a>Освобождение ресурсов

Прежде чем можно будет освободить память, которая была привязана к конвейеру, необходимо завершить графический процессор.

Ожидание отрисовки кадров, вероятно, является грубым способом убедиться в том, что GPU завершен. В более тонком Гране можно снова использовать ограждения — когда команда записывается в список команд, для которого необходимо отследить завершение, вставьте ограждение сразу после нее. Затем можно выполнять различные операции синхронизации с ограждением. Вы отправляете новую работу (списки команд), которая ожидает до тех пор, пока заданная ограждение не перейдет к GPU, что указывает на то, что все до его завершения, или вы можете запросить возникновение события ЦП при передаче ограждения (которое приложение может ожидать в спящем потоке). В Direct3D 11 это было `EnqueueSetEvent` ().

## <a name="related-topics"></a>Связанные темы

* [Привязка ресурсов](resource-binding.md)
