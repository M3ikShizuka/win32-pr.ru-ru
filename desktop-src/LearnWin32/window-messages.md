---
title: Сообщения окна (начало работы с Win32 и C++)
description: Сообщения окна (начало работы с Win32 и C++)
ms.assetid: 90c20456-44ed-4f0f-a6d3-b6c5660f0bc7
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c00da564396e0f95947e33fb7d8db8b217ac5cdf
ms.sourcegitcommit: 95685061d5b0333bbf9e6ebd208dde8190f97005
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2021
ms.locfileid: "108103842"
---
# <a name="window-messages-get-started-with-win32-and-c"></a>Сообщения окна (начало работы с Win32 и C++)

Приложение графического пользовательского интерфейса должно реагировать на события от пользователя и из операционной системы.

- К **событиям пользователя** относятся все способы взаимодействия с программой: щелчки мыши, клавиши, жесты с сенсорным экраном и т. д.
- **События операционной системы** включают все «вне» программы, которая может повлиять на работу программы. Например, пользователь может подключить новое аппаратное устройство, или Windows может перейти в режим пониженного энергопотребления (спящий или спящий режим).

Эти события могут возникать в любое время, пока программа выполняется, в почти в любом порядке. Как структурировать программу, поток выполнения которой нельзя прогнозировать заранее?

Для решения этой проблемы в Windows используется модель передачи сообщений. Операционная система взаимодействует с окном приложения, передавая ему сообщения. Сообщение — это просто числовой код, обозначающий определенное событие. Например, если пользователь нажимает левую кнопку мыши, окно получает сообщение, в котором содержится следующий код сообщения.

```C++
#define WM_LBUTTONDOWN    0x0201
```

С некоторыми сообщениями связаны данные. Например, сообщение [**WM \_ лбуттондовн**](/windows/desktop/inputdev/wm-lbuttondown) содержит координаты x и y курсора мыши.

Чтобы передать сообщение в окно, операционная система вызывает процедуру окна, зарегистрированную для этого окна. (И теперь вы понимаете, для чего предназначена процедура окна.)

## <a name="the-message-loop"></a>Цикл обработки сообщений

Приложение получит тысячи сообщений во время выполнения. (Рассмотрите, что при каждом нажатии кнопки мыши и щелчке мышью создается сообщение.) Кроме того, приложение может иметь несколько окон, каждое из которых имеет собственную процедуру окна. Как программа получает все эти сообщения и доставляет их в правильную процедуру окна? Приложению требуется цикл для извлечения сообщений и их отправки в правильные окна.

Для каждого потока, создающего окно, операционная система создает очередь для сообщений окна. Эта очередь содержит сообщения для всех окон, созданных в этом потоке. Сама очередь скрыта от программы. Управлять очередью напрямую нельзя. Тем не менее можно извлечь сообщение из очереди, вызвав функцию "функция [**onmessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) ".

```C++
MSG msg;
GetMessage(&msg, NULL, 0, 0);
```

Эта функция удаляет первое сообщение из заголовка очереди. Если очередь пуста, функция блокируется до постановки в очередь другого сообщения. [**Тот факт, что блоки**](/windows/desktop/api/winuser/nf-winuser-getmessage) псевдо не сделают программу неотвечающей. Если сообщений нет, программа не будет выполнять никаких действий. Если необходимо выполнить фоновую обработку, можно создать дополнительные потоки, которые продолжают выполняться, а **Message** ожидает другого сообщения. (См. раздел [предотвращение узких мест в процедуре окна](writing-the-window-procedure.md).)

Первым параметром для [**параметра MSG является адрес**](/windows/desktop/api/winuser/nf-winuser-getmessage) структуры [**сообщения**](/windows/win32/api/winuser/ns-winuser-msg) . Если функция выполнена, она заполняет структуру **MSG** сведениями о сообщении. Сюда входят целевое окно и код сообщения. Другие три параметра позволяют фильтровать сообщения, получаемые из очереди. Почти во всех случаях эти параметры будут заданы равными нулю.

Несмотря на [**то, что структура сообщения**](/windows/win32/api/winuser/ns-winuser-msg) содержит сведения о сообщении, вы почти никогда не будете изучать эту структуру напрямую. Вместо этого он будет передан непосредственно двум другим функциям.

```C++
TranslateMessage(&msg); 
DispatchMessage(&msg);
```

Функция [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) связана с вводом с клавиатуры. Он преобразует нажатия клавиш (Клавиша вниз, клавиша вверх) в символы. Вам не обязательно быть уверенным в том, как работает эта функция. просто не забудьте вызвать ее перед [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage). Если вас интересуют, ссылка на документацию MSDN предоставит вам дополнительные сведения.

Функция [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) сообщает операционной системе о необходимости вызова оконной процедуры окна, которая является целью сообщения. Иными словами, операционная система ищет маркер окна в своей таблице окон, находит указатель на функцию, связанный с окном, и вызывает функцию.

Например, предположим, что пользователь нажимает левую кнопку мыши. Это приводит к цепочке событий:

1. Операционная система помещает сообщение [**WM \_ лбуттондовн**](/windows/desktop/inputdev/wm-lbuttondown) в очередь сообщений.
2. Ваша программа вызывает функцию WITH [**Message**](/windows/desktop/api/winuser/nf-winuser-getmessage) .
3. Параметр [**onmessage**](/windows/desktop/api/winuser/nf-winuser-getmessage) извлекает сообщение [**WM \_ лбуттондовн**](/windows/desktop/inputdev/wm-lbuttondown) из очереди и заполняет структуру [**MSG**](/windows/win32/api/winuser/ns-winuser-msg) .
4. Программа вызывает функции [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) и [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage) .
5. Внутри [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage)операционная система вызывает процедуру окна.
6. Ваша процедура окна может либо ответить на сообщение, либо пропустить ее.

Когда процедура окна возвращает, возвращается обратно в [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage). При этом возвращается цикл обработки сообщений для следующего сообщения. Пока программа запущена, сообщения будут по-прежнему поступать в очередь. Поэтому необходимо иметь цикл, который постоянно извлекает сообщения из очереди и отправляет их. Вы можете представить себе цикл, как показано ниже.

```C++
// WARNING: Don't actually write your loop this way.

while (1)      
{
    GetMessage(&msg, NULL, 0,  0);
    TranslateMessage(&msg); 
    DispatchMessage(&msg);
}
```

Как написано, этот цикл никогда бы не был завершен. Именно в этом случае возвращается возвращаемое значение функции- [**сообщения**](/windows/desktop/api/winuser/nf-winuser-getmessage) . Как правило, функция **onmessage** возвращает ненулевое значение. Если вы хотите выйти из приложения и приостановить цикл обработки сообщений, вызовите функцию [**посткуитмессаже**](/windows/desktop/api/winuser/nf-winuser-postquitmessage) .

```C++
        PostQuitMessage(0);
```

Функция [**посткуитмессаже**](/windows/desktop/api/winuser/nf-winuser-postquitmessage) помещает сообщение [**WM \_ Quit**](/windows/desktop/winmsg/wm-quit) в очередь сообщений. **WM \_ QUIT** — это специальное сообщение: оно приводит к тому, что [**сообщение**](/windows/desktop/api/winuser/nf-winuser-getmessage) возвращает ноль, и сообщает о завершении цикла обработки сообщений. Ниже приведен измененный цикл обработки сообщений.

```C++
// Correct.

MSG msg = { };
while (GetMessage(&msg, NULL, 0, 0) > 0)
{
    TranslateMessage(&msg);
    DispatchMessage(&msg);
}
```

При условии [**, что функция IsTrue возвращает**](/windows/desktop/api/winuser/nf-winuser-getmessage) ненулевое значение, выражение в цикле **while** вычисляется как true. После вызова [**посткуитмессаже**](/windows/desktop/api/winuser/nf-winuser-postquitmessage)выражение принимает значение false и программа выходит из цикла. (Один из интересных результатов такого поведения заключается в том, что ваша процедура окна никогда не получит сообщение [**\_ Quit WM**](/windows/desktop/winmsg/wm-quit) . Поэтому для этого сообщения в процедуре окна не обязательно иметь оператор Case.)

Следующий очевидный вопрос заключается в том, когда следует вызывать [**посткуитмессаже**](/windows/desktop/api/winuser/nf-winuser-postquitmessage). Мы вернемся к этому вопросу в разделе [закрытие окна](closing-the-window.md), но сначала нам нужно написать нашу процедуру окна.

## <a name="posted-messages-versus-sent-messages"></a>Отправка сообщений и отправленных сообщений

В предыдущем разделе говорились о сообщениях, помещаемых в очередь. Иногда операционная система вызывает процедуру окна напрямую, минуя очередь.

Терминология этого отличия может быть запутанной:

-   *Отправка* сообщения означает, что сообщение помещается в очередь сообщений и отправляется через цикл обработки [**сообщений (**](/windows/desktop/api/winuser/nf-winuser-getmessage) [**DispatchMessage**](/windows/desktop/api/winuser/nf-winuser-dispatchmessage)).
-   *Отправка* сообщения означает, что сообщение пропускается, а операционная система напрямую вызывает процедуру окна.

В настоящее отличие это не очень важно. Оконная процедура обрабатывает все сообщения. Однако некоторые сообщения обходят очередь и пройдут непосредственно в оконную процедуру. Однако это может повлиять на взаимодействие приложения между Windows. Более подробное описание этой проблемы см. в разделе [сообщения и очереди сообщений](/windows/desktop/winmsg/about-messages-and-message-queues).

## <a name="next"></a>Следующая

[Написание процедуры окна](writing-the-window-procedure.md)
