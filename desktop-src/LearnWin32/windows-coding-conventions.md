---
title: Соглашения о написании кода Windows
description: Если вы не знакомы с программированием для Windows, это можно сделать при первом просмотре программы Windows.
ms.assetid: 466a66db-7681-4fce-9672-07849cd1b096
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 365a9c8509d7cb799bafdfa70c326f1074b64d93
ms.sourcegitcommit: ebd3ce6908ff865f1ef66f2fc96769be0aad82e1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/19/2020
ms.locfileid: "105672261"
---
# <a name="windows-coding-conventions"></a>Соглашения о написании кода Windows

Если вы не знакомы с программированием для Windows, это можно сделать при первом просмотре программы Windows. Код заполняется нестранными определениями типов, такими как **DWORD \_ ptr** и **лпрект**, а переменные имеют такие имена, как *HWND* и *пвсз* (называемые венгерской нотацией). Стоит потратить немного времени, чтобы изучить некоторые соглашения о написании кода Windows.

Большинство API-интерфейсов Windows состоят из функций или интерфейсов модели COM. В качестве классов C++ предоставляются очень мало API Windows. (Важным исключением является GDI+, один из API-интерфейсов двухмерной графики.)

## <a name="typedefs"></a>Определения типов

Заголовки Windows содержат множество определений типов. Многие из них определены в файле заголовка Виндеф. h. Ниже приведены некоторые из них, которые часто встречаются.

### <a name="integer-types"></a>Целочисленные типы



| Тип данных     | Размер    | Входил?  |
|---------------|---------|----------|
| **BYTE**      | 8 бит  | Без знака |
| **DWORD**     | 32 бита | Без знака |
| **INT32**     | 32 бита | Со знаком   |
| **INT64**     | 64 бита | Со знаком   |
| **LONG**      | 32 бита | Со знаком   |
| **лонглонг**  | 64 бита | Со знаком   |
| **UINT32**    | 32 бита | Без знака |
| **UINT64**    | 64 бита | Без знака |
| **ULONG**     | 32 бита | Без знака |
| **улонглонг** | 64 бита | Без знака |
| **WORD**      | 16 бит | Без знака |



 

Как видите, в этих определениях типов имеется определенный объем избыточности. Часть этого перекрывается просто из-за истории интерфейсов API Windows. Перечисленные типы имеют фиксированный размер, а размеры одинаковы в 32-и 64-приложениях. Например, тип **DWORD** всегда 32 бит в ширину.

### <a name="boolean-type"></a>Логический тип

**Bool** — это typedef для целочисленного значения, используемого в логическом контексте. Файл заголовка Виндеф. h также определяет два значения для использования с **bool**.


```C++
#define FALSE    0 
#define TRUE     1
```



Несмотря на это определение **true**, большинство функций, возвращающих тип **bool** , могут возвращать любое ненулевое значение, обозначающее логическую истинность. Поэтому всегда следует писать следующее:


```C++
// Right way.
BOOL result = SomeFunctionThatReturnsBoolean();
if (result) 
{ 
    ...
}
```



и не так:


```C++
// Wrong!
if (result == TRUE) 
{
    ... 
}
```



Помните, что **bool** является целочисленным типом и не является взаимозаменяемым с типом **bool** C++.

### <a name="pointer-types"></a>Типы указателей

Windows определяет множество типов данных *указателя на X*. Они обычно имеют префикс *P-* или *LP-* в имени. Например, **лпрект** является указателем на [**Rect**](/previous-versions//dd162897(v=vs.85)), где **Rect** — это структура, описывающая прямоугольник. Следующие объявления переменных эквивалентны.


```C++
RECT*  rect;  // Pointer to a RECT structure.
LPRECT rect;  // The same
PRECT  rect;  // Also the same.
```



Исторически, *P* означает "указатель", а *LP* — "длинный указатель". Длинные указатели (также называемые *дальнеимися указателями*) являются наследие из 16-разрядных окон, когда они были необходимы для адресации диапазонов памяти за пределами текущего сегмента. Префикс *LP* был сохранен, чтобы упростить перенос 16-разрядного кода в 32-разрядную версию Windows. На сегодняшний день нет различий — указатель является указателем.

### <a name="pointer-precision-types"></a>Типы точности указателей

Следующие типы данных всегда имеют размер указателя, то есть 32 бит в 32-разрядных приложениях и 64 бит на уровне в 64-разрядных приложениях. Размер определяется во время компиляции. Если 32-разрядное приложение выполняется в 64-разрядной версии Windows, эти типы данных по-прежнему имеют ширину 4 байта. (64-разрядное приложение не может работать в 32-разрядной версии Windows, поэтому обратная ситуация не возникает.)

-   **DWORD \_ ptr**
-   **INT \_ ptr**
-   **LONG \_ ptr**
-   **ULONG- \_ ptr**
-   **UINT \_ ptr**

Эти типы используются в ситуациях, когда целочисленное значение может быть приведено к указателю. Они также используются для определения переменных для арифметических операций с указателями и для определения счетчиков циклов, которые просматривают весь диапазон байтов в буферах памяти. В общем случае они появляются в местах, где существующее 32-разрядное значение было расширено до 64 бит в 64-разрядной версии Windows.

## <a name="hungarian-notation"></a>Венгерская нотация

*Венгерская нотация* — это практика добавления префиксов к именам переменных для предоставления дополнительных сведений о переменной. (Инвентаризация в нотации, Чарльз Симони, была венгерской, поэтому ее имя).

В исходной форме нотация Венгерская информация предоставляет *семантическую* информацию о переменной, которая сообщает вам о предполагаемом использовании. Например, *я* обозначает индекс, *CB* означает размер в байтах ("количество байт"), а значения строк и столбцов для значений *RW* и *Col* . Эти префиксы предназначены для того, чтобы избежать случайного использования переменной в неправильном контексте. Например, если вы видели выражение `rwPosition +  cbTable` , вы узнаете, что к размеру добавляется номер строки, что почти наверняка является ошибкой в коде.

Более распространенная форма венгерской нотации использует префиксы для предоставления сведений о *типе* , например *DW* для **DWORD** и *w* для **Word**.

При поиске в Интернете по «венгерской нотации» вы найдете множество мнений о том, хорошо ли Венгерская нотация. Некоторые программисты имеют сильная отличие от венгерской нотации. Другие считают это полезным. Независимо от многих примеров кода на MSDN используется Венгерская нотация, но вам не нужно запоминать префиксы для понимания кода.

## <a name="next"></a>Следующая

[Работа со строками](working-with-strings.md)

 

 