---
title: Работа со строками
description: Работа со строками
ms.assetid: 876ff8bb-67c3-4dcc-aa94-7fbd915c67dc
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4661c6b07a267d90e0fca05d04354c018be04527
ms.sourcegitcommit: 95685061d5b0333bbf9e6ebd208dde8190f97005
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2021
ms.locfileid: "108110972"
---
# <a name="working-with-strings"></a>Работа со строками

Windows изначально поддерживает строки в Юникоде для элементов пользовательского интерфейса, имен файлов и т. д. Юникод — предпочтительная кодировка символов, так как она поддерживает все наборы символов и языки. Windows представляет символы Юникода, используя кодировку UTF-16, в которой каждый символ кодируется как 16-разрядное значение. Символы UTF-16 называются *расширенными* символами, чтобы отличать их от 8-разрядных символов ANSI. Компилятор Visual C++ поддерживает встроенный тип данных **WCHAR \_ t** для расширенных символов. Файл заголовка WinNT. h также определяет следующий **typedef**.


```C++
typedef wchar_t WCHAR;
```



Обе версии будут отображаться в примере кода MSDN. Чтобы объявить литерал расширенных символов или строковый литерал расширенных символов, добавьте **L** перед литералом.


```C++
wchar_t a = L'a';
wchar_t *str = L"hello";
```



Вот некоторые другие определения типов, связанные со строками, которые вы увидите:



| Typedef                   | Определение       |
|---------------------------|------------------|
| **CHAR**                  | `char`           |
| **ПСТР** или **LPSTR**     | `char*`          |
| **Пкстр** или **LPCSTR**   | `const char*`    |
| **Пвстр** или **LPWSTR**   | `wchar_t*`       |
| **Пквстр** или **лпквстр** | `const wchar_t*` |



 

## <a name="unicode-and-ansi-functions"></a>Функции Юникода и ANSI

Когда корпорация Майкрософт ввела в Windows поддержку Юникода, она облегчило переход, предоставляя два параллельных набора API — один для строк ANSI, а другой для строк Юникода. Например, существует две функции для задания текста в строке заголовка окна:

-   **Сетвиндовтекста** принимает строку ANSI.
-   **Сетвиндовтекств** принимает строку в Юникоде.

На внутреннем уровне версия ANSI преобразует строку в Юникод. Заголовки Windows также определяют макрос, который разрешается в версию Юникода, если определен символ препроцессора `UNICODE` или если в противном случае используется версия ANSI.


```C++
#ifdef UNICODE
#define SetWindowText  SetWindowTextW
#else
#define SetWindowText  SetWindowTextA
#endif 
```



В библиотеке MSDN функция задокументирована под именем [**SetWindowText**](/windows/desktop/api/winuser/nf-winuser-setwindowtexta), хотя в действительности это имя макроса, а не имя самой функции.

Новые приложения всегда должны вызывать версии Юникода. Для многих языков мира требуется Юникод. Если вы используете строки ANSI, локализация приложения будет невозможно. Версии ANSI также менее эффективны, так как операционная система должна преобразовать строки ANSI в Юникод во время выполнения. В зависимости от предпочтений можно вызывать функции Юникода явным образом, например **сетвиндовтекств**, или использовать макросы. Пример кода в MSDN обычно вызывает макросы, но эти две формы точно эквивалентны. Большинство новых интерфейсов API в Windows имеют только версию Юникода, без соответствующей версии ANSI.

## <a name="tchars"></a>тчарс

Когда приложения, необходимые для поддержки Windows NT, а также Windows 95, Windows 98 и Windows Me, имели смысл компилировать один и тот же код для строк ANSI или Юникод в зависимости от целевой платформы. Для этого Windows SDK предоставляет макросы, которые сопоставляют строки с Юникодом или ANSI в зависимости от платформы.



| Макрос     | Юникод   | ANSI   |
|-----------|-----------|--------|
| TCHAR     | `wchar_t` | `char` |
| ТЕКСТ ("x") | `L"x"`    | `"x"`  |



 

Например, приведенный ниже код


```C++
SetWindowText(TEXT("My Application"));
```



разрешается в одно из следующих:


```C++
SetWindowTextW(L"My Application"); // Unicode function with wide-character string.

SetWindowTextA("My Application");  // ANSI function.
```



Макросы **Text** и **TCHAR** менее полезны в настоящее время, так как все приложения должны использовать Юникод. Однако они могут отображаться в старом коде и в некоторых примерах кода MSDN.

Заголовки библиотек времени выполнения Microsoft C определяют аналогичный набор макросов. Например, **\_ ткслен** разрешается в **strlen** , если `_UNICODE` не определен. в противном случае он разрешается в **wcslen**, который является версией **strlen** для расширенных символов.


```C++
#ifdef _UNICODE
#define _tcslen     wcslen
#else
#define _tcslen     strlen
#endif 
```



Будьте внимательны: в некоторых заголовках используется символ препроцессора `UNICODE` , а другие используют `_UNICODE` префикс подчеркивания. Всегда определяйте оба символа. Visual C++ задает их обоими по умолчанию при создании нового проекта.

## <a name="next"></a>Следующая

[Что такое окно?](what-is-a-window-.md)

 

 
