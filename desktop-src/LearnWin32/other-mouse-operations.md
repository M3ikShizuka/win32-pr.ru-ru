---
title: Различные операции мыши
description: В предыдущих разделах обсуждались щелчки мыши и перемещения мыши. Ниже приведены некоторые другие операции, которые можно выполнить с помощью мыши.
ms.assetid: 6A5B953F-7032-4AA6-8B64-2E9CBB8F59F1
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: a31877ab5a71819fa896fd1253e7391f9ed748dffff636ab9d3e8591669b7fae
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118387970"
---
# <a name="miscellaneous-mouse-operations"></a>Различные операции мыши

В предыдущих разделах обсуждались щелчки мыши и перемещения мыши. Ниже приведены некоторые другие операции, которые можно выполнить с помощью мыши.

## <a name="dragging-ui-elements"></a>Перетаскивание элементов пользовательского интерфейса

Если пользовательский интерфейс поддерживает перетаскивание элементов пользовательского интерфейса, то существует еще одна функция, которую следует вызывать в обработчике сообщений с помощью мыши: [**драгдетект**](/windows/desktop/api/winuser/nf-winuser-dragdetect). Функция **драгдетект** возвращает **значение true** , если пользователь инициирует жест мыши, который должен интерпретироваться как перетаскивание. В следующем коде показано, как использовать эту функцию.


```C++
    case WM_LBUTTONDOWN: 
        {
            POINT pt = { GET_X_LPARAM(lParam), GET_Y_LPARAM(lParam) };
            if (DragDetect(m_hwnd, pt))
            {
                // Start dragging.
            }
        }
        return 0;
```



Вот идея: когда программа поддерживает перетаскивание, каждое нажатие кнопки мыши не должно интерпретироваться как перетаскивание. В противном случае пользователь может случайно перетащить объект, если он просто щелкнул его (например, чтобы выбрать его). Но если мышь особенно важна, при нажатии на нее может быть трудно держать мышь. таким образом, Windows определяет пороговое значение перетаскивания в несколько пикселей. Когда пользователь нажимает кнопку мыши, он не считается перетаскиванием, если только указатель мыши не пересекает это пороговое значение. Функция [**драгдетект**](/windows/desktop/api/winuser/nf-winuser-dragdetect) проверяет, достигнуто ли это пороговое значение. Если функция возвращает **значение true**, щелчок мыши можно интерпретировать как перетаскивание. В противном случае — нет.

> [!Note]  
> если [**драгдетект**](/windows/desktop/api/winuser/nf-winuser-dragdetect) возвращает **значение FALSE**, Windows подавляет сообщение [**WM \_ лбуттонуп**](/windows/desktop/inputdev/wm-lbuttonup) , когда пользователь отпускает кнопку мыши. Поэтому не вызывайте **драгдетект** , если программа в данный момент находится в режиме, поддерживающем перетаскивание. (Например, если уже выбран перетаскиваемый элемент пользовательского интерфейса.) В конце этого модуля мы рассмотрим более длинный пример кода, использующий функцию **драгдетект** .

 

## <a name="confining-the-cursor"></a>Ограничивать курсор

Иногда может потребоваться ограничить курсор клиентской областью или частью клиентской области. Функция [**клипкурсор**](/windows/desktop/api/winuser/nf-winuser-clipcursor) ограничивают перемещение курсора на указанный прямоугольник. Этот прямоугольник задается в экранных координатах, а не в координатах клиента, поэтому точка (0, 0) обозначает верхний левый угол экрана. Чтобы перевести клиентские координаты в экранные координаты, вызовите функцию [**клиенттоскрин**](/windows/desktop/api/winuser/nf-winuser-clienttoscreen).

В следующем коде курсор ограничивается клиентской областью окна.


```C++
    // Get the window client area.
    RECT rc;
    GetClientRect(m_hwnd, &rc);

    // Convert the client area to screen coordinates.
    POINT pt = { rc.left, rc.top };
    POINT pt2 = { rc.right, rc.bottom };
    ClientToScreen(m_hwnd, &pt);
    ClientToScreen(m_hwnd, &pt2);
    SetRect(&rc, pt.x, pt.y, pt2.x, pt2.y);

    // Confine the cursor.
    ClipCursor(&rc);
```



[**Клипкурсор**](/windows/desktop/api/winuser/nf-winuser-clipcursor) принимает структуру [**Rect**](/previous-versions//dd162897(v=vs.85)) , но [**клиенттоскрин**](/windows/desktop/api/winuser/nf-winuser-clienttoscreen) принимает структуру [**Point**](/previous-versions//dd162805(v=vs.85)) . Прямоугольник определяется его верхней левой и нижней правой точками. Можно ограничить курсор на любую прямоугольную область, включая области за пределами окна, но ограничивать курсор в клиентскую область — типичный способ использования функции. Ограничивать курсор в регион, который полностью выходит за пределы окна, будет ненеобычным, и пользователи, вероятно, воспримет его как ошибку.

Чтобы удалить ограничение, вызовите [**клипкурсор**](/windows/desktop/api/winuser/nf-winuser-clipcursor) со значением **null**.


```C++
ClipCursor(NULL);
```



## <a name="mouse-tracking-events-hover-and-leave"></a>События отслеживания мыши: наведение и выход

Два других сообщения мыши по умолчанию отключены, но могут быть полезны для некоторых приложений:

-   [**WM \_ МАУСЕХОВЕР**](/windows/desktop/inputdev/wm-mousehover): курсор наводится на клиентскую область в течение фиксированного периода времени.
-   [**WM \_ MOUSELEAVE**](/windows/desktop/inputdev/wm-mouseleave): курсор остался в клиентской области.

Чтобы включить эти сообщения, вызовите функцию [**TrackMouseEven**](/windows/desktop/api/winuser/nf-winuser-trackmouseevent) .


```C++
    TRACKMOUSEEVENT tme;
    tme.cbSize = sizeof(tme);
    tme.hwndTrack = hwnd;
    tme.dwFlags = TME_HOVER | TME_LEAVE;
    tme.dwHoverTime = HOVER_DEFAULT;
    TrackMouseEvent(&tme);
```



Структура [**TrackMouseEven**](/windows/win32/api/winuser/ns-winuser-trackmouseevent) содержит параметры функции. Элемент **dwFlags** структуры содержит битовые флаги, указывающие, какие сообщения отслеживания вас интересуют. Вы можете получить и [**WM \_ маусеховер**](/windows/desktop/inputdev/wm-mousehover) , и [**WM \_ MOUSELEAVE**](/windows/desktop/inputdev/wm-mouseleave), как показано здесь, или только один из двух. Член **двховертиме** указывает, как долго мышь должна навести указатель мыши, прежде чем система создаст сообщение наведения. Это значение указывается в миллисекундах. Константа **\_ по умолчанию при наведении** означает использование системы по умолчанию.

После получения одного из запрошенных сообщений функция [**TrackMouseEven**](/windows/desktop/api/winuser/nf-winuser-trackmouseevent) сбрасывается. Чтобы получить другое сообщение отслеживания, необходимо вызвать его снова. Однако следует дождаться следующего сообщения, перемещая мышь, перед вызовом **TrackMouseEven** . В противном случае окно может быть переполнено сообщениями отслеживания. Например, при наведении указателя мыши система продолжит создавать поток сообщений [**WM \_ маусеховер**](/windows/desktop/inputdev/wm-mousehover) , когда мышь является стационарной. На самом деле не требуется другое сообщение **WM \_ маусеховер** , пока мышь не перемещается в другую точку и наводится на другой элемент.

Ниже приведен небольшой вспомогательный класс, который можно использовать для управления событиями отслеживания мыши.


```C++
class MouseTrackEvents
{
    bool m_bMouseTracking;

public:
    MouseTrackEvents() : m_bMouseTracking(false)
    {
    }
    
    void OnMouseMove(HWND hwnd)
    {
        if (!m_bMouseTracking)
        {
            // Enable mouse tracking.
            TRACKMOUSEEVENT tme;
            tme.cbSize = sizeof(tme);
            tme.hwndTrack = hwnd;
            tme.dwFlags = TME_HOVER | TME_LEAVE;
            tme.dwHoverTime = HOVER_DEFAULT;
            TrackMouseEvent(&tme);
            m_bMouseTracking = true;
        }
    }
    void Reset(HWND hwnd)
    {
        m_bMouseTracking = false;
    }
};
```



В следующем примере показано, как использовать этот класс в процедуре окна.


```C++
LRESULT MainWindow::HandleMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_MOUSEMOVE:
        mouseTrack.OnMouseMove(m_hwnd);  // Start tracking.

        // TODO: Handle the mouse-move message.

        return 0;

    case WM_MOUSELEAVE:

        // TODO: Handle the mouse-leave message.

        mouseTrack.Reset(m_hwnd);
        return 0;

    case WM_MOUSEHOVER:

        // TODO: Handle the mouse-hover message.

        mouseTrack.Reset(m_hwnd);
        return 0;

    }
    return DefWindowProc(m_hwnd, uMsg, wParam, lParam);
}
```



События отслеживания мыши требуют дополнительной обработки системой, поэтому оставьте их отключенными, если они не нужны.

Для полноты рассмотрим функцию, которая запрашивает у системы время ожидания при наведении по умолчанию.


```C++
UINT GetMouseHoverTime()
{
    UINT msec; 
    if (SystemParametersInfo(SPI_GETMOUSEHOVERTIME, 0, &msec, 0))
    {   
        return msec;
    }
    else
    {
        return 0;
    }
}
```



## <a name="mouse-wheel"></a>Колесико мыши

Следующая функция проверяет наличие колесика мыши.


```C++
BOOL IsMouseWheelPresent()
{
    return (GetSystemMetrics(SM_MOUSEWHEELPRESENT) != 0);
}
```



Если пользователь поворачивает колесико мыши, окно с фокусом получает сообщение [**WM \_ маусевхил**](/windows/desktop/inputdev/wm-mousewheel) . Параметр *wParam* этого сообщения содержит целочисленное значение, называемое *разностным* значением, которое измеряет расстояние поворота колесика. Дельта использует произвольные единицы, где 120 единиц определяется как поворот, необходимый для выполнения одного действия. Конечно, определение действия зависит от программы. Например, если колесико мыши используется для прокрутки текста, каждая 120 единиц вращения будет прокручиваться на одну строку текста.

Знак Дельта указывает направление поворота:

-   Положительный: поворот вперед от пользователя.
-   Отрицательно: поворот назад, направленный к пользователю.

Значение дельты помещается в *wParam* вместе с некоторыми дополнительными флагами. Чтобы получить значение разностного значения, используйте макрос [**Get \_ Wheel \_ Дельта \_ wParam**](/windows/desktop/api/winuser/nf-winuser-get_wheel_delta_wparam) .


```C++
int delta = GET_WHEEL_DELTA_WPARAM(wParam);
```



Если колесико мыши имеет высокое разрешение, абсолютное значение разницы может быть меньше 120. В этом случае, если имеет смысл выполнить действие с меньшим шагом, это можно сделать. Например, текст может прокручиваться с шагом меньше одной строки. В противном случае суммируйте общую разницу до того, как колесо поворачивается достаточно для выполнения действия. Сохраните неиспользуемую разницу в переменной и, когда 120 единиц накапливает (положительное или отрицательное), выполните действие.

## <a name="next"></a>Следующая

[Ввод с клавиатуры](keyboard-input.md)

 

 