---
title: Рисование окна
description: Вы создали окно. Теперь нужно отобразить что-то в нем. в терминологии Windows это называется рисованием окна. Чтобы смешивать метафоры, окно — это пустой холст, ожидающий его заполнения.
ms.assetid: db97a4c9-7592-42d1-a5de-9c468169eefc
ms.topic: article
ms.date: 08/16/2019
ms.openlocfilehash: 93d0cb0234975b61ee7ffc05a680b5e1e6b1e01b9d4de7235fc4239ec5573f29
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119897022"
---
# <a name="painting-the-window"></a>Рисование окна

Вы создали окно. Теперь нужно отобразить что-то в нем. в терминологии Windows это называется рисованием окна. Чтобы смешивать метафоры, окно — это пустой холст, ожидающий его заполнения.

Иногда программа запустит Рисование для обновления внешнего вида окна. В других случаях операционная система сообщит вам, что необходимо перекрасить часть окна. В этом случае операционная система отправляет окну сообщение [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) . Часть окна, которая должна быть окрашена, называется *областью обновления*.

При первом отображении окна вся клиентская область окна должна быть окрашена. Поэтому при отображении окна всегда будет отображаться по крайней мере одно сообщение [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) .

![Иллюстрация, показывающая область обновления окна](images/painting01.png)

Вы несете ответственность за рисование клиентской области. Окружающий фрейм, включая заголовок окна, автоматически зарисовывается операционной системой. После завершения заполнения клиентской области очищается регион обновления, который сообщает операционной системе, что ей не нужно отсылать другое сообщение [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) , пока что не изменится.

Теперь предположим, что пользователь перемещает другое окно, чтобы оно скрывало часть окна. Когда скрытая часть снова становится видимой, эта часть добавляется в область обновления, и окно получает другое сообщение [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) .

![Иллюстрация изменения региона обновления при перекрытии двух окон](images/painting02.png)

Регион обновления также изменяется, если пользователь растягивает окно. На следующей схеме пользователь растягивает окно вправо. Новая развернутая область в правой части окна добавляется в область обновления:

![Иллюстрация изменения области обновления при изменении размера окна](images/painting03.png)

В нашем первом примере программы подпрограмма рисования очень проста. Он просто заполняет всю клиентскую область сплошным цветом. Тем не менее, этот пример достаточно для демонстрации некоторых важных концепций.

```C++
switch (uMsg)
{
    case WM_PAINT:
    {
        PAINTSTRUCT ps;
        HDC hdc = BeginPaint(hwnd, &ps);

        // All painting occurs here, between BeginPaint and EndPaint.

        FillRect(hdc, &ps.rcPaint, (HBRUSH) (COLOR_WINDOW+1));

        EndPaint(hwnd, &ps);
    }
    return 0;
}
```

Запустите операцию рисования, вызвав функцию [**бегинпаинт**](/windows/desktop/api/winuser/nf-winuser-beginpaint) . Эта функция заполняет структуру [**PAINTSTRUCT**](/windows/win32/api/winuser/ns-winuser-paintstruct) сведениями о запросе на перерисовку. Текущий регион обновления указывается в элементе **члене rcpaint структуры** элемента **PAINTSTRUCT**. Этот регион обновления определяется относительно клиентской области:

![Иллюстрация, показывающая происхождение клиентской области](images/painting04.png)

В коде рисования есть два основных варианта:

- Paint всю клиентскую область независимо от размера региона обновления. Все, что находится за пределами области обновления, обрезается. То есть операционная система пропускает ее.
- Оптимизируйте, рисуя только часть окна внутри области обновления.

Если вы всегда рисуете всю клиентскую область, код будет проще. Однако при наличии сложной логики рисования может быть более эффективным пропускать области за пределами области обновления.

Следующая строка кода заполняет область обновления одним цветом, используя определенный системой цвет фона окна (**\_ окно цвета**). Фактический цвет, указанный **в \_ окне цвета** , зависит от текущей цветовой схемы пользователя.

```C++
FillRect(hdc, &ps.rcPaint, (HBRUSH) (COLOR_WINDOW+1));
```

Сведения о [**филлрект**](/windows/desktop/api/winuser/nf-winuser-fillrect) не важны для этого примера, но второй параметр дает координаты прямоугольника для заполнения. В этом случае мы передаем весь регион обновления (член **члене rcpaint структуры** объекта [**PAINTSTRUCT**](/windows/win32/api/winuser/ns-winuser-paintstruct)). В первом сообщении [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) вся клиентская область должна быть окрашена, поэтому **члене rcpaint структуры** будет содержать всю клиентскую область. В последующих сообщениях **WM \_ Paint** **члене rcpaint структуры** может содержать прямоугольник меньшего размера.

функция [**филлрект**](/windows/desktop/api/winuser/nf-winuser-fillrect) является частью интерфейс графических устройств (GDI), которая имеет Windows графику в течение очень долгого времени. в Windows 7 корпорация майкрософт представила новый графический механизм с именем Direct2D, который поддерживает высокопроизводительные графические операции, такие как аппаратное ускорение. Direct2D также доступен для Windows Vista через [обновление платформы для Windows Vista](../win7ip/platform-update-for-windows-vista-overview.md) и для Windows server 2008 через обновление платформы для Windows Server 2008. (GDI по-прежнему полностью поддерживается.)

Завершив рисование, вызовите функцию [**ендпаинт**](/windows/desktop/api/winuser/nf-winuser-endpaint) . эта функция очищает регион обновления, который сигнализирует, Windows, что окно завершило свою прорисовку.

## <a name="next"></a>Следующая

[Закрытие окна](closing-the-window.md)