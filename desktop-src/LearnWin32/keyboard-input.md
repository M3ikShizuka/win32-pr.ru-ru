---
title: ввод с клавиатуры (Начало работы с Win32 и C++)
description: Ввод с клавиатуры
ms.assetid: FC682E8B-8360-4D58-AC42-4CEFD9CB750F
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e3ed8ac1e8d7cd8e6ea35c9e9f58c10fd516cca010b5e5dce667817b32028c5d
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119822354"
---
# <a name="keyboard-input-get-started-with-win32-and-c"></a>ввод с клавиатуры (Начало работы с Win32 и C++)

Клавиатура используется для нескольких различных типов входных данных, включая:

-   Ввод символов. Текст, который пользователь вводит в документ или поле редактирования.
-   Сочетания клавиш. Ключевые черты, которые вызывают функции приложения; Например, CTRL + O, чтобы открыть файл.
-   Системные команды. Ключевые черты, вызывающие системные функции; Например, ALT + TAB для переключения окон.

При обдумывании ввода с клавиатуры важно помнить, что сочетание клавиш не совпадает с символом. Например, при нажатии клавиши может появиться любой из следующих символов.

-   а
-   Объект
-   б (если клавиатура поддерживает сочетание диакритических знаков)

Кроме того, если клавиша ALT удерживается, нажатие клавиши вызывает ALT + A, который система не обрабатывает как символ, а вместо системной команды.

## <a name="key-codes"></a>Коды клавиш

При нажатии клавиши оборудование создает *код сканирования*. Коды сканирования меняются от одной клавиатуры к следующей, и для событий ключа и нажатия клавиш существуют отдельные коды проверки. Вы почти не будете заботиться о кодах проверки. Драйвер клавиатуры преобразует коды проверки в *коды виртуальных клавиш*. Коды виртуальных клавиш не зависят от устройства. При нажатии клавиши на любой клавиатуре создается тот же код виртуального ключа.

В общем случае коды виртуальных клавиш не соответствуют кодам ASCII или любому другому стандарту кодировки символов. Это очевидно, если вы думаете о нем, так как один и тот же ключ может создавать разные символы (a, б), а некоторые ключи, такие как функциональные клавиши, не соответствуют какому-либо символу.

С другой стороны, следующие коды виртуальных клавиш соответствуют эквивалентам ASCII:

-   от 0 до 9 ключей = ASCII "0" – "9" (0x30 – 0x39)
-   От A до Z клавиш = ASCII ' A ' – ' Z ' (0x41 влево – 0x5A)

В некоторых отношениях это сопоставление относится к сожалению, поскольку в этом случае не следует думать о кодах виртуальных клавиш как символах, по указанным причинам.

Файл заголовка WinUser. h определяет константы для большинства кодов виртуальных клавиш. Например, код виртуального ключа для клавиши со стрелкой влево — **VK \_ Left** (0x25). Полный список кодов виртуальных ключей см. в разделе [**коды виртуальных ключей**](/windows/desktop/inputdev/virtual-key-codes). Для кодов виртуальных клавиш, соответствующих значениям ASCII, константы не определены. Например, код виртуального ключа для ключа — 0x41 влево, но нет константы с именем **VK \_ A**. Вместо этого просто используйте числовое значение.

## <a name="key-down-and-key-up-messages"></a>Сообщения Key-Down и Key-Up

При нажатии клавиши окно с фокусом клавиатуры получает одно из следующих сообщений.

-   [**WM \_ сискэйдовн**](/windows/desktop/inputdev/wm-syskeydown)
-   [**WM \_ KeyDown**](/windows/desktop/inputdev/wm-keydown)

Сообщение [**WM \_ сискэйдовн**](/windows/desktop/inputdev/wm-syskeydown) указывает на *системный ключ*, который является ключевым росчерком, вызывающим системную команду. Существует два типа системного ключа:

-   ALT + любой ключ
-   F10

Клавиша F10 активирует строку меню окна. Различные сочетания ALT-клавиш вызывают системные команды. Например, клавиши ALT + TAB переключились на новое окно. Кроме того, если окно содержит меню, клавишу ALT можно использовать для активации пунктов меню. Некоторые сочетания клавиш ALT не выполняют никаких действий.

Все остальные сочетания клавиш считаются несистемными ключами и создают сообщение [**WM \_ KeyDown**](/windows/desktop/inputdev/wm-keydown) . Сюда входят функциональные клавиши, отличные от F10.

При освобождении ключа система отправляет соответствующее сообщение о ключе:

-   [**WM \_ KEYUP**](/windows/desktop/inputdev/wm-keyup)
-   [**WM \_ сискэйуп**](/windows/desktop/inputdev/wm-syskeyup)

Если удерживать ключ достаточно долго для запуска функции повтора клавиатуры, система отправляет несколько сообщений о ключах, за которыми следует одно сообщение о нажатии.

Во всех четырех описанных выше сообщениях клавиатуры параметр *wParam* содержит код виртуального ключа. Параметр *lParam* содержит некоторые прочие сведения, упакованные в 32 бит. Как правило, сведения не нужны в параметре *lParam*. Одним из флагов, которые могут быть полезны, является бит 30, флаг "предыдущее состояние ключа" которого имеет значение 1 для повторяющихся сообщений о нажатии клавиш.

Как следует из названия, системные клавиши обводки в основном предназначены для использования операционной системой. Если вы перехватите сообщение [**WM \_ сискэйдовн**](/windows/desktop/inputdev/wm-syskeydown) , вызовите [**дефвиндовпрок**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) позже. В противном случае операционная система будет заблокирована для обработки команды.

## <a name="character-messages"></a>Символьные сообщения

При помощи функции [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) , которую мы впервые видели в [модуле 1](your-first-windows-program.md), они преобразуются в символы. Эта функция проверяет сообщения о нажатии клавиш и преобразует их в символы. Для каждого созданного символа функция **TranslateMessage** помещает сообщение [**WM \_ char**](/windows/desktop/inputdev/wm-char) или [**WM \_ сисчар**](/windows/desktop/menurc/wm-syschar) в очередь сообщений окна. Параметр *wParam* сообщения содержит символ UTF-16.

Как вы можете догадаться, сообщения [**WM \_ char**](/windows/desktop/inputdev/wm-char) формируются из сообщений [**WM \_ KeyDown**](/windows/desktop/inputdev/wm-keydown) , а сообщения [**WM \_ сисчар**](/windows/desktop/menurc/wm-syschar) создаются из сообщений [**WM \_ сискэйдовн**](/windows/desktop/inputdev/wm-syskeydown) . Например, предположим, что пользователь нажимает клавишу SHIFT, а затем ключ. При условии стандартной раскладки клавиатуры вы получите следующую последовательность сообщений:

**WM \_ KEYDOWN**: Shift  
**WM \_ KEYDOWN**: A  
**WM \_ CHAR**: ' A '  


С другой стороны, сочетание ALT + P создаст следующее:

 **WM \_ СИСКЭЙДОВН**: \_ меню VK  
**WM \_ СИСКЭЙДОВН**: 0x50  
**WM \_ СИСЧАР**: "p"  
**WM \_ СИСКЭЙУП**: 0x50  
**WM \_ Клавиша вверх**: VK \_ меню  


(Код виртуального ключа для клавиши ALT называется VK \_ МЕНЮ по историческим причинам.)

Сообщение [**WM \_ сисчар**](/windows/desktop/menurc/wm-syschar) указывает системный символ. Как и в [**WM \_ сискэйдовн**](/windows/desktop/inputdev/wm-syskeydown), это сообщение обычно следует передавать непосредственно в [**дефвиндовпрок**](/windows/desktop/api/winuser/nf-winuser-defwindowproca). В противном случае может возникнуть конфликт со стандартными системными командами. В частности, не следует рассматривать **WM \_ сисчар** как текст, вводимый пользователем.

Сообщение [**WM \_ char**](/windows/desktop/inputdev/wm-char) — это то, что обычно можно считать символьным вводом. Тип данных для символа — **WCHAR \_ t**, представляющий символ Юникода UTF-16. Символьные данные могут содержать символы за пределами диапазона ASCII, особенно с раскладками клавиатуры, которые обычно используются за пределами США. Вы можете попробовать различные раскладки клавиатуры, установив региональную клавиатуру, а затем используя функцию экранной клавиатуры.

Пользователи также могут установить редактор метода ввода (IME) для ввода сложных наборов символов, таких как японские символы, с помощью стандартной клавиатуры. Например, используя японский редактор IME для ввода символа катакана カ (ка), вы можете получить следующие сообщения:

**WM \_ KEYDOWN**: VK \_ процесскэй (клавиша обработки IME)  
**WM \_ Клавиша вверх**: 0x4B  
**WM \_ KEYDOWN**: VK \_ процесскэй  
**WM \_ Клавиша вверх**: 0x41 влево  
**WM \_ KEYDOWN**: VK \_ процесскэй  
**WM \_ CHAR**: カ  
**WM \_ Клавиша вверх**: VK \_ return  


Некоторые сочетания клавиш CTRL преобразуются в управляющие символы ASCII. Например, CTRL + A преобразуется в символ ASCII CTRL-A (SOH) (значение ASCII 0x01). Для ввода текста обычно следует отфильтровывать управляющие символы. Кроме того, не следует использовать [**WM \_ char**](/windows/desktop/inputdev/wm-char) для реализации сочетаний клавиш. Вместо этого используйте сообщения с помощью [**WM \_ KeyDown**](/windows/desktop/inputdev/wm-keydown) или еще лучше, используя таблицу сочетаний клавиш. Таблицы ускорителей описаны в следующем разделе: [таблицы сочетаний клавиш](accelerator-tables.md).

В следующем коде отображаются основные сообщения клавиатуры в отладчике. Попробуйте воспроизвести различные сочетания клавиш и посмотрите, какие сообщения создаются.


```C++
LRESULT CALLBACK WindowProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    wchar_t msg[32];
    switch (uMsg)
    {
    case WM_SYSKEYDOWN:
        swprintf_s(msg, L"WM_SYSKEYDOWN: 0x%x\n", wParam);
        OutputDebugString(msg);
        break;

    case WM_SYSCHAR:
        swprintf_s(msg, L"WM_SYSCHAR: %c\n", (wchar_t)wParam);
        OutputDebugString(msg);
        break;

    case WM_SYSKEYUP:
        swprintf_s(msg, L"WM_SYSKEYUP: 0x%x\n", wParam);
        OutputDebugString(msg);
        break;

    case WM_KEYDOWN:
        swprintf_s(msg, L"WM_KEYDOWN: 0x%x\n", wParam);
        OutputDebugString(msg);
        break;

    case WM_KEYUP:
        swprintf_s(msg, L"WM_KEYUP: 0x%x\n", wParam);
        OutputDebugString(msg);
        break;

    case WM_CHAR:
        swprintf_s(msg, L"WM_CHAR: %c\n", (wchar_t)wParam);
        OutputDebugString(msg);
        break;

    /* Handle other messages (not shown) */

    }
    return DefWindowProc(m_hwnd, uMsg, wParam, lParam);
}
```



## <a name="miscellaneous-keyboard-messages"></a>Различные сообщения клавиатуры

Большинство приложений могут спокойно игнорировать некоторые другие сообщения клавиатуры.

-   Сообщение [**WM \_ деадчар**](/windows/desktop/inputdev/wm-deadchar) отправляется для комбинированного ключа, например диакритических знаков. Например, на клавиатуре для испанского языка при вводе диакритических знаков ('), за которыми следует буква «E». Для символа ударения отправляется **\_ деадчар WM** .
-   Сообщение [**WM \_ уничар**](/windows/desktop/inputdev/wm-unichar) устарело. Он позволяет программам ANSI принимать входные символы Юникода.
-   Символ [**\_ IME редактора \_ WM**](/windows/desktop/Intl/wm-ime-char) ОТПРАВЛЯЕТСЯ, когда редактор IME преобразует последовательность нажатия клавиш в символы. Он отправляется в дополнение к обычному сообщению [**WM \_ char**](/windows/desktop/inputdev/wm-char) .

## <a name="keyboard-state"></a>Состояние клавиатуры

Сообщения клавиатуры управляются событиями. То есть вы получаете сообщение, когда что-нибудь интересное, например нажатие клавиши, и сообщение сообщает о том, что произошло. Но вы также можете проверить состояние ключа в любое время, вызвав функцию [**жеткэйстате**](/windows/desktop/api/winuser/nf-winuser-getkeystate) .

Например, рассмотрим, как можно определить сочетание левой кнопки мыши + ALT. Вы можете отвести состояние клавиши ALT, прослушивая сообщения о нажатии клавиш и сохранив флаг, но [**жеткэйстате**](/windows/desktop/api/winuser/nf-winuser-getkeystate) экономит проблемы. При получении сообщения [**WM \_ лбуттондовн**](/windows/desktop/inputdev/wm-lbuttondown) просто вызовите **жеткэйстате** следующим образом:


```C++
if (GetKeyState(VK_MENU) & 0x8000))
{
    // ALT key is down.
}
```



Сообщение [**жеткэйстате**](/windows/desktop/api/winuser/nf-winuser-getkeystate) принимает в качестве входных данных код виртуального ключа и возвращает набор битовых флагов (на самом деле только два флага). Значение 0x8000 содержит битовый флаг, который проверяет, нажата ли клавиша в данный момент.

Большинство клавиатур имеют две клавиши ALT слева и справа. В предыдущем примере проверяется, была ли нажата одна из них. Можно также использовать [**жеткэйстате**](/windows/desktop/api/winuser/nf-winuser-getkeystate) для различения левого и правого экземпляров клавиш ALT, Shift или CTRL. Например, следующий код проверяет, нажата ли правая клавиша ALT.


```C++
if (GetKeyState(VK_RMENU) & 0x8000))
{
    // Right ALT key is down.
}
```



Функция [**жеткэйстате**](/windows/desktop/api/winuser/nf-winuser-getkeystate) является интересной, так как она сообщает о состоянии *виртуальной* клавиатуры. Это виртуальное состояние основано на содержимом очереди сообщений и обновляется при удалении сообщений из очереди. По мере того как программа обрабатывает сообщения окна, **жеткэйстате** предоставляет моментальный снимок клавиатуры во время постановки каждого сообщения в очередь. Например, если Последнее сообщение в очереди — [**WM \_ лбуттондовн**](/windows/desktop/inputdev/wm-lbuttondown), **жеткэйстате** сообщает о состоянии клавиатуры в момент нажатия пользователем кнопки мыши.

Так как [**жеткэйстате**](/windows/desktop/api/winuser/nf-winuser-getkeystate) основан на очереди сообщений, она также игнорирует ввод с клавиатуры, отправленный в другую программу. Если пользователь переключается на другую программу, любые нажатия клавиш, отправленные в эту программу, игнорируются **жеткэйстате**. Если вы действительно хотите получить немедленное физическое состояние клавиатуры, существует функция для этого: [**жетасинккэйстате**](/windows/desktop/api/winuser/nf-winuser-getasynckeystate). Однако для большинства кода пользовательского интерфейса правильная функция — **жеткэйстате**.

## <a name="next"></a>Следующая

[Таблицы сочетаний клавиш](accelerator-tables.md)

 

 
