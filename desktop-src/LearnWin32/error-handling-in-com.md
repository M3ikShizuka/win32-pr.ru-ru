---
title: Обработка ошибок в COM (начало работы с Win32 и C++)
description: Обработка ошибок в COM (начало работы с Win32 и C++)
ms.assetid: 022ca652-59d2-4513-9d73-1c6d8688c478
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b69cf89170087469fa6ef8587fb5377e6374f6a8
ms.sourcegitcommit: 95685061d5b0333bbf9e6ebd208dde8190f97005
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 04/28/2021
ms.locfileid: "108103922"
---
# <a name="error-handling-in-com-get-started-with-win32-and-c"></a>Обработка ошибок в COM (начало работы с Win32 и C++)

COM использует значения **HRESULT** для указания на успешное или неуспешное завершение метода или вызова функции. Различные заголовки SDK определяют различные константы **HRESULT** . Общий набор кодов на уровне системы определяется в файле WinError. h. В следующей таблице показаны некоторые коды возврата для всей системы.



| Константа            | Числовое значение | Описание                                          |
|---------------------|---------------|------------------------------------------------------|
| **E \_ ACCESSDENIED** | 0x80070005    | Access denied. (Недопустимое значение {значение_утверждения} для утверждения {имя_утверждения}. Доступ запрещен.)                                       |
| **\_Ошибка E**         | 0x80004005    | Незаданная ошибка.                                   |
| **E \_ INVALIDARG**   | 0x80070057    | Недопустимое значение параметра.                             |
| **E \_ OUTOFMEMORY**  | 0x8007000E    | Недостаточно памяти.                                       |
| **\_указатель E**      | 0x80004003    | Значение **null** передано неверно для значения указателя. |
| **\_непредвиденная E**   | 0x8000FFFF    | Непредвиденное условие.                                |
| **\_ОК**           | 0x0           | Успешно.                                             |
| **S \_ false**        | 0x1           | Успешно.                                             |



 

Все константы с префиксом "E \_ " являются кодами ошибок. Константы **s \_ OK** и **\_ false** имеют оба кода успеха. Вероятно, 99% методов COM возвращают **S \_ ОК** , когда они успешны, но не позволяют этому факту выдать себя. Метод может вернуть другие коды успеха, поэтому всегда проверяйте наличие ошибок с помощью макроса Success [**или**](/windows/desktop/api/winerror/nf-winerror-succeeded) [**Failed**](/windows/desktop/api/winerror/nf-winerror-failed) . В следующем примере кода показан неправильный способ и правильный способ проверки успеха вызова функции.


```C++
// Wrong.
HRESULT hr = SomeFunction();
if (hr != S_OK)
{
    printf("Error!\n"); // Bad. hr might be another success code.
}

// Right.
HRESULT hr = SomeFunction();
if (FAILED(hr))
{
    printf("Error!\n"); 
}
```



Код успеха " **\_ false** " заслуживает упоминания. Некоторые методы используют **\_ значение false** для среднего, приблизительного, отрицательного условия, которое не является ошибкой. Он также может указывать на отсутствие операции — метод прошел, но не действовал. Например, функция [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex) возвращает **\_ значение S false** , если вы вызываете его второй раз из того же потока. Если необходимо отличить значения от **s \_ ОК** и **s \_ false** в коде, следует протестировать значение напрямую, но по-прежнему использовать [**неудачные**](/windows/desktop/api/winerror/nf-winerror-failed) или [**успешные**](/windows/desktop/api/winerror/nf-winerror-succeeded) операции для решения оставшихся вариантов, как показано в следующем примере кода.


```C++
if (hr == S_FALSE)
{
    // Handle special case.
}
else if (SUCCEEDED(hr))
{
    // Handle general success case.
}
else
{
    // Handle errors.
    printf("Error!\n"); 
}
```



Некоторые значения **HRESULT** относятся к определенной функции или подсистеме Windows. Например, графический API Direct2D определяет код ошибки **D2DERR \_ неподдерживаемый \_ \_ Формат пикселей**, то есть программа использовала неподдерживаемый формат пикселей. В документации MSDN часто содержится список конкретных кодов ошибок, которые может возвращать метод. Однако не следует думать о том, чтобы эти списки были обвышены. Метод всегда может возвращать значение **HRESULT** , не указанное в документации. Опять же, используйте макросы [**успешно**](/windows/desktop/api/winerror/nf-winerror-succeeded) и [**Failed**](/windows/desktop/api/winerror/nf-winerror-failed) . Если вы тестируете конкретный код ошибки, включите также вариант по умолчанию.


```C++
if (hr == D2DERR_UNSUPPORTED_PIXEL_FORMAT)
{
    // Handle the specific case of an unsupported pixel format.
}
else if (FAILED(hr))
{
    // Handle other errors.
}
```



## <a name="patterns-for-error-handling"></a>Шаблоны для обработки ошибок

В этом разделе рассматриваются некоторые закономерности обработки ошибок COM в структурированном виде. Каждый шаблон имеет свои преимущества и недостатки. В некоторой степени, по своему усмотрению. Если вы работаете над существующим проектом, возможно, у него уже есть рекомендации по написанию кода, проскрибе определенный стиль. Независимо от выбранного шаблона надежный код будет следовать следующим правилам.

-   Для каждого метода или функции, возвращающей **HRESULT**, проверьте возвращаемое значение перед продолжением.
-   Освободите ресурсы после их использования.
-   Не пытайтесь получить доступ к недопустимым или неинициализированным ресурсам, таким как указатели **null** .
-   Не пытайтесь использовать ресурс после его выпуска.

Учитывая эти правила, вот четыре шаблона обработки ошибок.

-   [Вложенная IFS](#nested-ifs)
-   [Каскадная IFS](#cascading-ifs)
-   [Сбой перехода](#jump-on-fail)
-   [Выдать ошибку при сбое](#throw-on-fail)

### <a name="nested-ifs"></a>Вложенная IFS

После каждого вызова, возвращающего **значение HRESULT**, используйте оператор **If** для проверки успешности. Затем вставьте следующий вызов метода в область оператора **If** . Другие операторы **If** могут быть вложенными при необходимости. В предыдущих примерах кода в этом модуле используется этот шаблон, но это еще раз:


```C++
HRESULT ShowDialog()
{
    IFileOpenDialog *pFileOpen;

    HRESULT hr = CoCreateInstance(__uuidof(FileOpenDialog), NULL, 
        CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&pFileOpen));
    if (SUCCEEDED(hr))
    {
        hr = pFileOpen->Show(NULL);
        if (SUCCEEDED(hr))
        {
            IShellItem *pItem;
            hr = pFileOpen->GetResult(&pItem);
            if (SUCCEEDED(hr))
            {
                // Use pItem (not shown). 
                pItem->Release();
            }
        }
        pFileOpen->Release();
    }
    return hr;
}
```



Преимущества

-   Переменные могут быть объявлены с минимальной областью действия. Например, *питем* не объявлен до тех пор, пока не будет использоваться.
-   В каждом операторе **If** некоторые инварианты имеют значение true: все предыдущие вызовы успешно выполнены, и все полученные ресурсы остаются действительными. В предыдущем примере, когда программа достигает самого внутреннего оператора **If** , известно, что оба *питем* и *пфилеопен* являются допустимыми.
-   Ясно, когда следует освобождать указатели интерфейса и другие ресурсы. Ресурс освобождается в конце оператора **If** , который сразу же следует за вызовом, получившим ресурс.

Недостатки

-   Некоторые люди находят глубокое вложение, сложное для чтения.
-   Обработка ошибок в сочетании с другими операторами ветвления и циклом. Это может усложнить создание всей логики программы.

### <a name="cascading-ifs"></a>Каскадная IFS

После каждого вызова метода используйте оператор **If** для проверки успешности. Если метод выполняется, поместите вызов следующего метода внутри блока **If** . Но вместо того, чтобы вложить последующие операторы **If** , поместите каждый последующий [**удачный**](/windows/desktop/api/winerror/nf-winerror-succeeded) тест после предыдущего блока **If** . Если какой-либо из методов завершается ошибкой, все оставшиеся **успешно выполненные** тесты просто завершаются сбоем до тех пор, пока не будет достигнут конец функции.


```C++
HRESULT ShowDialog()
{
    IFileOpenDialog *pFileOpen = NULL;
    IShellItem *pItem = NULL;

    HRESULT hr = CoCreateInstance(__uuidof(FileOpenDialog), NULL, 
        CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&pFileOpen));

    if (SUCCEEDED(hr))
    {
        hr = pFileOpen->Show(NULL);
    }
    if (SUCCEEDED(hr))
    {
        hr = pFileOpen->GetResult(&pItem);
    }
    if (SUCCEEDED(hr))
    {
        // Use pItem (not shown).
    }

    // Clean up.
    SafeRelease(&pItem);
    SafeRelease(&pFileOpen);
    return hr;
}
```



В этом шаблоне ресурсы освобождаются в самом конце функции. При возникновении ошибки некоторые указатели могут быть недопустимыми при выходе из функции. Вызов [**Release**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) на недопустимом указателе приведет к сбою программы (или хуже), поэтому необходимо инициализировать все указатели на **значение NULL** и проверить, не равны ли они **значению NULL** перед их освобождением. В этом примере используется `SafeRelease` функция; смарт-указатели также являются хорошим выбором.

При использовании этого шаблона необходимо соблюдать осторожность при использовании циклических конструкций. В цикле прерывается в цикле, если происходит сбой любого вызова.

Преимущества

-   Этот шаблон создает меньше вложений, чем шаблон "Nested IFS".
-   Общий поток управления более удобен для просмотра.
-   Ресурсы освобождаются в одной точке кода.

Недостатки

-   Все переменные должны быть объявлены и инициализированы в верхней части функции.
-   Если вызов завершается неудачно, функция выполняет несколько ненужных проверок ошибок вместо того, чтобы немедленно выйти из функции.
-   Поскольку поток управления просматривает функцию после сбоя, необходимо соблюдать осторожность во всем тексте функции, чтобы не обращаться к недопустимым ресурсам.
-   Для ошибок внутри цикла требуется специальный случай.

### <a name="jump-on-fail"></a>Сбой перехода

После каждого вызова метода протестируйте ошибку (не удалось). При сбое перейдите к метке в нижней части функции. После метки, но перед выходом из функции Освободите ресурсы.


```C++
HRESULT ShowDialog()
{
    IFileOpenDialog *pFileOpen = NULL;
    IShellItem *pItem = NULL;

    HRESULT hr = CoCreateInstance(__uuidof(FileOpenDialog), NULL, 
        CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&pFileOpen));
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pFileOpen->Show(NULL);
    if (FAILED(hr))
    {
        goto done;
    }

    hr = pFileOpen->GetResult(&pItem);
    if (FAILED(hr))
    {
        goto done;
    }

    // Use pItem (not shown).

done:
    // Clean up.
    SafeRelease(&pItem);
    SafeRelease(&pFileOpen);
    return hr;
}
```



Преимущества

-   Общий поток управления очень удобен для просмотра.
-   В любой точке кода после [**неудачной**](/windows/desktop/api/winerror/nf-winerror-failed) проверки, если вы не перейдете к метке, гарантируется, что все предыдущие вызовы были успешно выполнены.
-   Ресурсы освобождаются в одном месте кода.

Недостатки

-   Все переменные должны быть объявлены и инициализированы в верхней части функции.
-   Некоторым программистам не нужно использовать **goto** в своем коде. (Однако следует отметить, что такое использование **goto** очень структурировано; код никогда не переходит за пределы текущего вызова функции.)
-   операторы **goto** пропускают инициализаторы.

### <a name="throw-on-fail"></a>Выдать ошибку при сбое

Вместо перехода к метке можно вызвать исключение при сбое метода. Это может привести к созданию более идиоматическим стиля C++, если вы используете для написания безопасного кода.


```C++
#include <comdef.h>  // Declares _com_error

inline void throw_if_fail(HRESULT hr)
{
    if (FAILED(hr))
    {
        throw _com_error(hr);
    }
}

void ShowDialog()
{
    try
    {
        CComPtr<IFileOpenDialog> pFileOpen;
        throw_if_fail(CoCreateInstance(__uuidof(FileOpenDialog), NULL, 
            CLSCTX_INPROC_SERVER, IID_PPV_ARGS(&pFileOpen)));

        throw_if_fail(pFileOpen->Show(NULL));

        CComPtr<IShellItem> pItem;
        throw_if_fail(pFileOpen->GetResult(&pItem));

        // Use pItem (not shown).
    }
    catch (_com_error err)
    {
        // Handle error.
    }
}
```



Обратите внимание, что в этом примере для управления указателями интерфейса используется класс **CComPtr** . Как правило, если код создает исключения, следует следовать шаблону RAII (получение ресурсов — инициализация). То есть каждый ресурс должен управляться объектом, деструктор которого гарантирует, что ресурс будет освобожден надлежащим образом. При возникновении исключения гарантируется вызов деструктора. В противном случае программа может утечек ресурсов.

Преимущества

-   Совместимо с существующим кодом, использующим обработку исключений.
-   Совместимо с библиотеками C++, которые создают исключения, такие как библиотека стандартных шаблонов (STL).

Недостатки

-   Требуются объекты C++ для управления ресурсами, такими как память или дескрипторы файлов.
-   Необходимо хорошо понимать, как писать код, защищенный с помощью исключений.

## <a name="next"></a>Следующая

[Модуль 3. Графика Windows](module-3---windows-graphics.md)

 

 
