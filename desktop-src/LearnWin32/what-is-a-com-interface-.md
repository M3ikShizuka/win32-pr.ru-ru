---
title: Что такое COM-интерфейс
description: Что такое COM-интерфейс
ms.assetid: 36f27a58-cc63-4b67-bdcb-8f9a19650c6a
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d4a6eac63fb6395e04f36c89826a392046c906a70105e19bb6b9514975d89197
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118387616"
---
# <a name="what-is-a-com-interface"></a>Что такое COM-интерфейс?

Если вы знаете C# или Java, интерфейсы должны быть привычными концепциями. *Интерфейс* определяет набор методов, которые может поддерживать объект, без диктовки каких-либо сведений о реализации. Интерфейс помечает четкие границы между кодом, который вызывает метод, и кодом, реализующим метод. В условиях компьютерной науки вызывающий объект *отделен* от реализации.

![Иллюстрация, демонстрирующая границу интерфейса между объектом и приложением](images/com01.png)

В C++ ближайший эквивалент интерфейса является чистым виртуальным классом, то есть классом, который содержит только чистые виртуальные методы и не имеет других членов. Ниже приведен гипотетический пример интерфейса:

```C++
// The following is not actual COM.

// Pseudo-C++:

interface IDrawable
{
    void Draw();
};
```

Идея этого примера состоит в том, что набор объектов в некоторой графической библиотеке может быть нарисован. `IDrawable`Интерфейс определяет операции, которые должен поддерживать любой объект, поддерживающий рисование. (По соглашению имена интерфейсов начинаются с "I".) В этом примере `IDrawable` интерфейс определяет одну операцию: `Draw` .

Все интерфейсы являются *абстрактными*, поэтому программа не может создать экземпляр `IDrawable` объекта таким образом. Например, следующий код не компилируется.

```C++
IDrawable draw;
draw.Draw();
```

Вместо этого библиотека графики предоставляет объекты, *реализующие* `IDrawable` интерфейс. Например, Библиотека может предоставить объект Shape для рисования фигур и растровый объект для рисования изображений. В C++ это делается путем наследования от общего абстрактного базового класса:

```C++
class Shape : public IDrawable
{
public:
    virtual void Draw();    // Override Draw and provide implementation.
};

class Bitmap : public IDrawable
{
public:
    virtual void Draw();    // Override Draw and provide implementation.
};
```

`Shape`Классы и `Bitmap` определяют два различных типа рисуемого объекта. Каждый класс наследует от `IDrawable` и предоставляет собственную реализацию `Draw` метода. Естественно, две реализации могут значительно различаться. Например, `Shape::Draw` метод может расрастрировать набор строк, тогда как `Bitmap::Draw` бы Блит массив пикселей.

Программа, использующая эту библиотеку, будет обрабатывать `Shape` `Bitmap` объекты и `IDrawable` с помощью указателей, а не `Shape` напрямую использовать или `Bitmap` указатели.

```C++
IDrawable *pDrawable = CreateTriangleShape();

if (pDrawable)
{
    pDrawable->Draw();
}
```

Ниже приведен пример, в котором циклический перебор массива `IDrawable` указателей. Массив может содержать разнородный ассортимент фигур, точечных рисунков и других графических объектов при условии, что каждый объект в массиве наследуется `IDrawable` .

```C++
void DrawSomeShapes(IDrawable **drawableArray, size_t count)
{
    for (size_t i = 0; i < count; i++)
    {
        drawableArray[i]->Draw();
    }
}
```

Ключевой момент COM заключается в том, что вызывающий код никогда не видит тип производного класса. Иными словами, вы никогда не объявили переменную типа `Shape` или `Bitmap` в коде. Все операции с фигурами и точечными рисунками выполняются с помощью `IDrawable` указателей. Таким образом, COM обеспечивает четкое разделение между интерфейсом и реализацией. Сведения о реализации `Shape` `Bitmap` классов и могут изменяться, например, чтобы исправить ошибки или добавить новые возможности, не изменяя вызывающий код.

В реализации C++ интерфейсы объявляются с помощью класса или структуры.

> [!Note]  
> Примеры кода в этом разделе предназначены для передачи общих понятий, а не реальных рекомендаций. Определение новых COM-интерфейсов выходит за рамки этой серии, но интерфейс не определяется непосредственно в файле заголовка. Вместо этого COM-интерфейс определяется с помощью языка IDL. IDL-файл обрабатывается компилятором IDL, который создает заголовочный файл C++.

```C++
class IDrawable
{
public:
    virtual void Draw() = 0;
};
```

При работе с COM важно помнить, что интерфейсы не являются объектами. Они представляют собой коллекции методов, которые должны быть реализованы объектами. Несколько объектов могут реализовывать один и тот же интерфейс, как показано `Shape` в `Bitmap` примерах и. Более того, один объект может реализовать несколько интерфейсов. Например, Библиотека графики может определять интерфейс с именем `ISerializable` , который поддерживает сохранение и загрузку графических объектов. Теперь рассмотрим следующие объявления классов:

```C++
// An interface for serialization.
class ISerializable
{
public:
    virtual void Load(PCWSTR filename) = 0;    // Load from file.
    virtual void Save(PCWSTR filename) = 0;    // Save to file.
};

// Declarations of drawable object types.

class Shape : public IDrawable
{
    ...
};

class Bitmap : public IDrawable, public ISerializable
{
    ...
};
```

В этом примере `Bitmap` класс реализует `ISerializable` . Программа может использовать этот метод для сохранения или загрузки точечного рисунка. Однако класс не `Shape` реализует `ISerializable` , поэтому он не предоставляет эту функциональность. На следующей диаграмме показаны отношения наследования в этом примере.

![Иллюстрация, демонстрирующая наследование интерфейса с помощью классов Shape и Bitmap, указывающих на идравабле, но только точечный рисунок, указывающий на ISerializable](images/com02.png)

В этом разделе рассматривалась концепция интерфейсов, но пока мы не видели фактический код COM. Начнем с первого, что должно сделать любое приложение COM: Инициализация библиотеки COM.

## <a name="next"></a>Следующая

[Инициализация библиотеки COM](initializing-the-com-library.md)