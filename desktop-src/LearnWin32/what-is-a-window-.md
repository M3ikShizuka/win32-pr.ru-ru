---
title: Что такое окно
description: .
ms.assetid: eef5e139-91f9-4d8b-9153-e178d7416d7e
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1fcbba817e3e4c9059340d0a67c7170f4583270c
ms.sourcegitcommit: ebd3ce6908ff865f1ef66f2fc96769be0aad82e1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/19/2020
ms.locfileid: "104412851"
---
# <a name="what-is-a-window"></a>Что такое окно?

## <a name="what-is-a-window"></a>Что такое окно?

Очевидно, что Windows являются центральными для Windows. Так важно, чтобы они называли операционную систему после них. Но что такое окно? Если вы считаете окно, вы, вероятно, думаете примерно так:

![снимок экрана окна приложения](images/window01.png)

Этот тип окна называется *окном приложения* или *основным окном*. Обычно он содержит рамку с заголовком, кнопки **сворачивания** и **развертывания** , а также другие стандартные элементы пользовательского интерфейса. Фрейм называется *неклиентской областью* окна, поэтому вызывается, так как операционная система управляет этой частью окна. Область внутри рамки является *клиентской областью*. Это часть окна, которую управляет ваша программа.

Вот еще один тип окна:

![снимок экрана окна управления](images/window02.png)

Если вы не знакомы с программированием для Windows, это может неожиданно познакомиться с тем, что элементы управления пользовательского интерфейса, такие как кнопки и поля редактирования, являются окнами. Основное различие между элементом управления пользовательского интерфейса и окном приложения заключается в том, что сам элемент управления не существует. Вместо этого элемент управления располагается относительно окна приложения. При перетаскивании окна приложения элемент управления перемещается вместе с ним, как и хотелось бы. Кроме того, элемент управления и окно приложения могут взаимодействовать друг с другом. (Например, окно приложения получает команду уведомления от кнопки.)

Таким образом, при обдумывании *окна* не следует просто думать *окно приложения*. Вместо этого представьте окно как конструкцию программирования, которая:

-   Занимает определенную часть экрана.
-   Может быть невидимым в данный момент.
-   Знает, как рисовать себя.
-   Реагирует на события пользователя или операционной системы.

## <a name="parent-windows-and-owner-windows"></a>Родительского окна и окна владельца

В случае элемента управления пользовательского интерфейса окно элемента управления называется *дочерним* элементом окна приложения. Окно приложения является *родительским* для окна управления. Родительское окно предоставляет систему координат, используемую для размещения дочернего окна. Наличие родительского окна влияет на аспекты внешнего вида окна; Например, дочернее окно обрезается таким образом, что никакая часть дочернего окна не может отображаться вне границ родительского окна.

Еще одна связь — это связь между окном приложения и модальным диалоговым окном. Когда приложение отображает модальное диалоговое окно, окно приложения является окном *владельца* , а диалоговое окно является *владельцем* окна. Собственное окно всегда отображается перед его окном "владелец". Он скрыт, когда владелец сведен к минимуму, и уничтожается одновременно с владельцем.

На следующем рисунке показано приложение, которое отображает диалоговое окно с двумя кнопками:

![снимок экрана приложения с диалоговым окном](images/window03.png)

Окно приложения владеет диалоговым окном, а диалоговое окно является родительским для обоих окон кнопок. Эти связи показаны на следующей схеме:

![Иллюстрация, демонстрирующая отношения "родители-потомки" и "владелец" и владельца](images/window04.png)

## <a name="window-handles"></a>Дескрипторы окон

Окна являются объектами — они содержат как код, так и данные, но они не являются классами C++. Вместо этого программа ссылается на окно, используя значение, называемое *маркером*. Маркер является непрозрачным типом. По сути, это просто число, используемое операционной системой для обнаружения объекта. Вы можете создавать изображения для окон с большими таблицами всех созданных окон. Она использует эту таблицу для поиска окон по их дескрипторам. (Будь это именно то, как он работает внутренне, не имеет значения.) Для дескрипторов окон используется тип данных **HWND**, который обычно произносится как "аитч-ветер". Дескрипторы окон возвращаются функциями, которые создают окна: [**CreateWindow**](/windows/desktop/DirectShow/cbasewindow-docreatewindow) и [**CreateWindowEx**](/windows/desktop/api/winuser/nf-winuser-createwindowexa).

Для выполнения операции в окне обычно вызывается какая-либо функция, принимающая в качестве параметра значение **HWND** . Например, чтобы изменить расположение окна на экране, вызовите функцию [**мовевиндов**](/windows/desktop/api/winuser/nf-winuser-movewindow) :


```C++
BOOL MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);
```



Первый параметр — это маркер окна, которое требуется переместить. Другие параметры указывают новое расположение окна и необходимость перерисовки окна.

Помните, что дескрипторы не являются указателями. Если *HWND* является переменной, содержащей дескриптор, попытка разыменования дескриптора с помощью записи `*hwnd` является ошибкой.

## <a name="screen-and-window-coordinates"></a>Координаты экрана и окна

Координаты измеряются в аппаратно-независимых пикселях. При обсуждении графики мы будем говорить о *независимой* части аппаратно *-независимых пикселей* .

В зависимости от задачи можно измерять координаты относительно экрана, относительно окна (включая рамку) или относительно клиентской области окна. Например, можно разместить окно на экране с помощью экранных координат, но нарисовать внутри окна с помощью клиентских координат. В каждом случае источник (0, 0) всегда находится в левом верхнем углу области.

![Иллюстрация, показывающая экран, окно и клиентские координаты](images/coordinates01.png)

## <a name="next"></a>Следующая

[WinMain: точка входа приложения](winmain--the-application-entry-point.md)

 

 