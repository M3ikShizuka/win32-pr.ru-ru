---
title: Создание объекта в COM
description: Чтобы использовать COM-интерфейс, программа сначала создает экземпляр объекта, который реализует этот интерфейс.
ms.assetid: 75f2115d-d49d-4e4e-8f99-67a231559ba6
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 96f96e4d9c2afbac028bfcefffcec6a070c78c8b
ms.sourcegitcommit: ebd3ce6908ff865f1ef66f2fc96769be0aad82e1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/19/2020
ms.locfileid: "104412872"
---
# <a name="creating-an-object-in-com"></a>Создание объекта в COM

После того как поток инициализирует библиотеку COM, поток может использовать COM-интерфейсы. Чтобы использовать COM-интерфейс, программа сначала создает экземпляр объекта, который реализует этот интерфейс.

Как правило, существует два способа создания COM-объекта.

-   Модуль, реализующий объект, может предоставить функцию, специально предназначенную для создания экземпляров этого объекта.
-   Кроме того, COM предоставляет универсальную функцию создания с именем [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance).

Например, возьмем гипотетический `Shape` объект из раздела [что такое COM-интерфейс?](what-is-a-com-interface-.md). В этом примере `Shape` объект реализует интерфейс с именем `IDrawable` . Библиотека графики, реализующая `Shape` объект, может экспортировать функцию со следующей сигнатурой.


```C++
// Not an actual Windows function. 

HRESULT CreateShape(IDrawable** ppShape);
```



Используя эту функцию, можно создать новый объект, `Shape` как показано ниже.


```C++
IDrawable *pShape;

HRESULT hr = CreateShape(&pShape);
if (SUCCEEDED(hr))
{
    // Use the Shape object.
}
else
{
    // An error occurred.
}
```



Параметр *ппшапе* имеет тип указателя на указатель на `IDrawable` . Если вы ранее не видели этот шаблон, двойное косвенное обращение может быть замешательство.

Рассмотрим требования `CreateShape` функции. Функция должна предоставить `IDrawable` указатель обратно вызывающему объекту. Но возвращаемое значение функции уже используется для кода ошибки или успешного выполнения. Поэтому указатель должен возвращаться к функции с помощью аргумента. Вызывающий объект передаст в функцию переменную типа `IDrawable*` , и эта переменная будет перезаписана новым `IDrawable` указателем. В C++ существует два способа перезаписи значения параметра функцией: передать по ссылке или передать по адресу. В COM используется последняя передача по адресу. И адрес указателя является указателем на указатель, поэтому тип параметра должен быть `IDrawable**` .

Ниже приведена схема, помогающая визуализировать то, что происходит.

![Схема, показывающая косвенное обращение между указателями](images/com03.png)

`CreateShape`Функция использует адрес *пшапе* ( `&pShape` ) для записи нового значения указателя в *пшапе*.

## <a name="cocreateinstance-a-generic-way-to-create-objects"></a>CoCreateInstance — универсальный способ создания объектов

Функция [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) предоставляет универсальный механизм для создания объектов. Для понимания **CoCreateInstance** необходимо помнить, что два COM-объекта могут реализовывать один и тот же интерфейс, и один объект может реализовать два или больше интерфейсов. Таким словами, универсальной функции, создающей объекты, требуется два фрагмента информации.

-   Создаваемый объект.
-   Интерфейс, который необходимо получить из объекта.

Но как указать эту информацию при вызове функции? В COM объект или интерфейс определяется путем присвоения ему 128-разрядного числа, называемого *глобально уникальным идентификатором* (GUID). Идентификаторы GUID создаются таким образом, что они эффективно уникальны. Идентификаторы GUID — это решение проблемы создания уникальных идентификаторов без центрального центра регистрации. Идентификаторы GUID иногда называются *универсальными уникальными идентификаторами* (UUID). До COM они использовались в DCE/RPC (распределенные вычислительные среды или удаленный вызов процедур). Для создания новых идентификаторов GUID существует несколько алгоритмов. Не все эти алгоритмы строго гарантируют уникальность, но вероятность случайного создания одного и того же значения GUID в два раза очень мала — фактически ноль. Идентификаторы GUID можно использовать для обнаружения любой сущности, а не только для объектов и интерфейсов. Тем не менее, это единственное использование, которое касается нас в этом модуле.

Например, `Shapes` Библиотека может объявлять две константы GUID:


```C++
extern const GUID CLSID_Shape;
extern const GUID IID_IDrawable; 
```



(Можно предположить, что фактические 128-разрядные числовые значения для этих констант определены в других местах.) **\_ Фигура** константы CLSID определяет `Shape` объект, а константа **IID \_ идравабле** определяет `IDrawable` интерфейс. Префикс "CLSID" означает *идентификатор класса*, а префикс *IID* означает *идентификатор интерфейса*. Это стандартные соглашения об именовании в COM.

Учитывая эти значения, вы создадите новый `Shape` экземпляр следующим образом:


```C++
IDrawable *pShape;
hr = CoCreateInstance(CLSID_Shape, NULL, CLSCTX_INPROC_SERVER, IID_Drawable,
     reinterpret_cast<void**>(&pShape));

if (SUCCEEDED(hr))
{
    // Use the Shape object.
}
else
{
    // An error occurred.
}
```



Функция [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) имеет пять параметров. Первый и четвертый параметры являются идентификатором класса и идентификатором интерфейса. Фактически эти параметры указывают функции "создать объект Shape" и присвоить мне указатель на интерфейс Идравабле ".

Установите для второго параметра **значение NULL**. (Дополнительные сведения о значении этого параметра см. в разделе [агрегирование](/windows/desktop/com/aggregation) разделов в документации по com.) Третий параметр принимает набор флагов, основной целью которых является указание *контекста выполнения* для объекта. Контекст выполнения определяет, выполняется ли объект в том же процессе, что и приложение. в другом процессе на том же компьютере; или на удаленном компьютере. В следующей таблице показаны наиболее распространенные значения для этого параметра.



| Flag                       | Описание                                                                                                                                                        |
|----------------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **КЛСКТКС \_ INPROC \_ Server** | Тот же процесс.                                                                                                                                                      |
| **\_локальный \_ сервер клскткс**  | Другой процесс, один и тот же компьютер.                                                                                                                                  |
| **\_Удаленный \_ сервер клскткс** | Другой компьютер.                                                                                                                                                |
| **КЛСКТКС \_ все**            | Используйте наиболее эффективный вариант, который поддерживает объект. (Ранжирование, от наиболее эффективного до наименее эффективного, — это внутрипроцессный, внутрипроцессный и перекрестный компьютер.) |



 

Документация по конкретному компоненту может сообщить, какой контекст выполнения поддерживает объект. В противном случае используйте **клскткс \_ ALL**. Если вы запрашиваете контекст выполнения, который не поддерживает объект, функция [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) возвращает код ошибки **регдб \_ E \_ класснотрег**. Этот код ошибки также может указывать на то, что CLSID не соответствует ни одному компоненту, зарегистрированному на компьютере пользователя.

Пятый параметр для [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) получает указатель на интерфейс. Поскольку **CoCreateInstance** является универсальным механизмом, этот параметр не может быть строго типизированным. Вместо этого тип данных — **void \* \***, и вызывающий объект должен привести адрес указателя к типу **void \* \*** . Это предназначение **переинтерпретации \_** в предыдущем примере.

Важно проверить возвращаемое значение [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance). Если функция возвращает код ошибки, указатель интерфейса COM является недопустимым, и попытка его разыменования может привести к сбою программы.

Внутри функция [**CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance) использует различные методы для создания объекта. В самом простом случае он ищет идентификатор класса в реестре. Запись реестра указывает на DLL или EXE-файл, который реализует объект. **CoCreateInstance** также может использовать сведения из каталога COM+ или параллельного манифеста (SxS). Независимо от того, что сведения прозрачны для вызывающей стороны. Дополнительные сведения о внутренних деталях **CoCreateInstance** см. в разделе [COM-клиенты и серверы](/windows/desktop/com/com-clients-and-servers).

`Shapes`Пример, который мы использовали, немного надуманный, так что теперь давайте вернемся к реальному примеру com в действии: Отображение диалогового окна **Открыть** для пользователя, чтобы выбрать файл.

## <a name="next"></a>Следующая

[Пример. диалоговое окно "Открыть"](example--the-open-dialog-box.md)

 

 