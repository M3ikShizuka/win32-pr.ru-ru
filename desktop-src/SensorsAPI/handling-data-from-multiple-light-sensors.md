---
description: Использование данных освещения
ms.assetid: 98272df5-08c0-4392-a74b-2919bbdcb022
title: Использование данных освещения
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 6ccf1c032b4100174afd6073d8c43db27bce3892
ms.sourcegitcommit: d75fc10b9f0825bbe5ce5045c90d4045e3c53243
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/13/2021
ms.locfileid: "127265211"
---
# <a name="using-light-sensor-data"></a>Использование данных освещения

Существует два рекомендуемых способа интерпретации и использования данных Lux, поступающих от датчиков внешнего освещения.

-   Примените преобразование к данным, чтобы нормализованный уровень освещения можно было использовать в прямом пропорции в отношении поведения программы или взаимодействий. Например, можно изменить размер кнопки в программе в прямом пропорции на Нормализованные данные (или диапазон нормализованных данных, соответствующий туризм, например). Такой подход обеспечивает оптимальную реализацию.
-   Разработайте с диапазонами данных Lux и сопоставьте поведение программы и реакции на верхние и нижние пороговые значения этих диапазонов данных Lux. Это простой способ реагирования на условия освещения и может не дать оптимального пользовательского интерфейса. Однако этот подход работает нормально, если плавные переходы нецелесообразны.

## <a name="handling-data-from-multiple-light-sensors"></a>Обработка данных из нескольких датчиков освещения

Чтобы получить наиболее точную аппроксимацию текущих условий освещения, можно использовать данные из нескольких внешних датчиков освещения. Так как датчики окружающей среды могут частично или полностью закрываться тенями или объектами, охватывающими датчик, несколько датчиков, разоставляющих несколько расстояний, могут обеспечить гораздо лучшую аппроксимацию текущих условий освещения, чем один датчик.

Чтобы контролировать данные, поступающие из нескольких датчиков, можно использовать следующие два метода:

-   Для каждого из этих считываний можно хранить самые последние значения данных для каждого датчика окружающей среды, а также отметку времени из отчета с данными датчика. Последняя [**исенсордатарепорт**](/windows/desktop/api/sensorsapi/nn-sensorsapi-isensordatareport) , полученная для каждого считывания датчика, может быть сохранена и может предоставлять оба значения для последующего обращения. Ссылаясь на метку времени для каждого отчета с данными датчика, можно управлять данными на основе их возраста. Например, если данные более 2 секунд устарели, их можно опустить. В зависимости от более новых значений данных датчика можно использовать самый большой способ чтения, так как соответствующий датчик предположительно не будет скрываться.
-   Вы можете использовать Последнее значение датчика внешнего освещения. Эта реализация не будет оптимальной, так как значения из нескольких датчиков не сравниваются друг с другом, чтобы получить наиболее точный результат. Мы не рекомендуем использовать этот метод.

## <a name="example-code"></a>Пример кода

В следующем примере кода показана реализация для события [**ондатаупдатед**](/windows/win32/api/sensorsapi/nf-sensorsapi-isensorevents-ondataupdated) . Обработчик событий вызывает вспомогательную функцию с именем **упдатеуи**, которая изменяет пользовательский интерфейс на основе значения Lux. Написание реализации Упдатеуи в вашей области.


```C++
// Override of ISensorEvents::OnDataUpdated
// Part of an event sink implementation for ISensorEvents
STDMETHODIMP CALSEventSink::OnDataUpdated(
    ISensor* pSensor, 
    ISensorDataReport* pNewData)
{
    HRESULT hr = S_OK;
   
    if(pSensor == NULL ||
       pNewData == NULL)
    {
         return E_POINTER;
    }

    // Declare and initialize the PROPVARIANT
    PROPVARIANT lightLevel;
    PropVariantInit(&lightLevel);

    // Get the sensor reading from the ISensorDataReport object
    hr = pNewData->GetSensorValue(
        SENSOR_DATA_TYPE_LIGHT_LEVEL_LUX, 
        &lightLevel);

    if(SUCCEEDED(hr))
    {
        if(lightlevel.vt == VT_R4)
        {
            // Extract the float value from the PROPVARIANT object
            float luxValue = lightLevel.fltVal;

            // Normalize the light sensor data
            double lightNormalized = ::log10(luxValue) / 5.0;

            // Handle UI changes based on the normalized LUX data
            // which ranges from 0.0 - 1.0 for a lux range of 
            // 0 lux to 100,000 lux. 
            UpdateUI(lightNormalized);
        }
    }

    // Release the variant.     
    PropVariantClear(&lightLevel);

    return hr;
}
```



 

 
