---
description: в этом разделе приводятся общие сведения об использовании интерфейсов api компонента Windows imaging (WIC) для чтения и записи метаданных, внедренных в файлы изображений.
ms.assetid: b1e0b936-a13a-42dd-8470-957ba1d90423
title: Общие сведения о чтении и записи метаданных изображений
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 191ffbe919e09acb153505fd3b43b50453b67708259206bffe66a0322d485a1a
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119088149"
---
# <a name="overview-of-reading-and-writing-image-metadata"></a>Общие сведения о чтении и записи метаданных изображений

в этом разделе приводятся общие сведения об использовании интерфейсов api компонента Windows imaging (WIC) для чтения и записи метаданных, внедренных в файлы изображений.

В этом разделе содержатся следующие подразделы.

-   [Предварительные требования](#prerequisites)
-   [Введение](#introduction)
-   [Чтение Метададата с помощью средства чтения запросов](#reading-metadadata-using-a-query-reader)
    -   [Получение средства чтения запросов](#obtaining-a-query-reader)
    -   [Чтение метаданных](#reading-metadata)
    -   [Дополнительные методы чтения запросов](#additional-query-reader-methods)
-   [Запись метаданных с помощью модуля записи запроса](#writing-metadata-using-a-query-writer)
    -   [Получение модуля записи запроса](#obtaining-a-query-writer)
    -   [Добавление метаданных](#adding-metadata)
    -   [Удаление метаданных](#removing-metadata)
    -   [Копирование метаданных для повторной кодировки](#copying-metadata-for-re-encoding)
-   [Быстрая кодировка метаданных](#fast-metadata-encoding)
    -   [Добавление заполнения в блоки метаданных](#adding-padding-to-metadata-blocks)
    -   [Получение высокоскоростного кодировщика метаданных](#obtaining-a-fast-metadata-encoder)
    -   [Использование кодировщика быстрых метаданных](#using-the-fast-metadata-encoder)
-   [Связанные темы](#related-topics)

## <a name="prerequisites"></a>Обязательные условия

Чтобы понять этот раздел, необходимо ознакомиться с системой метаданных WIC, как описано в [обзоре метаданных WIC](-wic-about-metadata.md). Также следует ознакомиться с языком запросов, используемым для чтения и записи метаданных, как описано в разделе [Общие сведения о языке запросов метаданных](-wic-codec-metadataquerylanguage.md).

## <a name="introduction"></a>Введение

Компонент WIC предоставляет разработчикам приложений компоненты модели COM для чтения и записи метаданных, внедренных в файлы изображений. Существует два способа чтения и записи метаданных:

-   Использование модуля чтения и записи запросов и выражения запроса для запроса блоков метаданных для вложенных блоков или конкретных метаданных в блоке.
-   Использование обработчика метаданных (средства чтения метаданных или модуля записи метаданных) для доступа к вложенным блокам метаданных или конкретным метаданным в блоках метаданных.

Проще всего использовать для доступа к метаданным модуль чтения/записи запроса и выражение запроса. Средство чтения запросов ([**ивикметадатакуериреадер**](/windows/desktop/api/Wincodec/nn-wincodec-iwicmetadataqueryreader)) используется для чтения метаданных, пока для записи метаданных используется модуль записи запроса ([**ивикметадатакуеривритер**](/windows/desktop/api/Wincodec/nn-wincodec-iwicmetadataquerywriter)). В обоих случаях используется выражение запроса для чтения или записи нужных метаданных. В фоновом режиме средство чтения запросов (и модуль записи) использует обработчик метаданных для доступа к метаданным, описанным в выражении запроса.

Более продвинутый метод — прямой доступ к обработчикам метаданных. Обработчик метаданных извлекается из отдельных кадров с помощью модуля чтения блока ([**ивикметадатаблоккреадер**](/windows/desktop/api/Wincodecsdk/nn-wincodecsdk-iwicmetadatablockreader)) или модуля записи блока ([**ивикметадатаблокквритер**](/windows/desktop/api/Wincodecsdk/nn-wincodecsdk-iwicmetadatablockwriter)). Доступны два типа обработчиков метаданных: средство чтения метаданных ([**ивикметадатареадер**](/windows/desktop/api/Wincodecsdk/nn-wincodecsdk-iwicmetadatareader)) и модуль записи метаданных ([**ивикметадатавритер**](/windows/desktop/api/Wincodecsdk/nn-wincodecsdk-iwicmetadatawriter)).

Следующая схема содержимого файла изображения JPEG используется во всех примерах этого раздела. Изображение, представленное этой схемой, было создано с помощью Microsoft Paint; метаданные оценки были добавлены с помощью функции "фотоальбом" Windows Vista.

![Иллюстрация изображения JPEG с метаданными оценки](graphics/jpeg.png)

## <a name="reading-metadadata-using-a-query-reader"></a>Чтение Метададата с помощью средства чтения запросов

Самый простой способ прочитать метаданные — использовать интерфейс средства чтения запросов [**ивикметадатакуериреадер**](/windows/desktop/api/Wincodec/nn-wincodec-iwicmetadataqueryreader). Средство чтения запросов позволяет считывать блоки метаданных и элементы в блоках метаданных с помощью выражения запроса.

Существует три способа получить читателя запросов: с помощью декодера точечных рисунков ([**ивикбитмапдекодер**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapdecoder)) через отдельные кадры ([**IWICBitmapFrameDecode**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapframedecode)) или через модуль записи запросов ([**ивикметадатакуеривритер**](/windows/desktop/api/Wincodec/nn-wincodec-iwicmetadataquerywriter)).

### <a name="obtaining-a-query-reader"></a>Получение средства чтения запросов

В следующем примере кода показано, как получить декодер битовой карты из фабрики изображений и получить отдельный кадр точечного рисунка. Этот код также выполняет настройку, необходимую для получения средства чтения запросов из декодированного фрейма.


```
IWICImagingFactory *pFactory = NULL;
IWICBitmapDecoder *pDecoder = NULL;
IWICBitmapFrameDecode *pFrameDecode = NULL;
IWICMetadataQueryReader *pQueryReader = NULL;
IWICMetadataQueryReader *pEmbedReader = NULL;
PROPVARIANT value;

// Initialize COM
CoInitialize(NULL);

// Initialize PROPVARIANT
PropVariantInit(&value);

//Create the COM imaging factory
HRESULT hr = CoCreateInstance(
    CLSID_WICImagingFactory,
    NULL,
    CLSCTX_INPROC_SERVER,
    IID_IWICImagingFactory,
    (LPVOID*)&pFactory);

// Create the decoder
if (SUCCEEDED(hr))
{
    hr = pFactory->CreateDecoderFromFilename(
        L"test.jpg",
        NULL,
        GENERIC_READ,
        WICDecodeMetadataCacheOnDemand,
        &pDecoder);
}

// Get a single frame from the image
if (SUCCEEDED(hr))
{
    hr = pDecoder->GetFrame(
         0,  //JPEG has only one frame.
         &pFrameDecode); 
}
```



Декодер точечных рисунков для файла test.jpg получается с помощью метода **креатедекодерфромфиленаме** фабрики изображений. В этом методе четвертый параметр устанавливается в значение WICDecodeMetadataCacheOnDemand из перечисления [**викдекодеоптионс**](/windows/desktop/api/Wincodec/ne-wincodec-wicdecodeoptions) . Это означает, что декодер кэширует метаданные, когда требуются метаданные. либо путем получения читателя запросов, либо базового средства чтения метаданных. Использование этого параметра позволяет хранить поток в метаданных, необходимых для быстрой кодировки метаданных, и позволяет без потерь раскодировать изображение JPEG. Кроме того, можно использовать другое значение **викдекодеоптионс** , WICDecodeMetadataCacheOnLoad, которое кэширует внедренные метаданные изображения сразу после загрузки изображения.

Чтобы получить средство чтения запросов кадра, выполните простой вызов метода **жетметадатакуериреадер** в кадре. Этот вызов демонстрируется в следующем коде.


```
// Get the query reader
if (SUCCEEDED(hr))
{
    hr = pFrameDecode->GetMetadataQueryReader(&pQueryReader);
}
```



Аналогичным образом средство чтения запросов также может быть получено на уровне декодера. Простой вызов метода **жетметадатакуериреадер** декодера получает средство чтения запросов декодера. Средство чтения запросов декодера, в отличие от средства чтения запросов кадра, считывает метаданные для изображения, находящегося за пределами отдельных кадров. Однако этот сценарий не является распространенным, и форматы образов в машинном код не поддерживают эту возможность. КОДЕки машинных образов, предоставляемые компонентом WIC, считывают и записывают метаданные на уровне фрейма даже для однокадровых форматов, таких как JPEG.

### <a name="reading-metadata"></a>Чтение метаданных

Прежде чем перейти к фактической прочтению метаданных, ознакомьтесь со следующей схемой файла JPEG, включающего в себя внедренные блоки метаданных и реальные данные для извлечения. Эта диаграмма предоставляет выноски для конкретных блоков метаданных и элементов внутри изображения, предоставляющего выражение запроса метаданных каждому блоку или элементу.

![Иллюстрация изображения JPEG с выносками метаданных](graphics/jpegwithcallouts.png)

Чтобы запросить внедренные блоки метаданных или определенные элементы по имени, вызовите метод **жетметадатабинаме** . Этот метод принимает выражение запроса и [пропвариант](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) , в котором возвращается элемент метаданных. Следующий код запрашивает вложенный блок метаданных и преобразует компонент [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) , предоставленный значением пропвариант, в средство чтения запросов, если оно найдено.


```
if (SUCCEEDED(hr))
{
    // Get the nested IFD reader
    hr = pQueryReader->GetMetadataByName(L"/app1/ifd", &value);
    if (value.vt == VT_UNKNOWN)
    {
        hr = value.punkVal->QueryInterface(IID_IWICMetadataQueryReader, (void **)&pEmbedReader);
    }
    PropVariantClear(&value); // Clear value for new query
}
```



Выражение запроса "/APP1/IFD" запрашивает блок IFD, вложенный в блок App1. Файл изображения JPEG содержит вложенный блок метаданных IFD, поэтому [пропвариант](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) возвращается с типом переменной (VT) `VT_UNKNOWN` и указателем на интерфейс [IUnknown](/windows/win32/api/unknwn/nn-unknwn-iunknown) (пунквал). Затем вы запрашиваете интерфейс IUnknown для читателя запросов.

В следующем коде показан новый запрос, основанный на новом модуле чтения запросов, относительно вложенного блока IFD.


```
if (SUCCEEDED(hr))
{
    hr = pEmbedReader->GetMetadataByName(L"/{ushort=18249}", &value);
    PropVariantClear(&value); // Clear value for new query
}
```



Выражение запроса "/{ушорт = 18249}" запрашивает блок IFD для рейтинга Микрософтфото, внедренного в тег 18249. Значение [пропвариант](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) теперь будет содержать тип значения `VT_UI2` и значение данных 50.

Однако нет необходимости получать вложенный блок перед запросом конкретных значений данных. Например, вместо запроса вложенной IFD, а затем для оценки Микрософтфото можно использовать корневой блок метаданных и запрос, показанный в следующем коде, для получения той же информации.


```
if (SUCCEEDED(hr))
{
    hr = pQueryReader->GetMetadataByName(L"/app1/ifd/{ushort=18249}", &value);
    PropVariantClear(&value);
}
```



Помимо запроса конкретных элементов метаданных в блоке метаданных, можно также перечислить все элементы метаданных в блоке метаданных (не включая элементы метаданных во вложенных блоках метаданных). Для перечисления элементов метаданных в текущем блоке **используется метод GetEnumerator** средства чтения запросов. Этот метод получает интерфейс **иенумстринг** , заполненный элементами метаданных в текущем блоке. Например, следующий код выполняет перечисление оценки XMP и Микрософтфото для вложенного блока IFD, полученного ранее.


```
IEnumString *metadataItems = NULL;

if (SUCCEEDED(hr))
{
    hr = pEmbedReader->GetEnumerator(&metadataItems);
}
```



Дополнительные сведения об определении подходящих тегов для различных форматов изображений и форматов метаданных см. в разделе [запросы метаданных в формате образа в машинном код](-wic-native-image-format-metadata-queries.md).

### <a name="additional-query-reader-methods"></a>Дополнительные методы чтения запросов

Помимо чтения метаданных можно также получить дополнительные сведения о средстве чтения запросов и получить метаданные с помощью других средств. Средство чтения запросов предоставляет два метода, которые предоставляют сведения о модуле чтения и **жетконтаинерформат** запросов **.**

С помощью встроенного средства чтения запросов можно использовать **жетконтаинерформат** , чтобы определить тип блока метаданных, и можно вызвать метод **OnLocation** , чтобы получить путь относительно корневого блока метаданных. Следующий код запрашивает у встроенного модуля чтения запросов для своего расположения.


```
// Determine the metadata block format

if (SUCCEEDED(hr))
{
    hr = pEmbedReader->GetContainerFormat(&containerGUID);
}

// Determine the query reader's location
if (SUCCEEDED(hr))
{
    UINT length;
    WCHAR readerNamespace[100];
    hr = pEmbedReader->GetLocation(100, readerNamespace, &length);
}
```



Вызов **жетконтаинерформат** для встроенного средства чтения запросов возвращает идентификатор GUID формата метаданных IFD. Вызов метода **OnLocation** Возвращает пространство имен "/APP1/IFD"; предоставляя относительный путь, из которого будут выполняться последующие запросы к новому модулю чтения запросов. Разумеется, приведенный выше код не очень полезен, но в нем демонстрируется использование метода методического **размещения** для поиска вложенных блоков метаданных.

## <a name="writing-metadata-using-a-query-writer"></a>Запись метаданных с помощью модуля записи запроса

> [!Note]  
> Некоторые примеры кода, приведенные в этом разделе, не показаны в контексте фактических шагов, необходимых для записи метаданных. Примеры кода в контексте рабочего примера см. в статье руководство. повторное кодирование образа с помощью метаданных.

 

Основным компонентом для записи метаданных является модуль записи запросов ([**ивикметадатакуеривритер**](/windows/desktop/api/Wincodec/nn-wincodec-iwicmetadataquerywriter)). Модуль записи запросов позволяет устанавливать и удалять блоки метаданных и элементы в блоке метаданных.

Как и средство чтения запросов, существует три способа получить модуль записи запроса: через растровый кодировщик ([**ивикбитмапенкодер**](/windows/desktop/api/wincodec/nn-wincodec-iwicbitmapencoder)) через отдельные кадры ([**ивикбитмапфраминкоде**](/windows/desktop/api/Wincodec/nn-wincodec-iwicbitmapframeencode)) или с помощью быстрого кодировщика метаданных ([**ивикфастметадатаенкодер**](/windows/desktop/api/Wincodec/nn-wincodec-iwicfastmetadataencoder)).

### <a name="obtaining-a-query-writer"></a>Получение модуля записи запроса

Наиболее распространенный модуль записи запросов предназначен для отдельного кадра точечного рисунка. Этот модуль записи запросов задает и удаляет блоки и элементы метаданных фрейма изображения. Чтобы получить модуль записи запроса кадра изображения, вызовите метод **жетметадатакуеривритер** в кадре. В следующем коде показан простой вызов метода для получения модуля записи запроса в кадре.


```
IWICMetadataQueryWriter &pFrameQWriter = NULL;

//Obtain a query writer from the frame.
hr = pFrameEncode->GetMetadataQueryWriter(&pFrameQWriter);
```



Аналогичным образом для уровня кодировщика также может быть получен модуль записи запроса. Простой вызов метода **жетметадатакуеривритер** кодировщика получает модуль записи запроса кодировщика. Модуль записи запросов кодировщика, в отличие от модуля записи запроса кадра, записывает метаданные для изображения за пределами отдельного кадра. Однако этот сценарий не является распространенным, и форматы образов в машинном код не поддерживают эту возможность. Кодеки машинных образов, предоставляемые компонентом WIC, считывают и записывают метаданные на уровне фрейма даже для однокадровых форматов, таких как JPEG.

Кроме того, модуль записи запросов можно получить непосредственно из фабрики изображений ([**IWICImagingFactory**](/windows/desktop/api/Wincodec/nn-wincodec-iwicimagingfactory)). Существует два метода фабрики изображений, которые возвращают модуль записи запроса: **креатекуеривритер** и **креатекуеривритерфромреадер**.

**Креатекуеривритер** создает модуль записи запроса для указанного формата метаданных и поставщика. Этот модуль записи запросов позволяет создавать метаданные для определенного формата метаданных и добавлять их в образ. В следующем примере кода демонстрируется вызов **креатекуеривритер** для создания модуля записи запроса XMP.


```
IWICMetadataQueryWriter *pXMPWriter = NULL;

// Create XMP block
GUID vendor = GUID_VendorMicrosoft;
hr = pFactory->CreateQueryWriter(
        GUID_MetadataFormatXMP,
        &vendor,
        &pXMPWriter);
```



В этом примере понятное имя `GUID_MetadataFormatXMP` используется в качестве параметра *гуидметадатаформат* . Он представляет идентификатор GUID формата метаданных XMP, а поставщик представляет обработчик, созданный корпорацией Майкрософт. Кроме того, **значение NULL** может быть передано как параметр *пгуидвендор* с теми же результатами, если другие обработчики XMP не существуют. Если пользовательский обработчик XMP устанавливается вместе с собственным обработчиком XMP, передача **значения NULL** для поставщика приведет к тому, что модуль записи с самым низким идентификатором GUID будет возвращен.

**Креатекуеривритерфромреадер** аналогичен методу **креатекуеривритер** , за исключением того, что он заполняет новый модуль записи запросов данными, предоставленными модулем чтения запросов. Это полезно для повторного кодирования образа с сохранением существующих метаданных или удаления ненужных метаданных. В следующем коде демонстрируется вызов **креатекуеривритерфромреадер** .


```
hr = pFrameDecode->GetMetadataQueryReader(&pFrameQReader);

// Copy metadata using query readers
if(SUCCEEDED(hr) && pFrameQReader)
{
    IWICMetadataQueryWriter *pNewWriter = NULL;

    GUID vendor = GUID_VendorMicrosoft;
    hr = pFactory->CreateQueryWriterFromReader(
        pFrameQReader,
        &vendor,
        &pNewWriter);
```



### <a name="adding-metadata"></a>Добавление метаданных

После получения модуля записи запроса его можно использовать для добавления блоков и элементов метаданных. Для записи метаданных используется метод **сетметадатабинаме** модуля записи запроса. **Сетметадатабинаме** принимает два параметра: выражение запроса (*взнаме*) и указатель на [пропвариант](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) (*сервер*). Выражение запроса определяет блок или элемент, который необходимо задать, когда ПРОПВАРИАНТ предоставляет фактическое значение данных для установки.

В следующем примере показано, как добавить заголовок с помощью модуля записи запросов XMP, полученного ранее с помощью метода **креатекуеривритер** .


```
// Write metadata to the XMP writer
if (SUCCEEDED(hr))
{
    PROPVARIANT value;
    PropVariantInit(&value);

    value.vt = VT_LPWSTR;
    value.pwszVal = L"Metadata Test Image.";
   
    hr = pXMPWriter->SetMetadataByName(L"/dc:title", &value);

    PropVariantClear(&value);
}
```



В этом примере тип значения (VT) имеет значение `VT_LPWSTR` , указывающее, что строка будет использоваться в качестве значения данных. Так как тип *значения*— это строка, *пвсзвал* используется для задания заголовка. Затем **сетметадатабинаме** вызывается с помощью выражения запроса "/DC: Title" и только что установленного [пропвариант](/windows/win32/api/propidlbase/ns-propidlbase-propvariant). Используемое выражение запроса указывает, что должно быть задано свойство Title в схеме цифровой камеры (DC). Обратите внимание, что выражение не имеет значение "/КСМП/ДК: Title"; Это связано с тем, что модуль записи запросов уже связан с XMP и не содержит внедренный блок XMP, который предложит «/КСМП/ДК: Title».

До этого момента вы не добавили метаданные в кадр изображения. Вы просто заполнили модуль записи запросов данными. Чтобы добавить в кадр блок метаданных, представленный модулем записи запроса, снова вызовите **сетметадатабинаме** , используя модуль записи запроса в качестве значения [пропвариант](/windows/win32/api/propidlbase/ns-propidlbase-propvariant). Это эффективно копирует метаданные из модуля записи запроса в кадр изображения. В следующем коде показано, как добавить метаданные в модуль записи запросов XMP, ранее полученный в корневой блок метаданных фрейма.


```
// Get the frame's query writer and write the XMP query writer to it
if (SUCCEEDED(hr))
{
    hr = pFrameEncode->GetMetadataQueryWriter(&pFrameQWriter);

    // Copy the metadata in the XMP query writer to the frame
    if (SUCCEEDED(hr))
    {
        PROPVARIANT value;

        PropVariantInit(&value);
        value.vt = VT_UNKNOWN;
        value.punkVal = pXMPWriter;
        value.punkVal->AddRef();

        hr = pFrameQWriter->SetMetadataByName(L"/", &value);

        PropVariantClear(&value);
    }
}
```



В этом примере используется тип значения (VT), `VT_UNKOWN` указывающий тип значения COM-интерфейса. Затем в качестве значения [пропвариант](/windows/win32/api/propidlbase/ns-propidlbase-propvariant)используется модуль записи запросов XMP (пиксмпвритер), который добавляет ссылку на него с помощью метода AddRef. Наконец, модуль записи запросов XMP задается путем вызова метода **сетметадатабинаме** фрейма и передачи выражения запроса "/", указывающего на корневой блок, а также только что установленный пропвариант.

> [!Note]  
> Если в рамке уже содержится блок метаданных, который вы пытаетесь добавить, то добавляемые метаданные будут добавлены, а существующие метаданные перезаписаны.

 

### <a name="removing-metadata"></a>Удаление метаданных

Кроме того, модуль записи запросов позволяет удалять метаданные путем вызова метода **ремовеметадатабинаме** . **Ремовеметадатабинаме** принимает выражение запроса и удаляет блок метаданных или элемент, если он существует. В следующем коде показано, как удалить добавленный ранее заголовок.


```
if (SUCCEEDED(hr))
{
    hr = pFrameQWriter->RemoveMetadataByName(L"/xmp/dc:title");
}
```



В следующем коде показано, как удалить весь блок метаданных XMP.


```
if (SUCCEEDED(hr))
{
    hr = pFrameQWriter->RemoveMetadataByName(L"/xmp");
}
```



### <a name="copying-metadata-for-re-encoding"></a>Копирование метаданных для повторной кодировки

> [!Note]  
> Код в этом разделе действителен, только если форматы исходного и конечного изображений совпадают. Невозможно скопировать все метаданные изображения в одной операции при кодировании в другой формат изображения.

 

Для сохранения метаданных при повторном кодировании изображения в тот же формат изображения существуют методы, доступные для копирования всех метаданных в одной операции. Каждая из этих операций соответствует аналогичному шаблону. Каждый из них устанавливает метаданные декодированного кадра непосредственно в новый закодированный кадр.

Предпочтительным методом копирования метаданных является инициализация модуля записи блока нового кадра с помощью модуля чтения блоков декодированного кадра. Этот метод показан в следующем коде.


```
if (SUCCEEDED(hr) && formatsEqual)
{
    // Copy metadata using metadata block reader/writer
    if (SUCCEEDED(hr))
    {
        pFrameDecode->QueryInterface(
            IID_IWICMetadataBlockReader,
            (void**)&pBlockReader);
    }
    if (SUCCEEDED(hr))
    {
        pFrameEncode->QueryInterface(
            IID_IWICMetadataBlockWriter,
            (void**)&pBlockWriter);
    }
    if (SUCCEEDED(hr))
    {
        pBlockWriter->InitializeFromBlockReader(pBlockReader);
    }
}
```



В этом примере модуль чтения блока и модуль записи блока получаются из исходного фрейма и конечного фрейма соответственно. Затем модуль записи блока инициализируется модулем чтения блока. При этом модуль чтения блока инициализируется предварительно заполненными метаданными модуля чтения блока.

Другим методом копирования метаданных является запись блока метаданных, на который ссылается средство чтения запросов, с помощью модуля записи запроса кодировщика. Этот метод показан в следующем коде.


```
if (SUCCEEDED(hr) && formatsEqual)
{
    hr = pFrameDecode->GetMetadataQueryReader(&pFrameQReader);

    // Copy metadata using query readers
    if(SUCCEEDED(hr))
    {
        hr = pFrameEncode->GetMetadataQueryWriter(&pFrameQWriter);
        if (SUCCEEDED(hr))
        {
            PropVariantClear(&value);
            value.vt=VT_UNKNOWN;
            value.punkVal=pFrameQReader;
            value.punkVal->AddRef();
            hr = pFrameQWriter->SetMetadataByName(L"/", &value);
            PropVariantClear(&value);
        }
    }
}
```



Здесь средство чтения запросов получается из декодированного фрейма, а затем используется в качестве значения свойства [пропвариант](/windows/win32/api/propidlbase/ns-propidlbase-propvariant) с типом значения VT \_ Unknown. Модуль записи запроса для кодировщика получен, а выражение запроса "/" используется для задания метаданных по корневому пути навигации. Этот метод также можно использовать при задании вложенных блоков метаданных путем настройки выражения запроса в нужное место.

Аналогичным образом можно создать модуль записи запроса на основе средства чтения запросов декодированного кадра с помощью метода **креатекуеривритерфромреадер** фабрики изображений. Модуль записи запросов, созданный в этой операции, будет предварительно заполнен метаданными из средства чтения запросов и затем может быть задан в кадре. В следующем примере кода демонстрируется операция копирования **креатекуеривритерфромреадер** .


```
IWICMetadataQueryWriter *pNewWriter = NULL;

GUID vendor = GUID_VendorMicrosoft;
hr = pFactory->CreateQueryWriterFromReader(
    pFrameQReader,
    &vendor,
    &pNewWriter);

if (SUCCEEDED(hr))
{
    // Get the frame's query writer
    hr = pFrameEncode->GetMetadataQueryWriter(&pFrameQWriter);
}

// Set the query writer to the frame.
if (SUCCEEDED(hr))
{
    PROPVARIANT value;

    PropVariantInit(&value);
    value.vt = VT_UNKNOWN;
    value.punkVal = pNewWriter;
    value.punkVal->AddRef();
    hr = pFrameQWriter->SetMetadataByName(L"/",&value);
}
```



В этом методе создается отдельный модуль записи запросов, основанный на данных средства чтения запросов. Этот новый модуль записи запросов, затем задается в кадре.

Опять же, эти операции копирования метаданных работают только в том случае, если исходные и конечные образы имеют одинаковый формат. Это обусловлено тем, что различные форматы изображений хранят блоки метаданных в разных местах. Например, JPEG и TIFF поддерживают блоки метаданных XMP. В изображениях JPEG блок XMP находится в корневом блоке метаданных, как показано в разделе [Общие сведения о метаданных WIC](-wic-about-metadata.md). Однако в изображении TIFF блок XMP вложен в корневой блок IFD. На следующей схеме показаны различия между изображением JPEG и изображением TIFF с одинаковыми метаданными рейтинга.

![Сравнение JPEG и TIFF.](graphics/jpgvstiff.png)

## <a name="fast-metadata-encoding"></a>Быстрая кодировка метаданных

Не всегда требуется перекодировать образ для записи новых метаданных в него. Метаданные также можно записать с помощью быстрого кодировщика метаданных. Быстрый кодировщик метаданных может записывать ограниченный объем метаданных в образ без повторной кодировки образа. Это достигается путем записи новых метаданных в пустое заполнение, предоставленное некоторыми форматами метаданных. Собственные форматы метаданных, поддерживающие заполнение метаданных, — это EXIF, IFD, GPS и XMP.

### <a name="adding-padding-to-metadata-blocks"></a>Добавление заполнения в блоки метаданных

Прежде чем можно будет выполнять быструю кодировку метаданных, в блоке метаданных должно быть место для записи дополнительных метаданных. Если в рамках существующего заполнения не хватает места для записи новых метаданных, то Быстрая кодировка метаданных завершится ошибкой. Чтобы добавить в изображение заполнение метаданных, необходимо повторно закодировать образ. Можно добавить заполнение таким же образом, как и любой другой элемент метаданных, с помощью выражения запроса, если этот блок метаданных поддерживает заполнение. В следующем примере показано, как добавить дополнение к блоку IFD, внедренному в блок App1.


```
if (SUCCEEDED(hr))
{
    // Add metadata padding
    PROPVARIANT padding;

    PropVariantInit(&padding);
    padding.vt = VT_UI4;
    padding.uiVal = 4096; // 4KB

    hr = pFrameQWriter->SetMetadataByName(L"/app1/ifd/PaddingSchema:padding", &padding);

    PropVariantClear(&padding);
}
```



Чтобы добавить дополнение, создайте ПРОПВАРИАНТ типа VT \_ UI4 и значение, соответствующее числу байтов добавляемого дополнения. Типичное значение — 4096 байт. В этой таблице приведены запросы метаданных для JPEG, TIFF и JPEG-XR.



| Формат метаданных | Запрос метаданных JPEG                  | TIFF, JPEG — запрос метаданных XR    |
|-----------------|--------------------------------------|---------------------------------|
| IFD             | /app1/ifd/PaddingSchema: заполнение      | /ИФД/паддингсчема: заполнение      |
| EXIF            | /app1/ifd/exif/PaddingSchema: заполнение | /ИФД/ексиф/паддингсчема: заполнение |
| ПОДДЕРЖИВАЮЩ             | /КСМП/паддингсчема: заполнение           | /ИФД/КСМП/паддингсчема: заполнение  |
| GPS             | /app1/ifd/gps/PaddingSchema: заполнение  | /ИФД/ГПС/паддингсчема: заполнение  |



 

### <a name="obtaining-a-fast-metadata-encoder"></a>Получение высокоскоростного кодировщика метаданных

При наличии изображения с заполнением метаданных можно получить быстрый кодировщик метаданных, используя методы фабрики изображений **креатефастметадатаенкодерфромдекодер** и **креатефастметадатаенкодерфромфрамедекоде**.

Как следует из названия, **креатефастметадатаенкодерфромдекодер** создает быстрый кодировщик метаданных для метаданных на уровне декодера. Форматы образов в машинном код, предоставляемые компонентом WIC, не поддерживают метаданные уровня декодера, но этот метод предоставляется в случае, когда формат изображения разрабатывается в будущем.

Наиболее распространенным сценарием является получение кодировщика метаданных из кадра изображения с помощью **креатефастметадатаенкодерфромфрамедекоде**. Следующий код получает кодировщик быстрых метаданных для декодированного кадра и изменяет значение рейтинга в блоке App1.


```
if (SUCCEEDED(hr))
{
    IWICFastMetadataEncoder *pFME = NULL;
    IWICMetadataQueryWriter *pFMEQW = NULL;

    hr = pFactory->CreateFastMetadataEncoderFromFrameDecode(
        pFrameDecode, 
        &pFME);
}
```



### <a name="using-the-fast-metadata-encoder"></a>Использование кодировщика быстрых метаданных

С помощью быстрого кодировщика метаданных можно получить модуль записи запроса. Это позволяет создавать метаданные с помощью выражения запроса, как показано выше. После задания метаданных в модуле записи запроса зафиксируйте быстрый кодировщик метаданных, чтобы завершить обновление метаданных. В следующем примере кода показано задание и фиксация изменений метаданных


```
    if (SUCCEEDED(hr))
    {
        hr = pFME->GetMetadataQueryWriter(&pFMEQW);
    }

    if (SUCCEEDED(hr))
    {
        // Add additional metadata
        PROPVARIANT value;

        PropVariantInit(&value);

        value.vt = VT_UI4;
        value.uiVal = 99;
        hr = pFMEQW->SetMetadataByName(L"/app1/ifd/{ushort=18249}", &value);

        PropVariantClear(&value);
    }

    if (SUCCEEDED(hr))
    {
        hr = pFME->Commit();
    }
}
```



Если **фиксация** завершается неудачей по какой-либо причине, необходимо повторно закодировать образ, чтобы новые метаданные добавлялись в образ.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

**Зрения**
</dt> <dt>

[Windows Общие сведения о компонентах обработки изображений](-wic-about-windows-imaging-codec.md)
</dt> <dt>

[Общие сведения о метаданных компонента WIC](-wic-about-metadata.md)
</dt> <dt>

[Общие сведения о языке запросов метаданных](-wic-codec-metadataquerylanguage.md)
</dt> <dt>

[Общие сведения о расширяемости метаданных](-wic-codec-metadatahandlers.md)
</dt> <dt>

[Пошаговое руководство. повторное кодирование изображения JPEG с помощью метаданных](-wic-codec-jpegmetadataencoding.md)
</dt> </dl>

 

 
