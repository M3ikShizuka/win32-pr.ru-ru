---
title: Создание эффекта эха
description: Создание эффекта эха
ms.assetid: 3fac6c74-8221-4656-997b-0f903fae85b7
keywords:
- проигрыватель Windows Media подключаемые модули, метод Echo sample допроцессаутпут
- подключаемые модули, метод Echo Sample Допроцессаутпут
- подключаемые модули обработки цифровых сигналов, метод Echo Sample Допроцессаутпут
- Подключаемые модули DSP, метод Echo Sample Допроцессаутпут
- Пример подключаемого модуля Echo DSP, метод Допроцессаутпут
- Пример подключаемого модуля Echo DSP, создание эффекта эха
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: fcb79b5be53f391854f38ce9aeba1c1bbff61ed2c0a982395c7063ff53146760
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119902294"
---
# <a name="creating-the-echo-effect"></a>Создание эффекта эха

Сначала необходимо удалить код из образца мастера, который масштабирует звук. Из 8-разрядного раздела удалите следующий код:


```C++
// Apply scale factor to sample.
i = int( ((double) i) * m_dwDelayTime );

```



(Помните, что m \_ фскалефактор был заменен на m \_ двделайтиме.)

Из 16-разрядного раздела удалите следующий код:


```C++
// Apply scale factor to sample.
i = int( ((double) i) * m_dwDelayTime );

```



реализация **допроцессаутпут** , предоставляемая в примере кода мастера подключаемых модулей, создает цикл while, который выполняет итерацию один раз для каждого образца во входном буфере, предоставленном проигрыватель Windows Media. Этот цикл работает одинаково как для 8-разрядных, так и для 16-разрядных аудио, хотя для каждого из них требуется отдельный цикл. В каждом случае цикл инициируется следующим тестом:


```C++
while (dwSamplesToProcess--)

```



Внутри цикла подпрограммы обработки очень похожи на 8-разрядные и 16-разрядные аудио. Основное отличие состоит в том, что код в 8-битном разделе изменяет диапазон значений данных на-128 до 127, а затем преобразует диапазон обратно перед записью данных в выходной буфер. Это важно для удержания симметрии звуковой волны во время обработки.

Теперь можно приступить к добавлению и замене кода в цикле обработки.

## <a name="retrieve-a-sample-from-the-input-buffer"></a>Получение примера из входного буфера

Во время каждой итерации цикла из входного буфера извлекается один пример. Для 8-разрядного звука образец перемещается в новый диапазон, а затем указатель на входной буфер переходит к следующему примеру. Следующий код находится в мастере подключаемых модулей:


```C++
// Get the input sample and normalize to -128 .. 127
int i = (*pbInputData++) - 128;

```



Для 16-разрядного звука процесс аналогичен, за исключением нормализации:


```C++
// Get the input sample.
int i = *pwInputData++;

```



Помните, что указатели в 16-разрядном коде преобразованы в тип **Short**.

## <a name="retrieve-a-sample-from-the-delay-buffer"></a>Получение примера из буфера задержки

Затем извлеките один пример из буфера задержки. Для 8-разрядного кода примеры задержки хранятся в собственном диапазоне от 0 до 255. Следующий код, который необходимо добавить, извлекает пример 8-разрядной задержки:


```C++
// Get the delay sample and normalize to -128 .. 127
int delay = m_pbDelayPointer[0] - 128;

```



Для 16-разрядного звука процесс выглядит примерно так:


```C++
// Get the delay sample.
int delay = *pwDelayPointer;

```



## <a name="write-the-input-sample-to-the-delay-buffer"></a>Запись образца входных данных в буфер задержки

Теперь необходимо сохранить образец входных данных в буфере задержки в том же расположении, из которого был получен образец Delay. Ниже приведен код, который необходимо добавить для 8-разрядного звука:


```C++
// Write the input sample into the delay buffer.
m_pbDelayPointer[0] = i + 128;

```



Это код для добавления в 16-разрядный раздел:


```C++
// Write the input sample to the delay buffer.
*pwDelayPointer = i;

```



## <a name="move-the-delay-buffer-pointer"></a>Перемещение указателя отложенного буфера

Теперь, когда работа в буфере задержки завершена для этой итерации, можно переместить перемещаемый указатель на буфер задержки. Если указатель достигает конца круглого буфера, необходимо изменить его значение, чтобы оно указывало на заголовок буфера. Чтобы сделать это для 8-разрядного звука, используйте следующий код:


```C++
// Increment the delay pointer.
// If it has passed the end of the buffer,
// then move it to the head of the buffer.
if (++m_pbDelayPointer > pbEOFDelayBuffer)
    m_pbDelayPointer = m_pbDelayBuffer;

```



Ниже приведен код для 16-разрядного раздела.


```C++
// Increment the local delay pointer.
// If it is past the end of the buffer,
// then move it to the head of the buffer.
if (++pwDelayPointer > pwEOFDelayBuffer)
    pwDelayPointer = pwDelayBuffer;

```



Поскольку указатель в 16-разрядном разделе действительно является копией переменной-члена, необходимо не забывать обновить значение в переменной-члене новым адресом. Если этого не сделать, указатель буфера задержки будет указывать на заголовок буфера несколько раз, и ваш экран эха не будет работать должным образом. Добавьте следующий код в 16-разрядный раздел:


```C++
// Move the global delay pointer.
m_pbDelayPointer = (BYTE *) pwDelayPointer;

```



## <a name="mix-the-input-sample-with-the-delay-sample"></a>Смешанный образец входных данных с образцом Delay

В этом случае для создания окончательного примера выходных данных используются значения задолженности и набора сухой. Вы просто умножаете каждый выбор на значение с плавающей запятой, представляющее процент финального сигнала для образца. Умножьте входную выборку на значение, хранящееся в m \_ фдримикс; умножьте образец задержки на значение, хранящееся в m \_ фветмикс. Затем добавьте два значения. Код, который необходимо добавить, идентичен для 8-разрядных и 16-разрядных разделов:


```C++
// Mix the delay with the dry signal.
i = (int)((i * m_fDryMix ) + (delay * m_fWetMix));   

```



## <a name="write-the-data-to-the-output-buffer"></a>Запись данных в выходной буфер

Наконец, скопируйте смешанный пример в выходной буфер, а затем переведите указатель на выходной буфер. Для 8-разрядного звука мастер подключаемых модулей использует следующий код для возврата образца к исходному диапазону:


```C++
// Convert back to 0..255 and write to output buffer.
*pbOutputData++ = (BYTE)(i + 128);

```



Для 16-разрядного звука мастер использует следующий код в качестве последнего шага цикла обработки:


```C++
// Write to output buffer.
*pwOutputData++ = i;

```



## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[**Реализация Цечо::D Опроцессаутпут**](implementing-cecho--doprocessoutput.md)
</dt> </dl>

 

 




