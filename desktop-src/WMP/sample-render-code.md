---
title: Пример кода рендеринга
description: Пример кода рендеринга
ms.assetid: 14978cf4-47fa-4b2e-ba51-799be873dc8a
keywords:
- визуализации, пример кода
- Пользовательские визуализации, пример кода
- визуализации, функция Render
- Пользовательские визуализации, функция Render
- Функция Render, пример кода
- Примеры, функция Render для визуализаций
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5a1ee5d00bc1aed5bd8bd91880e43e2ac2d1f6bc
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "104068216"
---
# <a name="sample-render-code"></a>Пример кода рендеринга

Ниже приведен пример кода, который использует функцию **Render** для рисования линии на экране. Высота линии определяется значением волны.


```C++
STDMETHODIMP CStock::Render(TimedLevel *pLevels, HDC hdc, RECT *prc)
{
    // Create new brushes and pens.
    HBRUSH hNewBrush = ::CreateSolidBrush( 0 );
    // Create a new solid pen the color of the foreground.
    HPEN hNewPen = ::CreatePen( PS_SOLID, 0, m_clrForeground );


    // Add the pen to the device context.
    HPEN hOldPen= static_cast<HPEN>(::SelectObject( hdc, hNewPen ));

    // Fill the background with the black brush.
    ::FillRect( hdc, prc, hNewBrush );

    // Get the y value from the waveform.
    int y = pLevels->waveform[0][0];

    // Draw the line from left to right.
    ::MoveToEx( hdc, prc->left, y, NULL);  
    ::LineTo(hdc, prc->right, y); 

    // Delete your brush.
    if (hNewBrush)
    {
        ::DeleteObject( hNewBrush );
    }
    // Delete your pen.
    if (hNewPen)
    {
        ::SelectObject( hdc, hOldPen );
        ::DeleteObject( hNewPen );
    }

    // You're done for this round.
    return S_OK;
}

```



Функция **Render** — это место, где происходит основная работа кода. Каждый раз, когда проигрыватель Windows Media создает моментальный снимок звука, он вызывает эту функцию, и код будет выполняться.

Этот код выполняет следующие задачи. Дополнительные сведения о конкретных функциях см. в разделе пакет SDK для платформы Microsoft Windows для 32-разрядной версии Windows.

## <a name="creating-objects"></a>Создание объектов

Обычно используются функции рисования, которые входят в состав графического интерфейса Microsoft Windows (GDI). Необходимо создать перья для рисования линий и кистей для заполнения областей.

Для заполнения фона создается сплошная черная кисть.

Для рисования линии создается сплошное перо. Цвет будет основным цветом, определяемым обложкой, которая будет отображать визуализацию.

## <a name="adding-the-object-to-the-dc"></a>Добавление объекта в контроллер домена

Необходимо добавить перо в контекст устройства (DC). Контроллер домена — это часть памяти, в которой хранятся все данные и объекты рисования. По сути, контроллер домена — это окно диспетчера трафика, которое отслеживает все графические изображения.

Необходимо *привести* созданный объект Pen и сохранить его как старое перо. Используйте этот прием кодирования для всех новых перьев. Этот метод необходим для 32-разрядного программирования.

## <a name="filling-in-the-background"></a>Заполнение фона

Теперь все готово для рисования. Функция **филлрект** будет заполнять прямоугольник окна, как определено параметрами функции **Render** . Прямоугольник заполняется черной кистью.

## <a name="getting-audio-data"></a>Получение звуковых данных

Далее код получает некоторые звуковые данные из проигрывателя Windows Media. Используя массив форм, можно получить текущее значение звукового сигнала в момент создания моментального снимка. В этом случае вы принимаете звуковые данные левого канала. Первое значение в массиве является первым 1024thом снимка состояния звука.

Эти сведения будут использоваться для вывода строки, высота которой будет соответствовать снимку энергии звука.

## <a name="draw-the-line"></a>Рисование линии

Линия рисуется слева направо с помощью функций GDI **моветоекс** и **lineTo** .

Сначала переместите перо на начальную точку. В этом случае x и y используются для определения значений слева направо и сверху вниз, которые пользователь увидит на экране. X определяется прямоугольником PRC и, в частности, значением КНР->Left. Y определяется как значение данных волны в данный момент.

Затем вы рисуете линию на другой стороне окна. Точка, в которую рисуется линия, снова будет иметь значение x, y. X определяется прямоугольником PRC, но на этот раз — PRC->right. Y по-прежнему определяется данными волны и совпадает с точкой, с которой вы начали, так как вы рисуете прямую линию слева направо.

## <a name="clean-up-everything"></a>Очистить все

Необходимо удалить созданные объекты. В частности, необходимо удалить все созданные кисти и перья. При завершении работы с ними рекомендуется удалить перья и кисти.

Если вы не удалите их перед завершением реализации функции **Render** , Визуализация будет завершаться сбоем в течение минуты или меньше. Необходимо сосчитать число перьев и кистей и уничтожить каждое из них. Будьте внимательны, чтобы не создавать перья внутри цикла кода.

Используйте методику кодирования, приведенную в примере, чтобы уничтожить перья и кисти.

-   **Важно!** Удалите перья и кисти!

Когда вы завершите очистку, не забудьте вернуть S \_ OK, чтобы проигрыватель Windows Media знал, что вы закончили рисовать. После того, как вы закончите, ваш рисунок будет передан в окно, будет создан другой моментальный **снимок, после этого будет выдан** запрос на прорисовку кода и т. д.

## <a name="related-topics"></a>См. также

<dl> <dt>

[**Реализация отрисовки**](implementing-render.md)
</dt> </dl>

 

 




