---
title: Синтаксис переменных
description: Используйте следующие синтаксические правила для объявления переменных HLSL.
ms.assetid: 684c42d1-2dd4-42e1-9cff-580edb5c6bcd
keywords:
- extern, переменный синтаксис (DirectX HLSL)
- "\"интерполяция\", синтаксис переменных (DirectX HLSL)"
- Shared, синтаксис переменных (DirectX HLSL)
- граупшаред, синтаксис переменных (DirectX HLSL)
- статический синтаксис переменных (DirectX HLSL)
- унифицированный синтаксис переменных (DirectX HLSL)
- volatile, переменный синтаксис (DirectX HLSL)
- точный синтаксис переменных (DirectX HLSL)
ms.topic: article
ms.date: 05/31/2018
topic_type:
- kbArticle
api_name: ''
api_type: ''
api_location: ''
ms.openlocfilehash: 446444e09b0b6aff3e0ba8ca8b12cfbf6dc94128
ms.sourcegitcommit: adba238660d8a5f4fe98fc6f5d105d56aac3a400
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/09/2021
ms.locfileid: "111826072"
---
# <a name="variable-syntax"></a>Синтаксис переменных

Используйте следующие синтаксические правила для объявления переменных HLSL.

\[*Хранилище \_ Тип класса* \] \[ *\_ Модификатор* \] *имя типа* \[ *индекс* \] \[ *: семантика* \] \[ *: паккоффсет* \] \[ *: Register* \] ;    \[  \] Заметки \[ *= Начальный \_ Значение*                    \]



 

## <a name="parameters"></a>Параметры

<dl> <dt>

<span id="Storage_Class_"></span><span id="storage_class_"></span><span id="STORAGE_CLASS_"></span>*\_Класс хранения* 
</dt> <dd>

Необязательные модификаторы класса хранения, которые предоставляют указаниям компилятора сведения об области действия переменной и времени существования; Модификаторы можно указывать в любом порядке.



<table>
<colgroup>
<col style="width: 50%" />
<col style="width: 50%" />
</colgroup>
<thead>
<tr class="header">
<th>Значение</th>
<th>Описание</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><strong>extern</strong></td>
<td>Пометьте глобальную переменную как внешний входное значение для шейдера; Это обозначение по умолчанию для всех глобальных переменных. Не может использоваться вместе со <strong>статическим</strong>.</td>
</tr>
<tr class="even">
<td><strong>Интерполяция</strong></td>
<td>Не выдавайте интерполяцию выходов шейдера вершин перед передачей их в шейдер пикселей.</td>
</tr>
<tr class="odd">
<td><strong>точен</strong></td>
<td>Ключевое слово <strong>точной</strong> при применении к переменной ограничит любые вычисления, используемые для получения значения, присвоенного этой переменной, следующим образом.

*   Отдельные операции хранятся отдельно. Например, когда операция Mul и Add может быть назначена с помощью команды Mad, <strong>Точная</strong> заставляет операции оставаться отдельными. Вместо этого необходимо явно использовать встроенную функцию Mad.
*   Поддерживается порядок операций. Если порядок инструкций может быть изменен в случайном порядке для повышения производительности, <strong>Точная</strong> проверка того, что компилятор сохраняет порядок как записанный.
*   Ненадежные операции IEEE ограничены. Если компилятор может использовать быстрые математические операции, которые не задают значения NaN (не число) и INF (бесконечное значение), <strong>точнее</strong> принуждает требования IEEE к значениям NaN и INF. Без <strong>точной</strong>оптимизации и математические операции не являются стандартом IEEE.
*   Уточнение переменной <strong>точности</strong> не делает операций, использующих переменную <strong>точности</strong>. Так как <strong>точное</strong> распространение выполняется только для операций, которые вносят вклад в значения, присвоенные <strong>точной</strong>переменной, правильная <strong>точность</strong> вычислений может быть непростой, поэтому мы рекомендуем пометить <strong>выходные данные</strong> шейдера непосредственно там, где они объявляются, будь то на поле структуры или в выходном параметре, или на тип возвращаемого значения функции записи.

Возможность управления оптимизацией таким образом поддерживает недисперсию результата для измененной выходной переменной путем отключения оптимизаций, которые могут повлиять на окончательный результат из-за различий в накопленной точности. Это полезно, если требуется, чтобы шейдеры для тесселяции поддерживали стыки исправлений с ограниченными водами или совпасть со значениями глубины за несколько проходов.

[Пример кода](https://github.com/microsoft/DirectXShaderCompiler/blob/master/tools/clang/test/HLSLFileCheck/hlsl/types/modifiers/precise/precise4.hlsl): 
```HLSL
matrix g_mWorldViewProjection;
void main(in float3 InPos : Position, out precise float4 OutPos : SV_Position)
{
  // operation is precise because it contributes to the precise parameter OutPos
  OutPos = mul( float4( InPos, 1.0 ), g_mWorldViewProjection );
}
```
</td>
</tr>
<tr class="even">
<td><strong>используемый</strong></td>
<td>Пометьте переменную для совместного использования эффектов; Это подсказка для компилятора.</td>
</tr>
<tr class="odd">
<td><strong>граупшаред</strong></td>
<td>Пометьте переменную для общей памяти группы потоков для шейдеров вычислений. В D3D10 максимальный общий размер всех переменных с классом хранения граупшаред — 16 КБ, в D3D11 максимальный размер — 32 КБ. См. примеры.</td>
</tr>
<tr class="even">
<td><strong>static</strong></td>
<td>Пометьте локальную переменную, чтобы она была инициализирована один раз и сохранялась между вызовами функций. Если объявление не содержит инициализатор, значение устанавливается равным нулю. Глобальная переменная, помеченная как <strong>static</strong> , невидима для приложения.</td>
</tr>
<tr class="odd">
<td><strong>Однородный элемент</strong></td>
<td>Пометьте переменную, данные которой являются постоянными в ходе выполнения шейдера (например, цвет материала в шейдере вершин); глобальные переменные считаются <strong>универсальными</strong> по умолчанию.</td>
</tr>
<tr class="even">
<td><strong>volatile</strong></td>
<td>Пометьте переменную, которая часто изменяется; Это подсказка для компилятора. Этот модификатор класса хранения применяется только к локальной переменной.<br/>
<blockquote>
[!Note]<br />
Компилятор HLSL в настоящее время игнорирует этот модификатор класса хранения.
</blockquote>
<br/></td>
</tr>
</tbody>
</table>



 

</dd> <dt>

<span id="Type_Modifier"></span><span id="type_modifier"></span><span id="TYPE_MODIFIER"></span>*\_Модификатор типа*
</dt> <dd>

Необязательный модификатор типа переменной.



| Значение             | Описание                                                                                                                                                                                                                                  |
|-------------------|----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| **const**         | Пометьте переменную, которая не может быть изменена шейдером, поэтому она должна быть инициализирована в объявлении переменной. Глобальные переменные считаются **константами** по умолчанию (это поведение подавляется путем указания компилятору флага/ЖЕК). |
| **\_Основная строка**    | Пометьте переменную, в которой хранятся четыре компонента, в одну строку, чтобы их можно было хранить в одном регистре констант.                                                                                                                             |
| **\_основной столбец** | Пометьте переменную, в которой хранится 4 компонента, в один столбец, чтобы оптимизировать матричную формулу.                                                                                                                                                         |



 

> [!Note]  
> Если не указать значение модификатора типа, компилятор использует **столбец \_ Major** в качестве значения по умолчанию.

 

</dd> <dt>

<span id="Type"></span><span id="type"></span><span id="TYPE"></span>*Тип*
</dt> <dd>

Любой тип HLSL, указанный в [типах данных (DirectX HLSL)](dx-graphics-hlsl-data-types.md).

</dd> <dt>

<span id="Name_Index_"></span><span id="name_index_"></span><span id="NAME_INDEX_"></span>*Имя* \[ *Индекс*\]
</dt> <dd>

Строка ASCII, однозначно определяющая переменную шейдера. Чтобы определить необязательный массив, используйте **индекс** для размера массива, который является положительным целым числом = 1.

</dd> <dt>

<span id="Semantic"></span><span id="semantic"></span><span id="SEMANTIC"></span>*Семантическ*
</dt> <dd>

Необязательные параметры — сведения об использовании, используемые компилятором для связывания входных и выходных данных шейдера. Существует несколько предопределенных [семантик](dx-graphics-hlsl-semantics.md) для шейдеров вершин и пикселей. Компилятор игнорирует семантику, если только они не объявлены в глобальной переменной или параметр, переданный в шейдер.

</dd> <dt>

<span id="Packoffset"></span><span id="packoffset"></span><span id="PACKOFFSET"></span>*паккоффсет*
</dt> <dd>

Необязательное ключевое слово для констант упаковки шейдера вручную. См. [паккоффсет (DirectX HLSL)](dx-graphics-hlsl-variable-packoffset.md).

</dd> <dt>

<span id="Register"></span><span id="register"></span><span id="REGISTER"></span>*Зарегистрировать*
</dt> <dd>

Необязательное ключевое слово для присваивания переменной шейдера конкретному регистру вручную. См. раздел [Register (DirectX HLSL)](dx-graphics-hlsl-variable-register.md).

</dd> <dt>

<span id="Annotation_s_"></span><span id="annotation_s_"></span><span id="ANNOTATION_S_"></span>*Заметки*
</dt> <dd>

Необязательные метаданные в виде строки, присоединенной к глобальной переменной. Заметка используется платформой эффектов и игнорируется HLSL; более подробный синтаксис см. в разделе [синтаксис аннотации](/windows/desktop/direct3d10/d3d10-effect-annotation-syntax).

</dd> <dt>

<span id="Initial_Value"></span><span id="initial_value"></span><span id="INITIAL_VALUE"></span>*Начальное \_ значение*
</dt> <dd>

Необязательные начальные значения; число значений должно соответствовать числу компонентов в *типе*. Каждая глобальная переменная, помеченная как **extern** , должна быть инициализирована литеральным значением. Каждая переменная, помеченная как **static** , должна быть инициализирована с помощью константы.

Глобальные переменные, не помеченные как **static** или **extern** , не компилируются в шейдер. Компилятор не задает автоматически значения по умолчанию для глобальных переменных и не может использовать их при оптимизации. Чтобы инициализировать этот тип глобальной переменной, используйте отражение, чтобы получить его значение, а затем скопируйте значение в буфер констант. Например, можно использовать метод [**ID3D11ShaderReflection:: жетвариаблебинаме**](/windows/desktop/api/d3d11shader/nf-d3d11shader-id3d11shaderreflection-getvariablebyname) для получения переменной, использовать метод [**ID3D11ShaderReflectionVariable:: DESC**](/windows/desktop/api/d3d11shader/nf-d3d11shader-id3d11shaderreflectionvariable-getdesc) , чтобы получить описание переменной шейдера, и получить начальное значение из элемента **DefaultValue** в переменной пошагового [**\_ шейдера \_ \_ D3D11**](/windows/desktop/api/d3d11shader/ns-d3d11shader-d3d11_shader_variable_desc) . Чтобы скопировать значение в буфер констант, необходимо убедиться, что буфер был создан с доступом на запись ЦП ([**D3D11 доступ на \_ \_ \_ запись ЦП**](/windows/desktop/api/d3d11/ne-d3d11-d3d11_cpu_access_flag)). Дополнительные сведения о создании буфера констант см. [в разделе инструкции. Создание буфера констант](/windows/desktop/direct3d11/overviews-direct3d-11-resources-buffers-constant-how-to).

Кроме того, можно использовать [платформу Effects](../direct3d11/d3d11-graphics-programming-guide-effects.md) для автоматической обработки отражения и установки начального значения. Например, можно использовать метод [**ID3DX11EffectPass:: Apply**](/windows/desktop/direct3d11/id3dx11effectpass-apply) .

</dd> </dl>

## <a name="examples"></a>Примеры

Ниже приведено несколько примеров объявления переменных шейдера.


```
float fVar;
```




```
float4 color;
float fVar = 3.1f;

int iVar[3];

int iVar[3] = {1,2,3};

uniform float4 position : SV_POSITION; 
const float4 lightDirection = {0,0,1};
      
```



### <a name="group-shared"></a>Общая группа

HLSL позволяет потокам шейдера вычислений обмениваться значениями через общую память. HLSL предоставляет примитивы барьера, такие как [**граупмеморибарриервисграупсинк**](groupmemorybarrierwithgroupsync.md), и т. д., чтобы обеспечить правильный порядок операций чтения и записи в общую память в шейдере и избежать состязаний с данными.

> [!Note]  
> Оборудование выполняет потоки в группах (деформация или волна-переднюю часть), а синхронизация барьера иногда может быть опущена, чтобы повысить производительность, если только синхронизация потоков, принадлежащих одной группе, верна. Но мы настоятельно не рекомендуем это проявления по следующим причинам:
>
> -   Это подавление приводит к непереносимому коду, который может не работать на определенном оборудовании и не работает на программных средствах прорисовки, которые обычно выполняют потоки в небольших группах.
> -   Улучшения производительности, которые могут быть достигнуты в этом пропуске, будут незначительными по сравнению с использованием барьера всего потока.

 

В Direct3D 10 отсутствует синхронизация потоков при записи в **граупшаред**, поэтому каждый поток ограничен одним местом в массиве для записи. Используйте системное значение [SV \_ граупиндекс](dx-graphics-hlsl-semantics.md) для индексирования этого массива при записи, чтобы избежать конфликта между двумя потоками. С точки зрения чтения все потоки имеют доступ ко всему массиву для чтения.


```
struct GSData
{
    float4 Color;
    float Factor;
}

groupshared GSData data[5*5*1];

[numthreads(5,5,1)]
void main( uint index : SV_GroupIndex )
{
    data[index].Color = (float4)0;
    data[index].Factor = 2.0f;
    GroupMemoryBarrierWithGroupSync();
    ...
}
```



### <a name="packing"></a>Упаковоч

Упаковка подкомпонентов векторов и скаляров, размер которых достаточно велик для предотвращения пересечения границ регистров. Например, все они допустимы:


```
cbuffer MyBuffer
{
    float4 Element1 : packoffset(c0);
    float1 Element2 : packoffset(c1);
    float1 Element3 : packoffset(c1.y);
}
        
```



Невозможно смешивать типы упаковки.

Как и ключевое слово Register, паккоффсет может быть конкретным целевым. Упаковка вспомогательных компонентов доступна только с ключевым словом паккоффсет, а не с ключевым словом Register. В объявлении кбуффер ключевое слово Register не учитывается для целевых объектов Direct3D 10, так как предполагается совместимость с различными платформами.

Упакованные элементы могут перекрываться, и компилятор не выдает ошибок или предупреждений. В этом примере Element2 и Element3 будут перекрываться с помощью Element1. x и Element1. y.


```
cbuffer MyBuffer
{
    float4 Element1 : packoffset(c0);
    float1 Element2 : packoffset(c0);
    float1 Element3 : packoffset(c0.y);
}
        
```



Пример, в котором используется паккоффсет: [HLSLWithoutFX10 Sample](https://msdn.microsoft.com/library/Ee416414(v=VS.85).aspx).

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Переменные (DirectX HLSL)](dx-graphics-hlsl-variables.md)
</dt> </dl>

 

