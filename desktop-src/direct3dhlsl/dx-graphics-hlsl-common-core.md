---
title: Ядро Common-Shader
description: Ядро Common-Shader
ms.assetid: f3cf2969-83a4-461f-8177-d336536194ba
ms.topic: article
ms.date: 05/31/2018
topic_type:
- kbArticle
api_name: ''
api_type: ''
api_location: ''
ms.openlocfilehash: 9c2d1851025cb051a21a997f5e3a4987d3b6309e148248b3ea55c6b9ca6ad31c
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119950484"
---
# <a name="common-shader-core"></a>Ядро Common-Shader

В модели шейдера 4 каждый этап шейдера реализует одну и ту же базовую функциональность с помощью ядра общего шейдера. Кроме того, каждый из трех этапов шейдера (вершина, геометрия и пиксель) обеспечивает функциональность, уникальную для каждого этапа, например возможность создания новых примитивов на основе шейдера геометрии или для удаления определенного пикселя на этапе шейдера пикселей. На следующей диаграмме показано, как потоки данных проходят через стадию шейдера, а также отношение ядра общего шейдера с ресурсами памяти шейдера.

![Схема потока данных на этапе шейдера](images/d3d10-shader-unit.png)

-   **Входные данные**: шейдер вершин получает свои входные данные с этапа ассемблера ввода; геометрические и пиксельные шейдеры получают свои входные данные с предыдущей стадии шейдера. Дополнительные входы включают [семантику "система — значение](dx-graphics-hlsl-semantics.md)", которая используется первой единицей в конвейере, к которой они применимы.
-   **Выходные данные**: шейдеры создают выходные результаты, которые передаются на последующий этап в конвейере. Для шейдера Geometry объем выходных данных одного вызова может различаться. Некоторые выходные данные обрабатываются ядром общего шейдера (например, положением вершины и индексом-целевым массивом), а другие предназначены для интерпретации приложением.
-   **Код шейдера**. шейдеры могут считывать из памяти, выполнять векторные операции с плавающей запятой и целочисленными арифметическими операциями, а также операции управления потоком. Количество инструкций, которые могут быть реализованы в шейдере, не ограничено.
-   **Пробы**: пробы определяют, как выдаются образцы и отфильтруются текстуры. Можно одновременно привязать к шейдеру до 16 проб.
-   **Текстуры**. текстуры можно отфильтровать с помощью проб или прочесть на основе шаг текселя непосредственно с помощью встроенной функции [Load](dx-graphics-hlsl-to-load.md) .
-   **Буферы**. буферы никогда не фильтруются, но их можно считывать из памяти в отдельности по элементам непосредственно с помощью встроенной функции [Load](dx-graphics-hlsl-to-load.md) . Столько же, сколько и буферных ресурсов 128, и ресурсы буфера (Объединенные) могут одновременно привязываться к шейдеру.
-   **Буферы констант**. буферы констант оптимизированы для переменных констант-шейдеров. Так как 16 буферов констант можно привязать к этапу шейдера одновременно. Они предназначены для более частых обновлений ЦП; Поэтому у них есть дополнительные ограничения по размеру, макету и доступу.


Различия между Direct3D 9 и Direct3D 10:

- В Direct3D 9 каждая единица шейдера имела один и небольшой файл регистра констант для хранения всех переменных шейдера констант. Разведение всех шейдеров с ограниченным пространством, необходимым для частого перезапуска констант с помощью ЦП.
- В Direct3D 10 константы хранятся в неизменяемых буферах в памяти и управляются как любые другие ресурсы. Количество буферов констант, которые может создать приложение, не ограничено. Организуя константы в буферы по частоте обновления и использования, объем пропускной способности, необходимый для обновления констант в соответствии со всеми шейдерами, может значительно снизиться.



 

## <a name="integer-and-bitwise-support"></a>Целочисленная и Побитовая поддержка

Общее ядро шейдера предоставляет полный набор стандартных и побитовых операций, 32 соответствующих стандарту IEEE. Эти операции включают в себя новый класс алгоритмов в примерах графических устройств, включая методы сжатия и упаковки, Ффтс и битовую программу управления потоком.

Типы данных **int** и **uint** в Direct3D 10 HLSL сопоставляются с 32-разрядными целыми числами в оборудовании.



|                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Различия между Direct3D 9 и Direct3D 10:<br/> Входные потоки Direct3D 9, помеченные как целые числа в HLSL, были интерпретированы как операции с плавающей запятой. В Direct3D 10 входные данные потока, помеченные как целые числа, обрабатываются как 32-разрядное целое число.<br/> Кроме того, логические значения теперь задаются все биты или все биты заменяются. Данные, преобразованные в **bool** , будут интерпретироваться как true, если значение не равно 0,0 f (как положительные, так и отрицательные нули могут быть ложными) и false в противном случае.<br/> |



 

## <a name="bitwise-operators"></a>битовые операторы;

Общее ядро шейдера поддерживает следующие Побитовые операторы:



| Оператор  | Функция          |
|-----------|-------------------|
| ~         | Логическое НЕ       |
| <<  | Сдвиг влево        |
| >>  | Сдвиг вправо       |
| &         | Логическое «И»       |
| \|        | Логическое "или".        |
| ^         | Логическое исключающее или       |
| <<= | Сдвиг влево равен  |
| >>= | Сдвиг вправо равно |
| &=        | И равно         |
| \|=       | Или равно          |
| ^=        | XOR равно         |



 

Битовые операторы определяются только для типов данных **int** и **uint** . Попытка использовать побитовые операторы для типов данных с **плавающей запятой** или **структуры** приведет к ошибке. Побитовые операторы имеют тот же приоритет, что и C, в отношении других операторов.

## <a name="binary-casts"></a>Двоичные приведения

При приведении между целым числом и типом с плавающей запятой будет преобразовано числовое значение после правил усечения C. Приведение значения с **плавающей запятой** к типу **int** и обратно в тип **float** — это преобразование, зависящее от точности целевого типа данных. Ниже приведены некоторые функции преобразования: [**асфлоат (DirectX HLSL)**](dx-graphics-hlsl-asfloat.md), [**ASIN (DirectX HLSL)**](dx-graphics-hlsl-asint.md), [**асуинт (DirectX HLSL)**](dx-graphics-hlsl-asuint.md).

Двоичные приведения также можно выполнять с помощью встроенных функций HLSL. Это приводит к тому, что компилятор переинтерпретирует битовое представление числа в целевой тип данных.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Модель шейдера 4](dx-graphics-hlsl-sm4.md)
</dt> </dl>

 

 





