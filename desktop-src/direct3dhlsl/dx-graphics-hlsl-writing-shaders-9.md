---
title: Создание шейдеров HLSL в Direct3D 9
description: Создание шейдеров HLSL в Direct3D 9
ms.assetid: 7db6b264-c96c-4298-9b8a-d0c488390e4e
ms.topic: article
ms.date: 05/31/2018
topic_type:
- kbArticle
api_name: ''
api_type: ''
api_location: ''
ms.openlocfilehash: 64a64d08518cb987850c87da3fb19c264519a7f7
ms.sourcegitcommit: ca37395fd832e798375e81142b97cffcffabf184
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 05/24/2021
ms.locfileid: "110335388"
---
# <a name="writing-hlsl-shaders-in-direct3d-9"></a>Создание шейдеров HLSL в Direct3D 9

-   [Основные сведения о шейдере вершин](#vertex-shader-basics)
-   [Основы построителя текстуры](#pixel-shader-basics)
    -   [Стадия текстуры и состояния образца](#texture-stage-and-sampler-states)
    -   [Входные шейдеры пикселей](#pixel-shader-inputs)
    -   [Выходные данные шейдера пикселей](#pixel-shader-outputs)
-   [Входные и переменные шейдеров](#shader-inputs-and-shader-variables)
    -   [Объявление переменных шейдера](#declaring-shader-variables)
    -   [Входные данные универсального шейдера](#uniform-shader-inputs)
    -   [Различные входные и семантические значения шейдера](#varying-shader-inputs-and-semantics)
    -   [Пробы и объекты текстуры](#samplers-and-texture-objects)
-   [Написание функций](#writing-functions)
-   [Управление потоком](#flow-control)
-   [См. также](#related-topics)

## <a name="vertex-shader-basics"></a>Основы Vertex-Shader

При выполнении операции программируемый шейдер вершин заменяет обработку вершин, выполняемую конвейером Microsoft Direct3D Graphics. При использовании шейдера вершин сведения о состоянии, касающиеся операций преобразования и освещения, игнорируются с помощью фиксированного конвейера функций. Если шейдер вершин отключен и возвращается фиксированная обработка функций, применяются все текущие параметры состояния.

Тесселяция примитивов высокого порядка следует выполнять перед выполнением шейдера вершин. Реализации, которые выполняют тесселяцию поверхности после обработки шейдера, должны сделать это таким образом, что не очевидно для приложения и кода шейдера.

Как минимум Вершинный шейдер должен выводить расположение вершины в однородном пространстве для обрезки. При необходимости шейдер вершин может выводить координаты текстуры, цвет вершины, освещение вершин, факторы тумана и т. д.

## <a name="pixel-shader-basics"></a>Основы Pixel-Shader

Обработка пикселей выполняется построителейми текстур пикселей на отдельных пикселях. Шейдеры пикселей работают совместно с шейдерами вершин; выходные данные шейдера вершин предоставляют входные данные для шейдера пикселей. Другие операции с пикселями (смешение тумана, операции с трафаретами и наложение целевого объекта визуализации) происходят после выполнения шейдера.

### <a name="texture-stage-and-sampler-states"></a>Стадия текстуры и состояния образца

Шейдер пикселей полностью заменяет функциональные возможности смешения пикселей, заданные многотекстурным смешением, включая операции, ранее определенные состояниями стадии текстуры. Операции выборки текстур и фильтрации, которые управляются состояниями стандартного этапа текстуры для минификации, увеличения, MIP и режима адресации, можно инициализировать в шейдерах. Приложение может изменить эти состояния, не требуя повторного формирования шейдера, привязанного к текущему объекту. Задание состояния можно сделать еще проще, если шейдеры спроектированы в пределах влияния.

### <a name="pixel-shader-inputs"></a>Входные шейдеры пикселей

Для версий построителя текстуры PS \_ 1 \_ 1 — PS \_ 2 \_ 0 рассеянные и бликовые цвета загружаются в диапазоне от 0 до 1 перед использованием шейдера.

Предполагается, что входные значения цветов для шейдера пикселей верны, но это не гарантируется (для всех аппаратных средств). Цвета, выбираемые из координат текстуры, обрабатываются с точки зрения правильности и записываются в 0 – 1 диапазон во время итерации.

### <a name="pixel-shader-outputs"></a>Выходные данные шейдера пикселей

Для версий построителя текстуры PS \_ 1 \_ 1 — PS \_ 1 \_ 4 результат, выдаваемый шейдером пикселей, — это содержимое Register R0. Любое содержимое, которое он содержит после завершения обработки шейдера, отправляется на этап тумана и нацеливание на целевой объект.

Для версий построителя текстуры PS \_ 2 \_ 0 и выше выходной цвет создается из OC0-oC4.

## <a name="shader-inputs-and-shader-variables"></a>Входные и переменные шейдеров

-   [Объявление переменных шейдера](#declaring-shader-variables)
-   [Входные данные универсального шейдера](#uniform-shader-inputs)
-   [Различные входные и семантические значения шейдера](#varying-shader-inputs-and-semantics)
-   [Пробы и объекты текстуры](#samplers-and-texture-objects)

### <a name="declaring-shader-variables"></a>Объявление переменных шейдера

Простейшее объявление переменной включает тип и имя переменной, например следующее объявление с плавающей запятой:


```
float fVar;
```



Вы можете инициализировать переменную в той же инструкции.


```
float fVar = 3.1f;
```



Массив переменных можно объявить,


```
int iVar[3];
```



или объявлен и инициализирован в одной инструкции.


```
int iVar[3] = {1,2,3};
```



Ниже приведено несколько объявлений, демонстрирующих многие характеристики переменных языка шейдера высокого уровня (HLSL):


```
float4 color;
uniform float4 position : POSITION; 
const float4 lightDirection = {0,0,1};
```



В объявлениях данных может использоваться любой допустимый тип, включая:

-   [Типы данных (DirectX HLSL)](dx-graphics-hlsl-data-types.md)
-   [Тип вектора (DirectX HLSL)](dx-graphics-hlsl-vector.md)
-   [Тип матрицы (DirectX HLSL)](dx-graphics-hlsl-matrix.md)
-   [Тип шейдера (DirectX HLSL)](dx-graphics-hlsl-shader.md)
-   [Тип образца (DirectX HLSL)](dx-graphics-hlsl-sampler.md)
-   [Определяемый пользователем тип (DirectX HLSL)](dx-graphics-hlsl-user-defined.md)

Шейдер может иметь переменные верхнего уровня, аргументы и функции.


```
// top-level variable
float globalShaderVariable; 

// top-level function
void function(
in float4 position: POSITION0 // top-level argument
              )
{
  float localShaderVariable; // local variable
  function2(...)
}

void function2()
{
  ...
}
```



Переменные верхнего уровня объявляются за пределами всех функций. Аргументы верхнего уровня — это параметры функции верхнего уровня. Функция верхнего уровня — это любая функция, вызываемая приложением (в отличие от функции, которая вызывается другой функцией).

### <a name="uniform-shader-inputs"></a>Входные данные универсального шейдера

Шейдеры вершин и пикселей принимают два вида входных данных: разные и однородные. Различные входные данные являются уникальными для каждого выполнения шейдера. Для шейдера вершин различные данные (например, "расположение", "нормальный" и т. д.) поступают из потоков вершин. Однородные данные (например, "цвет материала", "универсальное преобразование" и т. д.) являются постоянными для нескольких выполнений шейдера. Для тех, кто знаком с моделями шейдера сборки, универсальные данные задаются постоянными регистрами и различными данными по регистрам v и t.

Однородные данные могут быть заданы двумя методами. Наиболее распространенным методом является объявление глобальных переменных и их использование в шейдере. Любое использование глобальных переменных в шейдере приведет к добавлению этой переменной в список универсальных переменных, необходимых для этого шейдера. Второй метод заключается в пометке входного параметра функции шейдера верхнего уровня как универсального. Эта маркировка указывает, что заданная переменная должна быть добавлена в список универсальных переменных.

Универсальные переменные, используемые шейдером, передаются обратно в приложение через таблицу констант. Таблица констант — это имя таблицы символов, которое определяет, как универсальные переменные, используемые шейдером, помещаются в постоянные регистры. Параметры универсальной функции отображаются в таблице констант в начале символа доллара ($), в отличие от глобальных переменных. Знак доллара необходим, чтобы избежать конфликтов имен между локальными универсальными входными данными и глобальными переменными с одним и тем же именем.

Таблица констант содержит расположения регистров констант всех универсальных переменных, используемых шейдером. Таблица также содержит сведения о типе и значение по умолчанию, если оно указано.

### <a name="varying-shader-inputs-and-semantics"></a>Различные входные и семантические значения шейдера

Различные входные параметры (функции шейдера верхнего уровня) должны быть помечены как семантическое или универсальное ключевое слово, указывающее, что значение является константой для выполнения шейдера. Если входные шейдеры верхнего уровня не помечены семантическим или равномерным ключевым словом, то шейдер не будет компилироваться.

Семантика ввода — это имя, используемое для связывания заданного ввода с выходными данными предыдущей части графического конвейера. Например, в шейдере вершин используется входная семантическая POSITION0 для указания места, где должны быть связаны данные о положении из буфера вершин.

Шейдеры пикселей и вершин имеют разные наборы входных данных в соответствии с различными частями графического конвейера, которые передаются в каждый блок шейдера. Семантика ввода шейдера вершин описывает сведения о каждой вершине (например: расположение, нормаль, координаты текстуры, цвет, тангенс, бинормал и т. д.), загружаемые из буфера вершин в форму, которая может использоваться шейдером вершин. Семантика ввода непосредственно сопоставляется с использованием объявления вершин и индекса использования.

Семантика ввода шейдера пикселей описывает сведения, предоставляемые на пиксель блоком растрирования. Данные создаются путем интерполяции между выходными данными шейдера вершин для каждой вершины текущего примитива. Семантическая семантика ввода шейдера пикселей связывает цвет вывода и сведения о координатах текстуры с входными параметрами.

Семантика ввода может быть назначена входным шейдером двумя методами:

-   Добавление двоеточия и семантического имени в объявление параметра.
-   Определение входной структуры с семантикой ввода, назначенной каждому члену структуры.

Шейдер вершин и пиксель предоставляют выходные данные на последующий этап графического конвейера. Семантика вывода используется для указания того, как данные, формируемые шейдером, должны быть связаны с входами следующего этапа. Например, семантика вывода для шейдера вершин используется для связывания выходных данных интерполяции в средствах программ-прорисовки, чтобы создать входные данные для шейдера пикселей. Выходные данные шейдера пикселей являются значениями, переданными в альфа-смешение для каждого целевого объекта прорисовки, или значение глубины, записанное в буфер глубины.

Семантика вывода шейдера вершин используется для связи шейдера с шейдером пикселей и с стадией средства развертки. Шейдер вершин, используемый средством программной прорисовки и недоступный для шейдера пикселей, должен создавать данные о положении как минимум. Шейдеры вершин, создающие координаты текстуры и данные цвета, предоставляют эти данные в шейдер пикселей после выполнения интерполяции.

Семантика вывода шейдера пикселей привязывает выходные цвета шейдера пикселей к правильному целевому объекту рендеринга. Выходной цвет шейдера пикселей связан с стадией альфа-смешения, который определяет, как изменяются целевые объекты отрисовки. Выходные данные глубины шейдера пикселей можно использовать для изменения значений глубины назначения в текущем растровом расположении. Выходные данные глубины и несколько целевых объектов рендеринга поддерживаются только в некоторых моделях шейдеров.

Синтаксис для семантики вывода идентичен синтаксису для указания семантики ввода. Семантика может быть указана непосредственно в параметрах, объявленных как "out", или назначена во время определения структуры, возвращаемой как параметр "out", либо возвращаемое значение функции.

Семантика определяет, откуда поступают данные. Семантика — это необязательные идентификаторы, которые определяют входные и выходные данные шейдера. Семантика отображается в одном из трех мест:

-   После элемента структуры.
-   После аргумента в списке входных аргументов функции.
-   После списка входных аргументов функции.

В этом примере используется структура для предоставления одного или нескольких входных шейдеров вершин и еще одна структура для предоставления одного или нескольких выходных данных шейдера вершин. Каждый из членов структуры использует семантику.


```
vector vClr;

struct VS_INPUT
{
    float4 vPosition : POSITION;
    float3 vNormal : NORMAL;
    float4 vBlendWeights : BLENDWEIGHT;
};

struct VS_OUTPUT
{
    float4  vPosition : POSITION;
    float4  vDiffuse : COLOR;

};

float4x4 mWld1;
float4x4 mWld2;
float4x4 mWld3;
float4x4 mWld4;

float Len;
float4 vLight;

float4x4 mTot;

VS_OUTPUT VS_Skinning_Example(const VS_INPUT v, uniform float len=100)
{
    VS_OUTPUT out;

    // Skin position (to world space)
    float3 vPosition = 
        mul(v.vPosition, (float4x3) mWld1) * v.vBlendWeights.x +
        mul(v.vPosition, (float4x3) mWld2) * v.vBlendWeights.y +
        mul(v.vPosition, (float4x3) mWld3) * v.vBlendWeights.z +
        mul(v.vPosition, (float4x3) mWld4) * v.vBlendWeights.w;
    // Skin normal (to world space)
    float3 vNormal =
        mul(v.vNormal, (float3x3) mWld1) * v.vBlendWeights.x + 
        mul(v.vNormal, (float3x3) mWld2) * v.vBlendWeights.y + 
        mul(v.vNormal, (float3x3) mWld3) * v.vBlendWeights.z + 
        mul(v.vNormal, (float3x3) mWld4) * v.vBlendWeights.w;
    
    // Output stuff
    out.vPosition    = mul(float4(vPosition + vNormal * Len, 1), mTot);
    out.vDiffuse  = dot(vLight,vNormal);

    return out;
}
```



Входная структура определяет данные из буфера вершин, которые будут предоставлять входные шейдеры. Этот шейдер сопоставляет данные из элементов "расположение", "нормальный" и "блендвеигхт" в буфере вершин с регистрами шейдера вершин. Тип входных данных не должен точно совпадать с типом данных объявления вершины. Если он не полностью соответствует, данные вершин будут автоматически преобразованы в тип данных HLSL при его написании в регистрах шейдера. Например, если обычные данные были определены в приложении как тип UINT, они будут преобразованы в float3 при чтении шейдером.

Если данные в потоке вершин содержат меньше компонентов, чем соответствующий тип данных шейдера, отсутствующие компоненты будут инициализированы значением 0 (за исключением w, который инициализируется значением 1).

Семантика ввода аналогична значениям в [**D3DDECLUSAGE**](/windows/desktop/direct3d9/d3ddeclusage).

Выходная структура определяет выходные параметры шейдера вершин в параметрах "расположение" и "цвет". Эти выходные данные будут использоваться конвейером для растрирования треугольника (при простой обработке). Вывод, помеченный как данные о положении, определяет расположение вершины в однородном пространстве. Как минимум Вершинный шейдер должен формировать данные о положении. Положение пространства на экране вычислено после завершения шейдера вершин путем деления координат (x, y, z) на w. В пространстве экрана-1 и 1 — минимальное и максимальное значения x и y границ окна просмотра, а z — для тестирования z-буфера.

Семантика вывода также аналогична значениям в [**D3DDECLUSAGE**](/windows/desktop/direct3d9/d3ddeclusage). В общем случае выходная структура для шейдера вершин также может использоваться в качестве входной структуры для шейдера пикселей, если построитель текстуры не считывает данные из любой переменной, помеченной как расположение, размер точки или семантика тумана. Эти семантики связаны с скалярными значениями для каждой вершины, которые не используются в шейдере пикселей. Если эти значения необходимы для шейдера пикселей, их можно скопировать в другую выходную переменную, использующую семантику шейдера пикселей.

Глобальные переменные назначаются для регистрации автоматически компилятором. Глобальные переменные также называются единообразными, поскольку содержимое переменной одинаково для всех пикселей, обрабатываемых при каждом вызове шейдера. Регистры содержатся в таблице констант, которую можно считать с помощью интерфейса [**ID3DXConstantTable**](/windows/desktop/direct3d9/id3dxconstanttable) .

Семантика ввода для шейдеров пикселей сопоставляет значения с конкретными аппаратными регистрами для транспортировки между шейдерами вершин и шейдерами пикселей. Каждый тип регистра имеет определенные свойства. Поскольку в настоящее время существует только две семантики для цветов и координат текстуры, большинство данных обычно помечаются как координаты текстуры, даже если это не так.

Обратите внимание, что выходная структура шейдера вершин использует входные данные с данными о положении, которые не используются шейдером пикселей. HLSL позволяет использовать допустимые выходные данные шейдера вершин, которые не являются допустимыми входными данными для шейдера пикселей при условии, что на него нет ссылок в шейдере пикселей.

Входные аргументы также могут быть массивами. Семантика автоматически увеличивается компилятором для каждого элемента массива. Например, рассмотрим следующее явное объявление:


```
struct VS_OUTPUT
{
    float4 Position   : POSITION;
    float3 Diffuse    : COLOR0;
    float3 Specular   : COLOR1;               
    float3 HalfVector : TEXCOORD3;
    float3 Fresnel    : TEXCOORD2;               
    float3 Reflection : TEXCOORD0;               
    float3 NoiseCoord : TEXCOORD1;               
};

float4 Sparkle(VS_OUTPUT In) : COLOR
```



Явное объявление, приведенное выше, эквивалентно следующему объявлению, в котором семантика будет автоматически увеличиваться компилятором:


```
float4 Sparkle(float4 Position : POSITION,
                 float3 Col[2] : COLOR0,
                 float3 Tex[4] : TEXCOORD0) : COLOR0
{
   // shader statements
   ...
```



Точно так же, как и семантика ввода, семантика вывода определяет использование данных для выходных данных построителя текстуры. Многие шейдеры пикселей записывают только один выходной цвет. Шейдеры пикселей также могут записывать значение глубины в один или несколько целевых объектов отрисовки одновременно (до четырех). Как и шейдеры вершин, шейдеры пикселей используют структуру для возвращения более чем одного результата. Этот шейдер записывает 0 в компоненты цвета, а также в компонент глубины.


```
struct PS_OUTPUT
{
    float4 Color[4] : COLOR0;
    float  Depth  : DEPTH;
};

PS_OUTPUT main(void)
{
    PS_OUTPUT out;

   // Shader statements
   ...

  // Write up to four pixel shader output colors
  out.Color[0] =  ...
  out.Color[1] =  ...
  out.Color[2] =  ...
  out.Color[3] =  ...

  // Write pixel depth 
  out.Depth =  ...

    return out;
}
```



Выходные цвета шейдера пикселей должны иметь тип float4. При записи нескольких цветов все выходные цвета должны использоваться последовательно. Иными словами, [COLOR1](dx-graphics-hlsl-semantics.md) не может быть выходным, если [COLOR0](dx-graphics-hlsl-semantics.md) уже не записан. Выходные данные глубины шейдера пикселей должны иметь тип float1.

### <a name="samplers-and-texture-objects"></a>Пробы и объекты текстуры

Образец содержит состояние образца. Состояние образца определяет текстуру для выборки и управляет фильтрацией, выполненной во время выборки. Для выборки текстуры необходимы три вещи.

-   Текстура
-   Образец (с состоянием образца)
-   Инструкция выборки

Пробы можно инициализировать с помощью текстур и состояния образца, как показано ниже:


```
sampler s = sampler_state 
{ 
  texture = NULL; 
  mipfilter = LINEAR; 
};
```



Ниже приведен пример кода для выборки двухмерной текстуры.


```
texture tex0;
sampler2D s_2D;

float2 sample_2D(float2 tex : TEXCOORD0) : COLOR
{
  return tex2D(s_2D, tex);
}
```



Текстура объявляется с помощью переменной текстуры tex0.

В этом примере объявляется переменная образца с именем s \_ 2D. Образец содержит состояние образца внутри фигурных скобок. Это включает в себя текстуру, которая будет выдавать выборку и, при необходимости, состояние фильтра (т. е. режимы переноса, режимы фильтрации и т. д.). Если состояние выборки опущено, то применяется состояние образца по умолчанию, определяющее линейную фильтрацию и режим переноса для координат текстуры. Функция выборки принимает координату текстуры с плавающей точкой с двумя компонентами и возвращает цвет из двух компонентов. Он представлен типом возвращаемого значения float2 и представляет данные в красном и зеленом компонентах.

Определены четыре типа выборки (см. [Ключевые слова](dx-graphics-hlsl-appendix.md)), а поиск текстур выполняется встроенными функциями: [**tex1D (s, t) (DirectX HLSL)**](dx-graphics-hlsl-tex1d.md), [**tex2D (s, t) (DirectX HLSL)**](dx-graphics-hlsl-tex2d.md), [**tex3D (s, t) (DirectX HLSL)**](dx-graphics-hlsl-tex3d.md), [**текскубе (s, t) (DirectX HLSL)**](dx-graphics-hlsl-texcube.md). Ниже приведен пример трехмерной выборки.


```
texture tex0;
sampler3D s_3D;

float3 sample_3D(float3 tex : TEXCOORD0) : COLOR
{
  return tex3D(s_3D, tex);
}
```



В этом объявлении образца используется состояние образца по умолчанию для параметров фильтра и режима адреса.

Ниже приведен пример соответствующей выборки Куба.


```
texture tex0;
samplerCUBE s_CUBE;

float3 sample_CUBE(float3 tex : TEXCOORD0) : COLOR
{
  return texCUBE(s_CUBE, tex);
}
```



И, наконец, ниже приведен пример одномерной выборки:


```
texture tex0;
sampler1D s_1D;

float sample_1D(float tex : TEXCOORD0) : COLOR
{
  return tex1D(s_1D, tex);
}
```



Так как среда выполнения не поддерживает одномерное текстуры, компилятор будет использовать двухмерную текстуру с набором знаний, что координата y не имеет значения. Поскольку [**tex1D (s, t) (DirectX HLSL)**](dx-graphics-hlsl-tex1d.md) реализован в виде 2D-поиска текстур, компилятор может эффективно выбирать компонент y. В некоторых редких случаях компилятор не может выбрать эффективный компонент y, в этом случае будет выдаваться предупреждение.


```
texture tex0;
sampler s_1D_float;

float4 main(float texCoords : TEXCOORD) : COLOR
{
    return tex1D(s_1D_float, texCoords);
}
```



Этот пример неэффективен, так как компилятор должен переместить входную координату в другой регистр (поскольку Уточняющий запрос одномерного типа реализуется как 2D-Поиск, а координата текстуры объявлена как float1). Если код перезаписывается с использованием входных данных float2 вместо float1, компилятор может использовать входную координату текстуры, так как известно, что y инициализировано как-то.


```
texture tex0;
sampler s_1D_float2;

float4 main(float2 texCoords : TEXCOORD) : COLOR
{
    return tex1D(s_1D_float2, texCoords);
}
```



Все поиски текстур можно добавить с помощью "смещения" или "proj" (то есть [**tex2Dbias (DirectX HLSL)**](dx-graphics-hlsl-tex2dbias.md), [**ТЕКСКУБЕПРОЖ (DirectX HLSL)**](dx-graphics-hlsl-texcubeproj.md)). При использовании суффикса "proj" Координата текстуры делится на компонент w-Component. При «смещении» уровень MIP смещается на w-Component. Таким же, все поиски текстур с суффиксом всегда принимают float4 входные данные. [**tex1D (s, t) (DirectX HLSL)**](dx-graphics-hlsl-tex1d.md) и [**tex2D (s, t) (DirectX HLSL)**](dx-graphics-hlsl-tex2d.md) игнорируют компоненты из и z соответственно.

В массиве также можно использовать пробы, хотя в настоящее время нет серверной части, поддерживающей динамический доступ к массиву образцов. Таким образом, следующий код является допустимым, так как он может быть разрешен во время компиляции:


```
tex2D(s[0],tex)
```



Однако этот пример является недопустимым.


```
tex2D(s[a],tex)
```



Динамический доступ к пробам в основном полезен для написания программ с помощью литеральных циклов. Следующий код иллюстрирует доступ к массиву образцов:


```
sampler sm[4];

float4 main(float4 tex[4] : TEXCOORD) : COLOR
{
    float4 retColor = 1;

    for(int i = 0; i < 4;i++)
    {
        retColor *= tex2D(sm[i],tex[i]);
    }

    return retColor;
}
```



> [!Note]
>
> Использование среды выполнения отладки Microsoft Direct3D может помочь в перехвате несоответствий между числом компонентов в текстуре и образцом.

 

## <a name="writing-functions"></a>Написание функций

Функции разбивают большие задачи на меньшие. Небольшие задачи проще в отладке и могут использоваться повторно, если они проверены. Функции можно использовать для скрытия сведений о других функциях, что упрощает отслеживание программы, состоящей из функций.

Функции HLSL похожи на функции C несколькими способами: они содержат определение и тело функции, а также объявляют типы возвращаемых значения и списки аргументов. Как и функции C, проверка HLSL выполняет проверку типов аргументов, типов аргументов и возвращаемого значения во время компиляции шейдера.

В отличие от функций C, функции точки входа HLSL используют семантику для привязки аргументов функции к входным и выходным данным шейдера (функции HLSL, которые называются внутренними семантиками). Это упрощает привязку данных буфера к шейдеру и привязывает выходные данные шейдера к входным данным шейдера.

Функция содержит объявление и тело, а объявление должно предшествовать телу.


```
float4 VertexShader_Tutorial_1(float4 inPos : POSITION ) : POSITION
{
    return mul(inPos, WorldViewProj );
};
```



Объявление функции включает все перед фигурными скобками:


```
float4 VertexShader_Tutorial_1(float4 inPos : POSITION ) : POSITION
```



Объявление функции содержит:

-   Тип возвращаемого значения
-   Имя функции
-   Список аргументов (необязательно)
-   Семантика вывода (необязательно)
-   Аннотация (необязательно)

Тип возвращаемого значения может быть любым из базовых типов данных HLSL, таких как float4:


```
float4 VertexShader_Tutorial_1(float4 inPos : POSITION ) : POSITION
{
   ...
}
```



Возвращаемым типом может быть структура, которая уже определена:


```
struct VS_OUTPUT
{
    float4  vPosition        : POSITION;
    float4  vDiffuse         : COLOR;
}; 

VS_OUTPUT VertexShader_Tutorial_1(float4 inPos : POSITION )
{
   ...
}
```



Если функция не возвращает значение, в качестве возвращаемого типа можно использовать void.


```
void VertexShader_Tutorial_1(float4 inPos : POSITION )
{
   ...
}
```



Тип возвращаемого значения всегда отображается первым в объявлении функции.


```
float4 VertexShader_Tutorial_1(float4 inPos : POSITION ) : POSITION
```



Список аргументов объявляет входные аргументы функции. Он также может объявлять значения, которые будут возвращены. Некоторые аргументы являются входными и выходными аргументами. Ниже приведен пример шейдера, который принимает четыре входных аргумента.


```
float4 Light(float3 LightDir : TEXCOORD1, 
             uniform float4 LightColor,  
             float2 texcrd : TEXCOORD0, 
             uniform sampler samp) : COLOR 
{
    float3 Normal = tex2D(samp,texcrd);

    return dot((Normal*2 - 1), LightDir)*LightColor;
}
```



Эта функция возвращает окончательный цвет, который является смешением образца текстуры и светлого цвета. Функция принимает четыре входных значения. У двух входов есть семантика: Лигхтдир имеет семантику [TEXCOORD1](dx-graphics-hlsl-semantics.md) , а текскрд имеет семантику [TEXCOORD0](dx-graphics-hlsl-semantics.md) . Семантика означает, что данные для этих переменных будут поступать из буфера вершин. Несмотря на то, что переменная Лигхтдир имеет семантику [TEXCOORD1](dx-graphics-hlsl-semantics.md) , параметр, вероятно, не является координатой текстуры. Семантический тип Текскурдн часто используется для предоставления семантики для типа, который не является стандартным (отсутствует семантика ввода шейдера вершин для самого светлого направления).

Два других входа Лигхтколор и SAMP помечаются ключевым словом [Uniform](dx-graphics-hlsl-appendix.md) . Это универсальные константы, которые не меняются между вызовами Draw. Значения этих параметров берутся из глобальных переменных шейдера.

Аргументы могут быть помечены как входные данные с ключевым словом in, а выходные аргументы — ключевым словом out. Аргументы не могут передаваться по ссылке; Однако аргумент может быть как входным, так и выходным, если он объявлен с ключевым словом InOut. Аргументы, передаваемые в функцию, помеченную ключевым словом InOut, считаются копиями исходного объекта до тех пор, пока функция не вернется и они будут скопированы обратно. Ниже приведен пример с использованием INOUT:


```
void Increment_ByVal(inout float A, inout float B) 
{ 
    A++; B++;
}
```



Эта функция увеличивает значения в A и B и возвращает их.

Тело функции — это весь код после объявления функции.


```
float4 VertexShader_Tutorial_1(float4 inPos : POSITION ) : POSITION
{
    return mul(inPos, WorldViewProj );
};
```



Текст состоит из операторов, заключенных в фигурные скобки. Тело функции реализует все функциональные возможности с помощью переменных, литералов, выражений и инструкций.

Текст шейдера выполняет две вещи: он вычисляет матрицу и возвращает результат float4. Умножение матрицы осуществляется с помощью функции [**mul (DirectX HLSL)**](dx-graphics-hlsl-mul.md) , которая выполняет умножение матрицы 4x4. **mul (DirectX HLSL)** называется встроенной функцией, так как она уже встроена в библиотеку HLSL функций. Встроенные функции будут подробно рассмотрены в следующем разделе.

Матрица умножает сочетание входного вектора POS и составной матрицы Ворлдвиевпрож. Результат — данные о положении, преобразованные в пространство экрана. Это минимальный способ обработки шейдера вершин. Если вместо шейдера вершин использовался конвейер фиксированной функции, то данные вершин могут быть выведены после выполнения этого преобразования.

Последняя инструкция в теле функции является оператором Return. Как и в C, эта инструкция возвращает управление из функции в инструкцию, которая вызвала функцию.

Возвращаемые функцией типы могут быть любыми простыми типами данных, определенными в HLSL, включая bool, int половины, float и Double. Возвращаемыми типами могут быть один из сложных типов данных, таких как векторы и матрицы. Типы HLSL, которые ссылаются на объекты, не могут использоваться в качестве возвращаемых типов. Сюда входят PixelShader, вертексшадер, текстура и образцы.

Ниже приведен пример функции, которая использует структуру для возвращаемого типа.


```
float4x4 WorldViewProj : WORLDVIEWPROJ;

struct VS_OUTPUT
{
    float4 Pos  : POSITION;
};

VS_OUTPUT VS_HLL_Example(float4 inPos : POSITION )
{
    VS_OUTPUT Out;

    Out.Pos = mul(inPos,  WorldViewProj );

    return Out;
};
```



Тип возвращаемого значения float4 был заменен структурой VS \_ Output, которая теперь содержит один элемент float4.

Оператор Return сообщает об окончании функции. Это простейший оператор return. Он возвращает управление из функции в вызывающую программу. Он не возвращает значения.


```
void main()
{
    return ;
}
```



Оператор return может возвращать одно или несколько значений. В этом примере возвращается литеральное значение:


```
float main( float input : COLOR0) : COLOR0
{
    return 0;
}
```



Этот пример возвращает скалярный результат выражения:


```
return  light.enabled;
```



Этот пример возвращает float4, созданный из локальной переменной и литерала:


```
return  float4(color.rgb, 1) ;
```



Этот пример возвращает float4, созданный на основе результата, возвращенного из подставляемой функции, и несколько литеральных значений:


```
float4 func(float2 a: POSITION): COLOR
{
    return float4(sin(length(a) * 100.0) * 0.5 + 0.5, sin(a.y * 50.0), 0, 1);
}
```



В этом примере возвращается структура, содержащая один или несколько элементов:


```
float4x4 WorldViewProj;

struct VS_OUTPUT
{
    float4 Pos  : POSITION;
};

VS_OUTPUT VertexShader_Tutorial_1(float4 inPos : POSITION )
{
    VS_OUTPUT out;
    out.Pos = mul(inPos, WorldViewProj );
    return out;
};
```



## <a name="flow-control"></a>Управление потоком

Большинство текущих устройств шейдера вершин и построителя текстуры разработано для выполнения построчного шейдера с выполнением каждой инструкции один раз. HLSL поддерживает управление потоком, которое включает в себя статическое ветвление, предикатные инструкции, статические циклы, Динамическое ветвление и динамическое зацикливание.

Ранее использование оператора if привело к появлению кода шейдера на языке ассемблера, который реализует как сторона If, так и else в потоке кода. Ниже приведен пример кода HLSL, который был скомпилирован для VS \_ 1 \_ 1:


```
if (Value > 0)
    oPos = Value1; 
else
    oPos = Value2; 
```



Вот итоговый код сборки:


```
// Calculate linear interpolation value in r0.w
mov r1.w, c2.x               
slt r0.w, c3.x, r1.w         
// Linear interpolation between value1 and value2
mov r7, -c1                      
add r2, r7, c0                   
mad oPos, r0.w, r2, c1  
```



Некоторые аппаратные средства поддерживают либо статический, либо динамический цикл, но для большинства требуется линейное выполнение. В моделях, которые не поддерживают циклы, все циклы должны быть отменены. Примером является пример примера [депсоффиелд](https://msdn.microsoft.com/library/Ee416592(v=VS.85).aspx) , использующий невыполненные циклы, даже \_ для \_ шейдеров PS 1 1.

HLSL теперь включает поддержку каждого из этих типов управления потоком:

-   Статическая ветвь
-   инструкции с предикатами
-   статические циклы
-   Динамическое ветвление
-   динамическое зацикливание

Статическое ветвление позволяет переключать или отключать блоки кода шейдера на основе константы шейдера Boolean. Это удобный способ включения или отключения путей кода в зависимости от типа объекта, для которого выполняется визуализация. Между вызовами Draw можно выбрать, какие функции должны поддерживаться с помощью текущего шейдера, а затем установить логические флаги, необходимые для получения такого поведения. Все инструкции, отключенные логической константой, пропускаются во время выполнения шейдера.

Наиболее знакомая поддержка ветвления — Динамическое ветвление. При динамической ветвлении условие сравнения находится в переменной, что означает, что сравнение выполняется для каждой вершины или каждого пикселя во время выполнения (в отличие от сравнения, происходящих во время компиляции, или между двумя вызовами Draw). Снижение производительности — это стоимость ветви, а также стоимость инструкций, выполняемых на стороне филиала. Динамическое ветвление реализуется в модели шейдеров 3 или более поздней версии. Оптимизация шейдеров, работающих с этими моделями, аналогична оптимизации кода, выполняемого на ЦП.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Руководство по программированию для HLSL](dx-graphics-hlsl-pguide.md)
</dt> </dl>

 

 
