---
title: Операторы
description: Выражения — это последовательности переменных и литералов, прерывистого операторами.
ms.assetid: c31aa0b8-1284-48aa-b000-d72433f0f5cc
ms.topic: article
ms.date: 05/31/2018
topic_type:
- kbArticle
api_name: ''
api_type: ''
api_location: ''
ms.openlocfilehash: d7a44fe02983038658247fedaec7122f09306548
ms.sourcegitcommit: b32433cc0394159c7263809ae67615ab5792d40d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/30/2021
ms.locfileid: "113119609"
---
# <a name="operators"></a>Операторы

Выражения — это последовательности [переменных](dx-graphics-hlsl-variable-syntax.md) и литералов, прерывистого [операторами](dx-graphics-hlsl-statement-blocks.md). Операторы определяют, как переменные и литералы объединяются, сравниваются, выбираются и т. д. К операторам относятся:



| имя оператора;                                                                                | Операторы                                                                   |
|---------------------------------------------------------------------------------|--------------------------------------------------------------------|
| [Аддитивные и Мультипликативные операторы](#additive-and-multiplicative-operators) | +, -, \*, /, %                                                     |
| [Оператор массива](#array-operator)                                               | \[i\]                                                              |
| [Операторы присваивания](#assignment-operators)                                   | =, +=, -=, \*=, /=, %=                                             |
| [Двоичные приведения](#binary-casts)                                                   | Правила c для логического типа float и int, C Rules или HLSL для bool     |
| [Битовые операторы](#bitwise-operators)                                         | ~,  <<,  >>, &, \| , ^,  <<=,  >>=, &=, \| =, ^ = |
| [Логические математические операторы](#boolean-math-operators)                               | & &, \| \| ,?:                                                      |
| [Оператор приведения](#cast-operator)                                                 | Тип                                                             |
| [Запятая, оператор](#comma-operator)                                               | ,                                                                  |
| [Операторы сравнения](#comparison-operators)                                   | <, >, = =,! =, <=, >=                                   |
| [Операторы префикса или постфикс](#prefix-or-postfix-operators)                     | ++, --                                                             |
| [Оператор Structure](#structure-operator)                                       | .                                                                  |
| [Унарные операторы](#unary-operators)                                             | !, -, +                                                            |



 

Многие из операторов относятся к каждому компоненту, что означает, что операция выполняется независимо для каждого компонента каждой переменной. Например, одна переменная компонента имеет одну операцию. С другой стороны, в переменной с четырьмя компонентами выполняется четыре операции, по одной для каждого компонента.

Все операторы, которые делают что-то значение, например + и \* , работают на каждом компоненте.

Операторы сравнения должны работать только с одним компонентом, если только не используется встроенная функция [**ALL**](dx-graphics-hlsl-all.md) или [**любая**](dx-graphics-hlsl-any.md) из них с несколькими компонентами. Следующая операция завершается ошибкой, так как оператор If требует один bool, но получает bool4:


```
if (A4 < B4)
```



Следующие операции выполнены.


```
if ( any(A4 < B4) )
if ( all(A4 < B4) )
```



Бинарные операторы приведения [**асфлоат**](dx-graphics-hlsl-asfloat.md), [**ASIN**](dx-graphics-hlsl-asint.md)и т. д. для каждого компонента, за исключением [**асдаубле**](asdouble.md) , для которого задокументированы особые правила.

Операторы выбора, такие как точка, запятая и скобки массива, не работают для каждого компонента.

Операторы CAST изменяют число компонентов. Следующие операции приведения показывают их эквивалентность:


```
(float) i4 ->   float(i4.x)
(float4)i ->   float4(i, i, i, i)
```



## <a name="additive-and-multiplicative-operators"></a>Аддитивные и Мультипликативные операторы

К операторам аддитивного и мультипликативные относятся: +,-, \* ,/,%


```
int i1 = 1;
int i2 = 2;
int i3 = i1 + i2;  // i3 = 3
i3 = i1 * i2;        // i3 = 1 * 2 = 2
```




```
i3 = i1/i2;       // i3 = 1/3 = 0.333. Truncated to 0 because i3 is an integer.
i3 = i2/i1;       // i3 = 2/1 = 2
```




```
float f1 = 1.0;
float f2 = 2.0f;
float f3 = f1 - f2; // f3 = 1.0 - 2.0 = -1.0
f3 = f1 * f2;         // f3 = 1.0 * 2.0 = 2.0
```




```
f3 = f1/f2;        // f3 = 1.0/2.0 = 0.5
f3 = f2/f1;        // f3 = 2.0/1.0 = 2.0
```



Оператор модуля возвращает остаток от деления. Это дает разные результаты при использовании целых чисел и чисел с плавающей запятой. Целочисленные остатки, которые являются дробными, будут обрезаны.


```
int i1 = 1;
int i2 = 2;
i3 = i1 % i2;      // i3 = remainder of 1/2, which is 1
i3 = i2 % i1;      // i3 = remainder of 2/1, which is 0
i3 = 5 % 2;        // i3 = remainder of 5/2, which is 1
i3 = 9 % 2;        // i3 = remainder of 9/2, which is 1
```



Оператор модуля усекает оставшуюся часть при использовании целых чисел.


```
f3 = f1 % f2;      // f3 = remainder of 1.0/2.0, which is 0.5
f3 = f2 % f1;      // f3 = remainder of 2.0/1.0, which is 0.0
```



Оператор% определен только в случаях, когда обе стороны либо положительные, либо обе стороны являются отрицательными. В отличие от C, он также работает с типами данных с плавающей запятой, а также с целыми числами.

## <a name="array-operator"></a>Оператор массива

Оператор выбора члена массива " \[ i \] " выбирает один или несколько компонентов в массиве. Это набор квадратных скобок, содержащих Отсчитываемый от нуля индекс.


```
int arrayOfInts[4] = { 0,1,2,3 };
arrayOfInts[0] = 2;
arrayOfInts[1] = arrayOfInts[0];
```



Оператор Array также может использоваться для доступа к вектору.


```
float4 4D_Vector = { 0.0f, 1.0f, 2.0f, 3.0f  };         
float 1DFloat = 4D_Vector[1];          // 1.0f
```



Добавив дополнительный индекс, оператор Array также может получить доступ к матрице.


```
float4x4 mat4x4 = {{0,0,0,0}, {1,1,1,1}, {2,2,2,2}, {3,3,3,3} };
mat4x4[0][1] = 1.1f;
float 1DFloat = mat4x4[0][1];      // 0.0f
```



Первый индекс — это Отсчитываемый от нуля индекс строки. Второй индекс — это Отсчитываемый от нуля индекс столбца.

## <a name="assignment-operators"></a>Операторы присваивания

Операторы присваивания: =, + =,-=, \* =,/=

Переменным могут быть присвоены литеральные значения:


```
int i = 1;            
float f2 = 3.1f; 
bool b = false;
string str = "string";
```



Переменным также можно назначить результат математической операции:


```
int i1 = 1;
i1 += 2;           // i1 = 1 + 2 = 3
```



Переменную можно использовать с любой стороны знака равенства:


```
float f3 = 0.5f;
f3 *= f3;          // f3 = 0.5 * 0.5 = 0.25
```



Деление переменных с плавающей запятой является ожидаемым, так как десятичные остатки не являются проблемой.


```
float f1 = 1.0;
f1 /= 3.0f;        // f1 = 1.0/3.0 = 0.333
```



Будьте внимательны, если используете целые числа, которые могут быть разделены, особенно если усечение влияет на результат. Этот пример идентичен предыдущему примеру, за исключением типа данных. Усечение приводит к совершенно другому результату.


```
int i1 = 1;
i1 /= 3;           // i1 = 1/3 = 0.333, which gets truncated to 0
```



## <a name="binary-casts"></a>Двоичные приведения

Операция приведения между int и float Преобразует числовое значение в соответствующие представления ниже правил C для усечения типа int. Приведение значения с плавающей запятой к типу int и обратно в тип float приведет к преобразованию потери на основе точности целевого объекта.

Двоичные приведения также можно выполнять с помощью [**встроенных функций (DirectX HLSL)**](dx-graphics-hlsl-intrinsic-functions.md), которые повторно преобразуют битовое представление числа в целевой тип данных.


```
asfloat() // Cast to float
asint()   // Cast to int 
asuint()  // Cast to uint
```



## <a name="bitwise-operators"></a>Побитовые операторы

HLSL поддерживает следующие битовые операторы, имеющие тот же приоритет, что и C, в отношении других операторов. В следующей таблице описаны операторы.

> [!Note]  
> Побитовым операторам требуется [модель шейдера 4 \_ 0](dx-graphics-hlsl-sm4.md) с Direct3D 10 и более высоким оборудованием.

 



| Оператор          |  Функция                 |
|-----------|-------------------|
| ~         | Логическое не       |
| <<  | Сдвиг влево        |
| >>  | Сдвиг вправо       |
| &         | Логическое «И»       |
| \|        | Логическое "или".        |
| ^         | Логическое исключающее или       |
| <<= | Сдвиг влево равен  |
| >>= | Сдвиг вправо равно |
| &=        | И равно         |
| \|=       | Или равно          |
| ^=        | XOR равно         |



 

Битовые операторы определяются только для типов данных int и uint. Попытка использовать побитовые операторы для типов данных float или struct приведет к ошибке.

## <a name="boolean-math-operators"></a>Логические математические операторы

Логические математические операторы:  &&, \| \| ,?:


```
bool b1 = true;
bool b2 = false;
bool b3 = b1 && b2 // b3 = true AND false = false
b3 = b1 || b2                // b3 = true OR false = true
```



В отличие от сокращенного вычисления &&, \| \| и?: в C выражения HLSL никогда не являются коротким вычислением, так как они являются векторными операциями. Все стороны выражения всегда оцениваются.

Логические операторы работают с каждым компонентом. Это означает, что при сравнении двух векторов результат будет вектором, содержащим логический результат сравнения для каждого компонента.

Для выражений, использующих логические операторы, размер и тип компонента каждой переменной становятся одинаковыми до выполнения операции. Повышенный тип определяет разрешение, при котором выполняется операция, а также тип результата выражения. Например, выражение с плавающей запятой + + + будет преобразовано в float3 + float3 для оценки, и его результат будет иметь тип float3.

## <a name="cast-operator"></a>Оператор приведения

Выражение с префиксом имени типа в круглых скобках является явным приведением типов. Приведение типа преобразует исходное выражение в тип данных приведения. В целом, простые типы данных можно привести к более сложным типам данных (с приведением повышения), но только некоторые сложные типы данных можно привести к простым типам данных (с помощью приведения понижения).

Допустимо только приведение типа с правой стороны. Например, такие выражения, как, `(int)myFloat = myInt;` являются недопустимыми. Используйте вместо этого `myFloat = (float)myInt;`.

Компилятор также выполняет неявное приведение типов. Например, следующие два выражения эквивалентны:


```
int2 b = int2(1,2) + 2;
int2 b = int2(1,2) + int2(2,2);
```



## <a name="comma-operator"></a>Запятая, оператор

Оператор запятой (,) разделяет одно или несколько выражений, которые должны вычисляться по порядку. Значение последнего выражения в последовательности используется в качестве значения последовательности.

В этом случае стоит обратить внимание на. Если тип конструктора случайно не находится справа от знака равенства, в правой части теперь содержится четыре выражения, разделенные тремя запятыми.


```
// Instead of using a constructor
float4 x = float4(0,0,0,1); 

// The type on the right side is accidentally left off
float4 x = (0,0,0,1); 
```



Оператор "запятая" вычисляет выражение слева направо. Это сокращает правую часть до:


```
float4 x = 1; 
```



В этом случае в HLSL используется скалярное продвижение, поэтому результат будет таким же, как если бы он был написан следующим образом:


```
float4 x = float4(1,1,1,1);
```



В этом случае выход из типа float4 с правой стороны, вероятно, является ошибкой, которую компилятору не удается обнаружить, поскольку это допустимая инструкция.

## <a name="comparison-operators"></a>Операторы сравнения

Операторы сравнения: <, >, = =,! =, <=, >=.

Сравните значения, которые больше (или меньше) любого скалярного значения:


```
if( dot(lightDirection, normalVector) > 0 )
   // Do something; the face is lit
```




```
if( dot(lightDirection, normalVector) < 0 )
   // Do nothing; the face is backwards
```



Или Сравните значения, равные (или не равные) любому скалярному значению:


```
if(color.a == 0)
   // Skip processing because the face is invisible

if(color.a != 0)
   // Blend two colors together using the alpha value
```



Или объединить и сравнить значения, которые больше или равны (или меньше или равны) любому скалярному значению:


```
if( position.z >= oldPosition.z )
   // Skip the new face because it is behind the existing face
```




```
if( currentValue <= someInitialCondition )
   // Reset the current value to its initial condition
```



Каждое из этих сравнений можно выполнить с любым скалярным типом данных.

Чтобы использовать операторы сравнения с типами Vector и Matrix, используйте встроенную функцию [**ALL**](dx-graphics-hlsl-all.md) или [**ANY**](dx-graphics-hlsl-any.md) .

Эта операция завершается ошибкой, так как оператор If требует один bool, но получает bool4:


```
if (A4 < B4)
```



Эти операции выполнены.


```
if ( any(A4 < B4) )
if ( all(A4 < B4) )
```



## <a name="prefix-or-postfix-operators"></a>Операторы префикса или постфикс

Префиксные и постфиксные операторы: + +,--. Операторы префикса изменяют содержимое переменной перед вычислением выражения. Постфиксные операторы изменяют содержимое переменной после вычисления выражения.

В этом случае цикл использует содержимое i для наблюдения за числом циклов.


```
float4 arrayOfFloats[4] = { 1.0f, 2.0f, 3.0f, 4.4f };

for (int i = 0; i<4; )
{
    arrayOfFloats[i++] *= 2; 
}
```



Так как используется постфиксный оператор инкремента (+ +), Аррайоффлоатс \[ i \] умножается на 2 до увеличения. Это может быть немного Переупорядочено для использования оператора префикса инкремента. Это труднее читать, хотя оба примера эквивалентны.


```
float4 arrayOfFloats[4] = { 1.0f, 2.0f, 3.0f, 4.4f };

for (int i = 0; i<4; )
{
    arrayOfFloats[++i - 1] *= 2; 
}
```



Поскольку используется префиксный оператор (+ +), Аррайоффлоатс \[ i + 1-1 \] умножается на 2 после увеличения.

Операторы декремента и постфикса префикса (--) применяются в той же последовательности, что и оператор инкремента. Разница заключается в том, что уменьшение вычитает 1 вместо сложения 1.

## <a name="structure-operator"></a>Оператор Structure

Оператор выбора члена структуры (.) — это точка. С учетом этой структуры:


```
struct position
{
float4 x;
float4 y;
float4 z;
};
```



Его можно прочитать следующим образом:


```
struct position pos = { 1,2,3 };

float 1D_Float = pos.x
1D_Float = pos.y
```



Каждый элемент может быть считан или записан с помощью оператора Structure:


```
struct position pos = { 1,2,3 };
pos.x = 2.0f;
pos.z = 1.0f;       // z = 1.0f
pos.z = pos.x      // z = 2.0f
```



## <a name="unary-operators"></a>Унарные операторы

Унарные операторы:!,-, +

Унарные операторы работают с одним операндом.


```
bool b = false;
bool b2 = !b;      // b2 = true
int i = 2;
int i2 = -i;       // i2 = -2
int j = +i2;       // j = +2
```



## <a name="operator-precedence"></a>Приоритет операторов

Если выражение содержит более одного оператора, порядок вычисления определяется приоритетом операторов. Приоритет операторов для HLSL соответствует тому же приоритету, что и в языке C.

## <a name="remarks"></a>Remarks

Фигурные скобки ( {,} ) начинаются и заканчиваются блоком операторов. Если блок операторов использует один оператор, фигурные скобки являются необязательными.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Инструкции (DirectX HLSL)](dx-graphics-hlsl-statements.md)
</dt> </dl>

 

 




