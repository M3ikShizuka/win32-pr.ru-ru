---
title: Per-Component математических операций
description: С помощью HLSL можно программировать шейдеры на уровне алгоритма.
ms.assetid: a919df50-2d13-489d-9011-1137c997e121
ms.topic: article
ms.date: 05/31/2018
topic_type:
- kbArticle
api_name: ''
api_type: ''
api_location: ''
ms.openlocfilehash: 5cd065e415aafffa59dd6c31d2b9aa4f4505021d
ms.sourcegitcommit: 7c7a05f65d2cf1ba2dadf05f63ae91a048083946
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/09/2021
ms.locfileid: "113589591"
---
# <a name="per-component-math-operations"></a>Per-Component математических операций

С помощью HLSL можно программировать шейдеры на уровне алгоритма. Чтобы понять язык, необходимо знать, как объявлять переменные и функции, использовать встроенные функции, определять пользовательские типы данных и использовать семантику для подключения аргументов шейдера к другим шейдерам и к конвейеру.

Когда вы научитесь создавать шейдеры в HLSL, вам потребуется изучить вызовы API, чтобы вы могли: компилировать шейдер для определенного оборудования, инициализировать константы шейдеров и при необходимости инициализировать другое состояние конвейера.

-   [Тип вектора](#the-vector-type)
-   [Тип матрицы](#the-matrix-type)
    -   [Упорядочение матрицы](#matrix-ordering)
-   [Примеры](#examples)
-   [Связанные разделы](#related-topics)

## <a name="the-vector-type"></a>Тип вектора

Vector — это структура данных, которая содержит от одного до четырех компонентов.


```
bool    bVector;   // scalar containing 1 Boolean
bool1   bVector;   // vector containing 1 Boolean
int1    iVector;   // vector containing 1 int
float3  fVector;   // vector containing 3 floats
double4 dVector;   // vector containing 4 doubles
```



Целое число непосредственно после типа данных — число компонентов в векторе.

Инициализаторы также можно включать в объявления.


```
bool    bVector = false;
int1    iVector = 1;
float3  fVector = { 0.2f, 0.3f, 0.4f };
double4 dVector = { 0.2, 0.3, 0.4, 0.5 };
```



Кроме того, тип Vector можно использовать для создания одних и тех же объявлений:


```
vector <bool,   1> bVector = false;
vector <int,    1> iVector = 1;
vector <float,  3> fVector = { 0.2f, 0.3f, 0.4f };
vector <double, 4> dVector = { 0.2, 0.3, 0.4, 0.5 };
```



Тип Vector использует угловые скобки для указания типа и количества компонентов.

Векторы содержат до четырех компонентов, к которым можно получить доступ с помощью одного из двух наборов имен:

-   Набор позиций: x, y, z, w
-   Набор цветов: r, g, b, a

Эти инструкции возвращают значение в третьем компоненте.


```
// Given
float4 pos = float4(0,0,2,1);

pos.z    // value is 2
pos.b    // value is 2
```



Наборы имен могут использовать один или несколько компонентов, но они не могут быть смешанными.


```
// Given
float4 pos = float4(0,0,2,1);
float2 temp;

temp = pos.xy  // valid
temp = pos.rg  // valid

temp = pos.xg  // NOT VALID because the position and color sets were used.
```



Указание одного или нескольких компонентов вектора при чтении компонентов называется группирующие. Пример:


```
float4 pos = float4(0,0,2,1);
float2 f_2D;
f_2D = pos.xy;   // read two components 
f_2D = pos.xz;   // read components in any order       
f_2D = pos.zx;

f_2D = pos.xx;   // components can be read more than once
f_2D = pos.yy;
```



Маскирование управляет количеством записываемых компонентов.


```
float4 pos = float4(0,0,2,1);
float4 f_4D;
f_4D    = pos;     // write four components          

f_4D.xz = pos.xz;  // write two components        
f_4D.zx = pos.xz;  // change the write order

f_4D.xzyw = pos.w; // write one component to more than one component
f_4D.wzyx = pos;
```



Назначения не могут быть записаны в один и тот же компонент несколько раз. Поэтому левая часть оператора является недопустимой:


```
f_4D.xx = pos.xy;   // cannot write to the same destination components 
```



Кроме того, пространства имен компонентов не могут быть смешанными. Это недопустимый компонент записи:


```
f_4D.xg = pos.rgrg;    // invalid write: cannot mix component name spaces 
```



Доступ к вектору в качестве скаляра будет осуществлять доступ к первому компоненту вектора. Следующие две инструкции эквивалентны.


```
f_4D.a = pos * 5.0f;
f_4D.a = pos.r * 5.0f;
```



## <a name="the-matrix-type"></a>Тип матрицы

Матрица — это структура данных, содержащая строки и столбцы данных. Данные могут быть любыми скалярными типами данных, однако каждый элемент матрицы имеет один и тот же тип данных. Число строк и столбцов указывается строкой по столбцам, добавляемым к типу данных.


```
int1x1    iMatrix;   // integer matrix with 1 row,  1 column
int2x1    iMatrix;   // integer matrix with 2 rows, 1 column
...
int4x1    iMatrix;   // integer matrix with 4 rows, 1 column
...
int1x4    iMatrix;   // integer matrix with 1 row, 4 columns
double1x1 dMatrix;   // double matrix with 1 row,  1 column
double2x2 dMatrix;   // double matrix with 2 rows, 2 columns
double3x3 dMatrix;   // double matrix with 3 rows, 3 columns
double4x4 dMatrix;   // double matrix with 4 rows, 4 columns
```



Максимальное число строк или столбцов равно 4; Минимальное значение равно 1.

Матрицу можно инициализировать при ее объявлении:


```
float2x2 fMatrix = { 0.0f, 0.1, // row 1
                     2.1f, 2.2f // row 2
                   };   
```



Или тип матрицы можно использовать для создания одних и тех же объявлений:


```
matrix <float, 2, 2> fMatrix = { 0.0f, 0.1, // row 1
                                 2.1f, 2.2f // row 2
                               };
```



Тип матрицы использует угловые скобки для указания типа, числа строк и числа столбцов. В этом примере создается матрица с плавающей точкой с двумя строками и двумя столбцами. Можно использовать любой скалярный тип данных.

Это объявление определяет матрицу значений float (32-разрядных чисел с плавающей запятой) с двумя строками и тремя столбцами:


```
matrix <float, 2, 3> fFloatMatrix;
```



Матрица содержит значения, упорядоченные в строках и столбцах, к которым можно получить доступ с помощью оператора структуры ".", за которым следует один из двух наборов именования:

-   Отсчитываемая от нуля расположение столбца строки:
    -   \_M00, \_ M01, \_ M02, \_ M03
    -   \_M10, \_ M11, \_ M12, \_ M13
    -   \_M20, \_ M21, \_ M22, \_ M23
    -   \_M30, \_ M31, \_ M32, \_ M33
-   Расположение строкового столбца, основанного на одной строке:
    -   \_11, \_ 12, \_ 13, \_ 14
    -   \_21, \_ 22, \_ 23, \_ 24
    -   \_31, \_ 32, \_ 33, \_ 34
    -   \_41, \_ 42, \_ 43, \_ 44

Каждый набор именования начинается с символа подчеркивания, за которым следует номер строки и номер столбца. Соглашение об отсчете от нуля также включает букву «m» перед номером строки и столбца. Ниже приведен пример, в котором для доступа к матрице используются два набора именования:


```
// given
float2x2 fMatrix = { 1.0f, 1.1f, // row 1
                     2.0f, 2.1f  // row 2
                   }; 

float f_1D;
f_1D = matrix._m00; // read the value in row 1, column 1: 1.0
f_1D = matrix._m11; // read the value in row 2, column 2: 2.1

f_1D = matrix._11;  // read the value in row 1, column 1: 1.0
f_1D = matrix._22;  // read the value in row 2, column 2: 2.1
```



Как и векторы, наборы имен могут использовать один или несколько компонентов из любого набора именований.


```
// Given
float2x2 fMatrix = { 1.0f, 1.1f, // row 1
                     2.0f, 2.1f  // row 2
                   };
float2 temp;

temp = fMatrix._m00_m11 // valid
temp = fMatrix._m11_m00 // valid
temp = fMatrix._11_22   // valid
temp = fMatrix._22_11   // valid
```



Доступ к матрице также можно получить с помощью нотации доступа к массиву, которая представляет собой набор индексов, начинающийся с нуля. Каждый индекс находится внутри квадратных скобок. Доступ к матрице 4x4 осуществляется со следующими индексами:

-   \[0 \] \[ 0 \] , \[ 0 \] \[ 1 \] , \[ 0 \] \[ 2 \] , \[ 0 \] \[ 3\]
-   \[1 \] \[ 0 \] , \[ 1 \] \[ 1 \] , \[ 1 \] \[ 2 \] , \[ 1 \] \[ 3\]
-   \[2 \] \[ 0 \] , \[ 2 \] \[ 1 \] , \[ 2 \] \[ 2 \] , \[ 2 \] \[ 3\]
-   \[3 \] \[ 0 \] , \[ 3 \] \[ 1 \] , \[ 3 \] \[ 2 \] , \[ 3 \] \[ 3\]

Ниже приведен пример доступа к матрице.


```
float2x2 fMatrix = { 1.0f, 1.1f, // row 1
                     2.0f, 2.1f  // row 2
                   };
float temp;

temp = fMatrix[0][0] // single component read
temp = fMatrix[0][1] // single component read
```



Обратите внимание, что оператор Structure "." не используется для доступа к массиву. Нотация доступа к массиву не может использовать группирующие для чтения более чем одного компонента.


```
float2 temp;
temp = fMatrix[0][0]_[0][1] // invalid, cannot read two components
```



Однако доступ к массиву может считывать вектор с несколькими компонентами.


```
float2 temp;
float2x2 fMatrix;
temp = fMatrix[0] // read the first row
```



Как и в случае с векторами, чтение более одного компонента матрицы называется группирующие. Можно назначить более одного компонента, предполагая, что используется только одно пространство имен. Все это допустимые назначения:


```
// Given these variables
float4x4 worldMatrix = float4( {0,0,0,0}, {1,1,1,1}, {2,2,2,2}, {3,3,3,3} );
float4x4 tempMatrix;

tempMatrix._m00_m11 = worldMatrix._m00_m11; // multiple components
tempMatrix._m00_m11 = worldMatrix.m13_m23;

tempMatrix._11_22_33 = worldMatrix._11_22_33; // any order on swizzles
tempMatrix._11_22_33 = worldMatrix._24_23_22;
```



Маскирование управляет количеством записываемых компонентов.


```
// Given
float4x4 worldMatrix = float4( {0,0,0,0}, {1,1,1,1}, {2,2,2,2}, {3,3,3,3} );
float4x4 tempMatrix;

tempMatrix._m00_m11 = worldMatrix._m00_m11; // write two components
tempMatrix._m23_m00 = worldMatrix._m00_m11;
```



Назначения не могут быть записаны в один и тот же компонент несколько раз. Поэтому левая часть оператора является недопустимой:


```
// cannot write to the same component more than once
tempMatrix._m00_m00 = worldMatrix._m00_m11;
```



Кроме того, пространства имен компонентов не могут быть смешанными. Это недопустимый компонент записи:


```
// Invalid use of same component on left side
tempMatrix._11_m23 = worldMatrix._11_22; 
```



### <a name="matrix-ordering"></a>Упорядочение матрицы

Порядок упаковки матрицы для однородных параметров по умолчанию имеет значение столбец-основной. Это означает, что каждый столбец матрицы хранится в одном регистре констант. С другой стороны, матрица, посвященная строке, построчно упаковывает каждую строку матрицы в один регистр констант. Упаковку матрицы можно изменить с помощью директивы **\# \_ матрицы прагмапакк** , либо со **строкой \_** ключевого слова Major или **Column \_** .

Данные в матрице загружаются в постоянные регистры шейдера перед запуском шейдера. Существует два способа считывания данных матрицы: в строке или в основном порядке столбцов. «Столбец — основной» означает, что каждый столбец матрицы будет храниться в одном регистре констант, а «строковый порядок» означает, что каждая строка матрицы будет храниться в одном регистре констант. Это важно учитывать, сколько регистров констант используется для матрицы.

Основная матрица, представленная в виде строки, выглядит следующим образом:

:::row:::
    :::column:::
        11<br/>
        21<br/>
        31<br/>
        41<br/>
    :::column-end:::
    :::column:::
        12<br/>
        22<br/>
        32<br/>
        42<br/>
    :::column-end:::
    :::column:::
        13<br/>
        23<br/>
        33<br/>
        43<br/>
    :::column-end:::
    :::column:::
        14<br/>
        24<br/>
        34<br/>
        44<br/>
    :::column-end:::
:::row-end:::




 

Основная матрица столбца выглядит следующим образом:


:::row:::
    :::column:::
        11<br/>
        12<br/>
        13<br/>
        14<br/>
    :::column-end:::
    :::column:::
        21<br/>
        22<br/>
        23<br/>
        24<br/>
    :::column-end:::
    :::column:::
        31<br/>
        32<br/>
        33<br/>
        34<br/>
    :::column-end:::
    :::column:::
        41<br/>
        42<br/>
        43<br/>
        44<br/>
    :::column-end:::
:::row-end:::




 

Упорядочение по строкам и основным столбцам определяет порядок, в котором компоненты матрицы считываются из входных шейдеров. После того как данные записываются в постоянные регистры, порядок матриц не влияет на использование данных или доступ из него в коде шейдера. Кроме того, матрицы, объявленные в теле шейдера, не упаковываются в постоянные регистры. Порядок упаковки строк и столбцов в основном и крупном порядке не влияет на порядок упаковки конструкторов (который всегда соответствует строкам в основном порядке).

Порядок данных в матрице может быть объявлен во время компиляции, или компилятор будет упорядочивать данные в среде выполнения для наиболее эффективного использования.

## <a name="examples"></a>Примеры

HLSL использует два специальных типа: Векторный тип и тип матрицы, чтобы упростить программирование двухмерной и трехмерной графики. Каждый из этих типов содержит более одного компонента; Вектор содержит до четырех компонентов, а матрица содержит до 16 компонентов. Если векторы и матрицы используются в стандартных уравнениях HLSL, математические операции предназначены для работы с каждым компонентом. Например, HLSL реализует это умножение:


```
float4 v = a*b;
```



при умножении четырех компонентов. Результат имеет четыре скалярных оператора:


```
float4 v = a*b;

v.x = a.x*b.x;
v.y = a.y*b.y;
v.z = a.z*b.z;
v.w = a.w*b.w;
```



Это четыре умножения, где каждый результат хранится в отдельном компоненте v. Это называется умножением четырех компонентов. HLSL использует математические компоненты, что делает создание шейдеров очень эффективным.

Это сильно отличается от умножения, которое обычно реализуется в виде точки, которая создает один скаляр:


```
v = a.x*b.x + a.y*b.y + a.z*b.z + a.w*b.w;
```



Матрица также использует операции для каждого компонента в HLSL:


```
float3x3 mat1,mat2;
...
float3x3 mat3 = mat1*mat2;
```



Результат является отдельным компонентом, умноженным на две матрицы (в отличие от стандартной матрицы 3x3). Матрица для каждого компонента возвращает этот первый термин:


```
mat3.m00 = mat1.m00 * mat2._m00;
```



Это отличается от умножения матрицы 3x3, что приведет к первому условию:


```
// First component of a four-component matrix multiply
mat.m00 = mat1._m00 * mat2._m00 + 
          mat1._m01 * mat2._m10 + 
          mat1._m02 * mat2._m20 + 
          mat1._m03 * mat2._m30;
```



Перегруженные версии метода умножения встроенных функций, где один операнд является вектором, а другой — матрицей. Например: вектор вектора \* , \* Матрица вектора, вектор матрицы и матрица \* матрицы \* . Например:


```
float4x3 World;

float4 main(float4 pos : SV_POSITION) : SV_POSITION
{
    float4 val;
    val.xyz = mul(pos,World);
    val.w = 0;

    return val;
}   
```



выдает тот же результат, что и:


```
float4x3 World;

float4 main(float4 pos : SV_POSITION) : SV_POSITION
{
    float4 val;
    val.xyz = (float3) mul((float1x4)pos,World);
    val.w = 0;

    return val;
}   
```



В этом примере демонстрируется преобразование вектора POS в вектор столбца с помощью приведения (float1x4). Изменение вектора путем приведения или переключение порядка аргументов, передаваемых для перемножения, эквивалентно преобразованию матрицы.

Автоматическое преобразование приведения приводит к тому, что встроенные функции умножения и точки возвращают те же результаты, что и здесь:


```
{
  float4 val;
  return mul(val,val);
}
```



Результатом умножения является \* 4 экземпляра 1ный вектор «1x4» = 1x1. Это эквивалентно продукту с точкой:


```
{
  float4 val;
  return dot(val,val);
}
```



, возвращающее одиночное скалярное значение.

## <a name="related-topics"></a>Связанные разделы

<dl> <dt>

[Типы данных (DirectX HLSL)](dx-graphics-hlsl-data-types.md)
</dt> </dl>

 

 




