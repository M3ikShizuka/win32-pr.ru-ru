---
description: В этой статье содержатся дополнительные сведения о метаданных Guard в потоках управления в образах PE.
title: Метаданные PE
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 52eb54ac953be4ac09461dbc92bb39d8afc5d332
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "105664650"
---
# <a name="pe-metadata"></a>Метаданные PE

В этой статье содержатся дополнительные сведения о метаданных (CFG) управляющего потока управления в образах PE. Предполагается знание структуры для метаданных CFG в образах PE. См. раздел [Формат PE](../debug/pe-format.md) для высокоуровневой документации по метаданным cfg в образах PE.

- Функции, которые являются допустимыми целями косвенных вызовов, перечислены в **гуардкффунктионтабле** , прикрепленном к каталогу конфигурации загрузки, иногда **гфидс** таблицу для краткости. Это отсортированный список относительных виртуальных адресов (RVA), содержащих сведения о допустимых целевых объектах вызова CFG. Обычно это говорят, что используются символы функции. Образ, которому требуется принудительное применение CFG, должен перечислить все символы, созданные в своей таблице **гфидс** . Список RVA в таблице **гфидс** должен быть отсортирован правильно или изображение не будет загружено. Таблица **гфидс** представляет собой массив из 4 + *n* байт, где *n* задается ((гуардфлагс & IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK)  >> IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_SHIFT). "Гуардфлагс" — это поле Гуардфлагс в каталоге конфигурации загрузки. Это позволяет прикреплять дополнительные метаданные к целям вызова CFG в будущем. Единственными определенными в данный момент метаданными является необязательное дополнительное поле дополнительных флагов ("ГФИДС Flags"), присоединенное к каждой записи **гфидс** , если у целей вызова есть метаданные. Определены два флага **гфидс** :
  
  | &nbsp; | &nbsp; |
  | ---- |:---- |
  | IMAGE_GUARD_FLAG_FID_SUPPRESSED/0x1 | Цель вызова явно подавлена (не обрабатывать ее как допустимую для целей CFG) |
  | IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED/0x2 | Целевой объект вызова является подавленным. Дополнительные сведения см. в разделе о [подавлении экспорта](#export-suppression) . |
  
  Для обеспечения совместимости с будущими версиями средства не должны устанавливать флаги **гфидс** , которые еще не были определены, и не должны включать дополнительные байты **гфидс** дополнительных метаданных, превышающие 1 байт, определенный в настоящее время, так как значения других флагов или дополнительных метаданных еще не назначены. Примеры образов, которые содержат дополнительные байты метаданных, можно найти, выполнив дамп таблицы **гфидс** двоичных файлов, например Ntdll.dll, в современной версии ОС Windows 10.

  Средства должны объявлять символы функций только как допустимые целевые объекты вызова, которые могут доставлять дополнительные соображения для кода ассемблера, где могут быть созданы метки. По историческим причинам код ассемблера может полагаться на метки кода, отличные от PROC или алтентри, так как не преобразуется в цели вызова CFG компоновщиком.

  Кроме того, по историческим причинам код может намеренно объявить код как данные, чтобы избежать включения в таблицу **гфидс** . Например, один объектный файл может реализовать символ как код, а другой может объявить его как данные, чтобы получить адрес символа без создания допустимой целевой записи CFG. Для обеспечения совместимости рекомендуется, чтобы наборы инструментов поддерживали эту методику.

- Образы, поддерживающие CFG и требующие или выполняющие проверки CFG, должны устанавливать IMAGE_GUARD_CF_INSTRUMENTED и IMAGE_GUARD_CF_FUNCTION_TABLE_PRESENT бит Гуардфлагс и устанавливать бит IMAGE_DLLCHARACTERISTICS_GUARD_CF DllCharacteristics в заголовках образа.

- Каталог конфигурации загрузки объявляет два указателя на функции: Гуардкфчеккфунктионпоинтер и Гуардкфдиспатчфунктионпоинтер (последний поддерживается только для определенных архитектур, таких как AMD64). Эти указатели функций должны указывать на память только для чтения для обеспечения безопасности в целях CFG. загрузчик DLL операционной системы будет повторно защищать память во время загрузки образа для хранения указателей функций. Обычно их использование может быть объединено в тот же раздел, который содержит таблицу адресов импорта (IAT). Гуардкфчеккфунктионпоинтер предоставляет адрес предоставленного загрузчиком ОС символа, который может быть вызван с указателем на функцию в первом регистре целочисленного аргумента (ECX для x86), который вернется при успешном выполнении или приведет к прерыванию процесса, если цель вызова не является допустимым целевым объектом CFG. Гуардкфдиспатчфунктионпоинтер предоставляет адрес символа загрузчика ОС, который принимает целевой объект вызова в Register RAX и выполняет объединенную проверку CFG и оптимизированный вызов метода хвостовой ветви в целевой объект вызова (регистры R10/R11 зарезервированы для использования в параметрах Гуардкфдиспатчфунктионпоинтер и целочисленных регистров, зарезервированных для использования в конечном объекте вызова). Адрес по умолчанию символов CFG в изображении должен указывать на функцию, которая просто возвращает (Гуардкфчеккфунктионпоинтер) или которая возвращает символ подавленного давления (или вообще полностью опускается из символа таблицы **гфидс** ), выполняющего инструкцию "переход RAX". Для AMD64 Гуардкфдиспатчфунктионпоинтер, когда изображение загружается в операционную систему с поддержкой CFG, а CFG включается, загрузчик DLL-файлов операционной системы установит соответствующие указатели функций, которые поддерживают обратную совместимость. Образ может предоставить значение 0 для Гуардкфдиспатчфунктионпоинтер в конфигурации загрузки, если он не планирует использовать механизм отправки CFG. Это следует делать для архитектур, отличных от AMD64, для обеспечения совместимости в будущем, если эти архитектуры в конечном итоге поддерживают механизм диспетчеризации CFG в некоторой форме. Обратите внимание, что Windows 8.1 AMD64 не поддерживал отправку CFG и оставить указатель на функцию по умолчанию вместо Гуардкфдиспатчфунктионпоинтер. Отправка CFG поддерживается только в операционных системах Windows 10 и более поздних версий.

- CFG в пользовательском режиме может применяться только для образов, которые помечены как совместимые с помощью функции случайного выбора макета адресного пространства (определяется параметром/DYNAMICBASE в компоновщике Microsoft). Это происходит из-за того, как ОС внутренне обрабатывает CFG, где она фактически продается в инфраструктуре ASLR. Как правило, пользователи CFG должны включить ASLR для образов в качестве первого шага. Средства не должны рассчитывать на то, что операционная система всегда будет игнорировать CFG без установки ASLR, но обычно оба они должны быть установлены одновременно.

## <a name="compiler-directives"></a>Директивы компилятора

- Цели вызова можно пометить явным образом с помощью модификатора __declspec (Guard (подавлять)) или с помощью директивы компоновщика/гуардсим: симнаме, S (например, для кода ASM). Это приводит к тому, что цель вызова включается в таблицу **гфидс** , но помечается таким образом, чтобы операционная система обработала цель вызова как недопустимую. В некоторых непроизводственных сценариях, например при включении определенного инструментария средства проверки приложений в некоторых старых операционных системах, может быть разрешено, чтобы подавленные целевые объекты считались допустимыми, но в общем случае эти сценарии не должны быть рабочими. Эта директива полезна для аннотирования "опасных" функций, которые не должны рассматриваться как допустимые цели вызова, даже несмотря на то, что они будут включены в правило "нормальное".

- Код может означать, что проверки CFG не нужны с помощью модификатора __declspec (Guard (нокф)). Это направляет компилятору возможность не вставлять проверки CFG для всей функции. Компилятор должен соблюдать осторожность при распространении этой директивы в любой код, который повлияет на встроенную функцию, помеченную как не имеющая проверки CFG. Этот подход обычно используется только в тех ситуациях, когда программист автоматически вставил «CFG-эквивалентный» уровень защиты. Программист знает, что они вызывают через некоторую таблицу функций только для чтения, адрес которой получается через ссылки памяти только для чтения, для которых индекс замаскирован на ограничение таблицы функции. Этот подход также можно применить к небольшим функциям-оболочкам, которые не являются встроенными и не делают вызов через указатель функции. Поскольку неправильное использование этой директивы может поставить под угрозу безопасность CFG, программист должен быть очень осторожным при использовании директивы. Как правило, это использование ограничено очень малыми функциями, которые вызывают только одну функцию.

## <a name="import-handling"></a>Обработка импорта

- Вызовы через IAT не должны использовать защиту CFG. Таблица IAT доступна только для чтения в современных образах (предполагая, что таблица IAT объявлена в заголовках PE, в этом случае она должна располагаться на собственных страницах). IAT можно использовать для обращения к функциям, которые являются защищенными, поэтому это требование верно. Защита памяти только для чтения с помощью IAT заменяет параметр CFG, так как привязка цели вызова является неизменяемой после разрешения привязок импорта изображений, и разрешение привязки детализировано.

- Защищенная задержка загрузки: вызовы с помощью IAT с отложенной нагрузкой не должны использовать защиту CFG по тем же причинам, что и стандартная IAT. Таблица IAT с отложенной загрузкой должна находиться в отдельном разделе, а образ должен установить IMAGE_GUARD_CF_PROTECT_DELAYLOAD_IAT Гуардфлагс бит. Это означает, что загрузчик DLL операционной системы должен изменить защиту для отложенной загрузки IAT при разрешении экспорта, если используется собственная поддержка отложенной загрузки операционной системы в Windows 8 и более поздних операционных системах. Синхронизация этого шага осуществляется загрузчиком библиотек DLL операционной системы, если используется собственная поддержка отложенной загрузки операционной системы (например, Ресолведелайлоадедапи), поэтому никакой другой компонент не должен повторно защищать страницы, охватывающие объявленную IAT с отложенной загрузкой. Для обеспечения обратной совместимости с более старыми операционными системами, предшествующими CFG, средства могут включать возможность перемещения IAT с отложенной нагрузкой в свой собственный раздел (каноническо ". Дидат"), защищенную для чтения и записи в заголовках изображений, а также устанавливать флаг IMAGE_GUARD_CF_DELAYLOAD_IAT_IN_ITS_OWN_SECTION. Этот параметр приведет к тому, что загрузчик DLL-файлов операционной системы с поддержкой CFG будет повторно защищать весь раздел, содержащий таблицу IMAGE_DIRECTORY_ENTRY_DELAY_IMPORT, на чтение только памяти во время загрузки образа. Возможность размещения IAT с отложенной загрузкой в собственном разделе может не требоваться, если вы не следите за запуском образа в операционных системах с предварительной поддержкой CFG, но средства должны принимать это решение на основе минимальной поддержки операционной системы, необходимой для образа.

  Если образ не использует встроенную поддержку отложенной загрузки операционной системы, он по-прежнему может установить связанные биты Гуардфлагс с защищенной задержкой. В этой конфигурации загрузчик операционной системы просто предоставляет поддержку для защиты немедленной загрузки IAT как прочитанной во время выполнения, если она поддерживается платформой, и она становится обязанностью заглушки разрешения внутренней задержки загрузки образа для синхронизации и управления защитой IAT с отложенной загрузкой. При условии, что таблица конфигурации загрузки хранится в памяти только для чтения (рекомендуемый вариант), присутствие или отсутствие бита с защищенной задержкой IAT в поле Гуардфлагс изображения может быть полезно в качестве внутренней подсказки в заглушках разрешения внутренней загрузки с задержкой изображения, чтобы указать, должна ли она защищать отправку с задержкой.

  Если параметр CFG включен, рекомендуется включить защищенную отложенную загрузку по умолчанию. Образы, работающие в более старых версиях операционной системы и использующие встроенную поддержку отложенной загрузки операционной системы, могут использовать для обеспечения обратной совместимости в собственном разделе поддержку немедленных загрузок. В противоположность этому помечать IAT с отложенной нагрузкой как доступную только для чтения и объединять ее с другим разделом, что привело бы к нарушению защиты от старых операционных систем, которые не понимают защищенную загрузку и обеспечивают поддержку собственного разрешения отложенной загрузки. Все выпуски Windows 10 и первая Windows 8.1/Windows Server 2012 R2, которые поддерживают CFG (то есть обновление за Ноябрь 2014), обеспечивают поддержку защищенной отложенной нагрузки в операционной системе.

## <a name="function-alignment"></a>Выравнивание функций

- Функции, которые были взяты из адреса и, следовательно, включены в таблицу **гфидс** , должны быть упорядочены по 16 байт, если это возможно. Это не всегда возможно. Например, для функций, не являющихся функциями COMDAT, которые являются частью объектных файлов, собранных в виде одной единицы с помощью средств, не учитывающих конечные средства, которые могут быть созданы некоторыми средствами сборки, пользователь средства, создавшего файлы, должен соответствующим образом задать выравнивание. В этом случае средства могут выдавать диагностические предупреждения, чтобы пользователь мог предпринять соответствующие корректирующие действия. Причина этого заключается в том, что CFG помечает целевые объекты как допустимые или недопустимые в 16-байтовых границах для повышения эффективности проверок на основе CFG. Если функция не имеет 16-байтовое значение, то весь 16-байтовый слот должен быть помечен как допустимый, что не так безопасно, так как вы можете вызвать неверное согласование кода, который не находится в самом начале функции. Этот сценарий поддерживается для простоты взаимодействия при первом внесении в проект. Изображения, не поддерживающие CFG, аналогично помечены как допустимые для любого выравнивания цели вызова для обеспечения совместимости. Как и ранее, наличие несогласованных целевых объектов приводит к снижению преимуществ безопасности для CFG, поэтому средства должны автоматически согласовать 16-байтовую границу для любого объекта в таблице **гфидс** , когда для изображения требуется cfg. Символы, которых нет в таблице **гфидс** , не должны иметь определенных выравниваний для cfg.

## <a name="export-suppression"></a>Подавление экспорта

- Подавление экспорта CFG (CFG ES) — это необязательный режим, который позволяет процессу указать, что цели вызова, которые были допустимы только потому, что они были символами-dllexport, и которые еще не были динамически разрешены с помощью GetProcAddress, будут рассматриваться как недопустимые для целей CFG. Это сокращает контактную зону CFG из системных библиотек DLL. Подавление экспорта включает в себя передачу подходящего запроса "экспорт подавленных", помечая их флагами IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **гфидс** . Символы dllexport и точка входа образа PE должны быть неявно считаться адресом, предпринимаемым инструментами для создания таблицы **гфидс** .  Если для символа экспорта задано 16-байтовое согласование, и его адрес получен не так, как dllexport, он может быть помечен с помощью флага Export подавлено **гфидс** в таблице функций. Целевые объекты вызова, которые не являются 16-байтовыми, не **должны** быть помечены флагом IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **гфидс** и не могут быть ограничены динамически, как допустимые целевые объекты вызова во время GetProcAddress.

  Образ, поддерживающий CFG ES, включает Гуардаддресстакениатентритабле, число которых предоставляется Гуардаддресстакениатентрикаунт в составе каталога конфигурации нагрузки. Эта таблица имеет структуру, отформатированную таким же образом, как и таблица **гфидс** . Он использует один и тот же механизм IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK Гуардфлагс для кодирования дополнительных байтов необязательных метаданных в таблице Address, который использует таблицу IAT, хотя все байты метаданных должны быть равны нулю для таблицы IAT и зарезервированы. В таблице адресная таблица IAT указывается упорядоченный массив RVA преобразователей импорта, который импортирован в качестве адреса символа, полученного с целью вызова. Эта конструкция поддерживает адрес, используемый для создания символов, которые существуют в удаленном модуле, и которые являются dllexport с использованием CFG ES. Пример такой конструкции кода выглядит следующим образом:

  ```
  mov rcx, [__imp_DefWindowProc]
  call foo ; where foo takes the actual address of DefWindowProc.
  ```

  Все преобразователи импорта, созданные этим адресом, должны быть перечислены, чтобы загрузчик операционной системы мог найти их и обеспечить допустимость соответствующих целевых объектов вызова при загрузке изображения и привязке его импорта. Таблица и количество могут быть равны 0, если не были сделаны преобразователи импорта.

  Модуль задает IMAGE_GUARD_CF_EXPORT_SUPPRESSION_INFO_PRESENT бит Гуардфлагс, чтобы указать, что он перечислил все преобразователи, созданные в адресе таблицы IAT, и все экспортируемые элементы, имеющие соответствующий CFG, будут помечены флагом IMAGE_GUARD_FLAG_EXPORT_SUPPRESSED **гфидс** . Обратите внимание, что такие преобразователи могут иметь нулевое значение, а также могут быть нулевые символы dllexport. Невозможность обслуживания адреса, полученного в таблице IAT, может быть проблемой, так как некоторые целевые объекты вызова могут быть недействительными, если они должны быть загружены на момент загрузки библиотеки DLL.

  Модуль задает IMAGE_GUARD_CF_ENABLE_EXPORT_SUPPRESSION бит Гуардфлагс, чтобы указать, что ему нужно включить CFG ES для процесса. На практике это имеет смысл только для exe-заданий в настоящее время. Процесс, позволяющий CFG ES, не должен загружать библиотеки DLL, не созданные с помощью CFG ES, или сбои во время выполнения из-за неназначенного адреса, полученного в виде символов IAT. Поддержка включения CFG ES должна быть отдельным вариантом согласия на включение CFG. Предоставление метаданных CFG ES является типобезопасным и рекомендуется по умолчанию с помощью CFG, хотя наборы инструментов должны следить за тем, чтобы они выдают правильные метаданные. В противном случае созданные образы могут не работать должным образом в процессе CFG ES. Такая поддержка должна быть тщательно протестирована в процессе тестирования, который принудительно применяет CFG. Встроенные системные библиотеки DLL операционной системы поддерживают метаданные CFG ES для современных версий операционной системы Windows 10, которые понимают, что такое CFG. Версии операционной системы до этой поддержки не понимают «CFG», а все директивы, связанные с CFG, будут игнорироваться в образе. Такие образы по-прежнему совместимы с более старыми версиями операционной системы.

  Поддержка CFG ES является необязательной с точки зрения набора инструментов, но рекомендуется, чтобы наборы инструментов включали в себя по крайней мере поддержку для перечисления достаточной информации, чтобы образы выполнялись в процессе, который помещает CFG. Как уже упоминалось, очень важно, чтобы поддержка набора инструментов была тщательно протестирована для обеспечения совместимости с CFG ES, так как большинство процессов еще не включают CFG.

## <a name="exception-handling-and-unwinding"></a>Обработка исключений и их очистка

- Обработчики конкретного языка, такие как __C_specific_handler, обозначенные сведениями обработчика исключений в регистрации pData, не должны помечаться как допустимые цели вызова в таблице **гфидс** . Вместо этого они ищутся путем обхода памяти только для чтения. Аналогично, обработчик конкретного языка Microsoft C использует поиск в памяти только для чтения, чтобы найти функлетс для обработчиков исключений и, таким образом, не объявил его функлетс как допустимые цели вызова в таблице **гфидс** .

- Длительная обработка переходов (для целевых платформ, отличных от x86): наборы инструментов, компилируемые с помощью CFG и поддерживающие setjmp ()/лонгжмп (), должны реализовывать длительный переход, как в случае "безопасного длинного перехода", взаимодействующего со структурной обработкой исключений (SEH). Это означает, что длительный переход реализуется как вызов Ртлунвиндекс с STATUS_LONGJUMP в качестве кода состояния в предоставленной записи исключения и стандартного _JUMP_BUFFER, на который указывает матрице ExceptionInformation [0]. Цель очистки перехода должна быть Таржетипой очистки. Буфер переходов представляет контекст регистра, который восстанавливается операционной системой после завершения длительного перехода. Ртлунвинд (ex) при вызове с STATUS_LONGJUMP имеет специальное значение, уникальное для CFG. Длинный целевой объект перехода (_JUMP_BUFFER. Копирование или _JUMP_BUFFER. LR в ARM64) ищется в списке загруженных модулей, поддерживаемом операционной системой в памяти только для чтения. Если содержащий модуль для целевого объекта перехода ("целевой модуль") имеет флаг IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT, установленный в поле Гуардфлагс, то каталог конфигурации загрузки содержит Гуардлонгжумптаржеттабле вхис число элементов, заданное в поле Load Configuration Гуардлонгжумптаржеткаунт (загрузка конфигурации). Эта таблица имеет структуру, отформатированную так же, как и таблицу **гфидс** , и использует тот же механизм гуардфлагс IMAGE_GUARD_CF_FUNCTION_TABLE_SIZE_MASK для кодирования необязательных байтов метаданных в длинной таблице переходов. Все байты метаданных должны быть нулевыми для длинной таблицы переходов и зарезервированы.

  Таблица длинных переходов представляет упорядоченный массив RVA, которые являются допустимыми целевыми объектами для перехода. Если модуль длинного целевого объекта перехода задает IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT в поле Гуардфлагс, все длинные цели перехода должны перечисляться в Лонгжумптаржеттабле. Даже если модуль имеет нулевые целевые объекты для перехода, он по-прежнему должен установить флаг IMAGE_GUARD_CF_LONGJUMP_TABLE_PRESENT, если набор инструментов поддерживает длительное повышение безопасности для CFG. Это явно означает, что образ не имеет больших целевых объектов для перехода и не является старым образом, который операционная система должна предположить, может иметь допустимые длительные цели перехода в непомеченных расположениях, для которых не удается выполнить длительную проверку целевого объекта.

  Если параметр CFG поддерживается, рекомендуется включить длительное усиление защиты по умолчанию. Это расположение компиляторов Майкрософт. Операционные системы, которые не понимают длительное повышение уровня защиты (до Windows 10 или более ранних версий Windows 10), не выполняют длительные проверки на переходы и не пропускают каких-либо длинных метаданных о повышении безопасности, так что длительное повышение уровня защиты обеспечивает обратную совместимость с более старыми выпусками операционной системы.

  В случае с образами в режиме ядра Целевая таблица защиты от длительного перехода не должна включаться в отброшенный раздел. Чтобы свойства безопасности были эффективными, необходимо хранить целевую таблицу с длительным переходом в память только для чтения.

## <a name="coff-information"></a>Сведения о COFF

- Существуют пометки объектных файлов, которые объявляют, соответствует ли объектный файл CFG. Объектный файл, который соответствует CFG, выводит список допустимых целевых объектов вызова, которые он создает, явно, а также любой адрес, который получает метаданные IAT. Объектный файл, который не соответствует CFG, должен иметь выводимые объекты вызова путем проверки перерасположений COFF файла OBJ, чтобы найти перемещения, указывающие на начало символа функции. Это может быть избыточно допустимые целевые объекты вызова CFG, поэтому желательно, чтобы средства помечают свои OBJ-файлы с учетом конечных файлов и включали метаданные файла OBJ, если компиляция выполняется с помощью CFG.

- Существуют пометки объектных файлов для объявления длинных целевых объектов перехода для длительных переходов CFG, которые должны быть заполнены для режима компиляции CFG.
