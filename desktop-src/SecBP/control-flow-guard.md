---
description: Защита потока управления (CFG) — это функция обеспечения безопасности платформы с высокой степенью оптимизации, которая была создана для борьбы с уязвимостями повреждения памяти.
ms.assetid: 116EAD64-7CAE-455C-BA43-9492F78DE873
title: Защита потока управления
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 91cf97a648443135e7fee666ea4c259b1c32104e
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "104156870"
---
# <a name="control-flow-guard"></a>Защита потока управления

## <a name="what-is-control-flow-guard"></a>Что такое защита потока управления?

Защита потока управления (CFG) — это функция обеспечения безопасности платформы с высокой степенью оптимизации, которая была создана для борьбы с уязвимостями повреждения памяти. Устанавливая строгие ограничения на то, где приложение может выполнять код из, злоумышленники могут намного сложнее выполнять произвольный код с помощью уязвимостей, таких как переполнение буфера. CFG расширяет предыдущие технологии защиты от эксплойтов, такие как [/GS](/cpp/build/reference/gs-buffer-security-check?view=vs-2019), [DEP](../memory/data-execution-prevention.md)и [ASLR](/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista).

Эта функция доступна в Microsoft Visual Studio 2015 и работает в версиях Windows с поддержкой CFG — 32-и 64-разрядных версий для настольных и серверных систем Windows 10 и Windows 8.1 Update (KB3000850).

Мы настоятельно рекомендуем разработчикам включить CFG для своих приложений. Не нужно включать CFG для каждой части кода, так как сочетание CFG и код, поддерживающий неcfg, будут выполняться нормально. Но если не включить CFG для всего кода, можно открыть зазоры в защите. Кроме того, код с поддержкой CFG прекрасно работает в версиях Windows, не поддерживающих CFG, и поэтому полностью совместим с ними.

## <a name="how-can-i-enable-cfg"></a>Как включить CFG?

В большинстве случаев нет необходимости изменять исходный код. Вам нужно только добавить параметр в проект Visual Studio 2015, а компилятор и компоновщик включит CFG.

Самый простой способ — переход к свойству **проекта свойства \| \| конфигурации \| \| Создание кода C/C++** и выбор **Да (/Guard: CF)** для защиты потока управления.

![Свойство cfg в Visual Studio](images/cfg-vs.png)

Кроме того, можно добавить **/Guard: CF** в **проект свойства конфигурации свойства \| \| настройки \| C/C++ \| Командная строка \| Дополнительные параметры** (для компилятора) и **/Guard: CF** в **проект \| Свойства конфигурации свойства \| настройки \| компоновщика \| \| Дополнительные параметры** (для компоновщика).

![Свойство cfg для компилятора](images/cfg-compiler.png)![Свойство cfg для компоновщика](images/cfg-linker.png)

Дополнительные сведения см. в разделе [/Guard (Включение защиты потока управления)](/cpp/build/reference/guard-enable-control-flow-guard?view=vs-2019) .

При сборке проекта из командной строки можно добавить те же параметры. Например, при компиляции проекта с именем Test. cpp используйте **CL/Guard: CF Test. cpp/Link/Guard: CF**.

Вы также можете динамически управлять набором конечных адресов в формате iCal, которые считаются допустимыми с помощью CFG с использованием [**сетпроцессвалидкаллтаржетс**](/windows/desktop/api/memoryapi/nf-memoryapi-setprocessvalidcalltargets) из API управления памятью. Один и тот же API можно использовать, чтобы указать, являются ли страницы недопустимыми или допустимыми целевыми объектами для CFG. Функции [**VirtualProtect**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualprotect) и [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) по умолчанию обрабатывают указанную область исполняемых и зафиксированных страниц как допустимые цели косвенного вызова. Это поведение можно переопределить, например при реализации JIT-компилятора, указав **\_ \_ недопустимые цели страницы** при вызове **VirtualAlloc** или **\_ целевых объектов страницы \_ без \_ обновления** при вызове **VirtualProtect** , как описано в разделе [**константы защиты памяти**](/windows/desktop/Memory/memory-protection-constants).

## <a name="how-do-i-tell-that-a-binary-is-under-control-flow-guard"></a>Как определить, что двоичный файл находится под защитой потока управления?

Запустите [средство DUMPBIN](/cpp/build/reference/dumpbin-reference) (входит в установку visual Studio 2015) из командной строки Visual Studio с параметрами */headers* и */лоадконфиг* : **DUMPBIN/HEADERS/лоадконфиг test.exe**. Выходные данные для двоичного файла в CFG должны показывать, что значения заголовков включают "Guard" и что значения конфигурации загрузки включают "CF инструментированный" и "Таблица FID Present".

![выходные данные подпрограммы DUMPBIN/HEADERS](images/cfg-dumpbin-headers.png)

![выходные данные/лоадконфиг DUMPBIN](images/cfg-dumpbin-loadconfig.png)

## <a name="how-does-cfg-really-work"></a>Как работает CFG?

Уязвимости программного обеспечения часто используют, предоставляя маловероятное, необычные или экстремальные данные для выполняющейся программы. Например, злоумышленник может воспользоваться уязвимостью переполнения буфера, предоставляя для программы больше входных данных, чем ожидалось, тем самым заставляя область, зарезервированную программой, для хранения ответа. Это может привести к повреждению смежной памяти, в которой может содержаться указатель на функцию. Когда программа вызывает эту функцию, она может перейти к непреднамеренному расположению, указанному злоумышленником.

Однако потент комбинация поддержки компиляции и времени выполнения из CFG реализует целостность потока управления, которая жестко ограничена, где могут выполняться косвенные инструкции по вызову.

Компилятор выполняет следующие действия:

1.  Добавляет упрощенные проверки безопасности в скомпилированный код.
2.  Определяет набор функций в приложении, которые являются допустимыми целевыми объектами для косвенных вызовов.

Поддержка среды выполнения, предоставляемая ядром Windows:

1.  Эффективно сохраняет состояние, определяющее допустимые цели косвенного вызова.
2.  Реализует логику, проверяющую допустимость непрямого целевого объекта вызова.

Для иллюстрации:

![псевдокод](images/cfg-pseudocode.jpg)

Если во время выполнения проверка CFG завершается сбоем, Windows немедленно завершает программу, тем самым нарушая тем самым атаку, которая пытается косвенно вызвать недопустимый адрес.

 

 
