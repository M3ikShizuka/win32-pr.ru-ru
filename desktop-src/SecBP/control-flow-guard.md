---
description: управление Flow Guard (CFG) — это функция обеспечения безопасности платформы с высокой степенью оптимизации, которая была создана для борьбы с уязвимостями повреждения памяти.
ms.assetid: 116EAD64-7CAE-455C-BA43-9492F78DE873
title: Защита потока управления
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 62186a86f821e7eb350381c7dfbc500c80dd040f4321a8f630c7d408937a8460
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119622821"
---
# <a name="control-flow-guard"></a>Защита потока управления

## <a name="what-is-control-flow-guard"></a>что такое управление Flow Guard?

управление Flow Guard (CFG) — это функция обеспечения безопасности платформы с высокой степенью оптимизации, которая была создана для борьбы с уязвимостями повреждения памяти. Устанавливая строгие ограничения на то, где приложение может выполнять код из, злоумышленники могут намного сложнее выполнять произвольный код с помощью уязвимостей, таких как переполнение буфера. CFG расширяет предыдущие технологии защиты от эксплойтов, такие как [/GS](/cpp/build/reference/gs-buffer-security-check?view=vs-2019), [DEP](../memory/data-execution-prevention.md)и [ASLR](/archive/blogs/michael_howard/address-space-layout-randomization-in-windows-vista).

эта функция доступна в Microsoft Visual Studio 2015 и работает в версиях Windows с поддержкой CFG — выпусков x86 и x64 для настольных и серверных Windows 10 и Windows 8.1 с обновлением (KB3000850).

Мы настоятельно рекомендуем разработчикам включить CFG для своих приложений. Не нужно включать CFG для каждой части кода, так как сочетание CFG и код, поддерживающий неcfg, будут выполняться нормально. Но если не включить CFG для всего кода, можно открыть зазоры в защите. кроме того, код с поддержкой cfg прекрасно работает в версиях Windows, не поддерживающих cfg, и поэтому полностью совместим с ними.

## <a name="how-can-i-enable-cfg"></a>Как включить CFG?

В большинстве случаев нет необходимости изменять исходный код. все, что нужно сделать, — это добавить параметр в проект Visual Studio 2015, и компилятор и компоновщик будут включать CFG.

самый простой способ — переход к **Project \| свойства \| конфигурации \| \| создание кода C/C++** и выбор **Yes (/guard: cf)** для Control Flow guard.

![Свойство cfg в Visual Studio](images/cfg-vs.png)

кроме того, добавьте **/guard: cf** в **Project \| свойства \| конфигурации свойства настройки \| C/C++ \| командная строка \| дополнительные параметры** (для компилятора) и **/guard: cf** в **Project \| свойств \| конфигурации свойства Configuration \| компоновщика \| \| дополнительные параметры** (для компоновщика).

![Свойство cfg для компилятора](images/cfg-compiler.png)![Свойство cfg для компоновщика](images/cfg-linker.png)

дополнительные сведения см. в разделе [/guard (Enable Control Flow guard)](/cpp/build/reference/guard-enable-control-flow-guard?view=vs-2019) .

При сборке проекта из командной строки можно добавить те же параметры. Например, при компиляции проекта с именем Test. cpp используйте **CL/Guard: CF Test. cpp/Link/Guard: CF**.

Вы также можете динамически управлять набором конечных адресов в формате iCal, которые считаются допустимыми с помощью CFG с использованием [**сетпроцессвалидкаллтаржетс**](/windows/desktop/api/memoryapi/nf-memoryapi-setprocessvalidcalltargets) из API управления памятью. Один и тот же API можно использовать, чтобы указать, являются ли страницы недопустимыми или допустимыми целевыми объектами для CFG. Функции [**VirtualProtect**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualprotect) и [**VirtualAlloc**](/windows/desktop/api/memoryapi/nf-memoryapi-virtualalloc) по умолчанию обрабатывают указанную область исполняемых и зафиксированных страниц как допустимые цели косвенного вызова. Это поведение можно переопределить, например при реализации JIT-компилятора, указав **\_ \_ недопустимые цели страницы** при вызове **VirtualAlloc** или **\_ целевых объектов страницы \_ без \_ обновления** при вызове **VirtualProtect** , как описано в разделе [**константы защиты памяти**](/windows/desktop/Memory/memory-protection-constants).

## <a name="how-do-i-tell-that-a-binary-is-under-control-flow-guard"></a>как определить, что двоичный файл находится под контролем Flow Guard?

запустите [средство dumpbin](/cpp/build/reference/dumpbin-reference) (которое входит в состав установки Visual Studio 2015) из командной строки Visual Studio с параметрами */headers* и */лоадконфиг* : **dumpbin/headers/лоадконфиг test.exe**. Выходные данные для двоичного файла в CFG должны показывать, что значения заголовков включают "Guard" и что значения конфигурации загрузки включают "CF инструментированный" и "Таблица FID Present".

![выходные данные подпрограммы DUMPBIN/HEADERS](images/cfg-dumpbin-headers.png)

![выходные данные/лоадконфиг DUMPBIN](images/cfg-dumpbin-loadconfig.png)

## <a name="how-does-cfg-really-work"></a>Как работает CFG?

Уязвимости программного обеспечения часто используют, предоставляя маловероятное, необычные или экстремальные данные для выполняющейся программы. Например, злоумышленник может воспользоваться уязвимостью переполнения буфера, предоставляя для программы больше входных данных, чем ожидалось, тем самым заставляя область, зарезервированную программой, для хранения ответа. Это может привести к повреждению смежной памяти, в которой может содержаться указатель на функцию. Когда программа вызывает эту функцию, она может перейти к непреднамеренному расположению, указанному злоумышленником.

Однако потент комбинация поддержки компиляции и времени выполнения из CFG реализует целостность потока управления, которая жестко ограничена, где могут выполняться косвенные инструкции по вызову.

Компилятор выполняет следующие действия:

1.  Добавляет упрощенные проверки безопасности в скомпилированный код.
2.  Определяет набор функций в приложении, которые являются допустимыми целевыми объектами для косвенных вызовов.

поддержка среды выполнения, предоставляемая ядром Windows:

1.  Эффективно сохраняет состояние, определяющее допустимые цели косвенного вызова.
2.  Реализует логику, проверяющую допустимость непрямого целевого объекта вызова.

Для иллюстрации:

![псевдокод](images/cfg-pseudocode.jpg)

если во время выполнения проверка CFG завершается сбоем, Windows немедленно завершает программу, тем самым нарушая тем самым атаку, которая пытается косвенно вызвать недопустимый адрес.

 

 
