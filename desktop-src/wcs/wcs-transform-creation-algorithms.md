---
title: Алгоритмы создания преобразования WCS
description: Алгоритмы создания преобразования WCS
ms.assetid: 526bbbfc-fb60-415d-b4f0-6a44a5d11a55
keywords:
- Цветовая система Windows (WCS), создание преобразования
- WCS (цветовая система Windows), создание преобразования
- Управление цветом изображений, создание преобразований
- Управление цветом, создание преобразований
- цвета, создание преобразования
- Создание преобразования
- Создание преобразования WCS
- алгоритмы, создание преобразований
ms.localizationpriority: high
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 418596c0e57571f3e504727d4606921d36ff9461
ms.sourcegitcommit: d39e82e232f6510f843fdb8d55d25b4e9e02e880
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/03/2021
ms.locfileid: "104550251"
---
# <a name="wcs-transform-creation-algorithms"></a>Алгоритмы создания преобразования WCS

[Создание преобразований](#creation-of-transforms)

 

[Выполнение последовательного преобразования](#sequential-transform-execution)

 

[Создание оптимизированных преобразований](#creation-of-optimized-transforms)

 

[иккпрофилефромвкспрофиле](#iccprofilefromwcsprofile)

 

[Черная сохранность и создание черной версии](#black-preservation-and-black-generation)

 

[Проверить цветовой охват](#checkgamut)

## <a name="creation-of-transforms"></a>Создание преобразований

Чтобы правильно объяснить, как работают преобразования цветов, полезно объяснить полный путь обработки с помощью ICM 2,0 и внутренних компонентов отв. Функция ICM 2,0 [**креатеколортрансформв**](/windows/win32/api/icm/nf-icm-createcolortransformw) создает цветное преобразование, которое приложения могут использовать для выполнения управления цветом. Эта функция создает контекст цвета на основе входных данных [**логколорспаце**](/windows/desktop/api/Wingdi/ns-wingdi-taglogcolorspacea) и намерения. Способы сопоставляются с базовым алгоритмом сопоставления цветового охвата ICC. Затем функция вызывает ICM 2,0 Function [**креатемултипрофилетрансформ**](/windows/desktop/api/Wingdi/) для единообразной обработки цвета. Функция **креатеколортрансформ** обычно копирует данные во внутреннюю оптимизированную структуру преобразования.

Функция ICM 2,0 Креатемултипрофилетрансформ принимает массив профилей и массив целей или один профиль связи устройства и создает цветное преобразование, которое приложения могут использовать для выполнения сопоставления цветов. Он обрабатывает эти входные профили и способы создания моделей устройств, моделей отображения цветов, описаний границ палитры и моделей сопоставления палитры. Вот как это делается:

-   Модели устройств инициализируются непосредственно из профилей DM. Для каждого профиля создается одна модель устройства в вызове [**креатемултипрофилетрансформ**](/windows/desktop/api/Wingdi/).
-   Модели цветового оформления инициализируются непосредственно из профилей камера. Для каждого профиля в вызове [**креатемултипрофилетрансформ**](/windows/desktop/api/Wingdi/)имеется один профиль фотокамера. Тем не менее можно указать один и тот же профиль фотокамера для более чем одного профиля.
-   Описания границ цветовой палитры инициализируются из объекта модели устройства и объекта «камера». Для каждого профиля в вызове [**креатемултипрофилетрансформ**](/windows/desktop/api/Wingdi/)имеется одно описание границы цветового охвата.
-   Модели сопоставления цветовых диапазонов инициализируются из двух границ цветового охвата и намерений. Необходимо создать модель сопоставления цветового охвата между каждой парой моделей устройств, созданных из вызова в [**креатемултипрофилетрансформ**](/windows/desktop/api/Wingdi/). Обратите внимание, что это означает, что используется одна модель отображения цветового охвата, отличная от модели устройства. Так как количество целей соответствует количеству моделей устройств, существует еще одна цель, чем требуется. Первая цель в списке пропускается. Вы просматриваете список моделей и целей устройств, создавая модели сопоставления цветовых диапазонов. Выберите первую и вторую модели устройств и второе намерение, а затем инициализируйте первую модель сопоставления цветов. Выберите вторую и третью модели устройств и третью намерение, а затем инициализируйте вторую модель сопоставления цветового охвата. Продолжайте таким образом, пока не будут созданы все модели сопоставления цветовой гаммы.

После того как профили были правильно обработаны и были созданы и инициализированы все промежуточные объекты, можно создать ЦИТИРУЕМое преобразование с помощью следующего вызова. *Пдесткам* и *пдестдм* — это связанные с последним профилем в вызове [**креатемултипрофилетрансформ**](/windows/desktop/api/Wingdi/).


```C++
HRESULT CreateCITEColorTransform(
 __inout     IDeviceModel          *pSourceDM,
 __inout     IColorAppearanceModel *pSourceCAM,
 __in        GamutMapArray         *pGamutMapArray,
 __inout     IColorAppearanceModel *pDestCAM,
 __inout     IDeviceModel          *pDestDM,
             EColorTransformMode    eTransformMode,
 __deref_out IColorTransform      **ppCTS
 );
```



## <a name="support-for-plug-ins"></a>Поддержка подключаемых модулей

Одной из проблем, связанных с настройкой списка преобразований, является проверка доступности требуемого подключаемого модуля. Следующий параметр модели предоставляет эту политику для управления этим поведением. Управление этим списком преобразований является методом во внутренней оптимизированной структуре преобразования, но каждый метод модели предоставляет указатель на себя и собственный набор значений параметров.

Режим должен быть одним из следующих.

-   Тфмробуст: Если профиль измерения указывает предпочтительный подключаемый модуль и подключаемый модуль недоступен, Новая система CTE будет использовать подключаемый модуль базового уровня. Если ни один из подключаемых модулей недоступен, преобразование сообщит об ошибке.
-   Тфмстрикт: Если Колорконтекст указывает предпочтительный подключаемый модуль, подключаемый модуль должен быть доступен. Если предпочтительный подключаемый модуль не найден, будет использоваться базовый подключаемый модуль. Если ни один из подключаемых модулей недоступен, преобразование сообщит об ошибке.
-   Тфмбаселине: в Аддмеасурементстеп можно использовать только подключаемые модули базового уровня. Если Колорконтекст указывает предпочтительный подключаемый модуль, подключаемый модуль будет проигнорирован. Если подключаемый модуль базового уровня недоступен, преобразование сообщит об ошибке.

## <a name="transform-execution"></a>Выполнение преобразования

Функция [**ТРАНСЛАТЕКОЛОРС**](/windows/win32/api/icm/nf-icm-translatecolors) API ICM 2,0 преобразует массив цветов из исходного [цветового](c.md) пространства в цветовое пространство назначения, как определено в преобразовании цвета. Эта функция внутренне проверяет массив кэшированных цветов, чтобы обеспечить немедленное сопоставление часто преобразованных цветов. Это преобразование поддерживает 8-битные массивы байтов на канал и 32 бит на массив с плавающей точкой на канале. Все остальные форматы будут преобразованы перед передачей в новое отв.

Функция [**ТРАНСЛАТЕБИТМАПБИТС**](/windows/win32/api/icm/nf-icm-translatebitmapbits) API ICM 2,0 преобразует цвета точечного рисунка, имеющего определенный формат, для создания другого точечного рисунка в запрошенном формате. Эта функция внутренне проверяет массив кэшированных цветов, чтобы обеспечить немедленное сопоставление часто преобразованных цветов. Чтобы избежать слишком большого количества путей кода, поддержки и сложности тестирования, в подсистеме преобразования и интерполяции фактически поддерживается только ограниченное количество форматов битовых рисунков. Эта функция должна переводить несобственные форматы входящего и исходящего растрового изображения в формат, поддерживаемый в собственном формате для обработки. Это преобразование поддерживает только 8-битные битовые байты на канал и 32 бит на канал с точечными рисунками с плавающей запятой. Все остальные форматы будут преобразованы перед передачей в новое отв.

 

### <a name="sequential-transform-execution"></a>Выполнение последовательного преобразования

Если параметр *dwFlags* имеет бит последовательного \_ преобразования, установленный при вызове функций [**креатеколортрансформв**](/windows/win32/api/icm/nf-icm-createcolortransformw) или **креатемултипрофилетрансформ** ICM, шаги преобразования выполняются последовательно. Это означает, что код проходит через каждую модель устройства, модель внешнего вида и модель сопоставления цветового охвата отдельно, как указано в вызове **креатеколортрансформ** или **креатемултипрофилетрансформ** . Это может быть полезно при отладке подключаемых модулей, но намного медленнее, чем с помощью оптимизированного преобразования. Поэтому запуск в последовательном режиме не рекомендуется для рабочего программного обеспечения. Кроме того, результаты, полученные в последовательном и оптимизированном режиме, могут быть незначительными. Это обусловлено вариациями, появившимися при объединении функций.

### <a name="creation-of-optimized-transforms"></a>Создание оптимизированных преобразований

Оптимизированное преобразование — это таблица многомерных уточняющих запросов. Таблица может быть обработана многомерной подсистемой интерполяции, например интерполяцией тетрахедрал, которая применяет цвета ввода к преобразованию. В следующем разделе описывается создание оптимизированных таблиц подстановки. В разделе после этого описано, как выполнить интерполяцию в оптимизированных таблицах подстановки.

## <a name="sparse-lookup-tables"></a>Разреженные таблицы подстановки

Обычные принтеры имеют CMYK красок. Чтобы расширить охват, одним из подходов является добавление новых красок в систему. Обычно в триадных цветах красок CMYK возникают проблемы при воспроизведении. Распространенные варианты: оранжевый, зеленый, красный, синий и т. д. Чтобы увеличить «очевидное разрешение», можно использовать краски с различными оттенками, например светло-голубой, светло-пурпурный и т. д. По сути, устройство принтера имеет более четырех каналов.

Хотя принтеры являются устройствами вывода, они также выполняют преобразование цветов из пространства устройства в другое цветовое пространство. В случае с принтером CMYK это преобразование будет преобразовано из CMYK в XYZ или «прямая модель» принтера. Комбинируя модель прямого с другими преобразованиями, можно эмулировать печать CMYK на другом устройстве. Например, цвет CMYK принтера для монитора RGB делает возможным механизм проверки, эмулирующий печать принтера CMYK на мониторе. Аналогичным образом также применяется для принтеров Hi-Fi. Преобразование КМИКОГ в RGB позволяет выполнять проверку принтера КМИКОГ на мониторе.

Традиционным подходом к реализации такого преобразования цвета является использование единообразного LUT. Например, в профиле ICC для принтера КМИКОГ, спецификация ICC требует тег A2B1, в котором хранится унифицированный LUT, представляющий унифицированную выборку в пространстве устройства КМИКОГ модели прямого, которая переходит от КМИКОГ к пространству подключения профиля ICC (ЦИЕЛАБ или ЦИЕКСИЗ). Профиль связи для устройства ICC обеспечивает прямое преобразование из пространства устройства КМИКОГ в любое цветовое пространство, включая пространство устройства, а также в виде LUT, который равномерно используется в КМИКОГ пространстве. Выборка никогда не выполняется с уровнями 256 (глубина бит 8) из-за большого LUTа, за исключением случаев использования монохромных устройств (1 канал). Вместо этого используется выборка с более низким уровнем глубины. Некоторые типичные варианты выбора: 9 (битовая глубина 3), 17 (битовая глубина 4), 33 (глубина бит 5). С числом уровней менее 256 в каждом канале LUT используется в сочетании с алгоритмом интерполяции для получения результата, если уровень находится между двумя уровнями выборки.

Хотя единообразный LUT является концептуально простым для реализации, и интерполяция на единообразном LUT обычно является эффективной, размер LUT увеличивается экспоненциально с входным измерением. Фактически, если *d* — число шагов, используемых в унифицированном LUT, а *n* — число каналов в исходном цветовом пространстве, то число узлов в LUT — это ![ ПЕРЕМЕННАЯ для количества узлов в LUT. ](images/transformcreation-image002.gif) . Очевидно, что количество узлов быстро требует большого объема памяти, что даже самые популярные вычислительные системы испытывают трудности при обработке спроса. Для устройств с шестью или восемью каналами, реализация ICC профиля устройства требует нескольких шагов в LUT, иногда даже до пяти шагов в таблице A2B1 для сохранения профиля в мегабайтах вместо гигабайтов. Очевидно, что использование меньшего количества шагов увеличивает ошибку интерполяции, так как теперь существует меньшее число выборок. Так как LUT должен быть однородным, точность в пределах всего цветового пространства снижается даже в тех областях пространства, где существенное различие цветов может быть вызвано небольшим изменением в значении устройства.

На устройствах с более чем четырьмя колорантс некоторые подпространства всего пространства устройства являются более важными, чем другие. Например, в КМИКОГ пространстве цвета голубой и зеленой красок редко используются, так как их оттенки во многом пересекаются друг с другом. Аналогичным образом, желтые и оранжевые краски во многом пересекаются друг с другом. Равномерное число шагов можно просмотреть в виде общего ухудшения качества в масштабе всего цветового пространства, что можно позволить себе для невероятных сочетаний рукописного ввода, но не для наиболее вероятных или важных сочетаний.

Несмотря на то, что единообразный выбор LUT является простым и эффективным для интерполяции, он накладывает требования к огромному объему памяти при увеличении размера измерения. На практике, хотя у устройства может быть шесть или восемь каналов, они редко используются одновременно. В большинстве случаев преобразование «входные цвета в цвет» имеет только несколько «активных» колорантс и, следовательно, находится в более низких цветовых пространствах. Это также означает, что интерполяцию можно сделать более эффективной в этом пространстве меньшего размера, так как интерполяция выполняется быстрее, если измерение меньше.

Таким образом, подход заключается в стратифи всего пространства устройства в подпространства различных измерений. Так как более низкие размеры (объединяющие три или четыре колорантс) более важны, стратифинг пространство, можно также применять разные частоты выборки. то есть различное количество шагов, на части; повышение частоты выборки для более низких размеров, уменьшая их для более высоких измерений.

Чтобы исправить нотацию, *n* — число каналов в исходном цветовом пространстве преобразования цвета, которое нужно вычислить. Можно также в качестве входного измерения указать *n* , а значение ![ n больше или равно 5.](images/transformcreation-image004.gif) , если не указано иное.

Основные стандартные блоки — это Лутс различных входных *измерений* и размеров вместо одного унифицированного LUT с входным измерением *n*. Чтобы быть более точным,*LUT* представляет собой прямоугольную Lattice, накладываемую на единичный куб. то есть все координаты устройства нормализованы до диапазона \[ 0, 1 \] ). Если является входным измерением LUT (Обратите внимание, что не должно быть равно *n*, хотя ![ выводится V меньше или равно n).](images/transformcreation-image006.gif) является обязательным), то он состоит из ν одномерной сетки выборки:

SAMP *i*: ![ показывает сетку с одномерной выборкой.](images/transformcreation-image008.gif)

Если все *x <sub>j</sub>s* должны находиться в диапазоне от \[ 0 до 1, \] будет ![ показан Надстрочный знак d (i).](images/transformcreation-image010.gif) число шагов для выборки *i* -канального типа, которое должно быть не меньше 1 и ![ показывает спуперскрипт X (индекс) d (i).](images/transformcreation-image012.gif) должно быть равно 1. С другой стороны, ![ показывает Надстрочный знак X (индекс 1).](images/transformcreation-image014.gif) не обязательно должен быть равен 0.

Будут определены только следующие два особых случая LUT.

*Закрытые LUT*: это LUT с дополнительным требованием, которое для каждого *<sub></sub>* SAMP i ![ показывает Надстрочный знак X (индекс 1) равным 0.](images/transformcreation-image016.gif) и ![ показывает Надстрочный знак d (i), который больше или равен 2.](images/transformcreation-image018.gif) . Равномерное закрытое LUT — это закрытая LUT, которая содержит один и тот же ![ Надстрочный знак d (i).](images/transformcreation-image010.gif) для каждого канала, и узлы устанавливаются по единому интервалу между 0 и 1.

*Open LUT*: это LUT с дополнительным требованием, которое для каждого SAMP *i* ![ показывает Надстрочный знак X (индекс 1) больше 0.](images/transformcreation-image020.gif) . Теперь можно ![ Показать Надстрочный знак d (i), равный 1.](images/transformcreation-image022.gif) .

Целью является стратифи единицы измерения \[ 0, 1 \] *n* в коллекцию закрытых Лутс и Open Лутс, чтобы вся коллекция покрыта куб единицы. Концептуально проще организовать эти "LUT Strata" по их размерам, чтобы на верхнем уровне:

![Показывает верхний уровень для организации L T Strata по их измерениям.](images/transformcreation-image024.png)

где ![ отображается подстрочный индекс k.](images/transformcreation-image026.gif) является коллекцией «*k* -мерный Strata». Обратите внимание, что измерение Strata начинается от 3 вместо 0; то есть, указывает, что интерполяция трех-колорант комбинаций может быть обработана без чрезмерного требования к памяти.

## <a name="description-of-the-lut-strata"></a>Описание LUT Strata

В этой реализации:

1. ![Содержит подстрочный индекс 3.](images/transformcreation-image028.gif) состоит из закрытых Лутс с тремя входными данными, по одному из всех возможных комбинаций трех колорантс, выбранных из *n* колорантс.

2. ![Содержит подстрочный индекс 4.](images/transformcreation-image030.gif) состоит из одного закрытого LUTа в сочетании CMYK (или первых четырех колорантс) вместе с ![Показывает (n более 4) минус 1.](images/transformcreation-image032.png) Откройте Лутс для всех остальных комбинаций из четырех колорант. Синглинг комбинацию CMYK, вы подтверждаете, что это важное сочетание.

3. Для ![ отображает k равным 5,..., n.](images/transformcreation-image034.gif) , ![ Показывает Сигма в подстрочном k.](images/transformcreation-image026.gif) состоит из ![ выводов (n поверх k).](images/transformcreation-image037.gif) Откройте Лутс, по одному для каждого возможного сочетания выбора *k* колорантс в сумме *n* колорантс.

В нем остается указать размеры Лутс. Основное различие между открытыми и закрытыми Лутс заключается в том, что открытая Лутс не перекрываются, а замкнутые Лутс могут перекрываться на границах. Тот факт, что одномерный выборка в открытом LUT не содержит 0, по сути означает, что в открытом LUT не хватает половины граней, поэтому имя "Open". Если два Лутс не перекрываются, можно использовать разное количество шагов или расположений узлов в каждом канале. То же самое не верно, если два Лутс перекрываются. В этом случае, если число шагов или расположений узлов отличается, точка пересечения двух Лутс будет принимать разное значение интерполяции в зависимости от того, какой LUT используется в интерполяции. Простое решение этой проблемы — использование унифицированной выборки с одинаковым количеством шагов, когда два Лутс перекрываются. Другими словами:

Все закрытые Лутс (все три колорант Лутс и CMYK LUT в этой реализации) должны быть однородными и иметь одинаковое число шагов, которые обозначены как *d*.

Для определения количества шагов *d* для закрытого Лутс и количества шагов для Open Лутс можно использовать следующие два алгоритма.

## <a name="algorithm-1"></a>Алгоритм \# 1

Этот алгоритм не требует внешних входных данных.

Все закрытые Лутс будут однородными с *d* числом шагов.

Все открытые Лутс в измерении *k* будут иметь одинаковое число шагов: ![ d (k).](images/transformcreation-image039.gif) в каждом входном канале, и узлы имеют одинаковый размер. то есть, для каждой ![ показывает i, равное 1, 2,..., k.](images/transformcreation-image041.gif) .

SAMP *i*: ![ показывает алгоритм SAMP i.](images/transformcreation-image043.png)

Наконец, укажите *d* и *d* (*k* ) в следующей таблице 1. Три режима: «proof», «обычная» и «лучшая» — параметры качества ICM 2,0. В этой реализации режим цветопробы имеет наименьший объем памяти, а оптимальный режим — наибольший объем памяти.

Для реализации этого алгоритма необходимо вызвать следующий алгоритм \# 2. Пользователи могут указать собственные расположения выборки, используя таблицы в качестве руководств.

## <a name="algorithm-2"></a>Алгоритм \# 2

Для этого алгоритма требуются внешние входные данные в виде списка "важных" расположений выборки, но это более Адаптивное и может сэкономить место в памяти.

Обязательный вход — это массив значений устройств, предоставленных пользователем. Эти значения устройств указывают, какой регион цветового пространства устройства важен; то есть, какой регион следует использовать в качестве примера.

Все закрытые Лутс будут однородными с *d* количеством шагов, как описано в разделе алгоритм \# 1. Значения для *d* приведены в таблице 1.

*(a) универсальное закрытое LUT*



|         | Режим цветопробы | Нормальный режим | Лучший режим |
|---------|------------|-------------|-----------|
| ***d*** | 9          | 17          | 33        |



 

*(б) Open LUT*



| Входное измерение | Режим цветопробы | Нормальный режим | Лучший режим |
|-----------------|------------|-------------|-----------|
| 4               | 5          | 7           | 9         |
| 5               | 2          | 3           | 3         |
| 6               | 2          | 3           | 3         |
| 7               | 2          | 2           | 2         |
| 8 или более       | 2          | 2           | 2         |



 

**Таблица 1.** Размеры LUT, используемые в алгоритме

Каждый открытый LUT может иметь различное количество шагов в каждом входном канале, а расположения выборки не должны иметь одинаковых пробелов. Для данного открытого LUT Стратум имеется связанное сочетание колорант, например, ![ содержит подстрочный индекс 1,..., c подстрочной буквой k.](images/transformcreation-image045.gif) , где ![ содержит подстрочный знак C.](images/transformcreation-image047.gif) — Это отдельные целые числа от 1 до *n*. Это индексы каналов, соответствующие "Active" колорантс в этом Strata.

Шаг 1. Отфильтруйте выведенный массив значений устройств, которые не содержатся в этом Strata. Значение устройства ![ показывает x-индекс 1, x-индекс 2,..., подстрочный индекс n.](images/transformcreation-image049.gif) содержится в Strata, только если ![ отображает набор значений для канала.](images/transformcreation-image051.gif) и все остальные каналы равны 0. Если в отфильтрованном наборе есть *N* записей, Let

![Показывает формулу, используемую, если отфильтрованный набор содержит N записей.](images/transformcreation-image053.png)

Для каждого  ![Показывает, что i равно 1, 2,..., k.](images/transformcreation-image041.gif) , выполните следующие шаги 2-5.

Шаг 2. Если ![ отображается подстрочный нижний индекс (k), равный 1.](images/transformcreation-image055.gif) , SAMP *i* имеет только 1 точку, которая должна быть 1,0. Перейти *к следующему.* В противном случае перейдите к ШАГУ 3.

Шаг 3. Сортировка отфильтрованных образцов в возрастающем порядке в ![Показывает подстрочную i в C.](images/transformcreation-image047.gif) канал.

Шаг 4. Определение сетки выборки "под вопросом" с помощью узлов

![Показывает узлы, используемые для определения сетки выборки "под вопросом".](images/transformcreation-image057.png)

where ![Показывает j равно 1, 2,..., d подстрочный индекс под вопросом (k).](images/transformcreation-image059.gif) .

Шаг 5. Регуларизе предварительную сетку, чтобы убедиться, что она соответствует ограниченному монотону, а также в том, что она заканчивается на 1,0. Поскольку массив уже отсортирован, узлы в предварительной сетке уже являются монотонными нондекреасинг. Однако соседние узлы могут быть идентичными. Это можно исправить, удалив идентичные узлы, если это необходимо. Наконец, после выполнения этой процедуры, если конечная точка меньше 1,0, замените ее на 1,0.

Обратите внимание, что шаг 5 является причиной того, что LUT Strata может иметь различное количество шагов в каждом канале. После этого число шагов в канале может быть меньше ![Отображение d подстрочных индексов под вопросом (k).](images/transformcreation-image061.gif) .

## <a name="interpolation"></a>Интерполяции

Вы можете создать соотношением Куба единицы, открыв LUT Strata и закрыв LUT Strata. Чтобы выполнить интерполяцию с помощью этой "разреженной LUT структуры", выполните следующие действия. Предполагается заданное значение входного устройства ![Показывает (X-индекс 1, X подстрочных и 2,..., X, подстрочность n).](images/transformcreation-image049.gif) .

Шаг 1. Определение количества активных каналов. Это число ненулевых каналов. Это определяет Strata измерение *k* для поиска содержащего Стратум. Точнее, измерение Strata равно 3, если число активных каналов ![ отображается меньше или равно 3.](images/transformcreation-image063.gif) в противном случае измерение Strata будет таким же, как и число активных каналов.

Шаг 2. в ![Показывает подстрочный индекс k.](images/transformcreation-image026.gif) , найдите содержащий Стратум. Значение устройства содержится в открытом Стратум, если все каналы, соответствующие Стратум, имеют ненулевое значение, а все остальные каналы равны нулю. Значение устройства содержится в закрытом Стратум, если каждый канал, не представленный Стратум, равен нулю. Если не найдено ни одного содержащего Стратум, возникает ошибка. Отменяет и сообщайте об ошибке. Если найден объект, содержащий Стратум, перейдите к следующему шагу.

Шаг 3. Если объект, содержащий Стратум, закрыт, то интерполяция в Стратум может выполняться любым известным алгоритмом интерполяции. В этой реализации для выбора алгоритма используется тетрахедрал интерполяция. Если объект, содержащий Стратум, открыт, а значение устройства находится строго в пределах Стратум, то есть

![Показывает X, нижний индекс, который больше или равен... ](images/transformcreation-image065.gif) Первый узел в *i* -ом канале

где *i* является индексом канала для Стратум, то работает стандартный алгоритм интерполяции, например тетрахедрал интерполяцию.

Если этот ![ ](images/transformcreation-image067.gif) параметр имеет значение X, а не первый узел в *i* -й канале, то в качестве значения устройства попадают «зазор» между Стратум и более низкими размерами. Этот мои не имеет дело с алгоритмом интерполяции на SE, поэтому любой алгоритм интерполяции можно использовать для интерполяции в этом «пропуске», хотя Предпочтительный алгоритм — это следующая ограниченная интерполяция.

Архитектура модуля интерполяции показана в двух частях рис. 1.

![Схема, которая показывает часть одной из архитектур модуля интерполяции.](images/transformcreation-image068.png)

![На схеме показана вторая часть архитектуры модуля интерполяции.](images/transformcreation-image070.png)

**Рис. 1.** Архитектура модуля интеполатион

Как упоминалось ранее, этот алгоритм способен достичь достаточно плотной выборки в регионах пространства устройства, которые содержат важное сочетание колорантс, и свести к минимуму общий размер Лутс. В следующей таблице показано сравнение количества узлов, необходимых для разреженной LUT реализации (с использованием алгоритма \# 1 и обычного режима) и соответствующей единообразной реализации LUT.



| **Число входных каналов** | **Разреженные LUT** | **Унифицированный LUT** |
|------------------------------|----------------|-----------------|
| 5                            | 142498         | 1419857         |
| 6                            | 217582         | 24137567        |
| 7                            | 347444         | 410338673       |
| 8                            | 559618         | 6975757441      |



 

## <a name="interpolation-within-a-unit-cube"></a>Интерполяция внутри единичного Куба

Базовым шагом в случае прямоугольной сетки является интерполяция внутри окружающей ячейки. Для входной точки можно легко определить окружающую ячейку. В прямоугольной сетке указано выходное значение в каждой из вершин (угловых точек) заданной ячейки. Они также являются единственными условиями границ (BCs), которым должен соответствовать интерполант: интерполант должен пройти все эти точки. Обратите внимание, что эти граничные условия относятся к дискретным точкам, в данном случае 2N угловые точки ячейки, где n — это измерение цветового пространства.

Перед переходом полезно вынести концепцию граничных условий. Для любого подмножества из границы окружающей ячейки (Куба единицы измерения в n измерений) условие границы в S является спецификацией функции BC: S → RM, где m — выходное измерение. Иными словами, интерполант, который может быть отмечен интерп: \[ 0, 1 \] n → RM, должен соответствовать следующим требованиям: интерп (x) = BC (x) для всех x в S.

В стандартном сценарии интерполяции в Кубе единиц измерения — это набор дискретных точек, которые являются вершинами 2N Куба.

Теперь можно обобщить граничные условия, чтобы решить проблемы, описанные выше, и предоставить новый алгоритм интерполяции в Кубе единицы. Вместо того чтобы разрешать только дискретные точки границ, можно налагать граничные условия на всю границу в Кубе. Ниже приведены точные предположения.

(a) точка VN = (1, 1,..., 1) является специальной, и допускается только дискретное условие границы. Иными словами, ни одно из постоянных границ не может быть наложено на n границ, равное XI = 1 (i = 1,..., n).

(б) для каждого из оставшихся n границ, равных 0 (i = 1,..., n), условие границы может быть наложено на всю грань, с условием совместимости, которое при пересечении двух фрагментов не должно быть согласовано с пересечением.

(c) все вершины, не содержащиеся в гранях с условием границы, будут иметь отдельное (дискретное) условие границы.

Можно ссылаться на дискретное условие границы в качестве конечных данных и непрерывное условие границы в качестве изолированных данных в обсуждении интерполяции конечных и ограниченных данных.

Во-первых, проверьте стандартную интерполяцию тетрахедрал (например, используемую в патентах Сакамото), которая помогает установить нотации для этого конкретного формулировку проблемы. Известно, что куб единицы \[ 0, 1 \] n можно разделить на n! тетрахедра, параметризованный набором перестановок на n символов. В частности, каждый такой тетрахедрон определяется неравенствами.

![Показывает формулу для инекуалитес тетрахедронс.](images/transformcreation-image073.gif)

где σ: {1, 2,.., n} > {1, 2,..., n} — это перестановка "Symbols" 1, 2,..., n, т. е. это бижективе сопоставление набора n символов. Например, если n = 3 и σ = (3, 2, 1), то есть σ (1) = 3, σ (2) = 2, σ (3) = 1, соответствующий тетрахедрон определяется z ≥ x, где для x1, x2, X3 используется стандартная нотация x, y, z. Обратите внимание, что эти тетрахедронс не являются отсоединенными друг от друга. Для интерполяции точки, которые полагаются на общее лицо двух различных тетрахедронс, будут иметь одинаковое значение интерполяции независимо от того, какой тетрахедрон используется в интерполяции. По-прежнему, в стандартном сценарии интерполяции в конечных точках для заданной входной точки (x1,..., xn), сначала определяется, в какой тетрахедрон он входит, или аналогично соответствующая σ перестановки, а тетрахедрал интерполант определяется как

![Показывает уравнение, определяющее тетрахедрал интерполант.](images/transformcreation-image075.png)

where ![Показывает уравнение для стандартных векторов.](images/transformcreation-image077.png) для i = 1,..., n и E1,..., EN — это стандартные векторы. Прежде чем перейти к обобщением, обратите внимание, что v0, v1,..., VN являются вершинами тетрахедрон и ![Показывает координаты барицентрик.](images/transformcreation-image079.png) — Это «барицентрик координаты».

В общем случае BCs на граничных лицах можно использовать концепцию барицентрик проекции. Как и ранее, для заданной входной точки (x1,..., xn) сначала определяется, в каком тетрахедрон он находится, или аналогично соответствующая σ перестановки. Затем выполните ряд проекций барицентрик, как показано ниже. Первая проекция ![Показывает Бпрож подстрочный 1 (x).](images/transformcreation-image081.gif) отправляет точку на плоскость ![Показывает значение индекса X Дельта (1), равное 0.](images/transformcreation-image083.gif) иное ![Показывает X равным V индексу n.](images/transformcreation-image085.gif) в этом случае он не изменяется. Точное определение Map Бпрож определяется следующим образом:

![Показывает уравнение для точного определения Бпрожа Map.](images/transformcreation-image087.png)

на ![Показывает уравнение для P надстрочного знака k.](images/transformcreation-image089.png) и k = 1, 2,..., n.

В случае ![Показывает X равным V индексу n.](images/transformcreation-image085.gif) , можно приостанавливаться, поскольку BC определяется в VN с помощью предположения (a). В случае ![Показывает, что X не равно V индексу n.](images/transformcreation-image091.gif) , ясно, что ![Показывает Бпрож подстрочный 1 (X).](images/transformcreation-image081.gif) имеет σ (1) a-й компонент аннихилатед. Иными словами, он находится на одном из граничных граней. Либо он находится на лицевой стороне, на которой определен BC. в этом случае вы можете приостанавливаться или выполнить другую проекцию барицентрик. ![Показывает Бпрож индекс 2 (X).](images/transformcreation-image093.gif) where ![Показывает X "равно Бпрож подстрочному индексу 1 (X).](images/transformcreation-image095.gif) . И если ![Показывает X ' ' = Бпрож подстрочный 1 (X ').](images/transformcreation-image097.gif) находится на лицевой стороне, на которой определен BC, можно приостанавливаться. в противном случае выполните еще одну проекцию ![Показывает Бпрож индекс 3 (X "").](images/transformcreation-image099.gif) . Так как каждая проекция аннихилатес один компонент, эффективное измерение уменьшается, поэтому вы узнаете, что процесс должен останавливаться в конечном итоге. В худшем случае вы выполняете n проекций в измерение 0, то есть вершины в Кубе, которые в соответствии с предположением (c), вам известно, что будет определено BC.

Если предположить, что были выполнены проекции, с

![Показывает формулу, используемую при условии, что была выполнена проекция.](images/transformcreation-image101.png)

x (0) = x, точка входа и BC определены в x (k). Затем прокрутить проекции, определив ряд выходных векторов:

![Показывает уравнения для ряда выходных векторов.](images/transformcreation-image103.png)

where ![Показывает уравнение для надстрочного знака Y (K).](images/transformcreation-image105.gif) и, наконец, вы получаете ответ

![Показывает интерп (x), равный надстрочными знакам y (0).](images/transformcreation-image107.gif)

## <a name="worked-example"></a>Пример

![Схема, на которой показан пример интерполяции с кубом единицы.](images/transformcreation-image108.png)

**Рис. 2.** Пример "работает"

Рассмотрим ситуацию, показанную на рис. 2, где n = 3, m = 1, и у вас есть следующий BCs:

(a) четыре дискретных BCs в вершинах

(0, 0, 1): β001

(0, 1, 1): β011

(1, 0, 1): β 101

(1, 1, 1): β 111

(b) непрерывный BC на лицевой стороне X3 = 0: F (x1, x2)

Вычисление \# 1. точка ввода x = (0,8, 0,5, 0,2). Включающий тетрахедрон связывается с перестановкой &lt; 1, 2, 3 &gt; .

1-я проекция: ![Показывает уравнение для первой проекции.](images/transformcreation-image110.png)

Это уже находится на стороне X3 = 0, поэтому вы можете приостанавливаться. Затем обратная подстановка дает

![Показывает ответ для первой проекции.](images/transformcreation-image112.png) ответ.

Вычисление \# 2. точка ввода x = (0,2, 0,5, 0,8). Включающий тетрахедрон связывается с перестановкой &lt; 3, 2, 1 &gt; .

1-я проекция: ![Показывает уравнение для первой проекции вычисления 2.](images/transformcreation-image113.png)

вторая проекция: ![Показывает уравнение для второй проекции вычисления 2.](images/transformcreation-image115.png)

Третья проекция: ![Показывает уравнение для третьей проекции вычисления 2.](images/transformcreation-image117.png) , который находится на стороне X3 = 0. Затем обратная подстановка дает

![Показывает первые два уравнения для обратной подстановки.](images/transformcreation-image119.png)

![Показывает Третье уравнение для обратной подстановки.](images/transformcreation-image123.png), который является окончательным ответом.

## <a name="applications"></a>Приложения

*(a) последовательная Тетрахедрал интерполяция*

![Схема, показывающая последовательную интерполяцию тетрахедрал.](images/transformcreation-image124.png)

**Рис. 3.** Последовательная тетрахедрал интерполяция

См. рис. 3. Чтобы выполнить интерполяцию между двумя плоскостями, на которых были наложены несовместимые сетки, рассмотрим ячейку, включающую заданную точку P, показанную на рисунке. Верхние вершины ячейки поступают непосредственно из сетки в верхней плоскости. Вершины в нижней части не совместимы с сеткой в нижней плоскости, поэтому вся грань обрабатывается как BC с значениями, полученными с помощью интерполяции на сетке в нижней плоскости. Затем он ясно, что эта программа установки удовлетворяет предположениям (a), (b) и (c) выше, и вы можете применить алгоритм интерполяции.

Также ясно, что алгоритм уменьшил измерение проблемы интерполяции на 1, поскольку результат представляет собой линейное сочетание значений в вершинах в верхней сетке и интерполяцию в нижней плоскости, у которой измерение меньше 1. Если в нижней плоскости существует аналогичная конфигурация плоскости, можно применить эту процедуру в этой плоскости, еще более уменьшая измерение на 1. Эта процедура может продолжаться до тех пор, пока не будет достигнуто измерение 0. Этот Каскад проекций и интерполяции можно назвать «последовательной Тетрахедрал интерполяцией».

*(б) интерполяция зазоров*

![Схема, в которой показана интерполяция зазоров.](images/transformcreation-image126.jpg)

**Рис. 4.** Интерполяция зазоров

Это сетка, накладываемая на куб, расположенный строго внутри положительного квадранта. Сам куб содержит сетку, и у каждой плоскости координат есть сетки, которые не обязательно являются совместимыми. «Зазор» между кубом и плоскостями координат имеет кросс-участок, который является «L-фигурой» и не податлива со стандартными методами. Тем не менее, с помощью появившегося метода можно легко добавить ячейки, охватывающие этот зазор. На рисунке 4 изображен один из этих элементов. Сетки на плоскостях координат поддерживают интерполяцию, которая предоставляет необходимые службы BCs для всех нижних граней ячейки, с одной оставшейся вершиной, BC которой обеспечивается в нижнем углу Куба.

## <a name="final-note-on-implementation"></a>Последнее примечание о реализации

В фактическом приложении «модульный куб», являющийся базовым значением алгоритма, извлекается из более крупного латтицес, а значения в вершинах могут требовать дорогостоящих вычислений. С другой стороны, также ясно, что для интерполяции тетрахедрал требуются только значения в вершинах тетрахедрон, которые являются подмножеством всех вершин Куба единиц измерения. Таким образом, более эффективно реализовать то, что можно назвать «отложенным вычислением». В программной реализации предыдущего алгоритма обычно используется подпрограмма, которая принимает куб единицы и значения на его вершинах в качестве входных данных. Отложенное вычисление означает, что вместо передачи значений в вершинам передается необходимая информация для оценки значений вершин, без фактического выполнения оценки. Внутри подпрограммы фактическое вычисление этих значений будет выполняться только для тех вершин, которые принадлежат к окружающему тетрахедрон, после того, как будет определено заключенный тетрахедрон.

## <a name="lookup-table-for-use-with-high-dynamic-range-virtual-rgb-source-devices"></a>Таблица подстановки для использования с динамическим диапазоном виртуальных RGB исходные устройства

Если преобразование создается с исходным устройством, которое моделируется как виртуальное устройство RGB, возможно, что исходные значения колорант могут быть отрицательными или больше Unity (1,0). В этом случае исходное устройство называется высоким динамическим диапазоном (HDR). В этом случае будет сделано особое внимание.

В случае преобразований HDR минимальное и максимальное значения для каждого канала колорант можно определить на основе границы цветового охвата устройства. Используя эти значения, можно выполнить простое масштабирование для каждого канала колорант, чтобы колорант значения, равные минимуму колорант, были преобразованы в 0,0, а колорант значения, равные максимальному значению колорант, будут преобразованы в 1,0. линейное масштабирование значений между 0,0 и 1,0.

### <a name="iccprofilefromwcsprofile"></a>иккпрофилефромвкспрофиле

Так как основная цель этой функции — поддержка версий Windows, предшествующих Vista, необходимо создать профили ICC версии 2,2, как указано в спецификации ICC ICC. 1:1998-09. В некоторых случаях (см. следующую таблицу: "базовое устройство для сопоставления класса ICC-профиля") можно создать матрицу или профиль ICC на основе TRC из профиля WCS. В других случаях профиль ICC состоит из Лутс. В следующей процедуре описывается создание АТОБ и Бтоа Лутс. Разумеется, профили ICC также имеют и другие поля. Некоторые данные могут быть получены из профиля WCS. Для других данных необходимо разработать интеллектуальные значения по умолчанию. Авторские права будут назначены корпорации Майкрософт; так как это технология Майкрософт, которая используется для создания Лутс.

Эта схема должна работать для всех типов моделей устройств, включая подключаемые модули. Если подключаемый модуль имеет связанную модель базовых устройств, можно определить тип базового устройства.

Сложная часть создания профиля ICC заключается в создании таблиц подстановки АТОБ и Бтоа. Эти таблицы сопоставлены между пространством устройства, например RGB или CMYK, и пространством подключения профиля (ПК), которое является вариантом ЦИЕЛАБ. Это по сути то же самое, что и процесс управления цветом, используемый при преобразовании, чтобы сопоставлять пространство устройства с местом на устройстве. Однако для выполнения преобразования необходимо иметь следующие сведения.

1) Условия просмотра ссылок для компьютеров.

2) Палитра эталонных компьютеров.

3) Модель устройства, преобразующая значения между компьютерами и колориметри.

Профиль WCS и связанная с ним Камера предоставляются в качестве параметров. Существует две модели базовых устройств, которые преобразуют между колориметри и кодировкой ПК. Причины, по которым вам нужны два, описаны ниже.

1) Можно получить условия просмотра ссылок для компьютеров из спецификации формата ICC. Сведения, предоставленные в спецификации формата ICC, достаточно для расчета всех данных, необходимых для инициализации Canvas, используемой CMS. Для обеспечения согласованности и гибкости эта информация хранится в цветном профиле WCS.

2) Профиль WCS также можно использовать для хранения образцов, определяющих эталонный охват компьютеров. В УПОМИНАЕМой системе управления цветом (CMS) предусмотрено два способа создания границ цветового охвата. Одним из них является выборка полного пространства на устройстве и использование модели устройства для создания значений измерений. Второй способ — использовать измеряемые образцы из профиля для создания границы эталонного цвета. Поскольку цветовой охват на компьютерах ICC слишком велик для создания полезного цветового охвата, первый метод является недопустимым. Но второй метод является гибким подходом на основе профиля. Чтобы переопределить цветовой охват эталонных компьютеров, можно изменить данные измерения в профиле устройства ПК.

3) Компьютеры ICC — это моделирование идеального устройства. Создавая модель компьютеров как реальное устройство, вы можете воспользоваться процессом управления цветом, используемым в смарт-CMM. Создание модели устройства из колориметри в кодировке ПК — это просто. Вы просто сопоставляете значения true и закодированные значения ПК. Поскольку интерфейс CMS для моделей устройств поддерживает только значения XYZ, также может потребоваться сопоставление между XYZ и LAB. Это хорошо известное преобразование. Эта модель описана в документе 2.2.02 "базовые модели устройств" в разделах 7,9 и 7,10.

Может потребоваться выполнить определенное сопоставление цветового охвата, если цветовой охват устройства больше, чем цветовой охват ПК. Для этой цели можно использовать базовые ГММС. Обратите внимание, что правильно созданный профиль ICC содержит таблицы уточняющих запросов для относительных, искусственного и насыщенных цветов, хотя они могут указывать на один и тот же LUT внутренне.

![Схема, на которой показано создание A T o B L T.](images/transformcreation-image128.png)

**Рис. 5.** Создание LUT АТОБ

Этот процесс показан на рис. 5. Сначала модель устройства инициализируется из данных в профиле DM. Затем создайте границу для палитры устройства, как показано ниже. Выборка данных из модели устройства выполняется с помощью модели устройства для получения данных с + +. Для создания данных с изображением на основе изображения используется камера. Данные внешнего вида используются для создания границы области охвата устройства.

Затем используйте данные из профиля измерения "эталонные компьютеры", чтобы создать границу для компьютеров.

Используйте только что созданные границы цветового охвата для инициализации ГММ. Затем используйте модель устройства, ГММ и модель устройства ПК для создания преобразования. Выполните выборку пространства устройства с помощью преобразования, чтобы создать LUT АТОБ.

![Схема, на которой показано создание A T o B L T с использованием выборки пространства P C S.](images/transformcreation-image130.png)

**Рис. 6.** Создание LUT Бтоа

На рис. 6 показано создание Бтоа LUT. Это практически идентично созданию АТОБ LUT с ролями исходного и целевого обмена. Кроме того, для создания LUT необходимо выполнить выборку полного спектра ПК.

Обратите внимание, что, поскольку камера (CIECAM02 в WCS) вовлечена в процесс, адаптация цветовой адаптации между белой точкой носителя и белой точкой ПК (которая задается ICC в D50) влияет на прозрачность.

## <a name="hdr-virtual-rgb-devices"></a>Виртуальные устройства RGB HDR

Необходимо учитывать особое внимание при создании профилей для виртуальных устройств RGB HDR. то есть устройства, для которых значения колорант могут быть меньше 0,0 или больше 1,0. В поколении АТОБ LUT создается больший набор из 1D входных Лутс. Значения колорант масштабируются и смещаются до диапазона 0. 1, используя минимальное и максимальное значения колорант в профиле WCS.

Поскольку пространство колорант для HDR-устройств, скорее всего, не будет полностью заполнено, в трехмерной LUT для тега также предоставляется специальная поддержка. Чтобы обрабатывать цвета в разреженном регионе, колорантс перекодированы, чтобы можно было достичь экстраполяции свыше 0,0 и 1,0. Используемый диапазон — 1.. + 4.

Из-за повторного масштабирования, применяемого для трехмерной LUT, создается набор из 1D выходного Лутс, который сопоставляет результат с диапазоном 0. 1.

## <a name="more-than-one-pcs"></a>Более одного ПК

ICC обнаружил, что один компьютер был недостаточно гибким для удовлетворения всех предполагаемых применений CMS. В версии 4 спецификации профиля ICC разъяснено, что на самом деле есть две кодировки ПК. Один используется для изображения с + +. другой используется для цели искусственного. (Для цели насыщенности не указаны компьютеры. Этот компонент не является неоднозначным.) На компьютере с + + установлена минимальная и максимальная освещенность, но значения чрома и оттенков задаются примерно ± 127. Эти ПК выглядят как прямоугольный Prism. Как упоминалось ранее, том ПК искусственного напоминает цветовой охват струйного принтера.

Два Пксса ICC также имеют две различные цифровые кодировки. На искусственного ПК нулевое значение представляет собой индикацию нуля. На компьютерах с + + нулевое значение соответствует минимальной освещенности ПК, что больше нуля. Эту проблему можно решить, настраивая другую модель устройства для каждой кодировки ПК.

## <a name="gamut-mapping"></a>Сопоставление палитры

Чтобы создать Лутс АТОБ в профиле ICC, необходимо соотнесение между охватом устройства и соответствующим пространством на компьютерах. Чтобы создать Лутс Бтоа, вы сопоставляете пространство ПК с областью охвата устройства. Сопоставление для АТОБ Лутс весьма похоже на то, что используется в CMS на основе измерения. Для искусственного ПК сопоставьте цветовой охват устройства правдоподобные с границей палитры искусственного ПК с помощью обрезки или сжатия для любых цветов, выходящих за пределы цветового охвата. Для того, чтобы отрезаться от экологичных целей, может возникнуть необходимость в обрезке, но значения чрома и оттенков будут помещаться в цветовой охват "темно-PCS".

Сопоставление для Бтоа Лутс немного отличается. Изображения с + + по-прежнему просты. Вы просто зарезаете значения для компьютеров в цветовой охват устройства. Но ICC требует, чтобы все возможные значения компьютеров сопоставлялись с определенными значениями устройств, а не просто в пределах эталонного спектра искусственного ПК. Поэтому необходимо убедиться, что ГММС может управлять исходными цветами, находящимися за пределами опорной гаммы. Это можно обработать, обрезать эти цвета с границей области охвата устройства.

## <a name="baseline-device-to-icc-profile-class-mapping"></a>Сопоставление класса базового устройства с классом ICC Profile



| Базовый тип устройства              | Класс профиля ICC       | Комментарий                                                                      |
|-----------------------------------|-------------------------|-----------------------------------------------------------------------------|
| Устройство для записи RGB                | Устройство ввода ("скнр")   | ПК — ЦИЕЛАБ. AToB0Tag — это устройство для компьютеров с относительным намерением. |
| CRT, ЖК-монитор                  | Отображение устройства ("мнтр") | ПК — ЦИЕКСИЗ. См. следующие сведения о преобразовании модели.                      |
| Проектор с RGB                     | Цветовое пространство ("Спак")    | ПК — ЦИЕЛАБ.                                                              |
| Принтер RGB и CMYK              | Выходное устройство ("ПРТР")  | ПК — ЦИЕЛАБ.                                                              |
| Виртуальное устройство RGB (без использования HDR) | Отображение устройства ("мнтр") | ПК — ЦИЕКСИЗ.                                                              |
| Виртуальное устройство RGB (регистр HDR)     | Цветовое пространство ("Спак")    | ПК — ЦИЕЛАБ.                                                              |



 

Преобразование профилей монитора не включает сборку Лутс, а состоит из создания модели матрицы или TRC. Модель, используемая в ICC, немного отличается от модели, используемой в модели CRT или ЖК-моделирования в том, что термин «черная коррекция» отсутствует.  В частности:

Модель WCS: ![Показывает модель W C S.](images/transformcreation-image132.png)

Модель ICC: ![Показывает модель I C C.](images/transformcreation-image134.png)

Преобразование из модели WCS в модель ICC выполняется следующим образом.

Определите новые кривые:

![Показывает матрицу для определения новых кривых.](images/transformcreation-image136.png)

Это не оттенки воспроизведения, так как они не сопоставлены 1 с 1. Это достигается нормализацией. Ниже приведены окончательные определения модели ICC.

![Показывает окончательные определения модели I в c.](images/transformcreation-image138.png)

![Показывает последнюю матрицу для модели I C C.](images/transformcreation-image140.png)

Для виртуальных устройств RGB, отличных от HDR, вы также создаете экранный профиль ICC для эффективного использования пространства. В этом случае тристимулус матрицу *M ICC* можно получить непосредственно из первичных элементов профиля WCS без приведенного выше преобразования модели. Один последний, но важно, обратите внимание, что эта тристимулус матрица должна быть адаптирована к D50, чтобы соответствовать спецификации ICC компьютеров. Иными словами, записи в каждой строке матрицы, которая должна быть закодирована в профиле ICC, должны суммироваться соответственно в 96,42, 100 и 82,49. В текущей реализации адаптация цветовой палитры выполняется CAT02, что также является преобразованием «адаптация», используемой в CAM02.

## <a name="black-preservation-and-black-generation"></a>Черная сохранность и создание черной версии

Реализация черной сохранности связана вместе с поколением черного канала на устройствах, поддерживающих черный канал. Для этого сведения о каждом исходном цвете собираются, чтобы разрешить модели устройств, поддерживающие черный канал, чтобы определить, как лучше установить черный канал на выходе. Несмотря на то, что для преобразований цветов, преобразуемых с одного устройства черного канала в другое, используется черная подмножество, для всех преобразований, в которых используется устройство назначения с черным каналом, применяется черная генерация.

Сведения о черном канале записываются в структуру данных с именем [**блаккинформатион**](/previous-versions/windows/desktop/api/WcsPlugIn/ns-wcsplugin-_blackinformation). Структура **блаккинформатион** содержит логическое значение, указывающее, содержит ли цвет только черный колорант, и числовое значения, обозначающее степень «черной», называемую черным весом. Для устройств источника, поддерживающих черный канал, черный вес — это процентная доля черного колорант в исходном цвете. Для устройств источника, которые не содержат черного канала, черный вес вычисляются с помощью других колорантс и значения Appearance. Значение "чистота цвета" выдается путем вычисления разницы между максимальным колорант значением и минимальным значением колорант, деленным на максимальное значение колорант. Значение "относительная освещенность" выдается путем различия между освещенностью цвета и минимальным освещением для целевого устройства, деленного на разность между минимальным и максимальным освещением для целевого устройства. Если исходное устройство является аддитивным (монитор или проектор), то черный вес определяется как 1,0 минус цветовой чистоты, умноженной на относительное освещение. Например, если исходное устройство является монитором RGB, максимальное значение и минимальное значение R, G и B для каждого цвета вычисляются, а черный вес определяется формулой:

BW = (1,0 – (Max (R, G, B) – min (R, G, B))/max (R, G, B)) \* относительное освещение

Если исходное устройство поддерживает вычитание разметка, например принтер КМИ, то отдельные колорантс должны быть дополнены (вычитаются из 1,0) перед использованием в предыдущей формуле. Таким образом, для принтера КМИ R = 1,0 – C, G = 1,0 – M и B = 1,0 – Y.

Черная информация для каждого цвета, обрабатываемого преобразователем цветов, определяется во время преобразования цвета. Только черная информация определяется только в том случае, если задано значение «черная сохранение». Черный вес всегда определяется, если модель целевого устройства поддерживает черный колорант. Черная информация передается в модель целевого устройства с помощью метода [**колориметриктодевицеколорсвисблакк**](/previous-versions/windows/desktop/api/WcsPlugIn/nf-wcsplugin-idevicemodelplugin-colorimetrictodevicecolorswithblack) , который использует итоговый LUT.

Обратите внимание, что из-за оптимизации преобразования цветов описанный выше процесс выполняется только во время создания оптимизированного преобразования LUT, а не во время выполнения метода Транслатеколорс.

## <a name="optimization-for-transforms-with-more-than-three-source-channels"></a>Оптимизация для преобразований с более чем тремя каналами источника

Размер оптимизированного преобразования определяется несколькими факторами: количеством цветовых каналов на исходном устройстве, количеством шагов в таблице для каждого исходного цветового канала и количеством цветовых каналов на выходном устройстве. Для определения размера таблицы преобразования используется следующая формула:

Размер = число шагов на один <sub>Источник канала \ устройство (число \ из \ каналы \ в \ исходное \ устройство)</sub> x число каналов на выходном устройстве

Как видите, размер таблицы растет экспоненциально в зависимости от количества каналов на исходном устройстве. Многие исходные устройства поддерживают три цветовых канала, например красный, зеленый и синий. Однако если исходное устройство поддерживает четыре канала, например CMYK, размер таблицы и время, необходимое для создания таблицы, увеличиваются с учетом количества шагов. В CMS на основе измерения, где преобразования создаются "на лету", это время может быть неприемлемым.

Чтобы сократить время, необходимое для создания таблицы преобразования цветов, можно воспользоваться преимуществами двух фактов. Во-первых, хотя исходное устройство может поддерживать более трех цветовых каналов, в промежуточном аппаратном пространстве (CIECAM02 ja <sub>c</sub> b <sub>c</sub> ) имеется только три цветовых канала. Во-вторых, наиболее трудоемкая часть обработки не является моделированием устройств (преобразование из цветовых координат устройства в значения тристимулус), но сопоставление палитры. Используя эти факты, можно создать предварительную таблицу преобразования цветов, которая преобразует цвета в аппаратно-независимом цветовом пространстве с помощью шагов сопоставления палитры и, наконец, через цветовую модель устройства вывода. Конструкция этой таблицы состоит из трех измерений. Затем мы создаем измерение четыре итоговые таблицы преобразования цветов путем преобразования сочетаний исходных цветов в промежуточное, независимое от устройства пространство, а затем, используя предварительную таблицу преобразования цветов, завершите преобразование в цветовое пространство выходного устройства. Таким образом, сокращение от вычислений (число шагов в таблице подстановки) при сопоставлении цветовой гаммы " <sub>число \ из \ каналов</sub> " вычисляется до количества шагов в промежуточной таблице, вычисленных при сопоставлении палитры ₃. Несмотря на то, что в таблице (таблица уточняющих запросов) с <sub>числом вычислений \ of-Channels</sub> для моделирования устройств и трехмерных уточняющих запросов необходимо выполнить ряд действий, это по-прежнему выполняется гораздо быстрее, чем в исходном вычислении.

Предыдущий процесс будет хорошо работать при условии, что нет необходимости передавать информацию между моделью исходного устройства и любым другим компонентом преобразования цветов. Однако если устройство вывода и исходное устройство поддерживают черный колорант, а исходный черный колорант используется при определении выходного черного колорант, то процесс не сможет правильно передать исходные сведения о черном потоке. Альтернативным процессом является создание предварительной таблицы преобразования цветов, которая преобразует цвета в аппаратно-независимом цветовом пространстве с помощью шагов сопоставления палитры. Затем создайте таблицу Dimension с четырьмя таблицами преобразования цветов, выполнив следующие действия. а) преобразование сочетаний цветов источника в промежуточное независимое от устройства пространство б) выполнение шагов сопоставления палитры путем интерполяции в предварительной таблице цветов вместо применения фактических процессов сопоставления цветовой гаммы и c) Используйте результирующие значения из шагов сопоставления палитры и любые исходные данные черного канала, чтобы вычислить выходное устройство колорантс с помощью модели выходного устройства. Этот процесс также можно использовать при передаче данных между моделями исходного и выходного устройств, даже если отсутствует черный канал. Например, если два модуля реализуются с помощью подключаемой архитектуры, обеспечивающей обмен данными между модулями.

Описанные выше два процесса можно использовать для эффективного увеличения времени, необходимого для создания таблицы преобразования объемом четырех цветов.

### <a name="checkgamut"></a>чеккгамут

ICM вызывает Креатетрансформ и **креатемултипрофилетрансформ** принимает слова значений флагов, одно из которых включает \_ проверку цветовой гаммы \_ . Если этот флаг установлен, в параметре set необходимо создать преобразование по-другому. Начальные шаги одинаковы: исходный и целевой видеорегистраторов должны быть инициализированы, а затем должны быть инициализированы исходные и целевые дескрипторы границ цветового охвата. Независимо от указанного намерения необходимо использовать Чеккгамут ГММ. Чеккгамут ГММ должен быть инициализирован с использованием исходных и целевых моделей устройств и дескрипторов границ цветовой гаммы. Однако преобразование должно создать усеченное преобразование, включающее в себя модель исходного устройства, исходную камера, все промежуточные ГММС и Чеккгамут ГММ. Это гарантирует, что выходные данные Дельта J, Дельта C и Дельта h, выводимые модулями CMM Чеккгамут, становятся окончательными результирующими значениями.

Значение Чеккгамут ясно, если в преобразовании имеется только два профиля устройства. Если имеется более двух профилей устройств и более двух ГММС, то Чеккгамут сообщает о том, были ли цвета, преобразованные с помощью первой модели устройства, а также все ГММ, кроме последней, попадают в охват целевого устройства.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Основные понятия управления цветом](basic-color-management-concepts.md)
</dt> <dt>

[Схемы и алгоритмы цветовой системы Windows](windows-color-system-schemas-and-algorithms.md)
</dt> </dl>

 

 




