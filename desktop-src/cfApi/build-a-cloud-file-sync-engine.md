---
description: Узнайте, как создать модуль синхронизации облачных файлов, использующий файлы заполнителей с помощью API облачных файлов.
title: Создание облачного модуля синхронизации, поддерживающего файлы заполнителей
ms.topic: article
ms.date: 11/12/2020
ms.openlocfilehash: 4f1330285d0c8ef0359639f2be84162f8bc2ef3b
ms.sourcegitcommit: 3bdf30edb314e0fcd17dc4ddbc70e4ec7d3596e6
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/10/2021
ms.locfileid: "104557629"
---
# <a name="build-a-cloud-sync-engine-that-supports-placeholder-files"></a>Создание облачного модуля синхронизации, поддерживающего файлы заполнителей

Модуль синхронизации — это служба, которая синхронизирует файлы, обычно между удаленным узлом и локальным клиентом. Модули синхронизации в Windows часто представляют эти файлы пользователю с помощью файловой системы Windows и проводника. До Windows 10, версия 1709, поддержка модуля синхронизации в Windows была ограничена нерегламентированными поверхностями, такими как панель навигации проводника, область задач Windows и (для дополнительных технических приложений) драйверы фильтра файловой системы.

В Windows 10 версии 1709 (также именуемой обновлением для авторов обновлений) появился *API облачных файлов*. Этот API — это новая платформа, которая является формализацией поддержки модулей синхронизации. API облачных файлов обеспечивает поддержку модулей синхронизации таким образом, что предоставляет разработчикам и конечным пользователям множество новых преимуществ.

API облачных файлов содержит следующие собственные API-интерфейсы Win32 и среда выполнения Windows (WinRT):

* [API облачного фильтра](cloud-filter-reference.md). Этот собственный API Win32 обеспечивает функциональность на границе между режимом пользователя и файловой системой. Этот API обрабатывает создание и управление заполнителями файлов и каталогов.
* [Пространство имен Windows. Storage. Provider](/uwp/api/windows.storage.provider). Этот API-интерфейс WinRT позволяет приложениям настроить поставщик облачного хранилища и зарегистрировать корень синхронизации в операционной системе.

> [!NOTE]
> В настоящее время API облачных файлов не поддерживает реализацию облачных модулей синхронизации в приложениях UWP. Модули синхронизации облака должны быть реализованы в приложениях для настольных систем.

## <a name="supported-features"></a>Поддерживаемые функции

API облачных файлов предоставляет следующие возможности для создания облачных модулей синхронизации.

### <a name="placeholder-files"></a>Файлы заполнителей

* Модули синхронизации могут создавать файлы заполнителей, которые используют только 1 КБ хранилища для заголовка FileSystem и автоматически расконсервации в полные файлы при нормальных условиях использования. Файлы заполнителей представляются как обычные файлы для приложений и конечных пользователей в оболочке Windows.
* Файлы заполнителей вертикально интегрированы из ядра Windows в оболочку Windows, а совместимость приложений с файлами заполнителей обычно не вызывает проблем. Независимо от того, используете ли вы API-интерфейсы файловой системы, командную строку или приложение UWP для доступа к файлу заполнителя, файл будет расконсервации без дополнительных изменений кода и приложение сможет использовать этот файл в обычном режиме.
* Файлы могут находиться в трех состояниях:
  * **Файл заполнителя**: пустое представление файла и доступно только в том случае, если доступна служба синхронизации.
  * **Полный файл**. файл был сохранен неявным образом и может быть восстановлен системой, если требуется пространство.
  * **Закрепленный полный файл**: файл сохранен явным образом пользователем через проводник и гарантированно доступен в автономном режиме.

На следующем рисунке показано, как заполнители, полные и закрепленные полные состояния файлов отображаются в проводнике.

  ![Пример трех состояний файла в проводнике](images/cloud-file-states-file-explorer.png)

### <a name="standardized-sync-root-registration"></a>Стандартизированная регистрация в корне синхронизации

* Регистрация корня синхронизации является простой и стандартизированной. Это включает создание фирменного узла в области навигации проводника, как показано на следующем снимке экрана. Корни могут создаваться либо как отдельные записи верхнего уровня, либо как дочерние элементы родительской группировки.

  ![Пример корневой записи синхронизации в проводнике](images/register-sync-root-file-explorer.png)

### <a name="shell-integration"></a>Интеграция оболочки

* Значки состояния:
  * API облачных файлов предоставляет стандартизированные, автоматические значки состояния расконсервации, отображаемые в проводнике и на рабочем столе Windows.
  * Помимо стандартных значков состояния Windows, используемых для состояния расконсервации, можно предоставить настраиваемые значки состояния для дополнительных свойств, зависящих от службы.
  * Заменяет расширения оболочки наложения значков прежних версий.
* Индикатор хода выполнения:
  * Открытие файла заполнителя, который занимает более нескольких секунд, расконсервации будет показывать ход выполнения расконсервации. Ход выполнения отображается в нескольких расположениях в зависимости от контекста:
    * В диалоговом окне механизма копирования.
    * Встроенный ход выполнения отображается рядом с файлом в проводнике.
    * Если файл не открывается в инструкции пользователя, отображается всплывающее уведомление для информирования пользователя и предоставления способа управления непредвиденными действиями расконсервации.
* Эскизы и метаданные:
  * Файлы заполнителей могут иметь обширные эскизы, предоставляемые службой, и расширенные метаданные файлов, чтобы предоставить пользователю возможность беспрепятственно работать с обозревателем файлов.
* Панель навигации обозревателя файлов:
  * Регистрация корня синхронизации с помощью API облачных файлов приводит к тому, что корневой каталог синхронизации (со значком и настраиваемым именем) отображается в области навигации проводника.
* Контекстные меню проводника:
  * Регистрация корня синхронизации с помощью API облачных файлов автоматически предоставляет несколько команд (пункты меню) в контекстном меню проводника, позволяющие пользователю управлять состоянием расконсервации файла.
  * Дополнительные команды можно добавить в этот раздел контекстного меню с помощью интерфейсов API, совместимых с мостом рабочих столов.
* Пользовательское управление файлом расконсервации:
  * Пользователи всегда управляют файлами расконсервации, даже если они не сохраняются явным образом пользователем. Интерактивное всплывающее уведомление отображается в фоновом расконсервации для оповещения пользователя и предоставления параметров. На следующем рисунке показано всплывающее уведомление для файла с заархивированием.
    ![Пример интерактивного уведомления, отображаемого для фонового расконсервации файла](images/file-hydration-interactive-toast.png)
  * Если пользователь блокирует восстановление файлов с помощью интерактивного всплывающего уведомления, он может разблокировать приложение на странице " **Автоматическая загрузка файлов** " в окне " **Параметры**".
    ![Снимок экрана: параметр "Автоматическая загрузка файлов"](images/allow-automatic-file-downloads-setting.png)
* Подключение операций механизма копирования (поддерживается в предварительной версии Windows 10 Insider Build 19624 и более поздних версий):
  * Поставщики облачного хранилища могут зарегистрировать обработчик копии оболочки для отслеживания операций с файлами в корне синхронизации.
  * Поставщик регистрирует свой обработчик копии, установив значение реестра **копихук** в разделе реестра корневого раздела синхронизации равным CLSID своего объекта ЛОКАЛЬНОГО сервера COM. Этот объект локального сервера реализует интерфейс [исторажепровидеркопихук](../shell/nn-shobjidl-istorageprovidercopyhook.md) .

### <a name="desktop-bridge"></a>Мост для классических приложений

* Модули синхронизации, использующие API облачных файлов, предназначены для использования [настольного моста](/windows/uwp/porting/desktop-to-uwp-root) в качестве требования к реализации.

## <a name="cloud-mirror-sample"></a>Пример зеркального облака

В [примере зеркальной базы облака](https://github.com/Microsoft/Windows-classic-samples/tree/master/Samples/CloudMirror) показано, как создать решение, использующее API облачных файлов. Он не предназначен для использования в качестве рабочего кода. В нем отсутствует надежная обработка ошибок, и она написана так, чтобы быть понятной как можно более понятную. Он называется зеркалом облака, так как он просто зеркально отображает локальную папку на локальном диске. Укажите серверную папку, которая должна представлять облачный файловый сервер, и клиентскую папку, которая будет указывать корневой путь синхронизации. Узел верхнего уровня появится в области навигации проводника с именем **тестсторажепровидердисплайнаме**, а этот узел сопоставляется с указанной клиентской папкой.

Когда дело доходит до синхронизации, это все, что необходимо реализовать в полностью разработанном поставщике синхронизации облачных файлов:

* Если корневой файл синхронизации является просто заполнителем, служба несет ответственность за копирование содержимого файла для расконсервации. Это реализовано в примере.
* Если корневой файл синхронизации является полным файлом и содержимое файла в облачной службе изменяется, служба несет ответственность за уведомление клиента об изменении локальной синхронизации, и клиент локальной синхронизации должен выполнять слияние в соответствии с собственными характеристиками. Это не реализовано в примере.
* Если корневой файл синхронизации представляет собой полный файл и содержимое файла в корневом пути синхронизации (локальный клиент), локальный клиент синхронизации должен уведомлять облачную службу и выполнять слияние в соответствии с собственными характеристиками. Уведомление об изменении локального файла реализовано в примере, но не выполняет никаких действий.

### <a name="use-the-sample"></a>Использование примера

1. Создайте две папки на локальном жестком диске. Один из них будет действовать как сервер, а другой — как клиент.
2. Добавьте файлы в папку сервера. Убедитесь, что папка клиента пуста.
3. Откройте пример зеркала Cloud в Visual Studio. Задайте проект **клаудмиррорпаккаже** в качестве запускаемого проекта, а затем выполните сборку и запуск примера. При появлении запроса в примере введите два пути к серверу и клиентским папкам. После этого отобразится окно консоли с диагностической информацией.
4. Откройте проводник и убедитесь, что вы видите узел **тестсторажепровидердисплайнаме** и заполнители для всех файлов, скопированных в папку сервера. Чтобы имитировать приложение, которое пытается открыть файлы без использования средства выбора, скопируйте несколько образов в папку сервера. Дважды щелкните одну из них в корневой папке синхронизации и подтвердите, что она будет восстановлена. Затем откройте приложение "фотографии". Приложение будет предварительно загружать смежные файлы в фоновом режиме, что позволит пользователю не столкнуться с задержками при просмотре других изображений. Вы можете наблюдать за фоновым восстановлением с помощью всплывающих уведомлений или проводника.
5. Щелкните правой кнопкой мыши файл в проводнике, чтобы открыть контекстное меню, и убедитесь, что вы видите пункт меню **тесткомманд** . При щелчке этого пункта меню отображается окно сообщения.
6. Чтобы прерывать выборку, установите фокус на выходные данные консоли и нажмите клавиши **CTRL + C**. При этом будет выполнена очистка корневой регистрации синхронизации, чтобы поставщик был удален. Если пример завершается сбоем, то возможно, что корень синхронизации останется зарегистрированным. Это приведет к повторному запуску проводника при каждом щелчке любого элемента и появлении запроса на фиктивные расположения клиента и сервера. В этом случае удалите пример приложения **клаудмиррорпаккаже** с компьютера.

### <a name="sample-architecture"></a>Пример архитектуры

Пример намеренно прост. Он использует статические классы, чтобы сделать его ненужным для передачи указателей на экземпляры. Ниже приведены основные классы в примере.

* **Факеклаудпровидер**: Этот класс верхнего уровня управляет следующими рабочими классами:
  * **Клаудпровидеррегистрар**: регистрирует корневую информацию синхронизации с оболочкой Windows.
  * **Заполнители**: создает файлы заполнителей в корневом пути синхронизации.
  * **Шеллсервицес**: конструирует поставщиков оболочки Windows для контекстного меню, эскизов и других служб.
  * **Клаудпровидерсинкрутватчер**: создает экземпляр директориватчер для отслеживания изменений в корневом пути синхронизации и выполнения действий над изменениями.
  * **Филекопиервиспрогресс**: копирует файлы из серверной папки в папку клиента медленно в фрагментах, чтобы имитировать их загрузку с реального облачного сервера. Предоставляет индикатор хода выполнения, чтобы всплывающие окна и пользовательский интерфейс проводника могли показать пользователю что-нибудь информативное.

Помимо приведенных выше классов, пример также предоставляет несколько вспомогательных классов для запроса пользователю папок и некоторых служебных программ. **Тестексплореркоммандхандлер**, **кустомстатепровидер**, **сумбнаилпровидер** и **Урисаурце** — это все примеры поставщиков служб оболочки.

## <a name="cloud-files-api-architecture"></a>Архитектура API облачных файлов

Ядром стека хранилища в API облачных файлов является драйвер минифильтра файловой системы, именуемый cldflt.sys. Этот драйвер выступает в качестве прокси-сервера между приложениями пользователя и модулем синхронизации. Модуль синхронизации знает, как загружать и загружать данные по запросу, в то время как обязанностью cldflt.sys работать с оболочкой для представления файлов, как если бы облачные данные были локально доступны.

Cldflt.sys в настоящее время поддерживает только тома NTFS, так как он зависит от некоторых функций, уникальных для NTFS.

В системе имеется много драйверов минифильтра файловой системы, которые могут быть активны на заданном томе одновременно. Драйверы, которые наиболее интересны для API облачных файлов, — это фильтры файловой системы антивирусной программы.

Драйверы минифильтра файловой системы управляются и поддерживаются специальным компонентом режима ядра, который называется диспетчером фильтров. Помимо многих других обязанностей Диспетчер фильтров упрощает нефильтрованное взаимодействие между фильтрами и компонентами пользовательского режима с помощью конструкции, известной как порт сообщений фильтра.

## <a name="hydration-policies"></a>Политики расконсервации

Windows поддерживает ряд [основных политик расконсервации](/windows/desktop/api/cfapi/ne-cfapi-cf_hydration_policy_primary) и дополнительных модификаторов [политики расконсервации](/windows/desktop/api/cfapi/ne-cfapi-cf_hydration_policy_modifier) . Ниже приведен порядок, в котором политики PRIMARY расконсервации:

  **Всегда полностью > полный > прогрессивный > частичный**

Приложения и модули синхронизации могут определять предпочтительную основную политику расконсервации. Если не указано, то политика расконсервации по умолчанию прогрессивна для приложений и модулей синхронизации.

Политика расконсервации для облачного файла определяется во время открытия файла по следующей формуле:

  ```File hydration policy = max(app hydration policy, provider hydration policy)```

Например, предположим, что пользователь пытается открыть PDF-файл, хранящийся на облачном диске Fabrikam, с помощью средства просмотра PDF-файлов Contoso, которое не указывает предпочитаемую политику расконсервации. Поэтому политика расконсервации приложений по умолчанию является прогрессивной расконсервации в данном случае. Однако, поскольку облачный диск Fabrikam является полным модулем синхронизации расконсервации, окончательная политика расконсервации в файле становится полной расконсервации, что приведет к полному восстановлению файла при первом доступе. Тот же результат происходит в случаях, когда модуль синхронизации поддерживает прогрессивный расконсервации, но предпочтение приложения полностью расконсервации.

Обратите внимание, что политику расконсервации файла нельзя изменить после открытия файла.

## <a name="compatibility-with-applications-that-use-reparse-points"></a>Совместимость с приложениями, использующими точки повторного анализа

API облачных файлов реализует систему-заполнитель с помощью [точек повторного анализа](/windows/desktop/FileIO/reparse-points). Распространенным заблуждением точек повторного анализа является то, что они совпадают с символической ссылкой. Это ошибочное понятие иногда отражено в реализациях приложений, и в результате многие существующие приложения сталкиваются с ошибками при обнаружении любой точки повторного анализа.

Чтобы устранить эту проблемы совместимости, API облачных файлов всегда скрывает свои точки повторной обработки из всех приложений, за исключением модулей синхронизации и процессов, основной образ которых находится в папке **% systemroot%**. Приложения, которые понимают точки повторного анализа, правильно позволяют платформе предоставлять точки повторного анализа API облачных файлов с помощью [ртлсетпроцессплацехолдеркомпатибилитимоде](/windows-hardware/drivers/ddi/content/ntifs/nf-ntifs-rtlsetprocessplaceholdercompatibilitymode) или [ртлсетсреадпроцессплацехолдеркомпатибилитимоде](/windows-hardware/drivers/ddi/content/ntifs/nf-ntifs-rtlsetthreadplaceholdercompatibilitymode).