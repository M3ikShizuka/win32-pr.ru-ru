---
title: О вводе с клавиатуры
description: В этом разделе рассматривается ввод с клавиатуры.
ms.assetid: de34727e-e8c7-481d-982d-0e42a02704db
keywords:
- Ввод данных пользователем, ввод с клавиатуры
- запись вводимых пользователем данных, ввод с клавиатуры
- ввод с клавиатуры
- фокус клавиатуры
- сообщения о нажатии клавиш
- Символьные сообщения
- Системные нажатия клавиш
- несистемные нажатия клавиш
- сообщения несистемных символов
- Мертвые ключи
- сообщения недоставленных символов
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0de85794901be3fef37156bde29520039f85702b
ms.sourcegitcommit: b3839bea8d55c981d53cb8802d666bf49093b428
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/16/2021
ms.locfileid: "114373201"
---
# <a name="about-keyboard-input"></a>О вводе с клавиатуры

Приложения должны принимать ввод пользователя с клавиатуры и с помощью мыши. Приложение получает ввод с клавиатуры в форме сообщений, размещенных в своих окнах.

В этом разделе описываются следующие темы:

-   [Модель ввода с клавиатуры](#keyboard-input-model)
-   [Фокус клавиатуры и активация](#keyboard-focus-and-activation)
-   [Сообщения о нажатии клавиш](#keystroke-messages)
    -   [Системные и несистемные нажатия клавиш](#system-and-nonsystem-keystrokes)
    -   [Описание кодов виртуальных клавиш](#virtual-key-codes-described)
    -   [Флаги сообщения о нажатии клавиш](#keystroke-message-flags)
-   [Символьные сообщения](#character-messages)
    -   [Сообщения несистемных символов](#nonsystem-character-messages)
    -   [Сообщения недоставленных символов](#dead-character-messages)
-   [Состояние ключа](#key-status)
-   [Нажатие клавиш и переводы символов](#keystroke-and-character-translations)
-   [Поддержка горячего ключа](#hot-key-support)
-   [Клавиши клавиатуры для обзора и других функций](#keyboard-keys-for-browsing-and-other-functions)
-   [Имитация входных данных](#simulating-input)
-   [Языки, языковые стандарты и раскладки клавиатуры](#languages-locales-and-keyboard-layouts)

## <a name="keyboard-input-model"></a>Модель ввода с клавиатуры

Система обеспечивает аппаратную поддержку клавиатуры для приложений, устанавливая драйвер устройства клавиатуры, подходящий для текущей клавиатуры. Система обеспечивает независимую от языка клавиатурную поддержку с помощью языковой структуры клавиатуры, выбранной пользователем или приложением. Драйвер устройства клавиатуры получает коды сканирования с клавиатуры, которые отправляются в раскладку клавиатуры, где они преобразуются в сообщения и публикуются в соответствующих окнах приложения.

Каждому ключу на клавиатуре присваивается уникальное значение, которое называется *кодом сканирования*, зависящим от устройства идентификатором для ключа на клавиатуре. Клавиатура формирует два кода сканирования, когда пользователь вводит ключ — один, когда пользователь нажимает клавишу, а другой — когда пользователь отпускает ключ.

Драйвер устройства клавиатуры интерпретирует код сканирования и преобразует его (сопоставляется) в *код виртуального ключа*, аппаратно-независимое значение, определяемое системой и определяющее назначение ключа. После перевода кода просмотра раскладка клавиатуры создает сообщение, содержащее код сканирования, код виртуального ключа и другие сведения о нажатии клавиши, а затем помещает сообщение в очередь системных сообщений. Система удаляет сообщение из очереди системных сообщений и отправляет его в очередь сообщений соответствующего потока. В конечном итоге, цикл обработки сообщений потока удаляет сообщение и передает его в соответствующую процедуру окна при обработке. На следующем рисунке показана модель ввода с клавиатуры.

![модель обработки ввода с клавиатуры](images/csinp-01.png)

## <a name="keyboard-focus-and-activation"></a>Фокус клавиатуры и активация

Система отправляет сообщения клавиатуры в очередь сообщений основного потока, создавшего окно с фокусом клавиатуры. *Фокус клавиатуры* является временным свойством окна. Система совместно использует клавиатуру для всех окон на экране, перебирая фокус клавиатуры в направлении пользователя из одного окна в другое. Окно с фокусом клавиатуры получает (из очереди сообщений создавшего его потока) все сообщения клавиатуры до тех пор, пока фокус не изменится на другое окно.

Поток может вызвать функцию [**Focus**](/windows/win32/api/winuser/nf-winuser-getfocus) , чтобы определить, какая из ее окон (если есть) в данный момент имеет фокус клавиатуры. Поток может передать фокус клавиатуры одному из окон, вызвав функцию [**SetFocus**](/windows/win32/api/winuser/nf-winuser-setfocus) . Когда фокус клавиатуры меняется с одного окна на другое, система отправляет сообщение [**WM \_ киллфокус**](wm-killfocus.md) в окно, которое потеряло фокус, а затем отправляет сообщение [**WM \_ SETFOCUS**](wm-setfocus.md) в окно, получивший фокус.

Понятие фокуса клавиатуры относится к активному окну. *Активное окно* — это окно верхнего уровня, с которым пользователь работает в данный момент. Окно с фокусом клавиатуры является либо активным окном, либо дочерним окном активного окна. Чтобы помочь пользователю определить активное окно, система размещает его в верхней части Z-порядка и выделяет его заголовок (если он имеет одно значение) и границу.

Пользователь может активировать окно верхнего уровня, щелкнув его, выбрав его с помощью сочетания клавиш ALT + TAB или ALT + ESC, или выбрав его из список задач. Поток может активировать окно верхнего уровня с помощью функции [**сетактивевиндов**](/windows/win32/api/winuser/nf-winuser-setactivewindow) . Он может определить, активно ли созданное окно верхнего уровня с помощью функции [**жетактивевиндов**](/windows/win32/api/winuser/nf-winuser-getactivewindow) .

Когда одно окно деактивируется, а другая активируется, система отправляет сообщение [**\_ активации WM**](wm-activate.md) . Младшее слово параметра *wParam* равно нулю, если окно деактивируется, и ненулевое значение, если оно активировано. Когда процедура окна по умолчанию получает сообщение об **\_ активации WM** , она устанавливает фокус клавиатуры на активное окно.

Для блокировки событий ввода с клавиатуры и мыши при достижении приложения используйте [**блоккинпут**](/windows/win32/api/winuser/nf-winuser-blockinput). Обратите внимание, что функция **блоккинпут** не будет влиять на асинхронную таблицу ввода состояния клавиатуры. Это означает, что вызов функции [**SendInput**](/windows/win32/api/winuser/nf-winuser-sendinput) во время блокировки входных данных приведет к изменению таблицы с асинхронным входным состоянием клавиатуры.

## <a name="keystroke-messages"></a>Сообщения о нажатии клавиш

Нажатие клавиши приводит к тому, что сообщение [**WM \_ KeyDown**](wm-keydown.md) или [**WM \_ сискэйдовн**](wm-syskeydown.md) помещается в очередь сообщений потока, подключенную к окну с фокусом клавиатуры. Освобождение ключа приводит к тому, что сообщение [**WM \_ KEYUP**](wm-keyup.md) или [**WM \_ сискэйуп**](wm-syskeyup.md) помещается в очередь.

Сообщения о ключах и ключах обычно встречаются парами, но если пользователь удерживает ключ достаточно долго для запуска функции автоматического повтора клавиатуры, система создает несколько сообщений [**WM \_ KeyDown**](wm-keydown.md) или [**WM \_ сискэйдовн**](wm-syskeydown.md) в строке. Затем он создает одно сообщение [**WM \_ KEYUP**](wm-keyup.md) или [**WM \_ сискэйуп**](wm-syskeyup.md) , когда пользователь отпускает ключ.

В этом разделе описываются следующие темы:

-   [Системные и несистемные нажатия клавиш](#system-and-nonsystem-keystrokes)
-   [Описание кодов виртуальных клавиш](#virtual-key-codes-described)
-   [Флаги сообщения о нажатии клавиш](#keystroke-message-flags)

### <a name="system-and-nonsystem-keystrokes"></a>Системные и несистемные нажатия клавиш

Система делает различие между нажатиями клавиш и несистемными нажатиями. Системные нажатия клавиш создают системные сообщения о нажатии клавиш, [**WM \_ Сискэйдовн**](wm-syskeydown.md) и [**WM \_ сискэйуп**](wm-syskeyup.md). Несистемные нажатия клавиш создают несистемные сообщения о нажатии клавиш, [**WM \_ KeyDown**](wm-keydown.md) и [**WM \_ KEYUP**](wm-keyup.md).

Если процедура окна должна обработать системное сообщение о нажатии, убедитесь, что после обработки сообщения процедура передает ее функции [**дефвиндовпрок**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) . В противном случае все системные операции, включающие клавишу ALT, будут отключены всякий раз, когда окно имеет фокус клавиатуры. То есть пользователь не сможет получить доступ к меню или системному окну окна или использовать сочетание клавиш ALT + ESC или ALT + TAB для активации другого окна.

Системные сообщения о нажатии клавиш предназначены главным образом для использования системой, а не приложением. Система использует их для предоставления встроенного интерфейса клавиатуры меню и позволяет пользователю управлять тем, какое окно активно. Системные сообщения о нажатии клавиш генерируются, когда пользователь вводит ключ в сочетании с клавишей ALT, или когда пользователь вводит и не имеет фокуса клавиатуры (например, если активное приложение является сведенным). В этом случае сообщения помещаются в очередь сообщений, присоединенную к активному окну.

Несистемные сообщения о нажатии клавиш предназначены для использования в окнах приложений; Функция [**дефвиндовпрок**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) не выполняет никаких действий с ними. Процедура окна может отменить любые несистемные сообщения о нажатии клавиш, которые не требуются.

### <a name="virtual-key-codes-described"></a>Описанные Virtual-Key коды

Параметр **wParam** сообщения с нажатием клавиши содержит код виртуального ключа нажатого или освобожденного ключа. Оконная процедура обрабатывает или игнорирует сообщение о нажатии клавиши в зависимости от значения в коде виртуального ключа.

Типичная процедура окна обрабатывает только небольшое подмножество получаемых сообщений о нажатии клавиш и игнорирует остальные. Например, процедура окна может обрабатывать только WM-сообщения с нажатием клавиши [**\_ KeyDown**](wm-keydown.md) и только те, которые содержат коды виртуальных клавиш для клавиш перемещения курсора, клавиши Shift (также называемые клавишами управления) и функциональные клавиши. Типичная процедура окна не обрабатывает сообщения нажатия клавиш из символьных клавиш. Вместо этого он использует функцию [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) для преобразования сообщения в символьные сообщения. Дополнительные сведения о **TranslateMessage** и символьных сообщениях см. в разделе [Message characters](#character-messages).

### <a name="keystroke-message-flags"></a>Флаги сообщения о нажатии клавиш

Параметр **lParam** сообщения с нажатием клавиши содержит дополнительные сведения о нажатии клавиши, создавшей сообщение. Эти сведения включают число повторов, код сканирования, флаг расширенного ключа, код контекста, предыдущий флаг состояния и флаг состояния перехода. На следующем рисунке показаны расположения этих флагов и значений в параметре **lParam** .

![Расположение флагов и значений в параметре LPARAM сообщения о нажатии клавиши](images/csinp-02.png)

Приложение может использовать следующие значения для управления флагами нажатия клавиш.



| Значение            | Описание                                                                       |
|------------------|-----------------------------------------------------------------------------------|
| **КФ \_ алтдовн**  | Управляет флагом клавиши ALT, который указывает, нажата ли клавиша ALT.     |
| **КФ \_ длгмоде**  | Управляет флагом режима диалогового окна, указывающим, является ли диалоговое окно активным. |
| **КФ \_ Расширенная** | Управляет флагом расширенного ключа.                                                |
| **КФ \_ менумоде** | Управляет флагом режима меню, указывающим, является ли меню активным.         |
| **\_Повтор КФ**   | Управляет предыдущим флагом состояния ключа.                                          |
| **КФ \_ up**       | Управляет флагом состояния перехода.                                            |

Пример кода:

```cpp
case WM_KEYDOWN:
case WM_KEYUP:
case WM_SYSKEYDOWN:
case WM_SYSKEYUP:
{
    WORD vkCode = LOWORD(wParam);                                       // virtual-key code

    BYTE scanCode = LOBYTE(HIWORD(lParam));                             // scan code
    BOOL scanCodeE0 = (HIWORD(lParam) & KF_EXTENDED) == KF_EXTENDED;    // extended-key flag, 1 if scancode has 0xE0 prefix

    BOOL upFlag = (HIWORD(lParam) & KF_UP) == KF_UP;                    // transition-state flag, 1 on keyup
    BOOL repeatFlag = (HIWORD(lParam) & KF_REPEAT) == KF_REPEAT;        // previous key-state flag, 1 on autorepeat
    WORD repeatCount = LOWORD(lParam);                                  // repeat count, > 0 if several keydown messages was combined into one message

    BOOL altDownFlag = (HIWORD(lParam) & KF_ALTDOWN) == KF_ALTDOWN;     // ALT key was pressed

    BOOL dlgModeFlag = (HIWORD(lParam) & KF_DLGMODE) == KF_DLGMODE;     // dialog box is active
    BOOL menuModeFlag = (HIWORD(lParam) & KF_MENUMODE) == KF_MENUMODE;  // menu is active
    
    // ...
}
break;
```

### <a name="repeat-count"></a>Число повторов

Можно проверить число повторов, чтобы определить, представляет ли сообщение с нажатием клавиши более одного нажатия. Система увеличивает число, когда клавиатура создает [**WM \_ KeyDown**](wm-keydown.md) или [**WM \_ сискэйдовн**](wm-syskeydown.md) сообщения быстрее, чем приложение может их обработать. Это часто происходит, когда пользователь удерживает ключ достаточно долго для запуска функции автоматического повтора клавиатуры. Вместо того чтобы заполнять очередь системных сообщений с помощью полученных сообщений о ключах, система объединяет сообщения в одно ключевое сообщение и увеличивает число повторов. Освобождение ключа не может запустить функцию автоматической повторной отправки, поэтому число повторов для сообщений [**WM \_ KEYUP**](wm-keyup.md) и [**WM \_ сискэйуп**](wm-syskeyup.md) всегда равно 1.

### <a name="scan-code"></a>Код сканирования

Код сканирования — это значение, которое генерирует аппаратное обеспечение клавиатуры при нажатии пользователем клавиши. Это зависящее от устройства значение, идентифицирующее нажатую клавишу, а не символ, представленный ключом. Приложение обычно игнорирует коды проверки. Вместо этого он использует ненезависимые от устройства коды виртуальных клавиш для интерпретации сообщений о нажатии клавиш.

### <a name="extended-key-flag"></a>Флаг Extended-Key

Флаг расширенного ключа указывает, поступило ли сообщение о нажатии клавиши из одного из дополнительных клавиш на расширенной клавиатуре. Расширенные ключи состоят из клавиш ALT и CTRL в правой части клавиатуры; клавиши INS, DEL, ДОМАШНяя, КОНЕЧная страница вверх, PAGE DOWN и стрелка в кластерах слева от цифровой клавиатуры; Клавиша NUM LOCK; Клавиша BREAK (CTRL + ПАУЗа); Клавиша PRINT СКРН; и клавиши деления (/) и ENTER на цифровой клавиатуре. Флаг расширенного ключа устанавливается, если ключ является расширенным ключом.

Если указано, код сканирования должен предшествовать байту префикса со значением 0xE0 (224).

### <a name="context-code"></a>Код контекста

Код контекста указывает, была ли нажата клавиша ALT при создании сообщения с нажатием клавиши. Код равен 1, если клавиша ALT была нажата, и 0, если он был включен.

### <a name="previous-key-state-flag"></a>Предыдущий Key-State флаг

Предыдущий флаг состояния ключа указывает, был ли ключ, создавший сообщение нажатия клавиши, выше или выше. Значение равно 1, если ключ был ранее отключен, и 0, если ключ был выше. Этот флаг можно использовать для указания сообщений о нажатии клавиш, созданных функцией автоматической повтора клавиатуры. Этот флаг имеет значение 1 для сообщений о нажатии клавиш WM [**\_ KeyDown**](wm-keydown.md) и [**WM \_ сискэйдовн**](wm-syskeydown.md) , созданных функцией автоматического повтора. Всегда имеет значение 1 для сообщений [**WM \_ KEYUP**](wm-keyup.md) и [**WM \_ сискэйуп**](wm-syskeyup.md) .

### <a name="transition-state-flag"></a>Флаг Transition-State

Флаг перехода в состояние указывает на нажатие клавиши или освобождение ключа, создавшего сообщение о нажатии клавиши. Этот флаг всегда имеет значение 0 для сообщений [**WM \_ KeyDown**](wm-keydown.md) и [**WM \_ сискэйдовн**](wm-syskeydown.md) . всегда имеет значение 1 для сообщений [**WM \_ KEYUP**](wm-keyup.md) и [**WM \_ сискэйуп**](wm-syskeyup.md) .

## <a name="character-messages"></a>Символьные сообщения

Сообщения о нажатии клавиш предоставляют много информации о нажатиях клавиш, но не содержат кодов символов для нажатия клавиш. Чтобы получить коды символов, приложение должно включить функцию [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) в цикл обработки сообщений потока. **TranslateMessage** передает сообщение [**WM \_ KeyDown**](wm-keydown.md) или [**WM \_ сискэйдовн**](wm-syskeydown.md) в раскладку клавиатуры. Макет проверяет код виртуального ключа сообщения и, если он соответствует ключу символа, предоставляет эквивалент кода символа (принимая во внимание состояние клавиш SHIFT и CAPS LOCK). Затем он создает символьное сообщение, содержащее код символа и размещает сообщение в верхней части очереди сообщений. Следующая итерация цикла обработки сообщений удаляет символьное сообщение из очереди и отправляет сообщение в соответствующую процедуру окна.

В этом разделе описываются следующие темы:

-   [Сообщения несистемных символов](#nonsystem-character-messages)
-   [Сообщения недоставленных символов](#dead-character-messages)

### <a name="nonsystem-character-messages"></a>Сообщения несистемных символов

Процедура окна может принимать следующие символьные сообщения: [**WM \_ char**](wm-char.md), [**WM \_ деадчар**](wm-deadchar.md), [**WM \_ сисчар**](/windows/desktop/menurc/wm-syschar), [**WM \_ сисдеадчар**](wm-sysdeadchar.md)и [**WM \_ уничар**](wm-unichar.md). Функция [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) создает сообщение **WM \_ char** или **WM \_ деадчар** при обработке сообщения [**WM \_ KeyDown**](wm-keydown.md) . Аналогичным образом создается сообщение **WM \_ Сисчар** или **WM \_ сисдеадчар** при обработке сообщения [**WM \_ сискэйдовн**](wm-syskeydown.md) .

Приложение, обрабатывающее ввод с клавиатуры, обычно игнорирует все сообщения, кроме [**WM \_ char**](wm-char.md) и [**WM \_ уничар**](wm-unichar.md) , передавая все остальные сообщения в функцию [**дефвиндовпрок**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) . Обратите внимание, что **WM \_ char** использует 16-разрядный формат преобразования Юникода (UTF), тогда как **WM \_ уничар** использует UTF-32. Система использует сообщения [**WM \_ Сисчар**](/windows/desktop/menurc/wm-syschar) и [**WM \_ сисдеадчар**](wm-sysdeadchar.md) для реализации мнемоник меню.

Параметр **wParam** всех символьных сообщений содержит код символа нажатой клавиши. Значение кода символа зависит от класса окна окна, получающего сообщение. Если версия функции [**registerClass**](/windows/desktop/api/winuser/nf-winuser-registerclassa) , используемая в Юникоде, использовалась для регистрации класса Window, система предоставляет символы Юникода всем окнам этого класса. В противном случае система предоставляет коды символов ASCII. Дополнительные сведения см. в разделе [Юникод и](/windows/desktop/Intl/unicode-and-character-sets)кодировки.

Содержимое параметра **lParam** символьного сообщения идентично содержимому параметра **lParam** сообщения о нажатии клавиши, которое было преобразовано для создания символьного сообщения. Дополнительные сведения см. в разделе [Флаги сообщения о нажатии клавиш](#keystroke-message-flags).

### <a name="dead-character-messages"></a>Сообщения Dead-Character

Некоторые неанглийские клавиатуры содержат ключи символов, которые не должны создавать символы самостоятельно. Вместо этого они используются для добавления диакритических знаков к символу, созданному последующим нажатием клавиши. Эти ключи называются *неработающими ключами*. Клавиша с циркумфлексом на немецкой клавиатуре является примером неработающего ключа. Чтобы ввести символ, состоящий из символа "o" с циркумфлексом, немецкий пользователь должен ввести ключ с циркумфлексом, а затем клавишу "o". Окно с фокусом клавиатуры получит следующую последовательность сообщений:

1.  [**WM \_ KeyDown**](wm-keydown.md)
2.  [**WM \_ деадчар**](wm-deadchar.md)
3.  [**WM \_ KEYUP**](wm-keyup.md)
4.  [**WM \_ KeyDown**](wm-keydown.md)
5.  [**WM \_ char**](wm-char.md)
6.  [**WM \_ KEYUP**](wm-keyup.md)

[**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) создает сообщение [**WM \_ Деадчар**](wm-deadchar.md) при обработке сообщения [**WM \_ KeyDown**](wm-keydown.md) из неработающего ключа. Хотя параметр *wParam* сообщения **WM \_ деадчар** содержит код символа диакритических знаков для неработающего ключа, приложение обычно игнорирует сообщение. Вместо этого он обрабатывает сообщение [**WM \_ char**](wm-char.md) , созданное последующим нажатием клавиши. Параметр *wParam* сообщения **WM \_ char** содержит код символа буквы с диакритическим знаком. Если последующее нажатие клавиш создает символ, который не может быть объединен с диакритическим знаком, система создает два сообщения **\_ типа WM char** . Параметр *wParam* первого элемента содержит код символа диакритических знаков; параметр *wParam* второго класса содержит код символа последующего символа.

Функция [**TranslateMessage**](/windows/desktop/api/winuser/nf-winuser-translatemessage) создает сообщение [**WM \_ Сисдеадчар**](wm-sysdeadchar.md) при обработке сообщения [**WM \_ сискэйдовн**](wm-syskeydown.md) от системного неработающего ключа (неработающего ключа, который нажат в сочетании с клавишей Alt). Как правило, приложение игнорирует сообщение **WM \_ сисдеадчар** .

## <a name="key-status"></a>Состояние ключа

При обработке сообщения клавиатуры приложению может потребоваться определить состояние другого ключа, Кроме того, который создал текущее сообщение. Например, приложение для обработки текста, которое позволяет пользователю нажать SHIFT + END, чтобы выбрать блок текста, должен проверять состояние клавиши SHIFT при получении сообщения о нажатии клавиши из конечного ключа. Приложение может использовать функцию [**жеткэйстате**](/windows/win32/api/winuser/nf-winuser-getkeystate) для определения состояния виртуального ключа на момент создания текущего сообщения; она может использовать функцию [**жетасинккэйстате**](/windows/win32/api/winuser/nf-winuser-getasynckeystate) для получения текущего состояния виртуального ключа.

Раскладка клавиатуры содержит список имен. Имя ключа, создающего один символ, совпадает с символом, созданным ключом. Имя несимвольного ключа, такого как TAB и ENTER, хранится в виде символьной строки. Приложение может получить имя любого ключа из драйвера устройства, вызвав функцию [**жеткэйнаметекст**](/windows/win32/api/winuser/nf-winuser-getkeynametexta) .

## <a name="keystroke-and-character-translations"></a>Нажатие клавиш и переводы символов

Система включает несколько специальных функций, которые преобразуют коды сканирования, коды символов и коды виртуальных клавиш, предоставляемые различными сообщениями о нажатии клавиш. К этим функциям относятся [**мапвиртуалкэй**](/windows/win32/api/winuser/nf-winuser-mapvirtualkeya), [**ToAscii**](/windows/win32/api/winuser/nf-winuser-toascii), [**тауникоде**](/windows/win32/api/winuser/nf-winuser-tounicode)и [**вккэйскан**](/windows/win32/api/winuser/nf-winuser-vkkeyscana).

Кроме того, Microsoft Rich Editing 3,0 поддерживает [редактор IME для хекстауникоде](/windows/desktop/Intl/hextounicode-ime), позволяющий пользователю выполнять преобразование между шестнадцатеричными и символами Юникода с помощью горячих клавиш. Это означает, что при включении Microsoft Rich Edit 3,0 в приложение приложение будет наследовать функции IME Хекстауникоде.

## <a name="hot-key-support"></a>Поддержка Hot-Key

*Горячая клавиша* — это сочетание клавиш, которое создает сообщение с помощью [**\_ горячих клавиш WM**](wm-hotkey.md) , сообщение, которое система размещает в верхней части очереди сообщений потока, минуя все существующие сообщения в очереди. Приложения используют Горячие ключи для получения высокого приоритетного ввода с клавиатуры пользователя. Например, путем определения сочетания клавиш, состоящего из сочетания клавиш CTRL + C, приложение может позволить пользователю отменить длительную операцию.

Чтобы определить горячую клавишу, приложение вызывает функцию [**RegisterHotKey**](/windows/win32/api/winuser/nf-winuser-registerhotkey) , задавая сочетание клавиш, которое создает сообщение с [**помощью \_ горячих клавиш WM**](wm-hotkey.md) , маркер окна для получения сообщения и идентификатор сочетания клавиш. Когда пользователь нажимает клавишу горячего ключа, в очередь сообщений потока, создавшего окно, помещается сообщение с **\_ сочетанием клавиш WM** . Параметр *wParam* сообщения содержит идентификатор сочетания клавиш. Приложение может определить несколько горячих ключей для потока, но каждый горячий ключ в потоке должен иметь уникальный идентификатор. Перед завершением работы приложения следует использовать функцию [**унрегистерхоткэй**](/windows/win32/api/winuser/nf-winuser-unregisterhotkey) для уничтожения сочетания клавиш.

Приложения могут использовать сочетание клавиш, чтобы облегчить пользователю выбор сочетания клавиш. Элементы управления горячими ключами обычно используются для определения горячего ключа, который активирует окно. они не используют функции [**RegisterHotKey**](/windows/win32/api/winuser/nf-winuser-registerhotkey) и [**унрегистерхоткэй**](/windows/win32/api/winuser/nf-winuser-unregisterhotkey) . Вместо этого приложение, использующее горячее управление ключами, обычно отправляет сообщение [**WM \_ сесоткэй**](wm-sethotkey.md) для установки сочетания клавиш. Всякий раз, когда пользователь нажимает клавишу горячего ключа, система отправляет сообщение [**WM \_ сискомманд**](/windows/desktop/menurc/wm-syscommand) с указанием \_ сочетания клавиш SC. Дополнительные сведения об элементах управления горячими ключами см. в разделе «Использование элементов управления горячих клавиш» раздела [элементы управления горячими ключами](../controls/hot-key-controls.md).

## <a name="keyboard-keys-for-browsing-and-other-functions"></a>Клавиши клавиатуры для обзора и других функций

Windows обеспечивает поддержку клавиатур с специальными ключами для функций браузера, функций мультимедиа, запуска приложений и управления питанием. [**WM \_ аппкомманд**](wm-appcommand.md) поддерживает дополнительные клавиши клавиатуры. Кроме того, функция [**шеллпрок**](/previous-versions/windows/desktop/legacy/ms644991(v=vs.85)) изменяется для поддержки дополнительных клавиш клавиатуры.

Маловероятно, что дочернее окно в приложении компонента сможет напрямую реализовать команды для этих дополнительных клавиш клавиатуры. Поэтому при нажатии одной из этих клавиш [**дефвиндовпрок**](/windows/desktop/api/winuser/nf-winuser-defwindowproca) отправит сообщение [**WM \_ аппкомманд**](wm-appcommand.md) в окно. **Дефвиндовпрок** также получит всплывающее сообщение **WM \_ аппкомманд** в родительском окне. Это похоже на способ вызова контекстных меню с помощью правой кнопки мыши, которая заключается в том, что **дефвиндовпрок** отправляет сообщение [**WM \_ CONTEXTMENU**](/windows/desktop/menurc/wm-contextmenu) при щелчке правой кнопкой мыши и передает его родительскому элементу. Кроме того, если **дефвиндовпрок** получает сообщение **WM \_ аппкомманд** для окна верхнего уровня, оно будет вызывать обработчик оболочки с кодом **хшелл \_ аппкомманд**.

Windows также поддерживает Microsoft IntelliMouse Explorer, который является мышью с пятью кнопками. Две дополнительные кнопки поддерживают навигацию в браузере вперед и назад. Дополнительные сведения см. в разделе [ксбуттонс](about-mouse-input.md).

## <a name="simulating-input"></a>Имитация входных данных

Для имитации непрерывной последовательности событий пользовательского ввода используйте функцию [**SendInput**](/windows/win32/api/winuser/nf-winuser-sendinput) . Функция принимает три параметра. Первый параметр, *Цинпутс*, указывает количество событий ввода, которые будут смоделированы. Второй параметр, *ргинпутс*, представляет собой массив [**входных**](/windows/win32/api/winuser/ns-winuser-input) структур, каждый из которых описывает тип входного события и дополнительные сведения об этом событии. Последний параметр, *кбсизе*, принимает размер **входной** структуры в байтах.

Функция [**SendInput**](/windows/win32/api/winuser/nf-winuser-sendinput) работает путем встраивания последовательности имитации входных событий в входной поток устройства. Этот результат аналогичен многократному вызову [**\_ события кэйбд**](/windows/win32/api/winuser/nf-winuser-keybd_event) или функции [**мыши \_**](/windows/win32/api/winuser/nf-winuser-mouse_event) за исключением того, что система гарантирует, что никакие другие события ввода не интермингле с имитацией событий. По завершении вызова возвращаемое значение указывает количество успешно воспроизведенных входных событий. Если это значение равно нулю, входные данные были заблокированы.

Функция [**SendInput**](/windows/win32/api/winuser/nf-winuser-sendinput) не сбрасывает текущее состояние клавиатуры. Таким образом, если при вызове этой функции пользователь нажал клавиши, они могут повлиять на события, создаваемые этой функцией. Если вы беспокоитесь о возможных помехах, проверьте состояние клавиатуры с помощью функции [**жетасинккэйстате**](/windows/win32/api/winuser/nf-winuser-getasynckeystate) и при необходимости внесите необходимые исправления.

## <a name="languages-locales-and-keyboard-layouts"></a>Языки, языковые стандарты и раскладки клавиатуры

*Язык* — это естественный язык, например английский, французский и японский. *Подязык* — это вариант естественного языка, который говорят в определенном географическом регионе, например на английском языке, произнесенном в великобритании и США. Приложения используют значения, называемые [идентификаторами языка](/windows/desktop/Intl/language-identifiers), для уникальной идентификации языков и подязыков.

Приложения обычно используют *национальные* настройки для установки языка, на котором обрабатываются входные и выходные данные. Например, Настройка языкового стандарта для клавиатуры влияет на значения символов, формируемые клавиатурой. Установка языкового стандарта для дисплея или принтера влияет на отображаемые или печатаемые глифы. Приложения устанавливают языковой стандарт для клавиатуры, загружая и используя раскладки клавиатуры. Они устанавливают языковой стандарт для дисплея или принтера, выбирая шрифт, который поддерживает указанный языковой стандарт.

Раскладка клавиатуры не только определяет физическое положение клавиш на клавиатуре, но и определяет значения символов, создаваемые при нажатии клавиш. Каждый макет определяет текущий язык ввода и определяет, какие символьные значения должны быть созданы с помощью ключей и сочетаний клавиш.

Каждая раскладка клавиатуры имеет соответствующий маркер, который определяет макет и язык. Младшим словом маркера является идентификатор языка. Высокое значение — это обработчик устройства, который указывает физический макет или равен нулю, что указывает на физический макет по умолчанию. Пользователь может связать любой язык ввода с физическим макетом. Например, пользователь с английской диктовкой, который иногда работает на французском языке, может установить французский язык ввода для клавиатуры, не меняя при этом физический макет клавиатуры. Это означает, что пользователь может ввести текст на французском языке с помощью привычного английского макета.

Как правило, приложения не должны работать непосредственно с языками ввода. Вместо этого пользователь настраивает сочетания языка и макета, а затем переключается между ними. Когда пользователь щелкает текст, помеченный другим языком, приложение вызывает функцию [**активатекэйбоардлайаут**](/windows/win32/api/winuser/nf-winuser-activatekeyboardlayout) для активации макета пользователя по умолчанию для этого языка. Если пользователь редактирует текст на языке, который отсутствует в активном списке, приложение может вызвать функцию [**лоадкэйбоардлайаут**](/windows/win32/api/winuser/nf-winuser-loadkeyboardlayouta) с языком, чтобы получить макет на основе этого языка.

Функция [**активатекэйбоардлайаут**](/windows/win32/api/winuser/nf-winuser-activatekeyboardlayout) задает язык ввода для текущей задачи. Параметр *HKL* может быть либо маркером раскладки клавиатуры, либо идентификатором языка с нулевым значением. Маркеры раскладки клавиатуры можно получить из функции [**лоадкэйбоардлайаут**](/windows/win32/api/winuser/nf-winuser-loadkeyboardlayouta) или [**жеткэйбоардлайаутлист**](/windows/win32/api/winuser/nf-winuser-getkeyboardlayoutlist) . Для выбора следующей или предыдущей клавиатуры можно также использовать значения **HKL \_ Next** и HKL, предшествующие **\_ предыдущему** .

Функция [**жеткэйбоардлайаутнаме**](/windows/win32/api/winuser/nf-winuser-getkeyboardlayoutnamea) извлекает имя активной раскладки клавиатуры для вызывающего потока. Если приложение создает активный макет с помощью функции [**лоадкэйбоардлайаут**](/windows/win32/api/winuser/nf-winuser-loadkeyboardlayouta) , **жеткэйбоардлайаутнаме** извлекает ту же строку, которая использовалась для создания макета. В противном случае строка является основным идентификатором языка, соответствующим языковому стандарту активного макета. Это означает, что функция не обязательно различает различные макеты с одним и тем же основным языком, поэтому не может возвращать определенные сведения о языке ввода. Однако функцию [**жеткэйбоардлайаут**](/windows/win32/api/winuser/nf-winuser-getkeyboardlayout) можно использовать для определения языка ввода.

Функция [**лоадкэйбоардлайаут**](/windows/win32/api/winuser/nf-winuser-loadkeyboardlayouta) загружает раскладку клавиатуры и делает макет доступным для пользователя. Приложения могут сделать макет немедленно активным для текущего потока с помощью значения **\_ активации КЛФ** . Приложение может использовать значение **\_ переупорядочения КЛФ** для изменения порядка макетов без указания значения **КЛФ \_ Activate** . При загрузке раскладок клавиатуры в приложениях всегда следует использовать значение **\_ подстановки \_ КЛФ** .

Для многоязычной поддержки функция [**лоадкэйбоардлайаут**](/windows/win32/api/winuser/nf-winuser-loadkeyboardlayouta) предоставляет флаги **КЛФ \_ реплацеланг** и **КЛФ \_ нотеллшелл** . Флаг **КЛФ \_ реплацеланг** направляет функцию на замену существующей раскладки клавиатуры без изменения языка. Попытка заменить существующий макет, используя тот же идентификатор языка, но без указания **КЛФ \_ реплацеланг** , является ошибкой. Флаг **КЛФ \_ нотеллшелл** предотвращает уведомление функции от оболочки при добавлении или замене раскладки клавиатуры. Это полезно для приложений, которые добавляют несколько макетов в последовательный ряд вызовов. Этот флаг следует использовать во всех вызовах, кроме последнего.

Функция [**унлоадкэйбоардлайаут**](/windows/win32/api/winuser/nf-winuser-unloadkeyboardlayout) ограничена тем, что не может выгружать системный язык ввода по умолчанию. Это гарантирует, что пользователь всегда будет иметь один макет, доступный для ввода текста, используя тот же набор символов, который используется оболочкой и файловой системой.

 

 
