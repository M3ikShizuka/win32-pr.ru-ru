---
description: Программирование DirectX с помощью COM.
title: Программирование DirectX с помощью COM
ms.topic: article
ms.date: 01/29/2019
ms.openlocfilehash: 660f030e56d0b84325f7b90a9e2cc8e3864587660dd452611f41c78241220f54
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119600204"
---
# <a name="programming-directx-with-com"></a>Программирование DirectX с помощью COM

Модель COM — объектно-ориентированная модель программирования, используемая несколькими технологиями, включая основную часть поверхности API DirectX. По этой причине вы (как разработчик DirectX) неизбежно используете COM при программировании DirectX.

> [!NOTE]
> В разделе Использование [COM-компонентов с + +/WinRT](/windows/uwp/cpp-and-winrt-apis/consume-com) показано, как использовать API-интерфейсы DirectX (и любой интерфейс API COM) с помощью [c++/WinRT](/windows/uwp/cpp-and-winrt-apis/). Это далеко не самая удобная и рекомендуемая для использования технология.

Кроме того, можно использовать необработанный COM, и именно этот раздел посвящен. Вам потребуются основные сведения о принципах и методиках программирования, участвующих в использовании COM-интерфейсов API. Хотя у COM есть репутация для сложной и сложной модели, программирование COM, необходимое большинству приложений DirectX, — это просто. Это связано с тем, что вы используете COM-объекты, предоставляемые DirectX. Вам не нужно создавать собственные COM-объекты, которые, как правило, возникают в сложности.

## <a name="com-component-overview"></a>Общие сведения о компоненте COM

COM-объект — это, по сути, инкапсулированный компонент функций, который может использоваться приложениями для выполнения одной или нескольких задач. Для развертывания один или несколько компонентов COM упаковываются в двоичный файл, называемый COM-сервером. чаще, чем DLL.

Традиционная библиотека DLL экспортирует бесплатные функции. Сервер COM может выполнять те же действия. Но COM-компоненты внутри COM-сервера предоставляют интерфейсы COM и методы членов, принадлежащие этим интерфейсам. Приложение создает экземпляры COM-компонентов, извлекает из них интерфейсы и вызывает методы для этих интерфейсов, чтобы воспользоваться преимуществами функций, реализованных в COM-компонентах.

На практике это похоже на вызов методов в обычном объекте C++. Но есть некоторые различия.

- COM-объект обеспечивает более строгое инкапсуляцию, чем объект C++. Вы не можете просто создать объект, а затем вызвать любой открытый метод. Вместо этого открытые методы COM-компонента группируются в один или несколько COM-интерфейсов. Чтобы вызвать метод, необходимо создать объект и получить из объекта интерфейс, реализующий метод. Интерфейс обычно реализует связанный набор методов, которые предоставляют доступ к определенной функции объекта. Например, интерфейс [**ID3D12Device**](/windows/desktop/api/d3d12/nn-d3d12-id3d12device) представляет виртуальный графический адаптер и содержит методы, позволяющие создавать ресурсы, например и многие другие связанные с адаптером задачи.
- Объект COM не создается таким же образом, как и объект C++. Существует несколько способов создания COM-объекта, но все они содержат методы, относящиеся к COM. API DirectX включает множество вспомогательных функций и методов, упрощающих создание большинства COM-объектов DirectX.
- Для управления временем существования COM-объекта необходимо использовать методы, относящиеся к COM.
- COM-сервер (как правило, DLL) не нужно загружать явным образом. Кроме того, не нужно ссылаться на статическую библиотеку, чтобы использовать COM-компонент. Каждый компонент COM имеет уникальный зарегистрированный идентификатор (глобальный уникальный идентификатор или GUID), который используется приложением для идентификации COM-объекта. Приложение определяет компонент, и среда выполнения COM автоматически загружает правильную DLL-сервер COM.
- COM — это двоичная спецификация. Объекты COM могут быть написаны и доступны на различных языках. Вам не нужно ничего знать о исходном коде объекта. например, Visual Basic приложения обычно используют COM-объекты, написанные на C++.

## <a name="component-object-and-interface"></a>Компонент, объект и интерфейс

Важно понимать различие между компонентами, объектами и интерфейсами. В случайном использовании может слышаться компонент или объект, на который ссылается имя основного интерфейса. Однако условия не взаимозаменяемы. Компонент может реализовывать любое количество интерфейсов; объект является экземпляром компонента. Например, хотя все компоненты должны реализовывать [**интерфейс IUnknown**](/windows/desktop/api/unknwn/nn-unknwn-iunknown), они обычно реализуют по крайней мере один дополнительный интерфейс и могут реализовывать множество.

Чтобы использовать определенный метод интерфейса, необходимо не только создать экземпляр объекта, но и получить от него нужный интерфейс.

Кроме того, один интерфейс может реализовывать несколько компонентов. Интерфейс — это группа методов, которые выполняют логически связанный набор операций. В определении интерфейса указывается только синтаксис методов и их общие функциональные возможности. Любой COM-компонент, который должен поддерживать определенный набор операций, может сделать это путем реализации подходящего интерфейса. Некоторые интерфейсы являются очень специализированными и реализуются только одним компонентом. другие полезны в различных обстоятельствах и реализуются многими компонентами.

Если компонент реализует интерфейс, он должен поддерживать каждый метод в определении интерфейса. Иными словами, необходимо иметь возможность вызывать любой метод и быть уверенным, что он существует. Однако сведения о реализации конкретного метода могут отличаться от одного компонента к другому. Например, различные компоненты могут использовать разные алгоритмы для получения окончательного результата. Также нет никакой гарантии, что метод будет поддерживаться нетривиальным образом. Иногда компонент реализует часто используемый интерфейс, но он должен поддерживать только подмножество методов. Вы по-прежнему сможете успешно вызывать оставшиеся методы, но они возвращают [**HRESULT**](#hresult-values) (стандартный тип com, представляющий код результата), содержащий значение **E_NOTIMPL**. Чтобы увидеть, как интерфейс реализуется каким-либо конкретным компонентом, обратитесь к его документации.

В стандарте COM необходимо, чтобы определение интерфейса не изменялось после его публикации. Автор не может, например, добавить новый метод в существующий интерфейс. Вместо этого автор должен создать новый интерфейс. Хотя не существует ограничений на то, какие методы должны быть в этом интерфейсе, обычно используется интерфейс следующего поколения, включающий все методы старого интерфейса, а также все новые методы.

Интерфейс должен иметь несколько поколений. Как правило, все поколения выполняют по сути одну и ту же общую задачу, но они различаются в конкретных случаях. Часто COM-компонент реализует каждое текущее и прежнее поколение журнала преобразований определенного интерфейса. Это позволяет старым приложениям продолжать использовать более старые интерфейсы объектов, тогда как новые приложения могут использовать преимущества новых интерфейсов. Как правило, неспусковая группа интерфейсов имеет одно и то же имя, а также целое число, указывающее на поколение. Например, если исходный интерфейс назывался **IMyInterface** (что подразумевает поколение 1), то следующие два поколения будут называться **IMyInterface2** и **IMyInterface3**. В случае с интерфейсами DirectX последовательные поколения обычно именуются по номеру версии DirectX.

## <a name="guids"></a>Идентификаторы GUID

Идентификаторы GUID являются ключевой частью модели программирования COM. Как правило, идентификатор GUID представляет собой 128-разрядную структуру. Однако идентификаторы GUID создаются таким образом, чтобы гарантировать, что два идентификатора GUID не совпадают. Модель COM широко использует GUID для двух основных целей.

- Для уникальной идентификации конкретного COM-компонента. Идентификатор GUID, назначенный для идентификации COM-компонента, называется идентификатором класса (CLSID), а при необходимости создания экземпляра связанного COM-компонента используется CLSID.
- Для уникальной идентификации конкретного COM-интерфейса. Идентификатор GUID, назначенный для идентификации COM-интерфейса, называется идентификатором интерфейса (IID) и используется IID при запросе определенного интерфейса из экземпляра компонента (объекта). IID интерфейса будет одинаковым, независимо от того, какой компонент реализует интерфейс.

Для удобства документация DirectX обычно ссылается на компоненты и интерфейсы по описательным именам (например, **ID3D12Device**), а не по идентификаторам GUID. В контексте документации DirectX неоднозначность отсутствует. Технически возможно, что сторонним разработчикам нужно создать интерфейс с описательным именем **ID3D12Device** (для правильной работы он должен иметь другой идентификатор IID). Тем не менее, в интересах ясности не рекомендуется.

Таким образом, единственным однозначным способом обращения к конкретному объекту или интерфейсу является его идентификатор GUID.

Хотя идентификатор GUID является структурой, идентификатор GUID часто выражается в эквивалентной строковой форме. Общий формат строкового формата GUID состоит из 32 шестнадцатеричных цифр в формате 8-4-4-4-12. То есть {XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}, где каждый символ x соответствует шестнадцатеричной цифре. Например, строка идентификатора IID для интерфейса **ID3D12Device** имеет вид {189819F1-1DB6-4B57-BE54-1821339B85F7}.

Поскольку фактический идентификатор GUID несколько неловкий для использования и легкого ввода в заблуждение, обычно также предоставляется эквивалентное имя. В коде можно использовать это имя вместо фактической структуры при вызове функций, например при передаче аргумента для `riid` параметра в [**D3D12CreateDevice**](/windows/desktop/api/d3d12/nf-d3d12-d3d12createdevice). Особое соглашение об именовании заключается в начале IID_ или CLSID_ описательного имени интерфейса или объекта соответственно. Например, имя IID интерфейса **ID3D12Device** — IID_ID3D12Device.

> [!NOTE]
> Приложения DirectX должны быть связаны с ``dxguid.lib`` и, ``uuid.lib`` чтобы предоставить определения для различных идентификаторов GUID интерфейса и класса. Visual C++ и другие компиляторы поддерживают расширение языка оператора **__uuidof** , но также поддерживается явная компоновка в стиле C с этими библиотеками ссылок и полностью Переносимая.

## <a name="hresult-values"></a>Значения HRESULT

Большинство методов COM возвращают 32-разрядное целое число с именем **HRESULT**. В большинстве методов значение HRESULT по сути представляет собой структуру, которая содержит два основных фрагмента информации.
- Завершился ли метод успешно или неудачно.
- Более подробные сведения о результате операции, выполняемой методом.

Некоторые методы возвращают значение **HRESULT** из стандартного набора, определенного в `Winerror.h` . Однако метод может возвращать пользовательское значение **HRESULT** с более специализированной информацией. Эти значения обычно задокументированы на странице справки по методу.

Список значений **HRESULT** , найденных на странице справочника по методу, часто является подмножеством возможных значений, которые могут быть возвращены. В списке обычно рассматриваются только те значения, которые относятся к методу, а также стандартные значения, имеющие определенное значение для конкретного метода. Следует предположить, что метод может возвращать множество стандартных значений **HRESULT** , даже если они не задокументированы явным образом.

Хотя значения **HRESULT** часто используются для возврата сведений об ошибках, их не следует рассматривать как коды ошибок. Тот факт, что бит, указывающий на успех или неудачу, хранится отдельно от битов, содержащих подробные сведения, позволяет значениям **HRESULT** иметь любое количество успешных и неудачных кодов. По соглашению имена кодов успешного выполнения имеют префикс S_ и коды сбоев, E_. Например, два наиболее часто используемых кода — это S_OK и E_FAIL, которые указывают на простое или неудачное выполнение соответственно.

Тот факт, что методы COM могут возвращать различные коды успеха или сбоя, означает, что необходимо соблюдать осторожность при проверке значения **HRESULT** . Например, рассмотрим гипотетический метод с документированными возвращаемыми значениями S_OK в случае успеха и E_FAIL в противном случае. Однако помните, что метод может также возвращать другие коды ошибок или успешности. В следующем фрагменте кода показана опасность использования простого теста, где `hr` содержит значение **HRESULT** , возвращаемое методом.

```cpp
if (hr == E_FAIL)
{
    // Handle the failure case.
}
else
{
    // Handle the success case.
}  
```

При условии, что в случае сбоя этот метод возвращает только E_FAIL (а не какой-либо другой код ошибки), этот тест работает. Однако более реалистичным является реализация определенного метода для возврата набора конкретных кодов ошибок, возможно E_NOTIMPL или E_INVALIDARG. В приведенном выше коде эти значения будут неправильно интерпретированы как успешные.

Если требуются подробные сведения о результатах вызова метода, необходимо протестировать каждое соответствующее значение **HRESULT** . Тем не менее может быть интересно, что метод завершился успешно или неудачно. Надежный способ проверить, указывает ли значение **HRESULT** об успешном или неудачном завершении, — передать значение в один из следующих макросов, определенных в файле Winerror. h.

- `SUCCEEDED`Макрос возвращает значение true для кода успешного выполнения и значение false для кода сбоя.
- `FAILED`Макрос возвращает значение true для кода ошибки и false для кода успешного выполнения.

Таким образом, можно исправить предыдущий фрагмент кода с помощью `FAILED` макроса, как показано в следующем коде.

```cpp
if (FAILED(hr))
{
    // Handle the failure case.
}
else
{
    // Handle the success case.
}  
```

Этот исправленный фрагмент кода правильно обрабатывает E_NOTIMPL и E_INVALIDARG как сбои.

Хотя большинство методов COM возвращают структурированные значения **HRESULT** , небольшое число использует значение **HRESULT** для возврата простого целого числа. Неявно эти методы всегда выполняются успешно. Если **значение HRESULT** этой сортировки передается в макрос успешного выполнения, макрос всегда возвращает значение true. Примером часто вызываемого метода, который не возвращает **значение HRESULT** , является метод **IUnknown:: Release** , возвращающий ulong. Этот метод уменьшает значение счетчика ссылок объекта на единицу и возвращает текущее число ссылок. Обсуждение подсчета ссылок см. в разделе [Управление временем жизни COM-объекта](#managing-a-com-objects-lifetime) .

## <a name="the-address-of-a-pointer"></a>Адрес указателя

Если вы просматриваете несколько страниц со ссылками на COM-методы, возможно, вы заработаете примерно следующим образом.

```cpp
HRESULT D3D12CreateDevice(
  IUnknown          *pAdapter,
  D3D_FEATURE_LEVEL MinimumFeatureLevel,
  REFIID            riid,
  void              **ppDevice
);
```

Хотя обычные указатели хорошо знакомы любому разработчику C/C++, COM часто использует дополнительный уровень косвенного обращения. Второй уровень косвенного обращения обозначен двумя звездочками, `**` после объявления типа, а имя переменной обычно имеет префикс `pp` . Для приведенной выше функции `ppDevice` параметр обычно называется адресом указателя на void. На практике в этом примере `ppDevice` — это адрес указателя на интерфейс **ID3D12Device** .

В отличие от объекта C++, доступ к методам COM-объекта напрямую не осуществляется. Вместо этого необходимо получить указатель на интерфейс, предоставляющий метод. Для вызова метода используется практически тот же синтаксис, что и при вызове указателя на метод C++. Например, чтобы вызвать метод **IMyInterface::D осомесинг** , используйте следующий синтаксис.

```cpp
IMyInterface * pMyIface = nullptr;
...
pMyIface->DoSomething(...);
```

Необходимость второго уровня косвенного обращения обусловлена тем, что вы не создаете указатели на интерфейсы напрямую. Необходимо вызвать один из множества методов, например метод **D3D12CreateDevice** , показанный выше. Чтобы использовать такой метод для получения указателя на интерфейс, необходимо объявить переменную как указатель на нужный интерфейс, а затем передать адрес этой переменной методу. Иными словами, вы передаете адрес указателя на метод. Когда метод возвращает значение, переменная указывает на запрашиваемый интерфейс, и вы можете использовать этот указатель для вызова любого из методов интерфейса.

```cpp
IDXGIAdapter * pIDXGIAdapter = nullptr;
...
ID3D12Device * pD3D12Device = nullptr;
HRESULT hr = ::D3D12CreateDevice(
    pIDXGIAdapter,
    D3D_FEATURE_LEVEL_11_0,
    IID_ID3D12Device,
    &pD3D12Device);
if (FAILED(hr)) return E_FAIL;

// Now use pD3D12Device in the form pD3D12Device->MethodName(...);
```

## <a name="creating-a-com-object"></a>Создание COM-объекта

Существует несколько способов создания COM-объекта. Это два наиболее часто используемых в программировании DirectX.

- Косвенно, путем вызова метода или функции DirectX, которая создает объект. Метод создает объект и возвращает интерфейс для объекта. При таком способе создания объекта иногда можно указать, какой интерфейс следует вернуть, а также в других случаях. В приведенном выше примере кода показано, как косвенно создать COM-объект устройства Direct3D 12.
- Напрямую, передав CLSID объекта в [**функцию CoCreateInstance**](/windows/desktop/api/combaseapi/nf-combaseapi-cocreateinstance). Функция создает экземпляр объекта и возвращает указатель на заданный интерфейс.

Один раз перед созданием COM-объектов необходимо инициализировать COM, вызвав [**функцию CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex). Если объекты создаются косвенно, то эта задача обрабатывается методом создания объекта. Но если необходимо создать объект с помощью **CoCreateInstance**, необходимо явно вызвать метод **CoInitializeEx** . Когда все будет готово, COM должен быть инициализирован путем вызова метода [**CoUninitialize**](/windows/desktop/api/combaseapi/nf-combaseapi-couninitialize). При вызове **CoInitializeEx** необходимо сопоставить его с вызовом **CoUninitialize**. Как правило, приложения, которым требуется явная инициализация COM, делают это в подпрограмме запуска, и они отменяют инициализацию COM в своей подпрограмме очистки.

Чтобы создать новый экземпляр COM-объекта с помощью **CoCreateInstance**, необходимо иметь CLSID объекта. Если этот CLSID является общедоступным, он будет найден в справочной документации или в соответствующем файле заголовка. Если CLSID не является общедоступным, вы не сможете создать объект напрямую.

Функция **CoCreateInstance** имеет пять параметров. Для COM-объектов, которые будут использоваться с DirectX, обычно можно задать параметры следующим образом.

*рклсид* Присвойте этому объекту идентификатор CLSID объекта, который требуется создать.

*пункаутер* Задайте для значение `nullptr` . Этот параметр используется только при статистической обработке объектов. Обсуждение агрегата COM выходит за рамки данного раздела.

*двклсконтекст* Задайте значение CLSCTX_INPROC_SERVER. Этот параметр указывает, что объект реализован в виде библиотеки DLL и выполняется как часть процесса приложения.

*riid* Задайте идентификатор IID интерфейса, который необходимо вернуть. Функция создаст объект и вернет запрошенный указатель интерфейса в параметре ППВ.

*ППВ* Задайте для него адрес указателя, который будет задан интерфейсу, заданному `riid` при возврате функции. Эта переменная должна быть объявлена как указатель на запрашиваемый интерфейс, а ссылка на указатель в списке параметров должна быть приведена как (ЛПВОИД *).

Создание объекта, как правило, выполняется гораздо проще, как показано в приведенном выше примере кода. Вы передаете методу создания объекта адрес указателя интерфейса, а затем метод создает объект и возвращает указатель интерфейса. При прямом создании объекта, даже если не удается выбрать интерфейс, возвращаемый методом, часто можно указать множество вещей о том, как должен быть создан объект.

Например, можно передать в **D3D12CreateDevice** значение, указывающее минимальный уровень компонента D3D, который должен поддерживать возвращаемое устройство, как показано в примере кода выше.

## <a name="using-com-interfaces"></a>Использование COM-интерфейсов

При создании COM-объекта метод создания возвращает указатель интерфейса. Затем этот указатель можно использовать для доступа к любому методу интерфейса. Синтаксис идентичен тому, который использовался с указателем на метод C++.

## <a name="requesting-additional-interfaces"></a>Запрос дополнительных интерфейсов

Во многих случаях указатель интерфейса, полученный из метода создания, может быть единственным, который вам нужен. Фактически, объект может экспортировать только один интерфейс, отличный от **IUnknown**. Однако многие объекты экспортируют несколько интерфейсов, и вам могут потребоваться указатели на несколько из них. Если требуется больше интерфейсов, чем тот, который был возвращен методом создания, нет необходимости создавать новый объект. Вместо этого запросите другой указатель интерфейса с помощью [**метода IUnknown:: QueryInterface**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-queryinterface(refiid_void))объекта.

При создании объекта с помощью **CoCreateInstance** можно запросить указатель интерфейса **IUnknown** , а затем вызвать **IUnknown:: QueryInterface** , чтобы запросить все необходимые интерфейсы. Однако этот подход неудобен, если нужен только один интерфейс, и он не работает вообще, если используется метод создания объекта, который не позволяет указать, какой именно указатель интерфейса должен быть возвращен. На практике обычно не требуется получать явный указатель **IUnknown** , так как все COM-интерфейсы расширяют интерфейс **IUnknown** .

Расширение интерфейса концептуально похоже на наследование от класса C++. Дочерний интерфейс предоставляет все методы родительского интерфейса, а также один или несколько его собственных методов. Фактически, вы часто видите «Inherits from», а не «extends». Необходимо помнить, что наследование является внутренним по отношению к объекту. Приложение не может наследовать или расширять интерфейс объекта. Однако можно использовать дочерний интерфейс для вызова любого из методов дочернего или родительского элемента.

Поскольку все интерфейсы являются дочерними элементами **IUnknown**, можно вызвать **QueryInterface** на любом из указателей интерфейса, которые уже имеются для объекта. При этом необходимо указать IID запрашиваемого интерфейса и адрес указателя, который будет содержать указатель интерфейса при возврате из метода.

Например, следующий фрагмент кода вызывает **IDXGIFactory2:: креатесвапчаинфорхвнд** для создания основного объекта цепочки подкачки. Этот объект предоставляет несколько интерфейсов. Метод **креатесвапчаинфорхвнд** возвращает интерфейс **IDXGISwapChain1** . Затем в следующем коде используется интерфейс **IDXGISwapChain1** для вызова **QueryInterface** для запроса интерфейса **IDXGISwapChain3** .

```cpp
HRESULT hr = S_OK;

IDXGISwapChain1 * pDXGISwapChain1 = nullptr;
hr = pIDXGIFactory->CreateSwapChainForHwnd(
    pCommandQueue, // For D3D12, this is a pointer to a direct command queue.
    hWnd,
    &swapChainDesc,
    nullptr,
    nullptr,
    &pDXGISwapChain1));
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3 = nullptr;
hr = pDXGISwapChain1->QueryInterface(IID_IDXGISwapChain3, (LPVOID*)&pDXGISwapChain3);
if (FAILED(hr)) return hr;
```

> [!NOTE]
> В C++ можно использовать ``IID_PPV_ARGS`` макрос, а не ЯВНЫЙ IID и указатель приведения: ``pDXGISwapChain1->QueryInterface(IID_PPV_ARGS(&pDXGISwapChain3));`` .
> Это часто используется для методов создания, а также для **QueryInterface**. Дополнительные сведения см. в разделе [комбасеапи. h](/windows/win32/api/combaseapi/nf-combaseapi-iid_ppv_args) .

## <a name="managing-a-com-objects-lifetime"></a>Управление временем существования COM-объекта

При создании объекта система выделяет необходимые ресурсы памяти. Если объект больше не нужен, он должен быть уничтожен. Система может использовать эту память для других целей. С помощью объектов C++ можно управлять временем существования объекта непосредственно с помощью `new` операторов и `delete` в случаях, когда работа выполняется на этом уровне или с использованием стека и времени существования области. COM не позволяет напрямую создавать или уничтожать объекты. Причина этого заключается в том, что один и тот же объект может использоваться несколькими частями приложения или в некоторых случаях несколькими приложениями. Если одна из этих ссылок должна уничтожить объект, другие ссылки станут недействительными. Вместо этого COM использует систему подсчета ссылок для управления временем существования объекта.

Число ссылок объекта — это количество запросов к одному из его интерфейсов. При каждом запросе интерфейса увеличивается число ссылок. Приложение освобождает интерфейс, когда этот интерфейс больше не нужен, уменьшая число ссылок. Пока значение счетчика ссылок больше нуля, объект остается в памяти. Когда счетчик ссылок достигает нуля, объект уничтожает сам себя. Вам не нужно ничего знать о счетчике ссылок объекта. Пока вы получаете и освобождаете интерфейсы объекта должным образом, у объекта будет соответствующее время существования.

Правильная обработка подсчета ссылок является ключевой частью программирования COM. В противном случае можно легко создать утечку памяти или сбой. Одна из наиболее распространенных ошибок, которую делают программисты COM, не позволяет освободить интерфейс. В этом случае счетчик ссылок никогда не достигнет нуля, и объект остается в памяти неограниченно долго.

> [!NOTE]
> Direct3D 10 или более поздней версии имеет немного измененные правила времени существования для объектов. В частности, объекты, производные от **ID3DxxDeviceChild** , никогда не наносят свое родительское устройство (т. е. Если **ID3DxxDevice** -владелец равен 0 refcount, то все дочерние объекты также становятся недействительными). Кроме того, при использовании методов **Set** для привязки объектов к конвейеру отрисовки эти ссылки не увеличивают число ссылок (то есть они являются слабыми ссылками). На практике этот подход лучше всего обрабатывать, гарантируя, что все дочерние объекты устройств полностью освобождаются до выпуска устройства.

## <a name="incrementing-and-decrementing-the-reference-count"></a>Увеличение и уменьшение счетчика ссылок

При получении нового указателя интерфейса число ссылок должно увеличиваться путем вызова метода [**IUnknown:: AddRef**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-addref). Однако приложению обычно не нужно вызывать этот метод. Если получить указатель интерфейса путем вызова метода создания объекта или путем вызова **IUnknown:: QueryInterface**, то объект автоматически увеличит число ссылок. Однако при создании указателя интерфейса другим способом, например при копировании существующего указателя, необходимо явно вызвать **IUnknown:: AddRef**. В противном случае при освобождении исходного указателя на интерфейс объект может быть уничтожен, несмотря на то, что может потребоваться использовать копию указателя.

Необходимо освободить все указатели интерфейса, независимо от того, увеличился ли счетчик ссылок у вас или объектов. Если указатель интерфейса больше не нужен, вызовите [**IUnknown:: Release**](/windows/desktop/api/unknwn/nf-unknwn-iunknown-release) , чтобы уменьшить число ссылок. Распространенной практикой является инициализация всех указателей интерфейса на `nullptr` , а затем их возврат к `nullptr` моменту их освобождения. Это соглашение позволяет протестировать все указатели интерфейса в коде очистки. Те, которые `nullptr` еще не активны, необходимо освободить перед завершением работы приложения.

Следующий фрагмент кода расширяет пример, показанный ранее, чтобы продемонстрировать способ управления подсчетом ссылок.

```cpp
HRESULT hr = S_OK;

IDXGISwapChain1 * pDXGISwapChain1 = nullptr;
hr = pIDXGIFactory->CreateSwapChainForHwnd(
    pCommandQueue, // For D3D12, this is a pointer to a direct command queue.
    hWnd,
    &swapChainDesc,
    nullptr,
    nullptr,
    &pDXGISwapChain1));
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3 = nullptr;
hr = pDXGISwapChain1->QueryInterface(IID_IDXGISwapChain3, (LPVOID*)&pDXGISwapChain3);
if (FAILED(hr)) return hr;

IDXGISwapChain3 * pDXGISwapChain3Copy = nullptr;

// Make a copy of the IDXGISwapChain3 interface pointer.
// Call AddRef to increment the reference count and to ensure that
// the object is not destroyed prematurely.
pDXGISwapChain3Copy = pDXGISwapChain3;
pDXGISwapChain3Copy->AddRef();
...
// Cleanup code. Check to see whether the pointers are still active.
// If they are, then call Release to release the interface.
if (pDXGISwapChain1 != nullptr)
{
    pDXGISwapChain1->Release();
    pDXGISwapChain1 = nullptr;
}
if (pDXGISwapChain3 != nullptr)
{
    pDXGISwapChain3->Release();
    pDXGISwapChain3 = nullptr;
}
if (pDXGISwapChain3Copy != nullptr)
{
    pDXGISwapChain3Copy->Release();
    pDXGISwapChain3Copy = nullptr;
}
```

## <a name="com-smart-pointers"></a>Интеллектуальные указатели COM

Код на данный момент был явно вызван ``Release`` и ``AddRef`` для поддержания счетчиков ссылок с помощью методов **IUnknown** . Этот шаблон требует тщательного подхода программиста к правильному поддержанию количества во всех возможных кодепасс. Это может привести к сложной обработке ошибок, и при включенной обработке исключений C++ может быть особенно сложно реализовать. Лучшим решением с C++ является использование [смарт-указателя](/cpp/cpp/smart-pointers-modern-cpp).

* **WinRT:: com_ptr** — это интеллектуальный указатель, предоставляемый [проектами языка C++/WinRT](/uwp/cpp-ref-for-winrt/com-ptr). Это рекомендуемый интеллектуальный указатель COM для использования в приложениях UWP. Обратите внимание, что C++/WinRT требует C++ 17.

* **Microsoft:: WRL:: ComPtr** — это интеллектуальный указатель, предоставляемый [библиотекой шаблонов среда выполнения Windows C++ (WRL)](/cpp/cppcx/wrl/comptr-class). эта библиотека является "чистым" C++, поэтому ее можно использовать для среда выполнения Windows приложений (через c++/cx или c++/WinRT), а также для классических приложений Win32. этот интеллектуальный указатель также работает в более старых версиях Windows, которые не поддерживают среда выполнения Windows api. Для классических приложений Win32 можно использовать ``#include <wrl/client.h>`` для включения этого класса, а также при необходимости определять символ препроцессора ``__WRL_CLASSIC_COM_STRICT__`` . Дополнительные сведения см. в разделе [смарт-указатели COM, посещенные](/archive/msdn-magazine/2015/february/windows-with-c-com-smart-pointers-revisited)повторно.

* **CComPtr** — это интеллектуальный указатель, предоставляемый [библиотекой активных шаблонов (ATL)](/cpp/atl/reference/ccomptr-class). **Microsoft:: WRL:: ComPtr** является новой версией этой реализации, которая решает ряд незначительных проблем с использованием, поэтому использовать этот интеллектуальный указатель не рекомендуется для новых проектов. Дополнительные сведения см. [в разделе Создание и использование CComPtr и CComQIPtr](/cpp/cpp/how-to-create-and-use-ccomptr-and-ccomqiptr-instances).


## <a name="using-atl-with-directx-9"></a>Использование ATL с DirectX 9

Чтобы использовать библиотеку активных шаблонов (ATL) с DirectX 9, необходимо переопределить интерфейсы для совместимости с библиотекой ATL. Это позволяет правильно использовать класс **CComQIPtr** для получения указателя на интерфейс.

Вы узнаете, не переопределяйте ли интерфейсы для ATL, так как вы увидите следующее сообщение об ошибке.

```
[...]\atlmfc\include\atlbase.h(4704) :   error C2787: 'IDirectXFileData' : no GUID has been associated with this object
```

В следующем примере кода показано, как определить интерфейс Идиректксфиледата.

```cpp
// Explicit declaration
struct __declspec(uuid("{3D82AB44-62DA-11CF-AB39-0020AF71E433}")) IDirectXFileData;

// Macro method
#define RT_IID(iid_, name_) struct __declspec(uuid(iid_)) name_
RT_IID("{1DD9E8DA-1C77-4D40-B0CF-98FEFDFF9512}", IDirectXFileData);
```

После переопределения интерфейса необходимо использовать метод **attach** для подключения интерфейса к указателю интерфейса, возвращаемому **::D irect3dcreate9**. В противном случае интерфейс **IDirect3D9** не будет правильно освобожден классом интеллектуального указателя.

Класс **CComPtr** внутренне вызывает **IUnknown:: AddRef** для указателя интерфейса при создании объекта и при назначении интерфейса классу **CComPtr** . Чтобы избежать утечки указателя интерфейса, не вызывайте * * IUnknown:: AddRef в интерфейсе, возвращенном из **::D irect3dcreate9**.

Следующий код правильно освобождает интерфейс, не вызывая **IUnknown:: AddRef**.

```cpp
CComPtr<IDirect3D9> d3d;
d3d.Attach(::Direct3DCreate9(D3D_SDK_VERSION));
```

Используйте предыдущий код. Не используйте следующий код, который вызывает **IUnknown:: AddRef** , а затем **IUnknown:: Release** и не освобождает ссылку, добавленную **::D irect3dcreate9**.

```cpp
CComPtr<IDirect3D9> d3d = ::Direct3DCreate9(D3D_SDK_VERSION);
```

Обратите внимание, что это единственное место в Direct3D 9, где вам придется использовать метод **attach** таким образом.

Дополнительные сведения о классах **CComPTR** и **CComQIPtr** см. в их определениях в `Atlbase.h` файле заголовка.
