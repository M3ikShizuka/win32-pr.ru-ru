---
title: Имеющуюся цепочку буферов по программированию композиции
description: API-интерфейс композиции имеющуюся цепочку буферов — это спиритуалный последователь для имеющуюся цепочку буферов DXGI, который позволяет приложениям визуализировать и отображать содержимое на экране.
ms.topic: article
ms.date: 09/10/2021
ms.openlocfilehash: cd87e1d47e3e44c922310937c0106348ebb4954f
ms.sourcegitcommit: 2c13d0f1620f7c089687ef1d97e8c1d22e5d537a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/24/2021
ms.locfileid: "128524008"
---
# <a name="composition-swapchain-programming-guide"></a>Имеющуюся цепочку буферов по программированию композиции

> [!NOTE]
> **Некоторые сведения относятся к предварительной версии продукта, в которую перед коммерческим выпуском могут быть внесены существенные изменения. Корпорация Майкрософт не дает никаких гарантий, явных или подразумеваемых, в отношении предоставленной здесь информации.**

API-интерфейс композиции имеющуюся цепочку буферов — это спиритуалный последователь для имеющуюся цепочку буферов DXGI, который позволяет приложениям визуализировать и отображать содержимое на экране. Использование этого API через имеющуюся цепочку буферов DXGI имеет несколько преимуществ. Более детализированный контроль передается вашему приложению в соответствии с состоянием имеющуюся цепочку буферов, и при этом предоставляется более свобода, когда речь идет о том, как используется имеющуюся цепочку буферов. Кроме того, API предоставляет более качественную историю для точного представления времени.

## <a name="what-is-presentation"></a>Что такое презентация?

*Представление* — это концепция отображения результатов операций рисования на экране. *Представление* представляет собой единственный экземпляр представления запроса на &mdash; Отображение результатов операции рисования в один буфер на экране. Представление может содержать дополнительные атрибуты, описывающие способ отображения на экране. В этом API-интерфейсе присутствие может также иметь *целевое время*, которое представляет собой относительную отметку времени (время прерывания), описывающее идеальное время, в котором должно отображаться представление. Приложение может использовать это для более точного контроля скорости отображения содержимого на экране, а также для синхронизации с другими событиями в системе, такими как звуковая дорожка.

В основе презентации лежит синхронизация. То есть операции рисования обычно выполняются графическим процессором, в отличие от ЦП, и, как таковые, они выполняются на асинхронной временной шкале от процессора, который изначально выдал операции. Представление — это операция, отправленная на графический процессор, которая гарантирует, что операции рисования, которые были выполнены ранее, будут завершены до отображения буфера на экране.

Как правило, ваше приложение будет выдавать многие из них со временем и иметь несколько текстур для выбора при выдаче. Приложение должно использовать механизмы синхронизации, предоставляемые этим API, чтобы гарантировать, что после рисования в буфере и представления буфера вы не рисуйте его повторно, пока он не будет показан и затем заменит новый буфер из последующего представления. В противном случае содержимое буфера, которое предполагалось представиму приложению, может быть перезаписано, так как оно отображается на экране.

## <a name="presentation-modesmdashcomposition-multiplane-overlay-and-iflip"></a>Композиция режимов представления &mdash; , многоплановый оверлей и ифлип

Буферы, представленные приложением, могут отображаться системой несколькими разными способами.

Самый простой способ, который является значением по умолчанию, заключается в том, что представление будет отправлено в DWM, а DWM выполнит визуализацию кадра на основе представленного буфера. То есть копия (или более точная) буфера презентации находится в буфере в буфере обмена, который DWM отправляет на экран. Этот метод отображения представления называется композиция.

Более производительный режим отображения представляет собой возможность просмотра буфера презентации непосредственно на оборудовании и устранения той копии, которая выполняется. Этот метод отображения представления называется *прямым сканированием*. При обработке обнаруживает, что программа DWM может запрограммировать оборудование для непосредственного сканирования буфера презентации путем назначения буфера в плоскость *многоплановой наложения* (или плоскость MPO) или прямого перелистывания буфера на оборудование (также называется *прямым отражением*).

Еще более производительный способ отобразить представление — предоставить представление, которое будет отображаться непосредственно ядром графики и полностью обойти DWM. Этот метод презентации называется *независимым отражением* (ифлип). Как многоплановые наложения, так и ифлип описаны в разделе [для лучшей производительности, используйте модель перелистывания DXGI](https://devblogs.microsoft.com/directx/dxgi-flip-model/).

Компоновка является самой простой, но и наименее эффективной. Поверхность должна быть специально распределена, чтобы иметь право на прямое сканирование или ифлип, а этот тип специального выделения имеет более строгое соответствие требованиям к системе, чем имеющуюся цепочку буферов компоновки. Он доступен только в WDDM 3,0 и большем оборудовании. В результате приложение может запрашивать поддержку API для представления только для композиции, а также для представления, которое подходит для прямого сканирования или ифлип.

## <a name="presentation-factory-checking-capability-and-presentation-manager"></a>Фабрика презентации, возможность проверки и диспетчер презентаций

Первый объект, который будет использоваться приложением имеющуюся цепочку буферов API композиции, является *фабрикой представления*. Фабрика презентаций создается приложением и связывается с устройством Direct3D, которое приложение передает в вызов для создания, и, таким образом, имеет сходство с видеоадаптером, связанным с этим устройством.

Фабрика презентаций предоставляет методы для проверки того, поддерживает ли текущее системное и графическое устройство использование API-интерфейса композиции имеющуюся цепочку буферов. Для проверки системной поддержки можно использовать методы возможностей, такие как [**ипресентатионфактори:: испресентатионсуппортед**](/windows/win32/api/presentation/nf-presentation-ipresentationfactory-ispresentationsupported) . Если методы возможностей указывают на системную поддержку API, можно использовать фабрику презентаций для создания *диспетчера презентаций*. Этот диспетчер презентаций — это объект, используемый для выполнения функций представления и привязанный к тому же устройству Direct3D и видеоадаптеру, что и фабрика представления, которая использовалась для ее создания.

в настоящее время требования к системе для использования API-интерфейса компоновки имеющуюся цепочку буферов в любом случае являются драйверами GPU, поддерживающими WDDM (модель драйвера устройства Windows) 2,0. Чтобы использовать API композиции имеющуюся цепочку буферов в наиболее производительном (прямом сканировании и независимом переворачивании или *ифлип*), системам потребуется драйвер GPU, поддерживающий WDDM 3,0.

Если система не может использовать API-интерфейс композиции имеющуюся цепочку буферов, приложение должно иметь отдельную коду для работы с презентацией с помощью более старых методов, таких как DXGI имеющуюся цепочку буферов.

## <a name="register-presentation-buffers-to-present"></a>Регистрация буферов презентации для показа

Диспетчер презентаций отслеживает буферы, которые он может представлять. Чтобы предоставить текстуру Direct3D, приложение должно сначала создать эту текстуру с помощью Direct3D, а затем зарегистрировать ее с помощью диспетчера презентаций. Если в диспетчере презентаций была зарегистрирована текстура, она называется *буфером представления* и может быть выведена на экран с помощью диспетчера презентаций. Приложение может добавлять и удалять буферы презентации по своему усмотрению, хотя существует максимальное число буферов презентации, которые можно добавить в один диспетчер презентаций (в настоящее время 31). Эти буферы презентации также могут иметь различные размеры и форматы, которые вступят в силу при представлении отдельного буфера представления.

Текстуру можно зарегистрировать с любым числом руководителей презентаций; Однако это не будет считаться нормальным применением в большинстве случаев и приведет к усложнению сценариев синхронизации, которые приложение будет отвечать за управление.

## <a name="defining-the-content-to-be-presented"></a>Определение отображаемого содержимого

Как правило, буферы, которые мы используем, должны быть связаны с содержимым в *визуальном дереве*. Поэтому необходимо определить тип *привязки* , чтобы при возникновении проблем в приложении ясно, где в визуальном дереве представлены буферы. Мы вызываем *содержимое представления* привязки.

Представленное содержимое может принимать множество форм. Приложение может предоставить один буфер для отображения, или же он может показывать стерео-содержимое с буферами как для левого, так и для правильного глаз и так далее. Первоначальная версия этого API обеспечивает поддержку представления одного буфера на экран.

*Область представления* определяется как форма содержимого презентации, в которой один буфер представлен за раз. Поверхность презентации может быть задана в виде содержимого в визуальном дереве и может отображать один буфер презентации одновременно на экране. Диспетчер презентаций будет обновлять буфер, отображаемый одной или несколькими поверхностями представления, атомарным образом.

Диспетчер презентаций можно использовать для создания одной или нескольких областей представления для данного *маркера поверхности композиции*. каждый маркер области композиции можно привязать к одному или нескольким визуальным элементам в визуальном дереве (стратегии, описанные в документации по [**Windows. UI. композиция**](/uwp/api/windows.ui.composition) и [**DirectComposition**](/windows/win32/directcomp/directcomposition-portal) API), чтобы определить связь между связанной областью представления и ее отображением в визуальном дереве. Приложение может обновить одну или несколько поверхностей презентации, которые передаются в систему и выполняются в следующей текущей операции.

Обратите внимание, что диспетчер презентаций может представлять любой буфер презентации любому количеству всех областей презентации. Ограничений нет. Однако приложение может следить за тем, какие буферы были выданы, и где, чтобы не пытаться выпустить новый документ в буфер, пока он все еще отображается в области презентации.

## <a name="applying-properties-to-presentation-surface"></a>Применение свойств к поверхности представления

Помимо указания того, какие буферы должны отображаться в области презентации, в представлении можно также указать различные другие свойства для этой области презентации. К ним относятся свойства, определяющие способ выборки текстуры источника, включая альфа-режим и цветовое пространство, способ преобразования и отображения текстуры источника, а также любые отображаемые или реадбакк ограничения для защищенного содержимого. Все они представлены в виде методов задания свойств на поверхности презентации, которые могут быть изменены приложением, и, как и в случае с обновлениями буфера, вступят в силу при наличии приложения.

## <a name="presenting-to-the-presenting-surface"></a>Представление поверхности

После того как приложение создаст поверхности презентации, зарегистрирует буферы представления и выдает обновления, которые выдаются в настоящее время, можно применить эти свойства, выполнив презентацию. Приложение выдает представление через диспетчер презентаций. Если эта система обрабатывается системой, все обновления применяются атомарно. Кроме того, в приложении можно также указать другие свойства представления, такие как идеальное время, которое должно быть выполнено ( *текущее целевое* время) и другие свойства реже, такие как предполагаемая скорость содержимого, которая может использоваться для включения пользовательских режимов обновления в системе. Так как представление может быть запланировано в определенный момент времени, приложение может заранее выдавать несколько раз. Они будут обрабатываться по одному по мере достижения запланированного времени. 

## <a name="synchronizing-presentation"></a>Синхронизация презентации

Приложение должно быть уверенным в том, что при подготовке к просмотру буферов, а также проблем он выбирает буфер для подготовки к просмотру, на который в данный момент не ссылается ни один из других невыполненных операций, так как это может привести к перезаписи содержимого буфера, предназначенного для этого представления. Кроме того, если приложение выдает представление в буфер, который в настоящее время отображается в области презентации на оборудовании сканирования, то его отрисовка может быть остановлена бессрочно, так как Direct3D запрещает *отрисовку переднего буфера*.

API-интерфейс композиции имеющуюся цепочку буферов предоставляет несколько различных механизмов, позволяющих приложению попрактиковаться в правильной синхронизации буферов, которые он представил.

Считается, что буфер *доступен* , если нет незавершенных ссылок, которые ссылаются на него, и в настоящее время не отображается системой. В противном случае он недоступен. API предоставляет событие для каждого буфера презентации, которое указывает, доступен ли буфер. Это самый простой способ синхронизации, используемый вашим приложением. Перед рисованием в буфере и его представлением приложение может гарантировать, что его *доступное* событие будет сигнальным. *Доступное* событие для определенного буфера перестает быть сигнальным, пока он привязан к поверхности представления в API и остается несигнальным до тех пор, пока не будет удален.

Во-вторых, диспетчер презентаций отслеживает единую неограниченную *ограждение* , чтобы сообщить о завершении приложения. Значение ограждения соответствует текущему идентификатору последнего представления, который начал этап *снятия* с учета в жизненном цикле, как описано в разделе *жизненный цикл* ниже. После того как текущий переход на этот этап, можно считать, что все буферы, которые были заменены последующими представлениями, могут быть использованы повторно.

Этот метод синхронизации является более сложным, но обеспечивает больший контроль над регулированием рабочего процесса и более информативно представляет состояние системы в отношении глубины текущей очереди. Общие сведения о жизненном цикле представления см. в разделе ниже.

## <a name="lifecycle-of-a-present"></a>Жизненный цикл текущего

Диспетчеры презентаций представляются в очереди системы как часть своей *очереди*. Системные процессы представляют в порядке очередей. Кроме того, каждый из них имеет уникальный *идентификатор*(для диспетчера презентаций), связанный с, который представляет собой увеличивающееся значение, присваиваемое представлению, начиная с 1 для первого представления и увеличивая на 1 для каждого последующего представления. Этот идентификатор используется в различных частях API, таких как примитивы синхронизации и статистика представления, чтобы ссылаться на эту конкретную презентацию.

Каждая из них посвящена определенному жизненному циклу приложения, как описано здесь.

После того как приложение настроит изменения, которые должны быть сделаны в рамках текущего приложения, оно будет использовать диспетчер презентаций для фактического выпуска. На этом этапе представление считается *ожидающим*.

Когда очередь находится в состоянии ожидания, она будет находиться в очереди презентации диспетчера презентаций, где она останется до того, как произойдет одно из двух событий.

* Эта презентация будет *отменена*. Диспетчер презентаций позволяет приложению отменить ранее выпущенные представления. Если это происходит, то представление считается *отмененным*, а затем сразу же становится *снятым*. В этом переходе связанный буфер *доступных* событий для отмененного представления будет обновлен, но текущая снятая ограждения не будет сигнальной, так как ранее отображаемые данные (до отклонения, которые были отменены) останутся видимыми. По этой причине приложение не может использовать текущую ограждение снятия с учета, чтобы определить, какие из них были отменены. Вместо этого необходимо изучить текущую статистику состояния, которая возвращается для каждого отмененного. Мы рекомендуем, чтобы приложение использовало *события буфера* , чтобы найти доступный буфер для представления после отмены. После этого в предыдущей презентации начнется процесс снятия с учета и будет обновлена текущая ограждение снятия с учета.
* Если это не было отменено, то в конечном итоге будет *Готово* к обработке. Чтобы быть готовым, должны выполняться два основных условия.
  * Все операции рисования, выданные контексту Direct3D до вызова Present, должны быть завершены. Это гарантирует, что буфер не будет отображаться до завершения рисования приложения.
  * Если указано указанное целевое время, то текущее время, относительное для системы, которое ожидалось для отображения текущего времени, соответствует запрошенному целевому времени, которое приложение применяет к текущему.

Когда система решает найти презентацию, которая будет отображаться на экране, она выберет Последнее представление, которое станет *готовым* к отображению. Если имеется несколько *готовых* презентаций, все, но самое последнее (то есть имеющееся с самым большим идентификатором) будут *пропущены* и сразу же перейдет *в отключенное* состояние, после чего будет получен сигнал о том, что его буфер *доступен* , но текущая ограждение не будет передана, так как пропущенная граница не перейдет из *отображаемого* состояния.

После выбора *готового* представления система начинает выполнять работу, чтобы показать ее на экране. Это может означать отображение буфера в составе кадра DWM, а затем запрос к оборудованию отображать кадр на экране или это означает, что буфер можно отправить напрямую для сканирования оборудования в случае ифлип. После этого происходит *постановка в очередь*. На высоком уровне это означает, что его можно отобразить.

Когда оборудование отображается для отображения на экране, то говорят, что он *отображается*. Там она останется, видима на экране, пока последующая презентация не поступает и не заменит ее.

Когда последующая презентация становится поставленной в очередь, мы понимаем, что оборудование в конечном итоге будет показывать текущее присутствие. На этом этапе говорят, что в настоящее время используется снятие с *учета.*

Когда последующее представление становится отображаемым, считается, что текущий ток был *снят* с учета.

Диспетчер презентаций предоставляет доступ к *представленной ограждению без снятия* с учета, которая сообщает об указанном идентификаторе каждой из них, когда она входит в состояние *снятия* с учета. Этот сигнал указывает приложению, что оно стало ненадежным для выработки операций визуализации в буферы, связанные с ним, без повреждения предыдущего представления. Если приложение выдает работу по отрисовке в режиме *снятия* с учета, то работа по отрисовке будет поставлена в очередь до тех пор, пока она не войдет в *отмененное* состояние, после чего она будет выполнена. Если работа по отрисовке выдается после того, как презентация будет *прекращена*, то она начнет выполняться немедленно.

Ниже приведена схема этого изменения состояния.

![Жизненный цикл текущего](images/lifecycle-of-a-present.png)

## <a name="diagram-of-buffers-surfaces-and-presents"></a>Схема буферов, поверхностей и представление

Ниже приведена схема, связанная с диспетчером презентаций, буферами презентации, областями презентации, представлениями и обновлениями.

![Схема буферов, поверхностей и представление](images/buffers-surfaces-and-presents.png)

На этой диаграмме показан Диспетчер презентаций с двумя областями презентации и тремя буферами представления, в которых было выдано два представления, выданных ранее, &mdash; а в первом отображенном буфере 1 в области 1, а в области 2 — буфер 2. Вторая текущая обновленная поверхность 2 для отображения буфера представления 3 и не изменила привязку поверхности 1. После отображения 2 в Surface 1 будет показан буфер 1, а на поверхности 2 будет показан буфер 3, который можно увидеть в текущем состоянии объектов в диспетчере презентаций. Все существующие в очереди вступят в силу при обработке в системе.

> [!NOTE]
> Так как Present 2 не изменил буфер для поверхности 1, поверхность 1 была привязана к буферу 1 из предыдущего представления. В этом смысле имеется "неявная" ссылка на буфер 1 в наличии 2, так как поверхность 1 останется привязанной к буферу 1 после отображения 2.

## <a name="adding-presentation-surfaces-to-visual-tree"></a>Добавление областей презентации в визуальное дерево

Поверхности представления — это содержимое, которое существует как часть визуального дерева композиции. Каждая область презентации привязана к *маркеру области композиции*. в Windows. UI. композиция можно создать кисть surface для уже существующего дескриптора области композиции и привязать ее к визуальному элементу sprite. В DirectComposition область композиции можно создать на основе уже существующего маркера области композиции и привязать как содержимое к визуальному элементу. Дополнительные сведения см. в соответствующей документации для каждого API.

api-интерфейсы, такие как Windows Media Foundation, построенные для использования этого API, предоставляют дескрипторы поверхности композиции, которые будут предварительно привязаны к поверхности представления. Приложение также может создать собственный обработчик области композиции для последующей привязки к поверхности представления и добавления в визуальное дерево путем вызова [дкомпоситионкреатесурфацехандле](/windows/win32/api/dcomp/nf-dcomp-dcompositioncreatesurfacehandle).

## <a name="reading-presentation-statistics"></a>Чтение статистики представления

API-интерфейс композиции имеющуюся цепочку буферов предоставляет *статистику представления*, которая описывает различные сведения о том, как обрабатывалась конкретная презентация. Эти сведения обычно описывают, как поверхность презентации использовалась в кадре DWM, на момент времени, когда он был показан, и т. д.

Существуют различные типы статистики представления, и они предназначены для расширения в будущих версиях API. Приложение использует диспетчер презентаций для регистрации для получения типов статистики, о которой он интересует. Затем эти статистические данные помещаются в *очередь статистики* диспетчера презентаций. Диспетчер презентаций предоставляет *доступ к статистике* для приложений, которые являются обработчиком событий, указывающим, когда в очереди статистики есть доступные для чтения элементы статистики. В этом случае приложение может вывести первый элемент статистики из очереди, прочитать его и обработать. Диспетчер презентаций сбрасывает событие "статистика доступна", когда приложение считывает все статистические данные, находящиеся в очереди. Как правило, приложение будет считывать и обрабатывать статистику в цикле до тех пор, пока не будет сброшено событие «статистика доступности». Как правило, приложение обрабатывает эту очередь статистики в том же цикле работы, который используется для выработки. Предлагаемый шаблон использования заключается в назначении приоритета для статистики обработки при выдаче новых выпусков, чтобы гарантировать, что очередь не будет переполнена.

В очереди содержится максимальное количество статистических данных, которое будет относиться в соответствии со статистикой 512-1024. Максимальная глубина очереди должна быть достаточной, чтобы в обычных случаях хранить в течение 5 секунд статистику. Если очередь статистики заполнена и сообщается о дополнительной статистике, то политика состоит в том, что самая старая статистика будет прекращена, чтобы освободить место.

## <a name="related-topics"></a>Связанные темы

* [Имеющуюся цепочку буферов композиции](comp-swapchain-portal.md)
* [Для достижения оптимальной производительности используйте модель перелистывания DXGI](https://devblogs.microsoft.com/directx/dxgi-flip-model/)
