---
title: Привязка к объекту Active Directory
description: Наиболее распространенным способом привязки к объекту Active Directory является использование функции GetObject между клиентом ADSI и поставщиком ADSI.
ms.assetid: d278ea26-2fd5-4343-8d87-ff85515325fb
ms.tgt_platform: multiple
keywords:
- Привязка к объекту Active Directory ADSI
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bc788ed9eb124e1da6c21848f02393d46608f00dd3a9e779788fa54429922400
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118429141"
---
# <a name="binding-to-an-active-directory-object"></a>Привязка к объекту Active Directory

Наиболее распространенным способом привязки к объекту Active Directory является использование функции **GetObject** между клиентом ADSI и поставщиком ADSI. Это также самый простой способ продемонстрировать, как компонент поставщика получает запросы и службы. как функция API ADSI [**адсжетобжект**](/windows/desktop/api/Adshlp/nf-adshlp-adsgetobject) , так и функция Visual Basic **getobject** следуют тем же действиям для привязки.

В этом примере предположим, что клиент ADSI является приложением для просмотра ADSI, которое получило значение ADsPath "Sample://Seattle/Redmond/Shelly" из пользовательского интерфейса (1). На следующем рисунке подробно описывается последовательность событий путем нумерации стрелок потока.

![подробное представление компонентов ADSI](images/dscsex.png)

На предыдущем рисунке клиент инициирует запрос указателя интерфейса на объект Active Directory, представленный параметром ADsPath "Sample://Seattle/Redmond/Shelly" из служб ADSI (2). Во время инициализации программное обеспечение служб заполняет таблицу установленных программных идентификаторов поставщика (ProgID) из реестра ("LDAP:", "Sample:", "WinNT:" и т. д.) и связывает их с соответствующими **идентификаторами CLSID**, которые указывают соответствующий программный модуль.

Сервер ADSI проверяет, существует ли идентификатор ProgID, в данном случае "Sample:", в расположении ADsPath. Затем он создает контекст привязки для оптимизации ссылок на этот объект и вызывает стандартную функцию COM [**мкпарседисплайнаме**](/windows/win32/api/objbase/nf-objbase-mkparsedisplayname) для создания моникера com, который может использоваться для поиска и привязки к объекту, представляющему пользователя "Шелли".

В следующем разделе имена файлов в примере исходного кода компонента поставщика включаются в круглые скобки там, где это уместно.

Как и в других реализациях COM-сервера, [**мкпарседисплайнаме**](/windows/win32/api/objbase/nf-objbase-mkparsedisplayname) изучает идентификатор ProgID и ищет правильный **идентификатор CLSID** в реестре (3) для поиска соответствующего кода фабрики класса (кпровкф. cpp) в соответствующей реализации поставщика (4). Этот код создает исходный объект верхнего уровня, реализующий метод [**ипарседисплайнаме::P арседисплайнаме**](/windows/win32/api/oleidl/nf-oleidl-iparsedisplayname-parsedisplayname) (кпров. cpp). Реализация поставщика **парседисплайнаме** разрешает путь в собственном пространстве имен поставщика. В итоге вызывается Адсобжект и вызывается средство синтаксического анализа, предоставляемое вместе с компонентом поставщика (Parse. cpp), чтобы проверить синтаксическую правильность определения ADsPath для этого пространства имен.

**GetObject,** определенный в жетобж. cpp, определяет, является ли запрошенный объект объектом пространства имен, объектом схемы или другим типом объекта. Если один из первых двух элементов, то создается этот тип объекта класса схемы и извлекается соответствующий указатель интерфейса. В противном случае путь к каталогу примеров создается из ADsPath (например, " \\ Сиэтл \\ Redmond \\ Шелли", но в другой службе каталога это может быть " \\ OU = Сиэтл \\ OU = Redmond \\ CN = Шелли"), а управление передается сампледсопенобжект, которое открывает объект в примере хранилища данных, а также получает тип объекта (в данном случае "User") (5).

После сбора данных создается новый объект (6), который представляет элемент, описываемый в параметре ADsPath, и извлекается указатель на интерфейс [**IUnknown**](/windows/win32/api/unknwn/nn-unknwn-iunknown) на этом объекте. В этом случае создается универсальный объект Active Directory, поддерживающий методы **IUnknown** и [**iAds**](/windows/desktop/api/Iads/nn-iads-iads) (Кженобж. cpp, Core. cpp). Подсистема Ксампледсженобжект:: Аллокатеженобжект считывает данные библиотеки типов для создания правильных записей диспетчеризации для этих новых объектов, чтобы обеспечить поддержку [**IDispatch**](/windows/win32/api/oaidl/nn-oaidl-idispatch).

Заключение указателя этого интерфейса в моникер завершает функцию Ресолвепаснаме (Кпров. cpp) и анализирует отображаемое имя.

Все COM-объекты, созданные во время этого процесса, кэшируются по соображениям производительности и управляются через контекст привязки. Это повышает производительность для других операций с тем же объектом, который сразу же следует за привязкой моникера.

Этот правильно сформированный Active Directory объект теперь запрашивается по идентификатору интерфейса, запрошенному для начального вызова [**адсжетобжект**](/windows/desktop/api/Adshlp/nf-adshlp-adsgetobject) , и получает указатель на этот интерфейс (7) и передается обратно серверу ADSI клиенту (8&9). После этого клиент работает непосредственно с компонентом поставщика через методы интерфейса до тех пор, пока не будет удовлетворен первоначальный запрос (10).

Кроме того, запросы данных объектов от клиента обычно принимают форму запросов на получение свойств, и все они оптимизируются посредством реализации поставщика кэша свойств (Кпропс. cpp). Интеллектуальная упаковка и распаковка данных, часто включая копирование и освобождение структур и строк, между собственными типами данных в примере операционной системы компонента поставщика и типом [**варианта**](/windows/win32/api/oaidl/ns-oaidl-variant) автоматизации, поддерживаемым интерфейсом ADSI, происходит перед загрузкой свойств в кэш (смпопер. cpp).

Пример компонента поставщика разработан таким образом, чтобы фактические вызовы операционной системы были логически изолированы от компонента поставщика, создав программное обеспечение, переносимое в более чем одну операционную систему (Регдсапи. cpp).

 

 