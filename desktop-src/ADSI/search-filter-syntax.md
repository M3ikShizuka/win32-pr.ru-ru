---
title: Синтаксис фильтра поиска
description: Фильтры поиска позволяют определять условия поиска и предоставлять более эффективные и эффективные поисковые запросы.
ms.assetid: 3ce4709c-5ef7-4713-8fb7-b46ab284339f
ms.tgt_platform: multiple
keywords:
- Синтаксис фильтра поиска ADSI
- запросы, синтаксис фильтра поиска
ms.topic: article
ms.date: 09/25/2020
ms.openlocfilehash: 28875bd49a3d1df7418c37706e58852066bbe08a
ms.sourcegitcommit: d75fc10b9f0825bbe5ce5045c90d4045e3c53243
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/13/2021
ms.locfileid: "127172171"
---
# <a name="search-filter-syntax"></a>Синтаксис фильтра поиска

Фильтры поиска позволяют определять условия поиска и предоставлять более эффективные и эффективные поисковые запросы.

ADSI поддерживает фильтры поиска LDAP, как определено в RFC2254. Эти фильтры поиска представлены строками Юникода. В следующей таблице перечислены некоторые примеры фильтров поиска LDAP.



| Фильтр поиска                                                               | Описание                                                |
|-----------------------------------------------------------------------------|------------------------------------------------------------|
| "(objectClass = \* )"                                                          | Все объекты.                                               |
| "(& (objectCategory = Person) (objectClass = User) (! ( CN = Энди))) "                  | Все пользовательские объекты, но «Энди».                               |
| "(SN = SM \* )"                                                                 | Все объекты с фамилией, начинающейся с "SM".          |
| "(& (objectCategory = Person) (objectClass = Contact) ( \| (SN = Smith) (SN = Джонсон)))" | Все контакты с фамилией, равным "Иванов" или "Джонсон". |



 

Эти фильтры поиска используют один из следующих форматов.


```C++
<filter>=(<attribute><operator><value>)
```



или


```C++
(<operator><filter1><filter2>)
```



Фильтры поиска ADSI используются двумя способами. Они формируют часть диалекта LDAP для отправки запросов через поставщика OLE DB. Они также используются с интерфейсом [**IDirectorySearch**](/windows/desktop/api/Iads/nn-iads-idirectorysearch) .

## <a name="operators"></a>Операторы

В следующей таблице перечислены часто используемые операторы фильтра поиска.



| Логический оператор | Описание                                |
|------------------|--------------------------------------------|
| =                | Равно                                   |
| ~=               | Приблизительно равно                     |
| <=            | Лексикографически меньше или равно    |
| >=            | Лексикографически больше или равно |
| &                | AND                                        |
| \|               | OR                                         |
| !                | NOT                                        |



 

В дополнение к операторам, приведенным выше, LDAP определяет два сопоставления идентификаторов объектов правил (OID), которые можно использовать для побитового сравнения числовых значений. Правила сопоставления имеют следующий синтаксис.


```C++
<attribute name>:<matching rule OID>:=<value>
```



" &lt; имя атрибута &gt; " — это атрибут **lDAPDisplayName** атрибута, " &lt; rule OID &gt; " — OID для правила сопоставления, а " &lt; value &gt; " — это значение, используемое для сравнения. Имейте в виду, что в этой строке нельзя использовать пробелы. " &lt; значение &gt; " должно быть десятичным числом; оно не может быть шестнадцатеричным числом или постоянным именем, таким как " **\_ \_ \_ \_ Включение безопасности типа группы баннеров**". Дополнительные сведения о доступных атрибутах Active Directory см. в разделе [все атрибуты](/windows/desktop/ADSchema/attributes-all).

В следующей таблице перечислены идентификаторы объектов правил сопоставления, реализованные в LDAP.



| Идентификатор объекта правила сопоставления       | Идентификатор строки (из Нтлдап. h)   | Описание                                                                                                                                                                                   |
|-------------------------|-------------------------------------|-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| 1.2.840.113556.1.4.803  | **\_ \_ бит правила сопоставления \_ LDAP \_ и**  | Совпадение обнаруживается только в том случае, если все биты атрибута соответствуют значению. Это правило эквивалентно побитовому оператору **и** .                                                                  |
| 1.2.840.113556.1.4.804  | **\_ \_ бит правила сопоставления \_ LDAP \_ или**   | Совпадение обнаруживается, если все биты атрибута соответствуют значению. Это правило эквивалентно побитовому оператору **или** .                                                                        |
| 1.2.840.113556.1.4.1941 | **\_правило СОПОСТАВЛЕНИЯ \_ LDAP \_ в \_ цепочке** | Это правило ограничено фильтрами, применяемыми к DN. Это специальный расширенный оператор match, который просматривает цепочку происхождение в объектах до корня до тех пор, пока не обнаружит совпадение. |



 

В следующем примере строки запроса выполняется поиск объектов Group, для которых установлен флаг **\_ \_ \_ \_ включения безопасности типа группы ADS** . Имейте в виду, что для значения сравнения используется десятичное значение **\_ \_ \_ безопасности типа \_ группы ADS** (0x80000000 = 2147483648).


```C++
(&(objectCategory=group)(groupType:1.2.840.113556.1.4.803:=2147483648))
```



**\_ Правило сопоставления LDAP \_ \_ в \_ цепочке** — это идентификатор OID правила сопоставления, предназначенный для предоставления метода для поиска происхождение объекта. Многие приложения, использующие AD и AD LDS, обычно работают с иерархическими данными, упорядоченными по связям типа «родители-потомки». Ранее приложения выполнили расширение транзитивных групп, чтобы определить членство в группе, которое использовало слишком много пропускной способности сети. приложения, которые требовали несколько обращений для определения того, находился ли объект в цепочке в случае прохода по ссылке до конца.

Примером такого запроса является проверка того, является ли пользователь user1 членом группы "Group1". Необходимо задать для базы данных имя пользователя `(cn=user1, cn=users, dc=x)` и область `base` , а затем использовать следующий запрос.


```C++
(memberof:1.2.840.113556.1.4.1941:=cn=Group1,OU=groupsOU,DC=x)
```



Аналогично, чтобы найти все группы, членом которых является Пользователь1, установите базовое имя для контейнера групп. например `(OU=groupsOU, dc=x)` , и область `subtree` , и используйте следующий фильтр.


```C++
(member:1.2.840.113556.1.4.1941:=cn=user1,cn=users,DC=x)
```



Обратите внимание, что при использовании **\_ правила сопоставления LDAP \_ \_ в \_ цепочке** область ограниченна — это может быть `base` , `one-level` или `subtree` . Некоторые запросы к поддеревьям могут потребовать больше ресурсов процессора, таких как отслеживание ссылок с высоким уровнем их вращения. то есть список всех групп, членом которых является пользователь. При неэффективном поиске будут регистрироваться соответствующие сообщения журнала событий, как в случае любого другого типа запросов.

## <a name="wildcards"></a>подстановочные знаки;

В фильтр поиска LDAP также можно добавить подстановочные знаки и условия. В следующих примерах показаны подстроки, которые можно использовать для поиска в каталоге.

Получить все записи:


```C++
(objectClass=*)
```



Получение записей, содержащих "Bob" где-нибудь в общем имени:


```C++
(cn=*bob*)
```



Получить записи с общим именем, большим или равным "Bob":


```C++
(cn>='bob')
```



Получить всех пользователей с атрибутом email:


```C++
(&(objectClass=user)(email=*))
```



Получить все записи пользователей с атрибутом сообщения электронной почты и фамилией, равной Smith:


```C++
(&(sn=smith)(objectClass=user)(email=*))
```



Получить все записи пользователей с общим именем, которое начинается с "Энди", "Стив" или "Margaret":


```C++
(&(objectClass=user)(| (cn=andy*)(cn=steve*)(cn=margaret*)))
```



Получить все записи без атрибута email:


```C++
(!(email=*))
```



Формальное определение фильтра поиска выглядит следующим образом (из [RFC 2254](https://tools.ietf.org/html/rfc2254)):


```C++
<filter> ::= '(' <filtercomp> ')'
<filtercomp> ::= <and> | <or> | <not> | <item>
<and> ::= '&' <filterlist>
<or> ::= '|' <filterlist>
<not> ::= '!' <filter>
<filterlist> ::= <filter> | <filter> <filterlist>
<item>::= <simple> | <present> | <substring>
<simple> ::= <attr> <filtertype> <value><filtertype> ::= <equal> | <approx> | <ge> | <le>
<equal> ::= '='
<approx> ::= '~='
<ge> ::= '>='
<le> ::= '<='
<present> ::= <attr> '=*'
<substring> ::= <attr> '=' <initial> <any> <final>
<initial> ::= NULL | <value><any> ::= '*' <starval>
<starval> ::= NULL | <value>'*' <starval>
<final> ::= NULL | <value>
```



&lt;Attr токена &gt; — это строка, представляющая attributeType. &lt;Значение токена &gt; — это строка, представляющая значение AttributeValue, формат которого определяется базовой службой каталогов.

Если &lt; значение &gt; должно содержать символ звездочки ( \* ), открывающую круглую скобку (() или правую круглую скобку ()), перед символом должен стоять escape-символ обратной косой черты ( \\ ).

## <a name="special-characters"></a>Специальные символы

Если какой-либо из следующих специальных символов должен отображаться в фильтре поиска как литералы, они должны быть заменены указанной escape-последовательностью.



| Символ ASCII | Замена escape-последовательности |
|-----------------|----------------------------|
| \*              | \\2а                       |
| (               | \\8                       |
| )               | \\29                       |
| \\              | \\5c                       |
| NUL             | \\100,00                       |
| /               | \\2F                       |



 

> [!Note]  
> в случаях, когда используется многобайтовый набор символов, необходимо использовать escape-последовательности, перечисленные выше, если поиск выполняется ADO с использованием диалекта SQL.

 

Кроме того, произвольные двоичные данные могут быть представлены с помощью синтаксиса escape-последовательности путем кодирования каждого байта двоичных данных с помощью обратной косой черты ( \\ ), за которой следуют две шестнадцатеричные цифры. Например, 4-байтовый параметр 0x00000004 кодируется как \\ 00 \\ 00 \\ 00 \\ 04 в строке фильтра.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Диалект LDAP](ldap-dialect.md)
</dt> <dt>

[диалект SQL](sql-dialect.md)
</dt> <dt>

[Поиск с помощью интерфейса IDirectorySearch](searching-with-idirectorysearch.md)
</dt> <dt>

[поиск с помощью объекты данных ActiveX](searching-with-activex-data-objects-ado.md)
</dt> <dt>

[Поиск с помощью OLE DB](searching-with-ole-db.md)
</dt> </dl>

 

 
