---
title: Вопросы упаковки C-компилятора
description: Уровни упаковки влияют на компоновку памяти типов как для MIDL, так и для компилятора Microsoft C/C++ аналогичным образом.
ms.assetid: 029e2f68-e68f-4627-bdf0-889939d7d3c6
keywords:
- MIDL-компилятор MIDL, проблемы с упаковкой в компиляторе C
- Упаковка MIDL
- MIDL макета памяти
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 63c441439499d1a9b22e36c697ab6615f3292744
ms.sourcegitcommit: ebd3ce6908ff865f1ef66f2fc96769be0aad82e1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/19/2020
ms.locfileid: "103890576"
---
# <a name="c-compiler-packing-issues"></a>Вопросы упаковки C-компилятора

Уровни упаковки влияют на компоновку памяти типов как для MIDL, так и для компилятора Microsoft C/C++ аналогичным образом. В средах Microsoft Build, таких как среда сборки, определенная с помощью VC + + или пакета средств разработки программного обеспечения платформы (SDK), уровень упаковки по умолчанию для компиляторов MIDL и C/C++ не отличается. по умолчанию для 32-разрядных и 64-разрядных сред сборки Windows используется уровень упаковки 8.

## <a name="natural-alignment"></a>Естественное выравнивание

Для типов в памяти выравнивание по умолчанию аналогично его естественному выравниванию.

-   Базовый тип, например Short, float и \_ \_ Int64, и указатель выровнены естественным образом, если его представление начинается с адреса по модулю его размера. Все поддерживаемые в настоящее время базовые типы имеют размеры 1, 2, 4 или 8. Указатели имеют размер 4 в 32-разрядных средах и 8 в 64-разрядных средах.
-   Составной тип согласуется естественным образом, если каждый из его компонентов выровнен естественным образом относительно начала типа, и если между компонентами нет лишних пробелов (заполнений). Комплексные компоненты, такие как поля или элементы, рекурсируют на компоненты указателя или базового типа.

Простое правило, помогающее запомнить это поведение, заключается в том, что естественное выравнивание типа равно наибольшему выравниванию его компонентов.

Между выравниванием и размером памяти для типа в таких языках, как C или C++ и IDL, существует соединение, выраженное оператором **sizeof ()**. Размер является кратным выравниванию (минимально кратным охвату типа). Это следует за представлением массива в памяти.

Естественное выравнивание важно, так как доступ к невыровненным данным может вызвать исключение в некоторых системах. Данные могут быть помечены для безопасной манипуляции при неправильном согласовании, но обычно это подразумевает снижение скорости, которое может быть значительным на некоторых платформах.

> [!Note]  
> В памяти объекты типов с естественным выравниванием *n* гарантированно должны быть правильно выровнены при размещении по адресам, кратным *n*.

 

## <a name="packing-versus-alignment"></a>Упаковка и выравнивание

Задание уровня упаковки, превышающего естественное выравнивание типа, не изменяет выравнивание типа. Задание уровня упаковки меньше естественного выравнивания уменьшает выравнивание типа до уровня упаковки. В результате Упакованные типы могут размещаться в памяти по адресам, кратным уровню упаковки (сокращенное выравнивание), не вызывая неправильного выравнивания. Это влияет на простые типы и типы компонентов. Для составных типов может быть затронуто внутренняя структура типа, так как уменьшение выравнивания компонентов может изменить размер заполнения, необходимый для правильного выравнивания компонентов, таким образом уменьшая размер типа.

Простое правило, помогающее запомнить это поведение, заключается в том, что новое выравнивание упакованного типа меньше уровня упаковки и его естественного выравнивания. Размер типа является кратным новому выравниванию. Оператор **sizeof ()** Возвращает уменьшенный размер упакованных типов.

Например, если уровень упаковки 2 является длинным, он выравнивается по 2 и, следовательно, может быть размещен на любом четном адресе, а не только на адресах, кратных 4, как при естественном выравнивании. Для структуры с коротким и длинным, упакованным в 2, не требуется внутренний зазор между коротким и длительным временем, который был необходим для естественного выравнивания. Следовательно, не только структура, выравниваемая по отношению к 2, также имеет размер, уменьшенный с 8 до 6.

В качестве примера рассмотрим составной тип, состоящий из 1-байтного символа, целого числа 4 байт и 1-байтового символа:

``` syntax
struct mystructtype 
{    
    char c1;  /* requires 1 byte  */
              /* 3 bytes of padding with natural alignment only */
    long l2;  /* requires 4 bytes */
    char c3;  /* requires 1 byte  */
              /* 3 bytes of padding with natural alignment only */
 } mystruct;
```

Эта структура естественным образом выровнена по 4 и имеет натуральный размер 12.

Для уровня упаковки 4 или выше структура **MyStruct** соответствует 4 и `sizeof(struct mystructtype)` равна 12. Структура будет неправильно согласована, если она находится в памяти по адресу, не кратному 4.

Для уровня упаковки 2 Структура выровняться по 2, а ее размер — 8. Структура, упакованная с уровнем 2, будет неправильно согласована, если она находится в памяти по адресу, не кратному 2.

Для уровня упаковки 1 структура соответствует 1, а ее размер — 6. Структуру, упакованную с уровнем 1, можно разместить в любом месте, не вызывая ошибки выравнивания.

## <a name="related-topics"></a>См. также

<dl> <dt>


</dt> <dt>

[/ZP](./-zp.md)
</dt> <dt>

[/Pack](./-pack.md)
</dt> </dl>

 

 