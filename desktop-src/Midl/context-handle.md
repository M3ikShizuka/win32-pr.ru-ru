---
title: атрибут context_handle
description: Атрибут \ context \_ Handle \ определяет маркер привязки, который сохраняет контекст или сведения о состоянии на сервере между вызовами удаленных процедур.
ms.assetid: ab1aee44-4add-4816-a7ef-38bbf7b38918
keywords:
- context_handle атрибута MIDL
topic_type:
- apiref
api_name:
- context_handle
api_type:
- NA
ms.topic: reference
ms.date: 05/31/2018
ms.openlocfilehash: d71c47554454118d584110ec43211a302e12cd77
ms.sourcegitcommit: ebd3ce6908ff865f1ef66f2fc96769be0aad82e1
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/19/2020
ms.locfileid: "103789870"
---
# <a name="context_handle-attribute"></a>\_атрибут Handle контекста

Атрибут **\[ \_ Handle \] контекста** определяет маркер привязки, который сохраняет контекст или сведения о состоянии на сервере между вызовами удаленных процедур.

``` syntax
typedef [context_handle [ , type-attribute-list ] ] type-specifier declarator-list;

[context_handle [, function-attr-list ] ] type-specifier [ptr-decl] function-name(
    [ [parameter-attribute-list] ] type-specifier [declarator], ...);

[ [ function-attr-list ] ] type-specifier [ ptr-decl ] function-name(
    [context_handle [ , parameter-attribute-list ] ] type-specifier [declarator], ...);

[ void __RPC_USER context-handle-type_rundown (
  context-handle-type); ]
```

## <a name="parameters"></a>Параметры

<dl> <dt>

*Type-Attribute-List* 
</dt> <dd>

Указывает один или несколько атрибутов, применяемых к типу.

</dd> <dt>

*Описатель типа* 
</dt> <dd>

Указывает тип указателя или идентификатор типа. Дополнительная спецификация хранилища может предшествовать *спецификатору типа*.

</dd> <dt>

*декларатор и декларатор-список* 
</dt> <dd>

Задает стандартные деклараторы C, такие как идентификаторы, деклараторы указателей и деклараторы массивов. Декларатор для обработчика контекста должен включать хотя бы один декларатор указателя. Дополнительные сведения см. в разделе [атрибуты Array и Sized-Pointer](array-and-sized-pointer-attributes.md), [**массивы**](arrays-1.md), [массивы и указатели](/windows/desktop/Rpc/arrays-and-pointers). *Список деклараторов* состоит из одного или нескольких деклараторов, разделенных запятыми. Идентификатор параметра-Name в деклараторе функции является необязательным.

</dd> <dt>

*Function-attr-список* 
</dt> <dd>

Указывает ноль или более атрибутов, которые применяются к функции. Допустимые атрибуты функции — **\[** [**обратный вызов**](callback.md) **\]** , **\[** [**локальный**](local.md) **\]** объект, атрибут указателя **\[** [**ref**](ref.md) **\]** , **\[** [**UNIQUE**](unique.md) **\]** или **\[** [**ptr**](ptr.md) **\]** ; и атрибуты использования **\[** [**строка**](string.md) **\]** , **\[** [**Ignore**](ignore.md) **\]** и **\[ Контекстный \_ маркер \]**.

</dd> <dt>

*PTR-decl* 
</dt> <dd>

Указывает ноль или несколько деклараторов указателей. Декларатор указателя аналогичен декларатору указателя, используемому в C; Он создается из **\*** указателя, модификаторов, таких как **FAR**, и квалификатора [**const**](const.md).

</dd> <dt>

*имя функции* 
</dt> <dd>

Задает имя удаленной процедуры.

</dd> <dt>

*Parameter-список атрибутов* 
</dt> <dd>

Указывает ноль или более атрибутов направления, атрибутов полей, атрибутов использования и атрибутов указателя, подходящих для указанного типа параметра. Несколько атрибутов разделяются запятыми.

</dd> <dt>

*Контекстный-Handle-тип* 
</dt> <dd>

Задает идентификатор, указывающий тип обработчика контекста, определенный в объявлении [**typedef**](typedef.md) , который принимает атрибут **\[ \_ Handle \]** . Подпрограммы очистки являются необязательными.

**Windows server 2003 и Windows XP:** Один интерфейс может разрешать как сериализованные, так и несериализованные дескрипторы контекста, что позволяет одному методу интерфейса получить доступ к дескриптору контекста исключительно (сериализованный), а другие методы — к этому дескриптору контекста в общем режиме (не сериализованном). Эти возможности доступа сравнимы с механизмами блокировки чтения и записи. методы, использующие сериализованный контекстный маркер, являются эксклюзивными пользователями (модулями записи), тогда как методы, использующие несериализованный контекст контекста, являются общими пользователями (читателями). Методы, которые удаляют или изменяют состояние обработчика контекста, должны быть сериализованы. Методы, которые не изменяют состояние маркера контекста, например методы, которые просто считывают из обработчика контекста, могут быть несериализуемыми. Обратите внимание, что методы создания неявно сериализуются.

</dd> </dl>

## <a name="remarks"></a>Комментарии

Атрибут **\[ \_ Handle \] контекста** может отображаться как атрибут типа IDL [**typedef**](typedef.md) , как атрибут типа возвращаемого значения функции, или как атрибут параметра. При применении атрибута **\[ \_ Handle \] контекста** к определению типа необходимо также предоставить подпрограммы очистки контекста. Дополнительные сведения см. в разделе [контекст запуска для сервера](/windows/desktop/Rpc/server-context-run-down-routine) .

При использовании компилятора MIDL в режиме по умолчанию ([**/МС \_ ext**](-ms-ext.md)) дескриптор контекста может быть любым типом указателя, выбранным пользователем, при условии, что он соответствует требованиям для дескрипторов контекста, описанных здесь. Данные, связанные с таким типом обработчика контекста, не передаются в сети и должны управляться только серверным приложением. Компиляторы DCE IDL ограничивают дескрипторы контекста указателями типа [**void**](void.md) **\*** . Поэтому эта функция недоступна при использовании параметра компилятора MIDL [**/ОСФ**](-osf.md) .

Как и в случае с другими типами обработчиков, маркер контекста непрозрачен для клиентского приложения, и все связанные с ним данные не передаются. На сервере обработчик контекста служит в качестве маркера для активного контекста, и все данные, связанные с типом обработчика контекста, доступны.

Чтобы создать маркер контекста, клиент передает на сервер **\[** [](out-idl.md) **\]** указатель out, **\[** [**ref**](ref.md) , **\]** на маркер контекста. (Сам обработчик контекста может иметь значение **null** или не **null** , если его значение согласуется с атрибутами указателя. Например, если к типу обработчика контекста **\[** [](ref.md) **\]** применен атрибут ref, он не может иметь значение **null** .) Для выполнения привязки необходимо указать другой маркер привязки, пока не будет создан маркер контекста. Если явный маркер не указан, используется неявная привязка. Если **\[** [**неявный атрибут \_ Handle**](implicit-handle.md) отсутствует **\]** , используется автоматический обработчик.

Удаленная процедура на сервере создает Активный обработчик контекста. Клиент должен использовать этот обработчик контекста в качестве параметра **\[** [**in**](in.md) **\]** или **\[ in**, **out \]** в последующих вызовах. **\[ В \]** качестве маркера привязки можно использовать только описатель контекста, который должен иметь значение, отличное от **null** . Обработчик контекста только **\[ в \]** режиме не отражает изменения состояния на сервере.

На сервере вызываемая процедура может интерпретировать обработчик контекста по мере необходимости. Например, вызываемая процедура может выделить хранилище кучи и использовать контекстный маркер в качестве указателя на это хранилище.

Чтобы закрыть контекстный маркер, клиент передает контекст контекста как **\[** [](in.md) **\]** **\[** аргумент [**out**](out-idl.md) **\]** . Сервер должен вернуть **нулевой** обработчик контекста, когда он больше не обслуживает контекст от имени вызывающего. Например, если контекстный обработчик представляет открытый файл, а вызов закрывает файл, сервер должен установить для контекста **значение NULL** и вернуть его клиенту. Значение **null** в качестве маркера привязки для последующих вызовов является недопустимым.

Маркер контекста допустим только для одного сервера. Если функция имеет два параметра дескриптора и дескриптор контекста не равен **null**, дескрипторы привязки должны ссылаться на одно и то же адресное пространство.

Если у функции есть **\[** [](in.md) **\]** обработчик контекста in или **\[ in**, **\]** его контекстный обработчик может использоваться в качестве маркера привязки. В этом случае неявная привязка не используется, и атрибут **\[** [**неявного \_**](implicit-handle.md) **\]** или **\[** [**автоматического \_ обработчика**](auto-handle.md) **\]** игнорируется.

К дескрипторам контекста применяются следующие ограничения.

-   Дескрипторы контекста не могут быть элементами массива, членами структуры или членами объединения. Они могут быть только параметрами.
-   Дескрипторы контекста не могут иметь атрибут " **\[** [**передать \_ как**](transmit-as.md) " **\]** или " **\[** [**представить \_ как**](represent-as.md) " **\]** .
-   Параметры, являющиеся указателями **\[** [**на**](out-idl.md) **\]** дескрипторы контекста, должны быть **\[** [**ссылками на REF**](ref.md) **\]** .
-   **\[** [**В**](in.md) **\]** качестве маркера привязки можно использовать маркер контекста, который не может иметь **значение NULL**.
-   **\[ В** входном обработчике контекста может быть **значение NULL** , но только в том [**случае, если**](out-idl.md) процедура имеет другой явный параметр Handle. Если нет других явных параметров обработчика контекста, отличных от **null** , **\[ то обработчик** контекста **\] out** не может иметь **значение NULL**.
-   Описатель контекста не может использоваться с обратными вызовами.

## <a name="examples"></a>Примеры

``` syntax
typedef [context_handle] void * PCONTEXT_HANDLE_TYPE; 
short RemoteFunc1([out] PCONTEXT_HANDLE_TYPE * pCxHandle); 
short RemoteFunc2([in, out] PCONTEXT_HANDLE_TYPE * pCxHandle); 
void __RPC_USER PCONTEXT_HANDLE_TYPE_rundown (PCONTEXT_HANDLE_TYPE);
```

## <a name="see-also"></a>См. также раздел

<dl> <dt>

[**массивы**](arrays-1.md)
</dt> <dt>

[**Автоматическая \_ работа**](auto-handle.md)
</dt> <dt>

[**обратный вызов**](callback.md)
</dt> <dt>

[Сброс контекста клиента](/windows/desktop/Rpc/client-context-reset)
</dt> <dt>

[**const**](const.md)
</dt> <dt>

[Дескрипторы контекста](/windows/desktop/Rpc/context-handles)
</dt> <dt>

[**справиться**](handle.md)
</dt> <dt>

[Привязка и дескрипторы](/windows/desktop/Rpc/binding-and-handles)
</dt> <dt>

[**обращать**](ignore.md)
</dt> <dt>

[**неявный \_ обработчик**](implicit-handle.md)
</dt> <dt>

[**окне**](in.md)
</dt> <dt>

[**Языковые**](local.md)
</dt> <dt>

[Многопоточные клиенты и дескрипторы контекста](/windows/desktop/Rpc/multithreaded-clients-and-context-handles)
</dt> <dt>

[**/МС \_ ext**](-ms-ext.md)
</dt> <dt>

[**заполняет**](out-idl.md)
</dt> <dt>

[**ptr**](ptr.md)
</dt> <dt>

[**ref**](ref.md)
</dt> <dt>

[**представлять \_ как**](represent-as.md)
</dt> <dt>

[**рпкссдестройклиентконтекст**](/windows/desktop/api/rpcndr/nf-rpcndr-rpcssdestroyclientcontext)
</dt> <dt>

[Подпрограммы запуска контекста сервера](/windows/desktop/Rpc/server-context-run-down-routine)
</dt> <dt>

[**Строка**](string.md)
</dt> <dt>

[**передать \_ как**](transmit-as.md)
</dt> <dt>

[**определение**](typedef.md)
</dt> <dt>

[**однозначно**](unique.md)
</dt> <dt>

[**void**](void.md)
</dt> </dl>

 

 