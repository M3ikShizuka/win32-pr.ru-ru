---
title: Управляющие сообщения
description: В этом разделе содержатся сведения о том, как сообщения Windows используются для взаимодействия с элементами управления.
ms.assetid: 94d34132-25c2-4a1a-bd0e-35e5a666bbfa
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 923a1b47d625a2797a900a6c582d00c5169097f3
ms.sourcegitcommit: 8fa6614b715bddf14648cce36d2df22e5232801a
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/10/2020
ms.locfileid: "103891297"
---
# <a name="control-messages"></a>Управляющие сообщения

В этом разделе содержатся сведения о том, как сообщения Windows используются для взаимодействия с элементами управления.

Обсуждаются следующие темы.

-   [Сообщения для стандартных элементов управления](#messages-to-common-controls)
-   [Уведомления из элементов управления](#notifications-from-controls)
-   [См. также](#related-topics)

## <a name="messages-to-common-controls"></a>Сообщения для стандартных элементов управления

Так как стандартные элементы управления — Windows, приложение может взаимодействовать с ними с помощью общих сообщений Microsoft Win32, таких как [**WM- \_ Font**](/windows/desktop/winmsg/wm-getfont) или [**WM \_ SETTEXT**](/windows/desktop/winmsg/wm-settext). Кроме того, класс окон для каждого стандартного элемента управления поддерживает набор сообщений, относящихся к конкретному элементу управления. Как правило, приложение использует [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) или [**сенддлгитеммессаже**](/windows/desktop/api/winuser/nf-winuser-senddlgitemmessagea) для передачи сообщений элементу управления (часто получение сведений в возвращаемом значении).

Некоторые стандартные элементы управления также имеют набор макросов, которые приложение может использовать вместо [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage). Как правило, макросы проще использовать, чем функции. Следующий пример кода извлекает текст выбранного элемента представления дерева, сначала с помощью необработанных сообщений, а второй — с помощью эквивалентных макросов. Предположим, *HWND* является дескриптором окна управления.


```
BOOL fSuccess;
WCHAR itemText[99];
TVITEM tvItem = { 0 };
tvItem.mask = TVIF_TEXT;
tvItem.cchTextMax = ARRAYSIZE(itemText);
tvItem.pszText = itemText;

// This...
tvItem.hItem = (HTREEITEM)SendMessage(hwnd, TVM_GETNEXTITEM, TVGN_CARET, NULL);
fSuccess = SendMessage(hwnd, TVM_GETITEM, 0, (LPARAM)&tvItem);

// ... is equivalent to this.
tvItem.hItem = TreeView_GetSelection(hwnd);
fSuccess = TreeView_GetItem(hwnd, &tvItem);
```



При внесении изменений в параметры системного цвета Windows отправляет сообщение [**WM \_ сисколорчанже**](/windows/desktop/gdi/wm-syscolorchange) всем окнам верхнего уровня. Окно верхнего уровня должно пересылать сообщение **\_ сисколорчанже WM** в общие элементы управления. в противном случае элементы управления не будут уведомлены об изменении цвета. Пересылка сообщения гарантирует, что цвета, используемые общими элементами управления, будут соответствовать значениям, используемым другими объектами пользовательского интерфейса. Например, элемент управления ToolBar использует цвет "трехмерные объекты" для рисования своих кнопок. Если пользователь изменяет цвет трехмерного объекта, но сообщение **WM \_ сисколорчанже** не пересылается на панель инструментов, кнопки панели инструментов останутся в исходном цвете (или даже меняются на сочетание старого и нового цветов), а цвет других кнопок в системе изменится.

## <a name="notifications-from-controls"></a>Уведомления из элементов управления

Элементы управления являются дочерними окнами, которые отправляют сообщения уведомления родительскому окну, когда события, обычно активируемые вводом от пользователя, происходят в элементе управления. Приложение использует эти уведомления для определения действия, которое пользователь хочет предпринять. За исключением TrackBar, использующих [**сообщения \_ WM HSCROLL**](wm-hscroll.md) и [**WM \_ VSCROLL**](wm-vscroll.md) для уведомления родительского элемента об изменениях, общие элементы управления отправляют уведомления в виде [**\_ команды WM**](/windows/desktop/menurc/wm-command) или [**\_ уведомления WM notify**](wm-notify.md) , как указано в справочном разделе по уведомлению. Как правило, более старые уведомления (те, которые были в API в течение длительного времени) используют **\_ команду WM**.

Параметр *lParam* для [**WM \_ Notify**](wm-notify.md) является адресом структуры [**NMHDR**](/windows/desktop/api/richedit/ns-richedit-nmhdr) или адресом более крупной структуры, включающей **NMHDR** в качестве первого элемента. Структура содержит код уведомления и определяет общий элемент управления, который отправил сообщение уведомления. Значение остальных элементов структуры, если таковое имеется, зависит от кода уведомления.

Каждый тип общего элемента управления имеет соответствующий набор кодов уведомления. Общая библиотека элементов управления также предоставляет коды уведомлений, которые могут быть отправлены более чем одним типом общего элемента управления. Чтобы определить, какие коды уведомлений будут отправлены и какой формат они принимают, см. документацию по интересующему вас контролю.

Пример кода, демонстрирующий обработку сообщений [**WM \_ Notify**](wm-notify.md) , см. в справочном разделе по этому сообщению.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Справочник по общим элементам управления](common-control-reference.md)
</dt> </dl>

 

 
