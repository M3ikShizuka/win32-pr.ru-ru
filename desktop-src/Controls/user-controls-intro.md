---
title: Пользовательские элементы управления
description: В этом разделе содержатся сведения об определяемых приложением или пользовательских элементах управления.
ms.assetid: 220f7058-db04-46d0-acee-ed5e676790b3
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 12d1a31a44f1f71d99088f7729c2de6d5fdb597e14507f5f994dfaca1b96613d
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "120059714"
---
# <a name="custom-controls"></a>Пользовательские элементы управления

В этом разделе содержатся сведения об определяемых приложением или пользовательских элементах управления.

Обсуждаются следующие темы.

-   [Создание элементов управления Owner-Drawn](#creating-owner-drawn-controls)
-   [Подклассировать класс окна существующего элемента управления](#subclassing-the-window-class-of-an-existing-control)
-   [Реализация класса окна Application-Defined](#implementing-an-application-defined-window-class)
-   [Отправка уведомлений из элемента управления](#sending-notifications-from-a-control)
-   [Специальные возможности](#accessibility)
-   [Связанные темы](#related-topics)

## <a name="creating-owner-drawn-controls"></a>Создание элементов управления Owner-Drawn

Кнопки, меню, статические текстовые элементы управления, списки и поля со списком можно создавать с помощью флага стиля, рисуемого владельцем. Когда элемент управления имеет стиль, рисуемый владельцем, система обрабатывает взаимодействие пользователя с элементом управления обычным образом, выполняя такие задачи, как обнаружение того, когда пользователь выбрал кнопку, и уведомляет ее владельца о событии. Однако, поскольку элемент управления нарисован владельцем, родительское окно элемента управления отвечает за визуальный внешний вид элемента управления. Родительское окно получает сообщение, когда должен быть нарисован элемент управления.

Для кнопок и статических текстовых элементов управления стиль, рисуемый владельцем, влияет на то, как система рисует весь элемент управления. Для списков и полей со списком родительское окно рисует элементы внутри элемента управления, и элемент управления рисует свою собственную структуру. Например, приложение может настроить окно списка таким образом, чтобы оно отображало небольшое точечное изображение рядом с каждым элементом в списке.

В следующем примере кода показано, как создать элемент управления "статический текст", рисуемый владельцем. Предположим, что задан Юникод.


```
// g_myStatic is a global HWND variable.
g_myStatic = CreateWindowEx(0, L"STATIC", L"Some static text", 
            WS_CHILD | WS_VISIBLE | SS_OWNERDRAW, 
            25, 125, 150, 20, hDlg, 0, 0, 0);
```



В следующем примере из процедуры окна для диалогового окна, содержащего элемент управления, созданный в предыдущем примере, сообщение [**WM \_ DRAWITEM**](wm-drawitem.md) обрабатывается путем отображения текста в пользовательском цвете с использованием шрифта по умолчанию. Обратите внимание, что при обработке **WM \_ DRAWITEM** не нужно вызывать [**бегинпаинт**](/windows/desktop/api/winuser/nf-winuser-beginpaint) и [**ендпаинт**](/windows/desktop/api/winuser/nf-winuser-endpaint) .


```
case WM_DRAWITEM:
{
    LPDRAWITEMSTRUCT pDIS = (LPDRAWITEMSTRUCT)lParam;
    if (pDIS->hwndItem == g_myStatic)
    {
        SetTextColor(pDIS->hDC, RGB(100, 0, 100));
        WCHAR staticText[99];
        int len = SendMessage(myStatic, WM_GETTEXT, 
            ARRAYSIZE(staticText), (LPARAM)staticText);
        TextOut(pDIS->hDC, pDIS->rcItem.left, pDIS->rcItem.top, staticText, len);
    }
    return TRUE;
}
```



Дополнительные сведения об элементах управления, рисуемых владельцем, см. [в разделе Создание рисуемых владельцем списков](using-list-boxes.md) и [созданных владельцем полей со](about-combo-boxes.md)списками.

## <a name="subclassing-the-window-class-of-an-existing-control"></a>Подклассировать класс окна существующего элемента управления

Создание пользовательского элемента управления с помощью подкласса существующего элемента управления является еще одним способом. Процедура подкласса может изменить выбранные поведения элемента управления, обрабатывая эти сообщения, влияющие на выбранные поведения. Все остальные сообщения передаются в исходную процедуру окна для элемента управления. Например, приложение может отображать небольшое точечное изображение рядом с текстом в однострочном элементе управления "поле ввода" только для чтения, подклассом элемента управления и обрабатывая сообщение [**WM \_ Paint**](/windows/desktop/gdi/wm-paint) . Дополнительные сведения см. в разделе [сведения о процедурах окон](/windows/desktop/winmsg/about-window-procedures) и [подклассах элементов управления](subclassing-overview.md).

## <a name="implementing-an-application-defined-window-class"></a>Реализация класса окна Application-Defined

Чтобы создать элемент управления, который явно не основан на существующем элементе управления, приложение должно создать и зарегистрировать класс окна. Процесс регистрации определяемого приложением класса окна для пользовательского элемента управления аналогичен регистрации класса для обычного окна. Чтобы создать пользовательский элемент управления, укажите имя класса окна в функции [**CreateWindowEx**](/windows/desktop/api/winuser/nf-winuser-createwindowexa) или в шаблоне диалогового окна. Каждый класс должен иметь уникальное имя, соответствующую процедуру окна и другие сведения.

Как минимум, оконная процедура рисует элемент управления. Если приложение использует элемент управления для получения сведений о типе пользователя, то процедура окна также обрабатывает входные сообщения с клавиатуры и мыши и отправляет сообщения уведомления родительскому окну. Кроме того, если элемент управления поддерживает управляющие сообщения, то процедура окна обрабатывает сообщения, отправленные ей родительским окном или другими окнами. Например, элементы управления часто обрабатывают сообщение [**WM \_ жетдлгкоде**](/windows/desktop/dlgbox/wm-getdlgcode) , отправленное в диалоговых окнах, чтобы направлять диалоговое окно для обработки ввода с клавиатуры определенным способом.

Процедура окна для элемента управления, определяемого приложением, должна обрабатывать любое предопределенное управляющее сообщение в следующей таблице, если оно влияет на работу элемента управления.



| Message                                          | Рекомендация                                                                                                                                                                                                                                  |
|--------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [**WM \_ жетдлгкоде**](/windows/desktop/dlgbox/wm-getdlgcode)       | Обработка, если в элементе управления используются клавиши ВВОД, ESC, ТАБУЛЯЦИя или стрелка. Функция [**исдиалогмессаже**](/windows/desktop/api/winuser/nf-winuser-isdialogmessagea) отправляет это сообщение элементам управления в диалоговом окне, чтобы определить, следует ли обрабатывать ключи или передавать их в элемент управления. |
| [**WM, \_ Шрифт**](/windows/desktop/winmsg/wm-getfont)             | Обработка, если сообщение [**WM \_ сетфонт**](/windows/desktop/winmsg/wm-setfont) также обработано.                                                                                                                                                                  |
| [**WM \_ gettext**](/windows/desktop/winmsg/wm-gettext)             | Обработка, если текст элемента управления отличается от заголовка, указанного функцией [**CreateWindowEx**](/windows/desktop/api/winuser/nf-winuser-createwindowexa) .                                                                                                                 |
| [**WM \_ жеттекстленгс**](/windows/desktop/winmsg/wm-gettextlength) | Обработка, если текст элемента управления отличается от заголовка, указанного функцией [**CreateWindowEx**](/windows/desktop/api/winuser/nf-winuser-createwindowexa) .                                                                                                                 |
| [**WM \_ киллфокус**](/windows/desktop/inputdev/wm-killfocus)       | Обработка, если элемент управления отображает курсор, прямоугольник фокуса или другой элемент, чтобы показать, что он имеет фокус ввода.                                                                                                                            |
| [**WM \_ SETFOCUS**](/windows/desktop/inputdev/wm-setfocus)         | Обработка, если элемент управления отображает курсор, прямоугольник фокуса или другой элемент, чтобы показать, что он имеет фокус ввода.                                                                                                                            |
| [**WM \_ SETTEXT**](/windows/desktop/winmsg/wm-settext)             | Обработка, если текст элемента управления отличается от заголовка, указанного функцией [**CreateWindowEx**](/windows/desktop/api/winuser/nf-winuser-createwindowexa) .                                                                                                                 |
| [**WM \_ сетфонт**](/windows/desktop/winmsg/wm-setfont)             | Обработка, если элемент управления отображает текст. Система отправляет это сообщение при создании диалогового окна, имеющего \_ стиль сетфонт для DS.                                                                                                                  |



 

Определяемые приложением управляющие сообщения относятся к заданному элементу управления и должны быть явно отправлены в элемент управления с помощью функции [**SendMessage**](/windows/desktop/api/winuser/nf-winuser-sendmessage) или [**сенддлгитеммессаже**](/windows/desktop/api/winuser/nf-winuser-senddlgitemmessagea) . Числовое значение для каждого сообщения должно быть уникальным и не должно конфликтовать со значениями других оконных сообщений. Чтобы гарантировать, что определяемые приложением значения сообщений не конфликтуют, приложение должно создать каждое значение, добавив уникальный номер к значению [**\_ пользователя WM**](/windows/desktop/winmsg/wm-user) .

## <a name="sending-notifications-from-a-control"></a>Отправка уведомлений из элемента управления

Пользовательские элементы управления могут потребоваться для отправки уведомлений о событиях в родительское окно, чтобы ведущее приложение могло отвечать на эти события. Например, пользовательское представление списка может отправить уведомление, когда пользователь выберет элемент, и другое уведомление при двойном щелчке элемента.

Уведомления отправляются с сообщением [**\_ команды WM**](/windows/desktop/menurc/wm-command) или [**\_ уведомления WM**](wm-notify.md) . **WM \_ УВЕДОМЛЕНИЯ о** сообщениях содержат больше информации, чем **\_ Командные сообщения WM** .

Идентификатор элемента управления — это уникальный номер, который приложение использует для идентификации элемента управления, отправляющего сообщение. Приложение задает идентификатор элемента управления при создании элемента управления. Приложение указывает идентификатор либо в параметре *HMENU* функции [**CreateWindowEx**](/windows/desktop/api/winuser/nf-winuser-createwindowexa) , либо в элементе **ID** структуры [**длгитемтемплатикс**](/windows/desktop/dlgbox/dlgitemtemplateex) .

Так как сам элемент управления не задает идентификатор элемента управления, элемент управления должен получить идентификатор, прежде чем он сможет отправить сообщения уведомления. Элемент управления должен использовать функцию [**жетдлгктрлид**](/windows/desktop/api/winuser/nf-winuser-getdlgctrlid) для получения собственного идентификатора элемента управления. Хотя идентификатор элемента управления указывается в виде маркера меню при создании элемента управления, функцию [**Menu**](/windows/desktop/api/winuser/nf-winuser-getmenu) нельзя использовать для получения идентификатора. Кроме того, элемент управления может извлечь идентификатор из члена **HMENU** в структуре [**CREATESTRUCT**](/windows/win32/api/winuser/ns-winuser-createstructa) при обработке сообщения о [**\_ создании WM**](/windows/desktop/winmsg/wm-create) .

В следующих примерах, где *хвндконтрол* — это маркер окна управления, а CN \_ VALUECHANGED — пользовательское определение уведомления, покажите два способа отправки уведомления, относящихся к конкретному элементу управления.


```
 // Send as WM_COMMAND.
SendMessage(GetParent(hwndControl), 
    WM_COMMAND,
    MAKEWPARAM(GetDlgCtrlID(hwndControl), CN_VALUECHANGED),
    (LPARAM)hwndControl);

// Send as WM_NOTIFY.           
NMHDR nmh;
nmh.code = CN_VALUECHANGED;
nmh.idFrom = GetDlgCtrlID(hwndControl);
nmh.hwndFrom = hwndControl;
SendMessage(GetParent(hwndControl), 
    WM_NOTIFY, 
    (WPARAM)hwndControl, 
    (LPARAM)&nmh);
```



Обратите внимание, что структура [**NMHDR**](/windows/desktop/api/richedit/ns-richedit-nmhdr) может быть частью более крупной, определяемой элементом управления структуры, содержащей дополнительные сведения. В этом примере старые и новые значения элемента управления могут содержаться в этой структуре. (Такие расширенные структуры используются со многими стандартными уведомлениями. Например, см. раздел [ЛВН \_ INSERTITEM](lvn-insertitem.md), в котором используется структура [**нмлиствиев**](/windows/win32/api/commctrl/ns-commctrl-nmlistview) .)

## <a name="accessibility"></a>Специальные возможности

Все общие элементы управления поддерживают Microsoft Active Accessibility (MSAA), который обеспечивает программный доступ к приложениям с поддержкой специальных возможностей, таким как средства чтения с экрана. MSAA также обеспечивает автоматизацию пользовательского интерфейса, более новую технологию, для взаимодействия с элементами управления.

Пользовательские элементы управления должны реализовывать интерфейс [**IAccessible**](/windows/desktop/api/oleacc/nn-oleacc-iaccessible) (для поддержки MSAA) или интерфейсы модели автоматизации пользовательского интерфейса, или и то, и другое. В противном случае программные продукты, доступные для работы с технологиями, смогут получить только очень ограниченные сведения об окне управления, не будут иметь доступа к свойствам элемента управления и не смогут активировать события в элементе управления.

дополнительные сведения о том, как сделать элемент управления доступным, см. в разделе [Windows API автоматизации](/windows/desktop/WinAuto/windows-automation-api-portal).

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

**Зрения**
</dt> <dt>

[Справочник по общим элементам управления](common-control-reference.md)
</dt> <dt>

[Настройка внешнего вида элемента управления с помощью пользовательского рисования](custom-draw.md)
</dt> <dt>

[Управляющие сообщения](control-messages.md)
</dt> <dt>

[Использование стилей оформления с элементами управления Owner-Drawn](using-visual-styles.md)
</dt> </dl>

 

 