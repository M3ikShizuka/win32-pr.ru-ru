---
title: Подклассировать элементы управления
description: Если элемент управления выполняет практически все необходимые действия, но вам нужны еще несколько функций, можно изменить или добавить компоненты в исходный элемент управления, добавив в него подкласс.
ms.assetid: 7f558674-c8b2-4461-96ba-e139416b7a1c
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2f2e338deca61c4aac07fca431e77492f53f168540cfbbcf7596b8540ba5369f
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118168584"
---
# <a name="subclassing-controls"></a>Подклассировать элементы управления

Если элемент управления выполняет практически все необходимые действия, но вам нужны еще несколько функций, можно изменить или добавить компоненты в исходный элемент управления, добавив в него подкласс. Подкласс может иметь все функции существующего класса, а также любые дополнительные функции, которые вы хотите предоставить.

В этом документе рассматривается создание подклассов и включает в себя следующие разделы.

-   [Подклассировать элементы управления до ComCtl32.dll версии 6](#subclassing-controls-prior-to-comctl32dll-version-6)
    -   [Хранение пользовательских данных](#storing-user-data)
    -   [Недостатки старого подхода к подклассам](#disadvantages-of-the-old-subclassing-approach)
-   [Подклассировать элементы управления с помощью ComCtl32.dll версии 6](#subclassing-controls-using-comctl32dll-version-6)
    -   [сетвиндовсубкласс](#setwindowsubclass)
    -   [жетвиндовсубкласс](#getwindowsubclass)
    -   [ремовевиндовсубкласс](#removewindowsubclass)
    -   [дефсубкласспрок](#defsubclassproc)

## <a name="subclassing-controls-prior-to-comctl32dll-version-6"></a>Подклассировать элементы управления до ComCtl32.dll версии 6

Можно разместить элемент управления в подклассе и сохранить данные пользователя в элементе управления. Это делается при использовании версий ComCtl32.dll до версии 6. Существуют некоторые недостатки создания подклассов с более ранними версиями ComCtl32.dll.

чтобы создать новый элемент управления, лучше всего начать с одного из Windows стандартных элементов управления и расширить его в соответствии с конкретной потребностью. Чтобы расширить элемент управления, создайте элемент управления и замените его существующую процедуру окна новой. Новая процедура перехватывает сообщения элемента управления и либо обрабатывает их, либо передает их в исходную процедуру для обработки по умолчанию. Используйте функцию [**SetWindowLong**](/windows/desktop/api/winuser/nf-winuser-setwindowlonga) или [**сетвиндовлонгптр**](/windows/desktop/api/winuser/nf-winuser-setwindowlongptra) , чтобы заменить WndProc элемента управления. В следующем примере кода показано, как заменить WNDPROC.


```
OldWndProc = (WNDPROC)SetWindowLongPtr (hButton,
GWLP_WNDPROC, (LONG_PTR)NewWndProc);
```



### <a name="storing-user-data"></a>Хранение пользовательских данных

Может потребоваться сохранить данные пользователя в отдельном окне. Эти данные могут использоваться новой процедурой окна для определения способа рисования элемента управления или места отправки определенных сообщений. Например, вы можете использовать данные для хранения указателя на класс C++ в классе, который представляет элемент управления. В следующем примере кода показано, как использовать [**сбой setprop**](/windows/desktop/api/winuser/nf-winuser-setpropa) для хранения данных в окне.


```
SetProp (hwnd, TEXT("MyData"), (HANDLE)pMyData);
```



### <a name="disadvantages-of-the-old-subclassing-approach"></a>Недостатки старого подхода к подклассам

В следующем списке рассматриваются некоторые недостатки использования описанного выше подхода для подкласса элемента управления.

-   Процедуру окна можно заменить только один раз.
-   Удалить подкласс после его создания сложно.
-   Связывание закрытых данных с окном неэффективно.
-   Чтобы вызвать следующую процедуру в цепочке подклассов, невозможно привести старую процедуру окна и вызвать ее, необходимо вызвать ее с помощью функции [**каллвиндовпрок**](/windows/desktop/api/winuser/nf-winuser-callwindowproca) .

## <a name="subclassing-controls-using-comctl32dll-version-6"></a>Подклассировать элементы управления с помощью ComCtl32.dll версии 6

> [!Note]  
> ComCtl32.dll версии 6 — только Юникод. Стандартные элементы управления, поддерживаемые ComCtl32.dll версии 6, не должны быть переклассами (или классами) с помощью оконных процедур ANSI.

 

ComCtl32.dll версии 6 содержит четыре функции, которые упрощают создание подклассов и устраняют ранее обсуждаемые недостатки. Новые функции инкапсулируют управление, вовлеченное в множество наборов справочных данных, поэтому разработчик может сосредоточиться на функциях программирования, а не на управлении подклассами. Функции подкласса:

-   [**сетвиндовсубкласс**](/windows/desktop/api/commctrl/nf-commctrl-setwindowsubclass)
-   [**жетвиндовсубкласс**](/windows/desktop/api/commctrl/nf-commctrl-getwindowsubclass)
-   [**ремовевиндовсубкласс**](/windows/desktop/api/commctrl/nf-commctrl-removewindowsubclass)
-   [**дефсубкласспрок**](/windows/desktop/api/commctrl/nf-commctrl-defsubclassproc)

### <a name="setwindowsubclass"></a>сетвиндовсубкласс

Эта функция используется для первоначального подкласса окна. Каждый подкласс однозначно идентифицируется по адресу *пфнсубкласс* и его *уидсубкласс*. Оба параметра являются параметрами функции [**сетвиндовсубкласс**](/windows/desktop/api/commctrl/nf-commctrl-setwindowsubclass) . Несколько подклассов могут совместно использовать одну и ту же процедуру подкласса, и идентификатор может опознать каждый вызов. Чтобы изменить ссылочные данные, можно выполнить последующие вызовы **сетвиндовсубкласс**. Важным преимуществом является то, что каждый экземпляр подкласса имеет собственные справочные данные.

Объявление процедуры-подкласса немного отличается от обычной процедуры окна, поскольку содержит два дополнительных фрагмента данных: Идентификатор подкласса и ссылочные данные. Это показано в двух последних параметрах приведенного ниже объявления функции.


```
LRESULT CALLBACK MyWndProc (HWND hWnd, UINT msg,
WPARAM wParam, LPARAM lParam, UINT_PTR uIdSubclass,
DWORD_PTR dwRefData);
```



При каждом получении сообщения с помощью новой процедуры окна включаются идентификатор подкласса и ссылочные данные.

> [!Note]  
> Все строки, передаваемые в процедуру, являются строками в Юникоде, даже если в качестве определения препроцессора не указан Юникод.

 

В следующем примере показана скелетная реализация процедуры окна для элемента управления с подклассом.


```
LRESULT CALLBACK OwnerDrawButtonProc(HWND hWnd, UINT uMsg, WPARAM wParam,
                               LPARAM lParam, UINT_PTR uIdSubclass, DWORD_PTR dwRefData)
{
    switch (uMsg)
    {
    case WM_PAINT:
        .
        .
        .
        return TRUE;
    // Other cases...
    } 
    return DefSubclassProc(hWnd, uMsg, wParam, lParam);
}
```



Процедура окна может быть присоединена к элементу управления в обработчике [**WM \_ инитдиалог**](/windows/desktop/dlgbox/wm-initdialog) процедуры диалогового окна, как показано в следующем примере.


```
case WM_INITDIALOG:
{
    HWND button = GetDlgItem(hDlg, IDC_OWNERDRAWBUTTON);
    SetWindowSubclass(button, OwnerDrawButtonProc, 0, 0);
    return TRUE;
}
```



### <a name="getwindowsubclass"></a>жетвиндовсубкласс

Эта функция получает сведения о подклассе. Например, можно использовать [**жетвиндовсубкласс**](/windows/desktop/api/commctrl/nf-commctrl-getwindowsubclass) для доступа к эталонным данным.

### <a name="removewindowsubclass"></a>ремовевиндовсубкласс

Эта функция удаляет подклассы. [**Ремовевиндовсубкласс**](/windows/desktop/api/commctrl/nf-commctrl-removewindowsubclass) в сочетании с [**сетвиндовсубкласс**](/windows/desktop/api/commctrl/nf-commctrl-setwindowsubclass) позволяет динамически добавлять и удалять подклассы.

### <a name="defsubclassproc"></a>дефсубкласспрок

Функция [**дефсубкласспрок**](/windows/desktop/api/commctrl/nf-commctrl-defsubclassproc) вызывает следующий обработчик в цепочке подклассов. Функция также получает соответствующие ИДЕНТИФИКАТОРы и ссылочные данные и передает их в следующую процедуру окна.

 

 