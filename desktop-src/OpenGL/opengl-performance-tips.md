---
title: Советы производительности OpenGL
description: Советы производительности OpenGL
ms.assetid: f85bf725-1361-49b9-894c-c803b2dead60
keywords:
- OpenGL, советы по повышению производительности
- OpenGL, рекомендации
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b7e5b6fa33f8d6841d0fd47d1a655ef99facc84e
ms.sourcegitcommit: d75fc10b9f0825bbe5ce5045c90d4045e3c53243
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/13/2021
ms.locfileid: "127244879"
---
# <a name="opengl-performance-tips"></a>Советы производительности OpenGL

Эти методики программирования оптимизируют производительность приложения:

-   Используйте [**глколорматериал**](glcolormaterial.md) , если только одно свойство материала изменяется быстро (например, в каждой вершине). Используйте [**глматериал**](glmaterial-functions.md) для редких изменений или при быстром изменении одного свойства материалов.
-   Используйте [**гллоадидентити**](glloadidentity.md) для инициализации матрицы вместо загрузки собственной копии матрицы идентификаторов.
-   Используйте конкретные вызовы матрицы, такие как [**глротате**](glrotate.md), [**глтранслате**](gltranslate.md)и [**глскале**](glscale.md), вместо создания собственных матриц вращения, перевода и масштабирования и вызова [**глмултматрикс**](glmultmatrix.md).
-   Используйте [**глпушаттриб**](glpushattrib.md) и [**глпопаттриб**](glpopattrib.md) для сохранения и восстановления значений состояния. Используйте функции запросов, только если приложению требуются значения состояния для собственных вычислений.
-   Списки отображения используются для инкапсуляции потенциально ресурсоемких изменений состояния. Например, поместите все вызовы [**глтексимаже**](glteximage1d.md) , необходимые для полного указания текстуры (и, возможно, связанные с [**глтекспараметер**](gltexparameter-functions.md), [**глпикселсторе**](glpixelstore-functions.md)и [**глпикселтрансфер**](glpixeltransfer.md) ) в один список просмотра. Вызовите этот список экранов, чтобы выбрать текстуру.
-   Используйте списки отображения для инкапсуляции вызовов отрисовки нежестких объектов, которые будут отображаться повторно.
-   Чтобы снизить пропускную способность сети в клиентских и серверных средах, используйте оценивающие, даже для простых тесселяций поверхности.
-   Если это возможно, чтобы избежать издержек на \_ нормализацию главной книги, укажите нормальную длину блока. Поскольку [**глскале**](glscale.md) почти всегда требует включения \_ нормализации GL, Избегайте использования **глскале** при выполнении освещения.
-   Если плавное затенение не требуется, установите [**глшадемодел**](glshademodel.md) в GL \_ Flat.
-   По возможности используйте один вызов [**глклеар**](glclear.md) на кадр. Не используйте **глклеар** , чтобы очистить небольшие подобласти буферов. Используйте его только для полного или почти полного очистки буфера.
-   Чтобы нарисовать несколько независимых треугольников, используйте один вызов, а не несколько вызовов [**глбегин**](glbegin.md) ( \_ треугольники GL) или вызов **глбегин** ( \_ многоугольник GL). Верно

    Для рисования одного треугольника используйте \_ треугольные треугольники, а не \_ многоугольники GL.

    Используйте один вызов [**глбегин**](glbegin.md) ( \_ четыре неповторяющиеся), а не вызывайте **глбегин** ( \_ многоугольник GL).

    Используйте один вызов [**глбегин**](glbegin.md) ( \_ строки GL) для рисования нескольких независимых сегментов линии вместо вызова **глбегин** (строк GL \_ ) несколько раз.

-   Как правило, используйте векторные формы команд для передачи предварительно вычисленных данных и используйте скалярные формы команд для передачи значений, вычисленных около времени вызова.
-   Старайтесь не вносить изменения в избыточный режим, например устанавливать для цвета одно и то же значение между вершинами плоского многоугольника.
-   При рисовании или копировании изображений отключите растрирование и операции для отдельных фрагментов, чтобы оптимизировать ресурсы. OpenGL может применять текстуры к изображениям пикселей.

 

 




