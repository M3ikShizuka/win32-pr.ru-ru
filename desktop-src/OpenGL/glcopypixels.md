---
title: Функция Глкопипикселс (GL. h)
description: Функция Глкопипикселс копирует Пиксели в буфера кадров.
ms.assetid: c4055928-7b8b-4d0f-94f3-e3b9c0503308
keywords:
- Функция Глкопипикселс OpenGL
topic_type:
- apiref
api_name:
- glCopyPixels
api_location:
- opengl32.dll
api_type:
- DllExport
ms.topic: reference
ms.date: 05/31/2018
ms.openlocfilehash: 43c399b4ce63f84c41bcb2d65140356ac20a6ddd
ms.sourcegitcommit: 9b5faa61c38b2d0c432b7f2dbee8c127b0e28a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/19/2021
ms.locfileid: "122479450"
---
# <a name="glcopypixels-function"></a>Функция Глкопипикселс

Функция **глкопипикселс** копирует Пиксели в буфера кадров.

## <a name="syntax"></a>Синтаксис


```C++
void WINAPI glCopyPixels(
   GLint   x,
   GLint   y,
   GLsizei width,
   GLsizei height,
   GLenum  type
);
```



## <a name="parameters"></a>Параметры

<dl> <dt>

*x* 
</dt> <dd>

Координата x окна в левом нижнем углу прямоугольной области пикселей для копирования.

</dd> <dt>

*y* 
</dt> <dd>

Координата точки y окна для копирования левого нижнего угла прямоугольной области пикселей.

</dd> <dt>

*width* 
</dt> <dd>

Измерение ширины прямоугольной области пикселей для копирования. Должно быть неотрицательным значением.

</dd> <dt>

*height* 
</dt> <dd>

Измерение высоты прямоугольной области пикселей для копирования. Должно быть неотрицательным значением.

</dd> <dt>

*type* 
</dt> <dd>

Указывает, следует ли **глкопипикселс** копировать значения цветов, значения глубины или значения трафарета. Допустимые символьные константы:.




| Значение | Значение | 
|-------|---------|
| <span id="GL_COLOR"></span><span id="gl_color"></span><dl><dt><strong>GL_COLOR</strong></dt></dl> | Функция <strong>глкопипикселс</strong> считывает индексы или цвета RGBA из буфера, указанного в качестве исходного буфера чтения (см. <a href="glreadbuffer.md"><strong>глреадбуффер</strong></a>). <br /> Если OpenGL находится в режиме индексов цветов:<br /><ol><li>Каждый индекс, считанный из этого буфера, преобразуется в формат с фиксированной запятой с неопределенным числом битов справа от двоичной точки.</li><li>Каждый индекс смещается влево на GL_INDEX_SHIFT бит и добавляется в GL_INDEX_OFFSET. Если GL_INDEX_SHIFT является отрицательным, сдвиг вправо. В любом случае нулевые биты заполняются в результате неопределенных битовых точек в результатах.<br /></li><li>Если GL_MAP_COLOR имеет значение true, индекс заменяется на значение, на которое он ссылается в таблице подстановки GL_PIXEL_MAP_I_TO_I.</li><li>Независимо от того, выполняется ли замена уточняющего запроса индекса, целочисленная часть индекса затем <strong>и</strong>ED с 2<em><sup>b</sup></em> 1, где <em>b</em> — число битов в буфере цветового индекса.</li></ol>Если OpenGL находится в режиме RGBA:<br /><ol><li>Красный, зеленый, синий и альфа-компоненты каждого считанного пиксела преобразуются во внутренний формат с плавающей запятой с неопределенной точностью.</li><li>Преобразование сопоставляет значение самого крупного возможного компонента с 1,0, а значение компонента — нуль — 0,0.</li><li>Результирующие значения цвета с плавающей запятой затем умножаются на GL_c_SCALE и добавляются в GL_c_BIAS, где <em>c</em> — красный, зеленый, синий и альфа-канал для соответствующих компонентов цвета.</li><li>Результаты записываются в диапазон [0, 1].</li><li>Если GL_MAP_COLOR имеет значение true, каждый компонент цвета масштабируется по размеру таблицы подстановки GL_PIXEL_MAP_c_TO_c, а затем заменяется на значение, на которое она ссылается в этой таблице. <em>c</em> — R, G, B или A соответственно. Полученные в результате индексы или RGBA цвета преобразуются в фрагменты путем присоединения текущей растровой координаты <em>z</em>и координат текстуры к каждому пикселю, а затем присваиваются координаты окна (<em>x</em><sub>r + i</sub> , <em>y</em><sub>r</sub>  +  <em>j</em>), где (<em>x</em><sub>r</sub> , <em>y</em><sub>r</sub> ) — текущее положение в виде точки <em>в</em> строке <em>j</em> . Затем эти фрагменты пикселов обрабатываются так же, как фрагменты, созданные с помощью растровых точек, линий или многоугольников. Сопоставление текстур, туман и все операции фрагмента применяются до того, как фрагменты записываются в буфера кадров.<br /></li></ol> | 
| <span id="GL_DEPTH"></span><span id="gl_depth"></span><dl><dt><strong>GL_DEPTH</strong></dt></dl> | Значения глубины считываются из буфера глубины и преобразуются непосредственно во внутренний формат с плавающей запятой с неуказанной точностью. Полученное значение глубины с плавающей запятой затем умножается на GL_DEPTH_SCALE и добавляется в GL_DEPTH_BIAS. Результат задается в виде фиксации в диапазоне [0, 1]. <br /> Результирующие компоненты глубины затем преобразуются в фрагменты путем присоединения текущего растрового индекса цвета или цвета, а также координат текстуры к каждому пикселю, присваивания координат окна (<em>x</em><sub>r</sub> + i, <em>y</em><sub>r</sub>  +  <em>j</em>), где (<em>x</em><sub>r</sub> , <em>y</em><sub>r</sub> ) — Текущая позиция относительного расположения, а пиксель — пиксель в позиции <em>i</em> в строке <em>j</em> . Затем эти фрагменты пикселов обрабатываются так же, как фрагменты, созданные с помощью растровых точек, линий или многоугольников. Сопоставление текстур, туман и все операции фрагмента применяются до того, как фрагменты записываются в буфера кадров.<br /> | 
| <span id="GL_STENCIL"></span><span id="gl_stencil"></span><dl><dt><strong>GL_STENCIL</strong></dt></dl> | Индексы наборов элементов считываются из буфера шаблона и преобразуются во внутренний формат с фиксированной запятой с неопределенным числом битов справа от двоичной точки. Затем каждый индекс с фиксированной точкой смещается на GL_INDEX_SHIFT бит и добавляется в GL_INDEX_OFFSET. Если GL_INDEX_SHIFT является отрицательным, сдвиг вправо. В любом случае нулевые биты заполняются в результате неопределенных битовых точек в результатах. Если GL_MAP_STENCIL имеет значение true, индекс заменяется на значение, на которое он ссылается в таблице подстановки GL_PIXEL_MAP_S_TO_S. Независимо от того, выполняется ли замена уточняющего запроса индекса, целочисленная часть индекса затем <strong>и</strong>ED с 2<sup>b</sup> -1, где <em>b</em> — число битов в буфере шаблона. Итоговые индексы набора элементов затем записываются в буфер трафарета таким, что индекс, считанный из <em>i</em> -е строки <em>j</em> , записывается в расположение (<em>x</em><sub>r</sub>  +  <em>i</em>, <em>y</em><sub>r</sub>  +  <em>j</em>), где (<em>x</em><sub>r</sub> , <em>y</em><sub>r</sub> ) — текущее положение в виде растровой позиции. На эти операции записи влияют только тест «точка-владение», «прямоугольный тест» и вритемаск трафарета.<br /> | 




 

</dd> </dl>

## <a name="return-value"></a>Возвращаемое значение

Эта функция не возвращает значение.

## <a name="error-codes"></a>Коды ошибок

Функция [**глжетеррор**](glgeterror.md) может получить следующие коды ошибок.



| Имя                                                                                                  | Значение                                                                                                                               |
|-------------------------------------------------------------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------------|
| <dl> <dt>**\_недействительное \_ перечисление GL**</dt> </dl>      | *тип* не является допустимым значением.<br/>                                                                                          |
| <dl> <dt>**\_недопустимое \_ значение GL**</dt> </dl>     | Либо *Ширина* , либо высота были отрицательными.<br/>                                                                                     |
| <dl> <dt>**\_Недопустимая \_ Операция GL**</dt> </dl> | *тип* имел \_ глубину GL, а буфер глубины отсутствует.<br/>                                                                        |
| <dl> <dt>**\_Недопустимая \_ Операция GL**</dt> </dl> | *тип* был \_ трафаретом GL, но буфер трафарета не существует.<br/>                                                                    |
| <dl> <dt>**\_Недопустимая \_ Операция GL**</dt> </dl> | Функция была вызвана между вызовом [**глбегин**](glbegin.md) и соответствующим вызовом [**гленд**](glend.md).<br/> |



## <a name="remarks"></a>Комментарии

Функция **глкопипикселс** копирует прямоугольник пикселей с выставкой по экрану из указанного расположения буфера кадров в регион относительно текущей позиции. Его операция хорошо определена только в том случае, если область источника пикселя находится внутри видимой части окна. Результаты копирования извне окна или из областей окна, которые не являются видимыми, являются аппаратно зависимыми и неопределенными.

Параметры *x* и *y* задают координаты окна левого нижнего угла прямоугольной области для копирования. Параметры *Width* и *Height* определяют размеры прямоугольной области для копирования. *Ширина* и *Высота* должны быть неотрицательными.

Несколько параметров управляют обработкой данных пикселей во время их копирования. Эти параметры задаются тремя функциями: [**глпикселтрансфер**](glpixeltransfer.md), [**глпикселмап**](glpixelmap.md)и [**глпикселзум**](glpixelzoom.md). В этом разделе описывается влияние на **глкопипикселс** большинства (но не всех) параметров, заданных этими тремя функциями.

Функция **глкопипикселс** копирует значения из каждого пикселя в левом нижнем углу в (*x*  +  *i*, *y*  +  *j*) для 0 =   <  *Ширина* i и 0 = *j*  <  *Height*. Этот пиксель считается точкой *i* в строке *j* . Пиксели копируются в порядке строк от нижнего к верхнему, слева направо в каждой строке.

Параметр *типа* указывает, следует ли копировать данные цвета, глубины или трафарета.

Приведенная выше растрирования предполагает, что коэффициенты масштабирования пикселя в 1,0. При использовании [**глпикселзум**](glpixelzoom.md) для изменения коэффициентов масштабирования *x* и *y* Пиксели преобразуются в фрагменты следующим образом. Если (*x*<sub>r</sub> , *y*<sub>r</sub> ) является текущей позицией разряда, а заданный пиксель находится в позиции *i* в строке *j* исходного пиксельного прямоугольника, то фрагменты создаются для пикселов, центры которых находятся в прямоугольнике с углами в

(*x*<sub>r</sub>  +  *увеличить масштаб* я, y <sub>r</sub>  +  *Zoom*<sub>y</sub> *j*)

и

(*x*<sub>r</sub>  +  *увеличить масштаб* (*i* + 1), *y*<sub>r</sub>  +  *Zoom*<sub>y</sub> (*j* + 1))

где *увеличить*? — значение параметра «масштаб в GL» \_ \_ X, а « *масштаб*<sub>y</sub> » — значение « \_ Масштаб по \_ оси y».

Режимы, заданные параметром [**глпикселсторе**](glpixelstore-functions.md) , не влияют на работу **глкопипикселс**.

Следующие функции извлекают сведения, относящиеся к **глкопипикселс**:

[**глжет**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md) с аргументом \_ текущей \_ точечной \_ позицией GL

**глжет** с аргументом \_ текущей \_ точечной \_ позицией GL \_ допустимо

Чтобы скопировать цветовую точку в левом нижнем углу окна в текущую координату, используйте

**глкопипикселс**(0, 0, 1, 1, GL \_ );

## <a name="requirements"></a>Требования



| Требование | Значение |
|-------------------------------------|-----------------------------------------------------------------------------------------|
| Минимальная версия клиента<br/> | Windows 2000 Professional \[только классические приложения\]<br/>                              |
| Минимальная версия сервера<br/> | Windows 2000 Server \[только классические приложения\]<br/>                                    |
| Заголовок<br/>                   | <dl> <dt>GL. h</dt> </dl>         |
| Библиотека<br/>                  | <dl> <dt>Opengl32. lib</dt> </dl> |
| DLL<br/>                      | <dl> <dt>Opengl32.dll</dt> </dl> |



## <a name="see-also"></a>См. также

<dl> <dt>

[**глбегин**](glbegin.md)
</dt> <dt>

[**глдепсфунк**](gldepthfunc.md)
</dt> <dt>

[**глдравбуффер**](gldrawbuffer.md)
</dt> <dt>

[**глдравпикселс**](gldrawpixels.md)
</dt> <dt>

[**гленд**](glend.md)
</dt> <dt>

[**глжет**](glgetbooleanv--glgetdoublev--glgetfloatv--glgetintegerv.md)
</dt> <dt>

[**глпикселмап**](glpixelmap.md)
</dt> <dt>

[**глпикселсторе**](glpixelstore-functions.md)
</dt> <dt>

[**глпикселтрансфер**](glpixeltransfer.md)
</dt> <dt>

[**глпикселзум**](glpixelzoom.md)
</dt> <dt>

[**глрастерпос**](glrasterpos-functions.md)
</dt> <dt>

[**глреадбуффер**](glreadbuffer.md)
</dt> <dt>

[**глреадпикселс**](glreadpixels.md)
</dt> <dt>

[**глстенЦилфунк**](glstencilfunc.md)
</dt> </dl>

 

 





