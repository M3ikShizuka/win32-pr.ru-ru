---
description: Exclusive-Mode Потоки
ms.assetid: 196cc6fe-91bf-46fa-acc9-38a7a4005875
title: Exclusive-Mode Потоки
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 50bc9b17dbb508d04bd4665b48dfaa8f1373cc1e167b892f7ac791b3d9a0d0b2
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "120104414"
---
# <a name="exclusive-mode-streams"></a>Exclusive-Mode Потоки

Как упоминалось ранее, если приложение открывает поток в монопольном режиме, приложение имеет эксклюзивное использование устройства конечной точки аудио, которое воспроизводит или записывает поток. В отличие от этого, несколько приложений могут совместно использовать звуковое устройство для конечных точек, открывая потоки общего режима на устройстве.

Доступ к звуковому устройству в монопольном режиме может блокировать критические системные звуки, предотвращать взаимодействие с другими приложениями и иным образом снизить удобство работы пользователя. Чтобы устранить эти проблемы, приложение с потоком в монопольном режиме обычно освобождает управление звуковым устройством, когда приложение не является основным процессом или не является активной потоковой передачей.

Задержка потока — это задержка, которая связана с расположением данных, соединяющим буфер конечной точки приложения с устройством конечной точки аудио. Для потока отрисовки задержка — это максимальная задержка от времени, когда приложение записывает пример в буфер конечной точки до момента передачи образца через динамики. Для потока записи задержка — это максимальная задержка от времени, когда звук попадает в микрофон, до момента, когда приложение может прочитать образец для этого звука из буфера конечной точки.

Приложения, использующие потоки с монопольным режимом, часто делают это, так как они нуждаются в низких задержках между устройствами конечных точек аудио и потоками приложения, которые обращаются к буферам конечной точки. Как правило, эти потоки работают с относительно высоким приоритетом и сами по себе запланируются на периодические интервалы, близкие к одному или тому же, что и период, который разделяет последовательную обработку, продающуюся звуковым оборудованием. Во время каждого прохода звуковое оборудование обрабатывает новые данные в буферах конечной точки.

Для достижения наименьшей задержки потока приложению может потребоваться специальное звуковое оборудование и компьютерная система, которая будет легко загружена. Появление звукового оборудования, превышающего ограничения по времени, или загрузка системы с конкурирующими задачами с высоким приоритетом может вызвать сбой в потоке звука с низкой задержкой. Например, для потока отрисовки может произойти сбой, если приложению не удается выполнить запись в буфер конечной точки до того, как звуковая аппаратура прочитает буфер или если оборудование не сможет прочитать буфер до момента, когда буфер будет воспроизведен. Как правило, приложение, предназначенное для работы на самых разнообразных звуковых устройствах и в широком диапазоне систем, должно ослабить свои требования к времени, чтобы избежать сбоев во всех целевых средах.

Windows В Vista есть несколько функций для поддержки приложений, требующих звуковых потоков с низкой задержкой. Как обсуждалось в [пользовательских компонентах аудио](user-mode-audio-components.md), приложения, выполняющие критически важные для времени операции, могут вызывать функции службы управления правами (MMCSS) класса мультимедиа для повышения приоритета потоков без блокировки ресурсов ЦП на приложения с более низким приоритетом. Кроме того, метод [**иаудиоклиент:: Initialize**](/windows/desktop/api/Audioclient/nf-audioclient-iaudioclient-initialize) поддерживает \_ флаг аудклнт стреамфлагс \_ вложенный EventCallback, позволяющий потоку обслуживания буфера приложения запланировать его выполнение, когда новый буфер станет доступен с звукового устройства. Используя эти функции, поток приложения может уменьшить неопределенность при выполнении, что снижает риск возникновения сбоев в потоке звука с низкой задержкой.

Драйверы старых звуковых адаптеров, скорее всего, используют интерфейс драйвера устройства Вавециклик или ВавепЦи (DDI), тогда как драйверы для новых звуковых адаптеров, скорее всего, будут поддерживать DDI Ваверт. Для приложений с эксклюзивным режимом драйверы Ваверт могут обеспечить лучшую производительность, чем драйверы Вавециклик или ВавепЦи, но для драйверов Ваверт требуются дополнительные аппаратные возможности. Эти возможности включают возможность совместного использования буферов оборудования непосредственно с приложениями. При непосредственном совместном использовании не требуется вмешательство системы для передачи данных между приложением с монопольным режимом и звуковым оборудованием. Драйверы Вавециклик и ВавепЦи подходят для старых и менее производительных звуковых адаптеров. Эти адаптеры используют системное программное обеспечение для передачи блоков данных (подключенных к системным пакетам ввода-вывода и запросов IRP) между буферами приложений и аппаратными буферами. Кроме того, устройства USB аудио используют системное по для передачи данных между буферами приложений и аппаратными буферами. Чтобы повысить производительность приложений с монопольным режимом, подключающихся к звуковым устройствам, которые используют систему для передачи данных, ВАСАПИ автоматически повышает приоритет системных потоков, передающих данные между приложениями и оборудованием. ВАСАПИ использует MMCSS для увеличения приоритета потока. в Windows Vista, если системный поток управляет передачей данных для потока воспроизведения звука в монопольном режиме с форматом PCM и периодом устройства менее 10 миллисекунд, васапи присваивает потоку имя задачи MMCSS "Pro audio". Если период устройства потока больше или равен 10 миллисекундам, ВАСАПИ присваивает потоку имя задачи MMCSS "Audio". дополнительные сведения о вавециклик, вавепЦи и ваверт ддис см. в документации по Windows DDK. Сведения о выборе соответствующего периода устройства см. в разделе [**иаудиоклиент:: жетдевицепериод**](/windows/desktop/api/Audioclient/nf-audioclient-iaudioclient-getdeviceperiod).

Как описано в разделе [элементы управления томами сеанса](session-volume-controls.md), [Васапи](wasapi.md) предоставляет интерфейсы [**исимплеаудиоволуме**](/windows/desktop/api/Audioclient/nn-audioclient-isimpleaudiovolume), [**ичаннелаудиоволуме**](/windows/desktop/api/Audioclient/nn-audioclient-ichannelaudiovolume)и [**иаудиостреамволуме**](/windows/desktop/api/Audioclient/nn-audioclient-iaudiostreamvolume) для управления уровнями громкости звуковых потоков в общем режиме. Однако элементы управления в этих интерфейсах не влияют на потоки с монопольным режимом. Вместо этого приложения, которые управляют потоками в монопольном режиме, обычно используют интерфейс [**иаудиоендпоинтволуме**](/windows/desktop/api/Endpointvolume/nn-endpointvolume-iaudioendpointvolume) в [API ендпоинтволуме](endpointvolume-api.md) для управления уровнями громкости этих потоков. Сведения об этом интерфейсе см. в разделе [Управление томами конечных точек](endpoint-volume-controls.md).

Для каждого устройства воспроизведения и устройства записи в системе пользователь может управлять возможностью использования устройства в монопольном режиме. Если пользователь отключает использование устройства в монопольном режиме, устройство может использоваться для воспроизведения или записи только потоков в общем режиме.

Если пользователь разрешает использовать устройство в монопольном режиме, он также может управлять тем, будет ли запрос приложением использовать устройство в монопольном режиме, чтобы использовать его в приложениях, которые могут в настоящее время воспроизводить или записывать потоки общего режима через устройство. Если вызываемое прерывание включено, запрос приложения, чтобы получить монопольный контроль над устройством, будет успешным, если устройство в данный момент не используется или устройство используется в общем режиме, но запрос завершается сбоем, если другое приложение уже имеет монопольный контроль над устройством. Если прерывание отключено, запрос приложения на монопольное управление устройством завершается успешно, если устройство в настоящее время не используется, но запрос завершается неудачей, если устройство уже используется в режиме общего доступа или в монопольном режиме.

в Windows Vista параметры по умолчанию для устройства конечной точки аудио приведены ниже.

-   Устройство можно использовать для воспроизведения или записи потоков с монопольным режимом.
-   Запрос на использование устройства для воспроизведения или записи потока с монопольным режимом вызывает перегрузку любого потока общего режима, который в данный момент воспроизводится или записывается на устройстве.

**Изменение параметров монопольного режима для устройства воспроизведения или записи**

1.  Щелкните правой кнопкой мыши значок динамика в области уведомлений, расположенном в правой части панели задач, и выберите пункт **устройства воспроизведения** или **записывающие устройства**. (в качестве альтернативы запустите Windows панель управления мультимедиа Mmsys.cpl из окна командной строки. Дополнительные сведения см. в разделе Примечания [в \_ \_ константах в состоянии устройства XXX](device-state-xxx-constants.md).)
2.  После появления **звукового** окна выберите **Воспроизведение** или **запись**. Затем выберите запись в списке имен устройств и нажмите кнопку **Свойства**.
3.  После появления окна **Свойства** нажмите кнопку **Дополнительно**.
4.  Чтобы разрешить приложениям использовать устройство в монопольном режиме, установите флажок **Разрешить приложениям принимать монопольный контроль над этим устройством**. Чтобы отключить использование устройства в монопольном режиме, снимите флажок.
5.  Если включено использование устройства в монопольном режиме, можно указать, будет ли запрос на монопольный доступ к этому устройству выполняться, если устройство воспроизводит или записывает потоки в общем режиме. Чтобы предоставить приложениям с монопольным режимом приоритет над приложениями в общем режиме, установите флажок **задать приоритет для приложений с монопольным** режимом. Чтобы запретить приложениям с монопольным режимом приоритетно использовать приложения общего режима, снимите флажок.

В следующем примере кода показано, как воспроизвести аудиопоток с низкой задержкой на устройстве рендеринга звука, настроенном для использования в монопольном режиме:


```C++
//-----------------------------------------------------------
// Play an exclusive-mode stream on the default audio
// rendering device. The PlayExclusiveStream function uses
// event-driven buffering and MMCSS to play the stream at
// the minimum latency supported by the device.
//-----------------------------------------------------------

// REFERENCE_TIME time units per second and per millisecond
#define REFTIMES_PER_SEC  10000000
#define REFTIMES_PER_MILLISEC  10000

#define EXIT_ON_ERROR(hres)  \
              if (FAILED(hres)) { goto Exit; }
#define SAFE_RELEASE(punk)  \
              if ((punk) != NULL)  \
                { (punk)->Release(); (punk) = NULL; }

const CLSID CLSID_MMDeviceEnumerator = __uuidof(MMDeviceEnumerator);
const IID IID_IMMDeviceEnumerator = __uuidof(IMMDeviceEnumerator);
const IID IID_IAudioClient = __uuidof(IAudioClient);
const IID IID_IAudioRenderClient = __uuidof(IAudioRenderClient);

HRESULT PlayExclusiveStream(MyAudioSource *pMySource)
{
    HRESULT hr;
    REFERENCE_TIME hnsRequestedDuration = 0;
    IMMDeviceEnumerator *pEnumerator = NULL;
    IMMDevice *pDevice = NULL;
    IAudioClient *pAudioClient = NULL;
    IAudioRenderClient *pRenderClient = NULL;
    WAVEFORMATEX *pwfx = NULL;
    HANDLE hEvent = NULL;
    HANDLE hTask = NULL;
    UINT32 bufferFrameCount;
    BYTE *pData;
    DWORD flags = 0;
    DWORD taskIndex = 0;
    
    hr = CoCreateInstance(
           CLSID_MMDeviceEnumerator, NULL,
           CLSCTX_ALL, IID_IMMDeviceEnumerator,
           (void**)&pEnumerator);
    EXIT_ON_ERROR(hr)

    hr = pEnumerator->GetDefaultAudioEndpoint(
                        eRender, eConsole, &pDevice);
    EXIT_ON_ERROR(hr)

    hr = pDevice->Activate(
                    IID_IAudioClient, CLSCTX_ALL,
                    NULL, (void**)&pAudioClient);
    EXIT_ON_ERROR(hr)

    // Call a helper function to negotiate with the audio
    // device for an exclusive-mode stream format.
    hr = GetStreamFormat(pAudioClient, &pwfx);
    EXIT_ON_ERROR(hr)

    // Initialize the stream to play at the minimum latency.
    hr = pAudioClient->GetDevicePeriod(NULL, &hnsRequestedDuration);
    EXIT_ON_ERROR(hr)

    hr = pAudioClient->Initialize(
                         AUDCLNT_SHAREMODE_EXCLUSIVE,
                         AUDCLNT_STREAMFLAGS_EVENTCALLBACK,
                         hnsRequestedDuration,
                         hnsRequestedDuration,
                         pwfx,
                         NULL);
    if (hr == AUDCLNT_E_BUFFER_SIZE_NOT_ALIGNED) {
        // Align the buffer if needed, see IAudioClient::Initialize() documentation
        UINT32 nFrames = 0;
        hr = pAudioClient->GetBufferSize(&nFrames);
        EXIT_ON_ERROR(hr)
        hnsRequestedDuration = (REFERENCE_TIME)((double)REFTIMES_PER_SEC / pwfx->nSamplesPerSec * nFrames + 0.5);
        hr = pAudioClient->Initialize(
            AUDCLNT_SHAREMODE_EXCLUSIVE,
            AUDCLNT_STREAMFLAGS_EVENTCALLBACK,
            hnsRequestedDuration,
            hnsRequestedDuration,
            pwfx,
            NULL);
    }
    EXIT_ON_ERROR(hr)

    // Tell the audio source which format to use.
    hr = pMySource->SetFormat(pwfx);
    EXIT_ON_ERROR(hr)

    // Create an event handle and register it for
    // buffer-event notifications.
    hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if (hEvent == NULL)
    {
        hr = E_FAIL;
        goto Exit;
    }

    hr = pAudioClient->SetEventHandle(hEvent);
    EXIT_ON_ERROR(hr);

    // Get the actual size of the two allocated buffers.
    hr = pAudioClient->GetBufferSize(&bufferFrameCount);
    EXIT_ON_ERROR(hr)

    hr = pAudioClient->GetService(
                         IID_IAudioRenderClient,
                         (void**)&pRenderClient);
    EXIT_ON_ERROR(hr)

    // To reduce latency, load the first buffer with data
    // from the audio source before starting the stream.
    hr = pRenderClient->GetBuffer(bufferFrameCount, &pData);
    EXIT_ON_ERROR(hr)

    hr = pMySource->LoadData(bufferFrameCount, pData, &flags);
    EXIT_ON_ERROR(hr)

    hr = pRenderClient->ReleaseBuffer(bufferFrameCount, flags);
    EXIT_ON_ERROR(hr)

    // Ask MMCSS to temporarily boost the thread priority
    // to reduce glitches while the low-latency stream plays.
    hTask = AvSetMmThreadCharacteristics(TEXT("Pro Audio"), &taskIndex);
    if (hTask == NULL)
    {
        hr = E_FAIL;
        EXIT_ON_ERROR(hr)
    }

    hr = pAudioClient->Start();  // Start playing.
    EXIT_ON_ERROR(hr)

    // Each loop fills one of the two buffers.
    while (flags != AUDCLNT_BUFFERFLAGS_SILENT)
    {
        // Wait for next buffer event to be signaled.
        DWORD retval = WaitForSingleObject(hEvent, 2000);
        if (retval != WAIT_OBJECT_0)
        {
            // Event handle timed out after a 2-second wait.
            pAudioClient->Stop();
            hr = ERROR_TIMEOUT;
            goto Exit;
        }

        // Grab the next empty buffer from the audio device.
        hr = pRenderClient->GetBuffer(bufferFrameCount, &pData);
        EXIT_ON_ERROR(hr)

        // Load the buffer with data from the audio source.
        hr = pMySource->LoadData(bufferFrameCount, pData, &flags);
        EXIT_ON_ERROR(hr)

        hr = pRenderClient->ReleaseBuffer(bufferFrameCount, flags);
        EXIT_ON_ERROR(hr)
    }

    // Wait for the last buffer to play before stopping.
    Sleep((DWORD)(hnsRequestedDuration/REFTIMES_PER_MILLISEC));

    hr = pAudioClient->Stop();  // Stop playing.
    EXIT_ON_ERROR(hr)

Exit:
    if (hEvent != NULL)
    {
        CloseHandle(hEvent);
    }
    if (hTask != NULL)
    {
        AvRevertMmThreadCharacteristics(hTask);
    }
    CoTaskMemFree(pwfx);
    SAFE_RELEASE(pEnumerator)
    SAFE_RELEASE(pDevice)
    SAFE_RELEASE(pAudioClient)
    SAFE_RELEASE(pRenderClient)

    return hr;
}
```



В предыдущем примере кода функция Плайексклусивестреам выполняется в потоке приложения, который выполняет обслуживание буферов конечной точки во время воспроизведения потока отрисовки. Функция принимает один параметр Пмисаурце, который является указателем на объект, принадлежащий определяемому клиентом классу Мяудиосаурце. Этот класс содержит две функции члена, LoadData и Сетформат, которые вызываются в примере кода. Мяудиосаурце описывается в разделе [Подготовка потока](rendering-a-stream.md).

Функция Плайексклусивестреам вызывает вспомогательную функцию Жетстреамформат, которая согласовывается с устройством отрисовки по умолчанию, чтобы определить, поддерживает ли устройство формат потока с монопольным режимом, который подходит для использования приложением. Код функции Жетстреамформат не отображается в примере кода. Это связано с тем, что сведения о его реализации полностью зависят от требований приложения. Однако операцию функции Жетстреамформат можно описать просто — она вызывает метод [**иаудиоклиент:: исформатсуппортед**](/windows/desktop/api/Audioclient/nf-audioclient-iaudioclient-isformatsupported) один или несколько раз, чтобы определить, поддерживает ли устройство подходящий формат. Требования приложения определяют, какие форматы Жетстреамформат представляют методу **исформатсуппортед** , и порядок их представления. Дополнительные сведения о **исформатсуппортед** см. в разделе [форматы устройств](device-formats.md).

После вызова Жетстреамформат функция Плайексклусивестреам вызывает метод [**иаудиоклиент:: жетдевицепериод**](/windows/desktop/api/Audioclient/nf-audioclient-iaudioclient-getdeviceperiod) , чтобы получить минимальный период устройства, поддерживаемый звуковым оборудованием. Затем функция вызывает метод [**иаудиоклиент:: Initialize**](/windows/desktop/api/Audioclient/nf-audioclient-iaudioclient-initialize) для запроса длительности буфера равным минимальному периоду. Если вызов будет выполнен, метод **Initialize** выделяет два буфера конечной точки, каждая из которых равна минимальному периоду. Позднее, когда начнется запуск аудиопотока, приложение и звуковое оборудование будут совместно использовать два буфера в «пинг-теннисе», т. е. когда приложение записывает данные в один буфер, оборудование считывает данные из другого буфера.

Перед запуском потока функция Плайексклусивестреам выполняет следующие действия:

-   Создает и регистрирует обработчик событий, через который он будет получать уведомления о готовности буферов к заполнению.
-   Заполняет первый буфер данными из источника аудио, чтобы уменьшить задержку, с которой начнется выполнение потока при проходе первоначального звукового сигнала.
-   Вызывает функцию **авсетммсреадчарактеристикс** , чтобы запросить, что служба MMCSS повышает приоритет потока, в котором выполняется плайексклусивестреам. (Когда поток прекращает выполнение, вызов функции **авревертммсреадчарактеристикс** восстанавливает исходный приоритет потока.)

дополнительные сведения о **авсетммсреадчарактеристикс** и **авревертммсреадчарактеристикс** см. в документации по Windows SDK.

Во время выполнения потока каждая итерация цикла **while** в предыдущем примере кода заполняет один буфер конечной точки. Между итерациями вызов функции **WaitForSingleObject** ожидает получения сигнала для дескриптора события. Когда дескриптор получает сигнал, тело цикла выполняет следующие действия:

1.  Вызывает метод [**иаудиорендерклиент::**](/windows/desktop/api/Audioclient/nf-audioclient-iaudiorenderclient-getbuffer) GetNext для получения следующего буфера.
2.  Заполняет буфер.
3.  Вызывает метод [**иаудиорендерклиент:: релеасебуффер**](/windows/desktop/api/Audioclient/nf-audioclient-iaudiorenderclient-releasebuffer) , чтобы освободить буфер.

дополнительные сведения о **WaitForSingleObject** см. в документации по Windows SDK.

Если звуковой адаптер управляется драйвером Ваверт, сигнал дескриптора события привязывается к уведомлениям передачи DMA с аудио-оборудования. Для звукового устройства USB или для звукового устройства, управляемого драйвером Вавециклик или ВавепЦи, сигнал дескриптора события связан с завершением запросов IRP, которые передают данные из буфера приложения в аппаратный буфер.

Предыдущий пример кода передает звуковое оборудование и компьютерную систему на свои ограничения производительности. Во-первых, чтобы сократить задержку потока, приложение планирует поток обслуживания буферов для использования минимального периода, поддерживаемого звуковым оборудованием. во-вторых, чтобы обеспечить надежное выполнение потока в каждом из периодов устройства, вызов функции **авсетммсреадчарактеристикс** устанавливает для параметра имя_задания значение "Pro Audio", т. е. в Windows Vista — имя задачи по умолчанию с наивысшим приоритетом. Определите, могут ли требования к времени приложения быть неослабленными без ущерба для его полезности. Например, приложение может запланировать использование потока обслуживания буферов в течение периода, превышающего минимальное значение. Более длительный период может безопасно разрешать использование более низкого приоритета потока.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Управление потоками](stream-management.md)
</dt> </dl>

 

 



