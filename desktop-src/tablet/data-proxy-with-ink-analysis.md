---
description: Как упоминалось в обзоре анализа рукописного ввода, технология анализа рукописного ввода внутренне поддерживает модель документа на основе дерева для хранения результатов и отношений анализа.
ms.assetid: 33ba9292-3bc7-41ba-a602-e2fc94cd3a57
title: Прокси-сервер данных с анализом рукописного ввода
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 52717b955625e67f50c20703dd0e84449aa1037f
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "103912916"
---
# <a name="data-proxy-with-ink-analysis"></a>Прокси-сервер данных с анализом рукописного ввода

Как упоминалось в [обзоре анализа рукописного ввода](ink-analysis-overview.md), технология анализа рукописного ввода внутренне поддерживает модель документа на основе дерева для хранения результатов и отношений анализа. Если в приложении уже есть хранилище документов, которое отличается, необходимо использовать функции анализа рукописного ввода, предназначенные для данных прокси-сервера между разнородными моделями документов.

## <a name="types-of-data-proxy"></a>Типы прокси-сервера данных

Функции прокси-сервера данных позволяют приложению выполнять следующие задачи:

-   Интегрируйте данные результатов анализа обратно в существующую модель документа.
-   Передача предыдущих результатов (или состояния) обратно в [**InkAnalyzer**](inkanalyzer.md).
-   Передает данные о нерукописном состоянии в [**InkAnalyzer**](inkanalyzer.md).
-   Передавать только минимальный набор данных (как для предыдущего, так и для нерукописного ввода), необходимый для выполнения операции анализа.
-   Легко обновляйте внутреннюю модель документа приложения с помощью результатов анализа.

Существует два основных подхода к прокси-серверу данных анализа рукописного ввода. Различия в деталях, когда и как происходит синхронизация между моделями документов. Первый подход, синхронное обновление, требует изменения модели документа анализа рукописного ввода при внесении изменений в документ приложения. Второй подход, обновление по запросу, требует, чтобы только данные, затрагиваемые изменениями в модели документа приложения, передавались в [**InkAnalyzer**](inkanalyzer.md). Таким образом, в **InkAnalyzer** должны быть переданы только данные для частей модели документа для анализа рукописного ввода, которые находятся в той же области, что и изменения документа приложения.

### <a name="synchronous-update"></a>Синхронное обновление

Метод синхронного обновления требует изменения (создания и удаления) узлов в коллекции объектов [**контекстноде**](icontextnode.md) объекта [**InkAnalyzer**](inkanalyzer.md) , как они встречаются в документе приложения. Например, при каждом добавлении текстового слова в приложение в **InkAnalyzer** создается соответствующий **Текстворд** в стиле **контекстноде** . Если изменяется расположение текстового слова на странице, то расположение соответствующего **контекстноде** обновляется одновременно. Этот метод менее эффективен в плане вычислительных ресурсов, чем метод по запросу, поскольку каждое изменение документа включает обновление **InkAnalyzer**, даже если изменение не влияет на анализируемые рукописные данные.

В следующем примере показано, как работает синхронное обновление. Представьте себе приложение, имеющее существующую модель документа. Когда конечный пользователь вносит изменения в документ, например добавляет новый текст, изменение обрабатывается следующим образом:

1.  Конечный пользователь создает новые данные.
2.  Приложение определяет способ обработки данных, сохраняет их и готовит к просмотру.
3.  В практических целях следующие шаги выполняются одновременно.
    1.  Приложение помещает данные в модель документа.
    2.  Приложение создает [**InkAnalyzer**](inkanalyzer.md) и обновляет его. Это гарантирует, что **InkAnalyzer** всегда содержит самые последние сведения.
    3.  Приложение вызывает [**баккграунданализе**](iinkanalyzer-backgroundanalyze.md) для [**InkAnalyzer**](inkanalyzer.md) , чтобы начать анализ.
4.  Если изменение включает рукописный ввод и [**InkAnalyzer**](inkanalyzer.md) определяет новые результаты, запускается ряд событий. Для каждого изменения, внесенного в коллекцию объектов [**контекстноде**](icontextnode.md) в **InkAnalyzer**, срабатывает одно событие. К этим событиям относятся [**контекстнодекреатед**](-ianalysisproxyevents-contextnodecreated.md), [**контекстнодеделетинг**](-ianalysisproxyevents-contextnodedeleting.md), [**контекстнодемовингтопоситион**](-ianalysisproxyevents-contextnodemovingtoposition.md), [**контекстнодепропертиесупдатед**](-ianalysisproxyevents-contextnodepropertiesupdated.md), [**ContextNodeLinkAdding**](-ianalysisproxyevents-contextnodelinkadding.md), [**ContextNodeLinkDeleting**](-ianalysisproxyevents-contextnodelinkdeleting.md)и [**ContextNodeReparenting**](-ianalysisproxyevents-contextnodereparenting.md). Приложение обрабатывает эти события для прокси результатов операции анализа обратно в модель документа, если это необходимо.
5.  Приложение обновляет макет документа, потянув новые данные из модели документа.
6.  Новые данные отготовятся к конечному пользователю.

### <a name="on-demand-update"></a>Обновление по запросу

Подход по запросу требует передачи данных только для тех объектов [**контекстноде**](icontextnode.md) , которые находятся в анализируемых областях. Необходимые объекты **контекстноде** извлекаются из модели документа приложения сразу после вызова операции анализа, а также перед согласованием результатов. Хотя реализация по сравнению с синхронными обновлениями сложнее, этот подход дает лучшие результаты производительности.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Обзор анализа рукописного ввода](ink-analysis-overview.md)
</dt> <dt>

[**Класс InkAnalyzer (C++)**](inkanalyzer.md)
</dt> <dt>

[**Microsoft. Ink. InkAnalyzer**](/previous-versions/ms583671(v=vs.100))
</dt> <dt>

[**Microsoft. Ink. Контекстноде**](/previous-versions/ms551996(v=vs.100))
</dt> </dl>

 

 
