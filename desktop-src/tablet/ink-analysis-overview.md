---
description: API-интерфейсы Инканалисис предоставляют разработчикам планшетных ПК мощные средства для программного анализа рукописного ввода. API классифицирует рукописный ввод на осмысленные категории, такие как слова, линии, абзацы и рисунки.
ms.assetid: d9521a8c-f61a-40ea-8603-e8afbba75a4e
title: Обзор анализа рукописного ввода
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3056a5e5fbff8be82f6df2de2a34fadd9761e50f451ee2d48c112589d1aff397
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118718924"
---
# <a name="ink-analysis-overview"></a>Обзор анализа рукописного ввода

API-интерфейсы Инканалисис предоставляют разработчикам планшетных ПК мощные средства для программного анализа рукописного ввода. API классифицирует рукописный ввод на осмысленные категории, такие как слова, линии, абзацы и рисунки.

Вы можете использовать каждую классификацию различными способами, в том числе улучшая результаты распознавания рукописного текста.

## <a name="ink-analysis-basics"></a>Основы анализа рукописного ввода

В этом разделе описывается технология анализа рукописного ввода Tablet PC Platform и объясняется, когда и как его использовать.

Интерфейсы API Инканалисис эффективно объединяют две отдельные, но бесплатные технологии: распознавание рукописного текста и классификация макета. Объединение этих двух технологий дает более высокий результат по сравнению с частями, созданными отдельно.

Распознавание рукописного ввода — это Вычислительный анализ рукописного цифрового рукописного ввода для возврата символьной интерпретации на заданном языке. То есть распознавание рукописного ввода — это то, как компьютер читает рукописный ввод.

Анализ рукописного ввода можно дополнительно разделить на классификацию рукописного ввода и анализ макета. Классификация рукописного ввода — это вычислительное деление рукописного ввода на семантически значимые единицы, такие как абзацы, линии, слова и рисунки. Анализ макета — это вычислительное исследование рукописного ввода, которое определяет положение чернил на поверхности рукописного ввода и то, как штрихи связаны друг с другом пространственно и даже семантически. Например, анализ макета может сообщить, что определенный фрагмент рукописного ввода является заметкой или вызовом.

### <a name="recognition"></a>Распознавание

Один из примеров того, как сочетание распознавания с анализом рукописного текста в API Инканалисис помогает разработчику улучшить результаты распознавания. Модули распознавания рукописного ввода Tablet PC разрабатывались в основном для распознавания одной горизонтальной линии рукописного текста. Тем не менее, люди, как правило, пишут несколько строк при создании заметок, и эти линии не обязательно должны быть горизонтально по отношению к странице. С помощью API Инканалисис рукописный ввод предварительно обрабатывается анализатором рукописного ввода перед отправкой распознавателю. Перед распознанием проанализированные рукописные данные преобразуются в горизонтальный, что позволяет улучшить результаты распознавания.

Другие преимущества распознавания производятся путем того, что анализатор рукописного ввода исправляет неверные сведения о заказе на обводку перед отправкой рукописного ввода распознавателю. Кроме того, результаты распознавания теперь доступны в выборочном режиме. Это значит, что разработчик может быстро получить результаты распознавания одного слова, строки или абзаца в одном вызове.

### <a name="ink-classification"></a>Классификация рукописного ввода

Конечно, существует множество сценариев, в которых вы можете не преобразовывать рукописные данные, а не непосредственно в текст. Анализ рукописного ввода также дает здесь преимущества. В частности, интерфейсы API Инканалисис позволяют разбивать рукописные штрихи в зависимости от того, являются ли они написанными или рисунками. Рукописные штрихи, которые классифицируются как записи, — это те, которые составляют слово или символы. Все остальные штрихи являются рисунками. Это обеспечивает новый способ доступа к данным рукописного ввода, что позволяет использовать новые пользовательские сценарии. Например, можно реализовать выбор, чтобы он отличался в зависимости от типа штриха, на который пользователь наследует. Если пользователь нажимает рукописный штрих, приложение выбирает весь набор штрихов, образующих слово, если пользователь нажимает рисунок необходимо, приложение выбирает только этот росчерк.

### <a name="layout-analysis"></a>Анализ макета

Полезный анализ макета на самом деле далеко выходит за рамки относительно простого разбиения рукописного ввода на компоненты для написания и рисования.

Анализ рукописного ввода также включает в себя более широкие возможности для создания и прорисовки штрихов. В качестве простого примера возьмем большой двоичный объект рукописного ввода, как показано на следующем рисунке.

![две простые строки рукописного ввода](images/12e7a221-59c1-4d69-b7aa-67f2caebe375.jpg)

После того как платформа проанализировала эти штрихи, она возвращает древовидное представление этих штрихов, как показано на следующем рисунке. В этом простом случае дерево содержит только сведения о абзацах, строках и словах, но насыщенность этого дерева увеличивается по мере роста сложности документа рукописного ввода.

![древовидное представление корня, абзаца, строк и слов](images/be5a7635-0abc-45ad-bcb5-98fddee5e148.jpg)

Так как эти сведения теперь разделены на управляемые единицы, теперь можно создавать более эффективные функции. Например, приложение может расширить функцию, в которой пользователь выбирает слово, в функцию, в которой пользователь выбирает слово, дважды касанием, чтобы выделить всю строку, и нажмет три раза, чтобы выделить весь абзац. С помощью древовидной структуры, возвращаемой операцией анализа, приложение может связать выделенную область с обводкой в дереве. После того, как приложение найдет штрих, оно может пройти по дереву, чтобы определить, как и какие соседние штрихи следует выбрать.

Выбор целой строки — это упрощенный пример преимуществ анализа рукописного ввода, но возможности становятся великолепной, если один из них учитывает различные типы иерархических структур, которые анализатор рукописного ввода может обнаружить:

-   Упорядоченные и неупорядоченные списки
-   Фигуры
-   Примечания, написанные с помощью текста

Типы функций изменяются от приложения к приложению и основываются на требованиях, доступных средствах анализа рукописного ввода и распознавания.

### <a name="key-ink-analysis-features"></a>Основные функции анализа рукописного ввода

Ниже перечислены основные возможности API Инканалисис.

-   Добавочный анализ
-   Сохраняемость
-   Прокси-сервер данных
-   Процессе
-   Расширение среды

### <a name="incremental-analysis"></a>Добавочный анализ

Когда конечные пользователи работают с рукописным вводом, они обычно обрабатываются как рукописный ввод. Рукописные данные постоянно подвергаются операциям редактирования, таким как добавление новых рукописных данных, удаление существующих рукописных данных и изменение свойств рукописного ввода. все это выполняется таким же образом, как рукописный ввод постоянно редактируется. Эти операции редактирования влияют на результаты анализа. При внесении изменений они обычно могут быть изолированы по разделам документа в определенные моменты времени. Например, предположим, что пользователь записывает пять строк рукописного ввода. Стандартный способ, которым приложения анализируют рукописные данные, — подождать, пока пользователь не закончит писать все пять строк рукописного ввода (например, параграф), а затем проанализирует результаты синхронно или асинхронно.

Вы можете оптимизировать общее время, затраченное на анализ этих пяти строк, изолируя анализируемые области по мере их написания, а затем повторно анализируя только те части результатов, которые были изменены. После анализа первой строки она никогда не будет распознаваться снова, если она не была изменена конечным пользователем. Распознавание второй строки рассматривается как независимая операция распознавания.

Этот инкрементный подход хорошо работает на уровне строк для операций распознавания, но он должен работать на более высоком уровне для операции анализа рукописного ввода. Так как анализатор рукописного ввода может обнаруживать разные классификации более высокого уровня для этих пяти рукописных строк (например, это может быть Стандартный абзац или пять элементов в списке), инкрементный подход к анализатору рукописного ввода заключается в том, что он должен анализировать более высокие структуры. Это означает, что после того, как анализатор рукописного ввода классифицирует первую строку рукописного ввода как строку, он дважды проверяет, что он по-прежнему является линией, когда он классифицирует вторую строку. Однако анализатор рукописного ввода изолирует этот двойной Поиск в абзаце и пропускает первый абзац при анализе второго абзаца, рассматривая второй абзац как независимую операцию анализатора рукописного ввода. Такой инкрементный подход к анализу значительно экономит время обработки, когда в приложении уже есть большие объемы рукописного ввода.

### <a name="persistence"></a>Сохраняемость

Добавочный анализ хорошо работает в пределах заданного сеанса или экземпляра объекта [**InkAnalyzer**](inkanalyzer.md) . Однако API платформы планшетных ПК первого поколения не могут выполнить добавочный анализ после сохранения рукописного ввода на диск. API Инканалисис позволяет сохранять рукописные данные на диск вместе с сохраненной формой результатов анализа. Результаты анализа могут быть загружены при загрузке рукописного ввода и могут быть добавлены в новый экземпляр **InkAnalyzer**. Новый экземпляр объекта **InkAnalyzer** имеет те же результаты, что и его состояние ранее было и теперь может принимать любые изменения в виде добавочных изменений в существующем состоянии, а не анализировать все еще.

### <a name="data-proxy"></a>Прокси-сервер данных

Многие приложения уже имеют определенную структуру документа в своих приложениях. Например, диаграмма или база данных. [**InkAnalyzer**](inkanalyzer.md) также представляет результаты в структурированной форме в виде дерева объектов [**контекстноде**](icontextnode.md) . Структура **InkAnalyzer** и существующая структура приложения должны взаимодействовать в двух направлениях: результаты извлекаются из **InkAnalyzer** в приложение и состояние помещается из приложения в **InkAnalyzer**.

Если извлечь результаты из [**InkAnalyzer**](inkanalyzer.md) в структуру приложения все, что требовалось, это было бы сравнительно просто. Приложения будут перебирать дерево результатов и копировать (интегрировать) все необходимые результаты в существующую структуру данных. Однако так как многие горизонтальные приложения нуждаются в добавочном анализе и сохранении данных на диске, проблема превращается в два направления. Состояние (прошлые результаты) должно быть извлечено из структуры приложения и помещено в **InkAnalyzer**.

Чтобы удовлетворить это требование, [**InkAnalyzer**](inkanalyzer.md) содержит ряд событий, которые он вызывает в нужное время во время операции анализа, чтобы позволить приложениям прокси-серверу запрашивать данные обратно в существующие структуры. Эти события вызываются только для тех объектов [**контекстноде**](icontextnode.md) , которые требуются для добавочной операции.

### <a name="reconciliation"></a>Процессе

Большинству приложений потребуется проанализировать рукописный ввод в фоновом режиме, чтобы предотвратить прерывание пользовательского интерфейса как минимум. Анализ рукописного ввода в фоновом режиме вызывает проблемы, если пользователь изменяет рукописный ввод (или соседний рукописный фрагмент), который анализируется. Например, если пользователь удаляет рукописный ввод во время фоновой операции, полученная структура будет отражать состояние документа при запуске фоновой операции, а не после ее завершения.

Чтобы помочь приложениям, [**InkAnalyzer**](inkanalyzer.md) согласовывает различия в состоянии документа между началом и концом операции анализа. Изменения, внесенные пользователем или приложением во время анализа в фоновом режиме, всегда переопределяют результаты, вычисленные в фоновом режиме. После сверки выводятся только части структуры результатов, которые не конфликтуют с изменениями документа, а конфликтующие штрихи помечаются для будущего анализа. В следующий раз при выполнении операции фонового анализа результаты пересчитываются на основе нового состояния.

Этот процесс показан на следующей схеме. Время выражается линейно сверху вниз на схеме.

![процесс согласования изменений состояния документа во время операции анализа](images/6323e0b5-b6b3-4adc-8c73-da3fad5b4bc2.jpg)

1.  Во время 1 (T1) приложение собирает рукописные данные от конечного пользователя, включая любые изменения рукописного ввода, такие как добавление, удаление или изменение.
2.  В T2 приложение вызывает операцию фонового анализа. [**InkAnalyzer**](inkanalyzer.md) определяет, какие рукописные данные не имеют результатов и какие рукописные данные необходимо дважды проверить. Он копирует необходимые данные рукописного ввода, что позволяет фоновому потоку выполняться независимо друг от друга.
3.  В T3 [**InkAnalyzer**](inkanalyzer.md) возвращает выполнение потока пользовательского интерфейса в приложение. **InkAnalyzer** создает второй поток, поток фонового анализа, а также механизмы анализа и распознавания рукописного текста, анализируя скопированные данные рукописного ввода.
4.  Пока операция анализа выполняется во втором фоновом потоке, конечный пользователь продолжит редактировать документ, добавляя и удаляя данные о штрихах в T4 и T5. Эти изменения могут конфликтовать с работой, которая обрабатывается в фоновом режиме.
5.  В T6 фоновый поток завершил операцию анализа, и результаты готовы. Прежде чем [**InkAnalyzer**](inkanalyzer.md) передает результаты в приложение, он запускает алгоритм сверки, чтобы определить, что пользователь внес во время вычисления операции анализа (T4 и T5). Если обнаружены конфликты, конфликтующие штрихи помечаются для повторного анализа, что происходит при следующем вызове приложением фоновой операции анализа.
6.  Наконец, в T7, где обнаружены все конфликты, [**InkAnalyzer**](inkanalyzer.md) представляет результаты для приложения.

### <a name="extensibility"></a>Расширение среды

Интерфейсы API Инканалисис позволяют приложениям использовать новые типы обработчиков анализа, таким образом, чтобы приложение не пришлось переписывать все преимущества API Инканалисис, включая сверку, прокси-сервер данных, сохраняемость и добавочный анализ.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Microsoft. Ink](/previous-versions/dotnet/netframework-3.5/ms581553(v=vs.90))
</dt> <dt>

[Справочник по анализу рукописного ввода](ink-analysis-reference.md)
</dt> </dl>

 

 
