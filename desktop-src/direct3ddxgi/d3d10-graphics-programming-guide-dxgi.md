---
description: В этом разделе содержатся следующие подразделы.
ms.assetid: 0522ccbf-e754-470a-8199-004fcbaa927d
title: Общие сведения о DXGI
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 324a5be26aade17385a6ab0b7d347015497a2a3f
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "104494568"
---
# <a name="dxgi-overview"></a>Общие сведения о DXGI

Графическая инфраструктура Microsoft DirectX (DXGI) распознает, что некоторые части графики развиваются медленнее, чем другие. Основной целью DXGI является управление задачами низкого уровня, которые могут быть независимыми от среды DirectX Graphics. DXGI предоставляет общую платформу для будущих графических компонентов; Первый компонент, использующий версию DXGI, — это Microsoft Direct3D 10.

В предыдущих версиях Direct3D задачи низкого уровня, такие как перечисление аппаратных устройств, отображение кадров в выход, контроль гаммы и управление полноэкранным переходом были добавлены в среду выполнения Direct3D. Эти задачи теперь реализуются в DXGI.

Цель DXGI заключается в взаимодействии с драйвером режима ядра и аппаратным обеспечением системы, как показано на следующей схеме.

![Схема обмена данными между приложениями, DXGI, драйверами и оборудованием](images/dxgi-dll.png)

Приложение может напрямую обращаться к DXGI или вызывать API-интерфейсы Direct3D в D3D11 \_ 1. h, D3D11. h, D3D10 \_ 1. h или D3D10. h, который обрабатывает обмен данными с DXGI. Вы можете работать с DXGI напрямую, если приложению требуется перечислить устройства или управлять способом представления данных для вывода.

В этом разделе содержатся следующие подразделы.

-   [Перечисление адаптеров](#enumerating-adapters)
    -   [Новые сведения о перечислении адаптеров для Windows 8](#new-info-about-enumerating-adapters-for-windows-8)
-   [Уровень представления](#presentation)
    -   [Создание цепочки буферов](#create-a-swap-chain)
    -   [Отслеживание и подача цепочки буферов обмена](#care-and-feeding-of-the-swap-chain)
    -   [Обработка изменения размера окна](#handling-window-resizing)
    -   [Выбор выходных и размеров DXGI](#choosing-the-dxgi-output-and-size)
    -   [Отладка в режиме Full-Screen](#debugging-in-full-screen-mode)
    -   [Уничтожение цепочки буферов](#destroying-a-swap-chain)
    -   [Использование повернутого монитора](#using-a-rotated-monitor)
    -   [Переключение режимов](#switching-modes)
    -   [Советы по повышению производительности в полноэкранном режиме](#full-screen-performance-tip)
    -   [Вопросы многопоточности](#multithread-considerations)
-   [Ответы DXGI из DLLMain](#dxgi-responses-from-dllmain)
-   [Изменения DXGI 1,1](#dxgi-11-changes)
-   [Изменения DXGI 1,2](#dxgi-12-changes)
-   [См. также](#related-topics)

Чтобы узнать, какие форматы поддерживаются оборудованием Direct3D 11:

-   [Поддержка формата DXGI для оборудования уровня компонентов Direct3D 12,1](hardware-support-for-direct3d-12-1-formats.md)
-   [Поддержка формата DXGI для оборудования уровня компонентов Direct3D 12,0](hardware-support-for-direct3d-12-0-formats.md)
-   [Поддержка формата DXGI для оборудования уровня компонентов Direct3D 11,1](format-support-for-direct3d-11-1-feature-level-hardware.md)
-   [Поддержка формата DXGI для оборудования уровня компонентов Direct3D 11,0](format-support-for-direct3d-11-0-feature-level-hardware.md)
-   [Аппаратная поддержка форматов Direct3D 10Level9](/previous-versions//ff471324(v=vs.85))
-   [Аппаратная поддержка форматов Direct3D 10,1](/previous-versions//cc627091(v=vs.85))
-   [Поддержка оборудования для форматов Direct3D 10](/previous-versions//cc627090(v=vs.85))

## <a name="enumerating-adapters"></a>Перечисление адаптеров

Адаптер представляет собой абстракцию оборудования и программного обеспечения компьютера. На компьютере обычно используется множество адаптеров. Некоторые устройства реализуются на оборудовании (например, на видеоадаптере), а некоторые — в программном обеспечении (например, средство программной прорисовки для Direct3D). Адаптеры реализуют функциональные возможности, используемые графическим приложением. На следующей диаграмме показана система с одним компьютером, двумя адаптерами (видеоадаптеры) и тремя мониторами вывода.

![Схема компьютера с двумя видеоадаптерами и тремя мониторами](images/dxgi-terms.png)

При перечислении этих компонентов оборудования DXGI создает интерфейс [**IDXGIOutput1**](/windows/win32/api/DXGI1_2/nn-dxgi1_2-idxgioutput1) для каждого вывода (или монитора) и интерфейса [**IDXGIAdapter2**](/windows/win32/api/DXGI1_2/nn-dxgi1_2-idxgiadapter2) для каждого видеоадаптера (даже если это видеоадаптер, встроенный в материнскую плату). Перечисление выполняется с помощью вызова интерфейса [**идксгифактори**](/windows/win32/api/DXGI1_2/nn-dxgi1_2-idxgifactory2) , [**Идксгифактори:: енумадаптерс**](/windows/win32/api/DXGI/nf-dxgi-idxgifactory-enumadapters), чтобы получить набор интерфейсов [**идксгиадаптер**](/windows/win32/api/DXGI/nn-dxgi-idxgiadapter) , представляющих оборудование видео.

В DXGI 1,1 добавлен интерфейс [**IDXGIFactory1**](/windows/win32/api/DXGI/nn-dxgi-idxgifactory1) . [**IDXGIFactory1:: EnumAdapters1**](/windows/win32/api/DXGI/nf-dxgi-idxgifactory1-enumadapters1) возвращает набор интерфейсов [**IDXGIAdapter1**](/windows/win32/api/DXGI/nn-dxgi-idxgiadapter1) , представляющих оборудование видео.

Если вы хотите выбрать определенные возможности видеооборудования при использовании интерфейсов API Direct3D, мы рекомендуем итеративно вызывать функцию [**D3D11CreateDevice**](/windows/win32/api/d3d11/nf-d3d11-d3d11createdevice) или [**D3D11CreateDeviceAndSwapChain**](/windows/win32/api/d3d11/nf-d3d11-d3d11createdeviceandswapchain) с каждым маркером адаптера и возможным [уровнем компонентов](../direct3d11/overviews-direct3d-11-devices-downlevel-intro.md)оборудования. Эта функция будет выполнена, если уровень компонента поддерживается указанным адаптером.

### <a name="new-info-about-enumerating-adapters-for-windows-8"></a>Новые сведения о перечислении адаптеров для Windows 8

Начиная с Windows 8, всегда имеется адаптер с именем "базовый драйвер подготовки отчетов (Майкрософт)". Этот адаптер имеет идентификатор поставщика **0x1414** и идентификатор **0x8C**. Этот адаптер также содержит значение [**\_ \_ \_ программного обеспечения флага адаптера DXGI**](/windows/win32/api/dxgi/ne-dxgi-dxgi_adapter_flag) , заданное в элементе **flags** в структуре [**\_ \_ DESC2 адаптера DXGI**](/windows/win32/api/DXGI1_2/ns-dxgi1_2-dxgi_adapter_desc2) . Этот адаптер является устройством, предназначенным только для просмотра и не имеющим выходных данных вывода. DXGI никогда не [**возвращает \_ устройство ошибки DXGI, \_ \_ Удаленное**](dxgi-error.md) для этого адаптера.

Если видеодрайвер компьютера не работает или отключен, основной адаптер (**null**) компьютера также может называться "Microsoft базовый драйвер подготовки отчетов". Но этот адаптер содержит выходные данные и не имеет установленного [**\_ \_ \_ программного значения флага адаптера DXGI**](/windows/win32/api/dxgi/ne-dxgi-dxgi_adapter_flag) . По умолчанию этот адаптер используется операционной системой и приложениями. Если драйвер экрана установлен или включен, приложения могут получать устройство с [**\_ ошибкой DXGI \_ , \_ удаленным**](dxgi-error.md) для этого адаптера, а затем повторно перечислять адаптеры.

Если основным видеоадаптером компьютера является адаптер Microsoft Basic (адаптер[деформации](../direct3d11/overviews-direct3d-11-devices-create-warp.md) ), этот компьютер также имеет второй адаптер. Второй адаптер — это устройство, доступное только для просмотра, не имеющее выходных данных и для которого не возвращается [**\_ \_ устройство \_ с ошибкой DXGI**](dxgi-error.md).

Если вы хотите использовать ДЕФОРМАЦИЯ для отрисовки, вычислений или других длительных задач, рекомендуется использовать устройство, предназначенное только для просмотра. Чтобы получить указатель на устройство, поддерживающее рендеринг, можно вызвать метод [**IDXGIFactory1:: EnumAdapters1**](/windows/win32/api/DXGI/nf-dxgi-idxgifactory1-enumadapters1) . Кроме того, можно создать устройство, доступное только для просмотра, при указании  [**\_ \_ типа драйвера \_ D3D**](/windows/win32/api/d3dcommon/ne-d3dcommon-d3d_driver_type) в параметре дривертипе [**D3D11CreateDevice**](/windows/win32/api/d3d11/nf-d3d11-d3d11createdevice) , поскольку устройство деформации также использует адаптер искривления только для просмотра.

## <a name="presentation"></a>Уровень представления

Задание приложения состоит в отображении кадров и постановке DXGI для предоставления этих кадров выходным данным. Если у приложения есть два буфера, он может визуализировать один буфер, одновременно представляя еще один. Приложению может потребоваться более двух буферов в зависимости от времени, необходимого для отрисовки кадра или желаемой частоты кадров для представления. Набор созданных буферов называется цепочкой подкачки, как показано ниже.

![Иллюстрация цепочки буферов обмена](images/dxgi-swap-chain.png)

-   [Создание цепочки буферов](#create-a-swap-chain)
-   [Отслеживание и подача цепочки буферов обмена](#care-and-feeding-of-the-swap-chain)
-   [Обработка изменения размера окна](#handling-window-resizing)
-   [Выбор выходных и размеров DXGI](#choosing-the-dxgi-output-and-size)
-   [Отладка в режиме Full-Screen](#debugging-in-full-screen-mode)
-   [Уничтожение цепочки буферов](#destroying-a-swap-chain)
-   [Использование повернутого монитора](#using-a-rotated-monitor)
-   [Переключение режимов](#switching-modes)
-   [Советы по повышению производительности в полноэкранном режиме](#full-screen-performance-tip)
-   [Вопросы многопоточности](#multithread-considerations)

Цепочка подкачки имеет один интерфейсный буфер и один или несколько задних буферов. Каждое приложение создает собственную цепочку буферов. Чтобы максимально увеличить скорость представления данных на выходе, цепочка подкачки почти всегда создается в памяти подсистемы отображения, которая показана на следующем рисунке.

![Иллюстрация подсистемы вывода](images/dxgi-adapter.png)

Подсистема просмотра (которая часто является видеоадаптером, но может быть реализована на материнской плате) содержит графический процессор, цифровой и аналоговый конвертер (DAC) и память. Цепочка буферов выделяется в памяти, чтобы сделать презентацию очень быстрой. Подсистема отображения предоставляет данные из переднего буфера в выходные данные.

Цепочка подкачки настраивается на прорисовку в полноэкранном или оконном режиме, что позволяет избавиться от необходимости определить, является ли вывод оконным или полноэкранным. Цепь подкачки в полноэкранном режиме может оптимизировать производительность, переключив разрешение экрана.

### <a name="create-a-swap-chain"></a>Создание цепочки буферов

<table>
<colgroup>
<col style="width: 100%" />
</colgroup>
<tbody>
<tr class="odd">
<td>Различия между Direct3D 9 и Direct3D 10: Direct3D 10 — это первый компонент графики для использования DXGI. Для DXGI существует несколько различных поведений цепочки буферов.<br/>
<ul>
<li>В DXGI цепочка подкачки привязывается к окну при создании цепочки буфера обмена. Это изменение повышает производительность и экономит память. Предыдущие версии Direct3D позволяли цепи подкачки изменять окно, к которому привязана цепочка буферов.</li>
<li>В DXGI цепочка подкачки привязана к устройству отрисовки при создании. Объект устройства, возвращаемый функциями устройства Direct3D Create, реализует интерфейс <a href="/windows/win32/api/unknwn/nn-unknwn-iunknown"><strong>IUnknown</strong></a> . Можно вызвать <a href="/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)"><strong>QueryInterface</strong></a> , чтобы запросить соответствующий интерфейс <a href="/windows/win32/api/DXGI1_2/nn-dxgi1_2-idxgidevice2"><strong>IDXGIDevice2</strong></a> для устройства. Изменение устройства отрисовки требует повторного создания цепочки буфера обмена.</li>
<li><p>В DXGI доступны эффекты переключения DXGI_SWAP_EFFECT_DISCARD и DXGI_SWAP_EFFECT_SEQUENTIAL. Начиная с Windows 8 также доступен эффекты переключения DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL. В следующей таблице показано сопоставление Direct3D 9 и эффектов переключения DXGI. </p>
<table>
<thead>
<tr class="header">
<th>D3D9 swap, результат</th>
<th>Воздействие переключения на DXGI</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td>D3DSWAPEFFECT_DISCARD</td>
<td>DXGI_SWAP_EFFECT_DISCARD</td>
</tr>
<tr class="even">
<td>D3DSWAPEFFECT_COPY</td>
<td>DXGI_SWAP_EFFECT_SEQUENTIAL с 1 буфером</td>
</tr>
<tr class="odd">
<td>D3DSWAPEFFECT_FLIP</td>
<td>DXGI_SWAP_EFFECT_SEQUENTIAL с 2 или более буферами</td>
</tr>
<tr class="even">
<td>D3DSWAPEFFECT_FLIPEX</td>
<td>DXGI_SWAP_EFFECT_FLIP_SEQUENTIAL с 2 или более буферами</td>
</tr>
</tbody>
</table>
<p></p>
<p> </p></li>
</ul></td>
</tr>
</tbody>
</table>



 

Буферы цепочки перекачки создаются с определенным размером и в определенном формате. Приложение задает эти значения (или можно наследовать размер из целевого окна) при запуске, а затем при необходимости может изменить их при изменении размера окна в ответ на пользовательские входные или программные события.

После создания цепочки буферов, как правило, необходимо визуализировать изображения в нее. Ниже приведен фрагмент кода, который настраивает контекст Direct3D для отрисовки в цепочку буферов. Этот код извлекает из цепочки буфера обмена буфер, создает представление с целевым объектом рендеринга из этого буфера, а затем устанавливает его на устройстве:


```
ID3D11Resource * pBB;
ThrowFailure( pSwapChain->GetBuffer(0, __uuidof(pBB),    
  reinterpret_cast<void**>(&pBB)), "Couldn't get back buffer");
ID3D11RenderTargetView * pView;
ThrowFailure( pD3D11Device->CreateRenderTargetView(pBB, NULL, &pView), 
  "Couldn't create view" );
pD3D11DeviceContext->OMSetRenderTargets(1, &pView, 0);
        
```



После того как приложение отрисовывает кадр в буфер цепочки подкачки, вызовите [**IDXGISwapChain1::P resent1**](/windows/win32/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1). Затем приложение может выполнить визуализацию следующего изображения.

### <a name="care-and-feeding-of-the-swap-chain"></a>Отслеживание и подача цепочки буферов обмена

После подготовки изображения вызовите метод [**IDXGISwapChain1::P resent1**](/windows/win32/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) и перейдите к следующему изображению. Это область ответственности.

Если вы ранее вызывали [**идксгифактори:: макевиндовассоЦиатион**](/windows/win32/api/DXGI/nf-dxgi-idxgifactory-makewindowassociation), пользователь может нажать сочетание клавиш Alt-Enter и DXGI, чтобы перевести приложение между оконным и полноэкранным режимом. **Идксгифактори:: макевиндовассоЦиатион** рекомендуется, так как для пользователя настоятельно требуется стандартный механизм управления.

Хотя вам не нужно писать какой-либо код, чем описано, несколько простых шагов могут сделать приложение более быстрым. Наиболее важным моментом является изменение размера буферов цепочки буфера обмена в ответ на изменение размера окна вывода. Естественно, оптимальный маршрут приложения отвечает на \_ Размер WM и вызывает [**идксгисвапчаин:: ресизебуфферс**](/windows/win32/api/DXGI/nf-dxgi-idxgiswapchain-resizebuffers), передавая размер, содержащийся в параметрах сообщения. Очевидно, что приложение реагирует на пользователя, когда он перемещает границы окна, но в точности то, что обеспечивает плавное преобразование в полноэкранный режим. Окно получит \_ сообщение о размере WM всякий раз, когда происходит такой переход, и вызов **идксгисвапчаин:: ресизебуфферс** является шансом цепочки буферов для повторного выделения памяти хранилища для оптимального представления. Именно поэтому приложение должно освобождать все ссылки на существующие буферы перед вызовом **идксгисвапчаин:: ресизебуфферс**.

Сбой вызова [**идксгисвапчаин:: ресизебуфферс**](/windows/win32/api/DXGI/nf-dxgi-idxgiswapchain-resizebuffers) в ответ на переключение в полноэкранный режим (в большинстве естественно, в ответ на размер WM \_ ) может привести к исключению оптимизации зеркального отображения, где DXGI может просто поменять местами отображаемый буфер, а не копировать данные, появляющиеся в полноэкранном режиме.

[**IDXGISwapChain1::P resent1**](/windows/win32/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) сообщит, будет ли окно вывода полностью перекрыто через **\_ \_ перекрыто состояния DXGI**. В этом случае мы рекомендуем, чтобы приложение перейдет в ждущий режим (вызвав **IDXGISwapChain1::P resent1** с **\_ \_ тестом DXGI Present**), так как ресурсы, используемые для отрисовки кадра, будут излишними. Если вы используете **\_ \_ тест DXGI Present** , данные не будут представлены, пока выполняется проверка перекрытия. После **IDXGISwapChain1::P resent1** возвращает " \_ ОК", необходимо выйти из режима ожидания; не используйте код возврата для переключения в режим ожидания, так как это может привести к выходу цепочки буферов на невозможность повторного полноэкранного режима.

Среда выполнения Direct3D 11,1, которая доступна начиная с Windows 8, предоставляет цепочку пересчета перелистывания (то есть цепочку подкачки, в которой [**имеется \_ \_ \_ повернутое \_ последовательное**](/windows/win32/api/DXGI/ne-dxgi-dxgi_swap_effect) значение, заданное в элементе **SwapEffect** в [**\_ \_ цепочке обмена \_ DXGI**](/windows/win32/api/DXGI/ns-dxgi-dxgi_swap_chain_desc) , а также [**\_ \_ цепочке \_**](/windows/win32/api/DXGI1_2/ns-dxgi1_2-dxgi_swap_chain_desc1)подстановки DXGI DESC1). При отображении кадров в выходных данных с помощью цепочки перелистывания моделей, DXGI отменяет привязку заднего буфера из всех расположений состояний конвейера, таких как целевой объект прорисовки выходных данных, для записи в задний буфер 0. Поэтому рекомендуется вызывать метод [**ссылку ID3D11DeviceContext:: омсетрендертаржетс**](/windows/win32/api/d3d11/nf-d3d11-id3d11devicecontext-omsetrendertargets) непосредственно перед отрисовкой в задний буфер. Например, не вызывайте **омсетрендертаржетс** , а затем выполните действия COMPUTE Shader, которые не приводят к подготовке к ресурсу. Дополнительные сведения о цепочках перестановки перелистывания моделей и их преимуществах см. в разделе [модель перелистывания DXGI](dxgi-flip-model.md).

> [!NOTE]  
> В Direct3D 10 и Direct3D 11 не нужно вызывать [**идксгисвапчаин::-buffer**](/windows/win32/api/DXGI/nf-dxgi-idxgiswapchain-getbuffer) для получения заднего буфера 0 после вызова [**IDXGISwapChain1::P resent1**](/windows/win32/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) , так как для удобства изменения идентификаторов задних буферов изменяются. Это не происходит в Direct3D 12, и приложение вместо этого может вручную отслеживаниь индексов буфера.

### <a name="handling-window-resizing"></a>Обработка изменения размера окна

Для управления изменением размера окна можно использовать метод [**идксгисвапчаин:: ресизебуфферс**](/windows/win32/api/DXGI/nf-dxgi-idxgiswapchain-resizebuffers) . Перед вызовом **ресизебуфферс** необходимо освободить все необработанные ссылки на буферы цепочки буфера обмена. Объект, который обычно содержит ссылку на буфер цепочки буфера обмена, является представлением визуализации-Target-.

В следующем примере кода показано, как вызвать [**ресизебуфферс**](/windows/win32/api/DXGI/nf-dxgi-idxgiswapchain-resizebuffers) из обработчика WindowProc для сообщений о \_ размере WM:


```
    case WM_SIZE:
        if (g_pSwapChain)
        {
            g_pd3dDeviceContext->OMSetRenderTargets(0, 0, 0);

            // Release all outstanding references to the swap chain's buffers.
            g_pRenderTargetView->Release();

            HRESULT hr;
            // Preserve the existing buffer count and format.
            // Automatically choose the width and height to match the client rect for HWNDs.
            hr = g_pSwapChain->ResizeBuffers(0, 0, 0, DXGI_FORMAT_UNKNOWN, 0);
                                            
            // Perform error handling here!

            // Get buffer and create a render-target-view.
            ID3D11Texture2D* pBuffer;
            hr = g_pSwapChain->GetBuffer(0, __uuidof( ID3D11Texture2D),
                                         (void**) &pBuffer );
            // Perform error handling here!

            hr = g_pd3dDevice->CreateRenderTargetView(pBuffer, NULL,
                                                     &g_pRenderTargetView);
            // Perform error handling here!
            pBuffer->Release();

            g_pd3dDeviceContext->OMSetRenderTargets(1, &g_pRenderTargetView, NULL );

            // Set up the viewport.
            D3D11_VIEWPORT vp;
            vp.Width = width;
            vp.Height = height;
            vp.MinDepth = 0.0f;
            vp.MaxDepth = 1.0f;
            vp.TopLeftX = 0;
            vp.TopLeftY = 0;
            g_pd3dDeviceContext->RSSetViewports( 1, &vp );
        }
        return 1;
```



### <a name="choosing-the-dxgi-output-and-size"></a>Выбор выходных и размеров DXGI

По умолчанию DXGI выбирает выходные данные, которые содержат большую часть клиентской области окна. Это единственный вариант, доступный для DXGI, если он полностью отображается в ответ на нажатие клавиши ALT + ВВОД. Если приложение выбирает переход в полноэкранный режим самостоятельно, оно может вызвать [**идксгисвапчаин:: сетфуллскринстате**](/windows/win32/api/DXGI/nf-dxgi-idxgiswapchain-setfullscreenstate) и передать явное [**IDXGIOutput1**](/windows/win32/api/DXGI1_2/nn-dxgi1_2-idxgioutput1) (или **null**, если приложение позволяет разрешить DXGI).

Чтобы изменить размер выходных данных в полноэкранном или оконном режиме, рекомендуется вызвать [**идксгисвапчаин:: ресизетаржет**](/windows/win32/api/DXGI/nf-dxgi-idxgiswapchain-resizetarget), так как этот метод изменяет размер целевого окна. Так как размер целевого окна изменяется, операционная система отправляет **\_ Размер WM**, а код естественным образом вызывает [**идксгисвапчаин:: ресизебуфферс**](/windows/win32/api/DXGI/nf-dxgi-idxgiswapchain-resizebuffers) в ответе. Таким результатом является некоторая трата усилий на изменение размера буферов и последующее изменение размера целевого объекта.

### <a name="debugging-in-full-screen-mode"></a>Отладка в полноэкранном режиме

Цепочка подкачки DXGI освобождает полноэкранный режим только при крайней необходимости. Это означает, что можно выполнить отладку полноэкранного приложения с помощью нескольких мониторов, если окно отладки не пересекается с целевым окном цепочки буферов. Кроме того, можно полностью запретить переключение в режим, не установив **флаг \_ \_ \_ \_ \_ режима \_ разрешения цепочки DXGI** .

Если переключение режима разрешено, цепочка подкачки будет дополнять полноэкранный режим, когда окно вывода перекрытося другим окном. Проверка перекрытия выполняется во время [**IDXGISwapChain1::P resent1**](/windows/win32/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1)или в отдельном потоке, цель которого — следить за тем, что приложение перестает отвечать (и больше не вызывает **IDXGISwapChain1::P resent1**). Чтобы отключить возможность отдельного потока вызвать параметр, присвойте следующему разделу реестра любое ненулевое значение.

**HKCU \\ программное обеспечение \\ Microsoft \\ DXGI \\ дисаблефуллскринватчдог**

### <a name="destroying-a-swap-chain"></a>Уничтожение цепочки буферов

Вы не можете освободить цепочку буферов в полноэкранном режиме, так как это может привести к конфликту потоков (что приведет к созданию исключения, которое будет вызываться DXGI). Прежде чем выпустить цепочку буферов, сначала переключитесь в оконный режим (с помощью [**идксгисвапчаин:: сетфуллскринстате**](/windows/win32/api/DXGI/nf-dxgi-idxgiswapchain-setfullscreenstate)( **false**, **null** )), а затем вызовите [**IUnknown:: Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release).

### <a name="using-a-rotated-monitor"></a>Использование повернутого монитора

Приложению не нужно беспокоиться о ориентации монитора, DXGI при необходимости поворачивает буфер цепочки подкачки во время презентации. Разумеется, это дополнительное вращение может повлиять на производительность. Для достижения оптимальной производительности выполните следующие действия в приложении.

-   Используйте **\_ \_ флаг цепочки подкачки DXGI \_ \_ нонпреротатед**. Это уведомление DXGI о том, что приложение будет создавать повернутое изображение (например, путем изменения его матрицы проекции). Обратите внимание на то, что этот флаг допустим только в полноэкранном режиме.
-   Выделите каждый буфер цепочки подкачки в его повернутом размере. При необходимости используйте [**идксгиаутпут:: DESC**](/windows/win32/api/DXGI/nf-dxgi-idxgioutput-getdesc) для получения этих значений.

Выполняя вращение в приложении, DXGI просто выполнит копирование вместо копирования и поворота.

Среда выполнения Direct3D 11,1, которая доступна начиная с Windows 8, предоставляет цепочку пересчета перелистывания (то есть цепочку подкачки с отправкой [**\_ \_ \_ \_ последовательного**](/windows/win32/api/DXGI/ne-dxgi-dxgi_swap_effect) значения, заданной в элементе **SwapEffect** в [**\_ \_ цепочке \_ DESC1 среды DXGI**](/windows/win32/api/DXGI1_2/ns-dxgi1_2-dxgi_swap_chain_desc1). Чтобы максимально увеличить возможности оптимизации представления в цепочке перелистывания моделей, рекомендуется сделать приложения ориентированными на содержимое, чтобы оно соответствовало определенному выходу, на котором находится содержимое, когда содержимое полностью занимает выходные данные. Дополнительные сведения о цепочках перестановки перелистывания моделей и их преимуществах см. в разделе [модель перелистывания DXGI](dxgi-flip-model.md).

### <a name="switching-modes"></a>Переключение режимов

Цепочка подкачки DXGI может изменить режим отображения выходных данных при выполнении полноэкранного перехода. Чтобы включить автоматическое изменение режима экрана, необходимо указать в описании цепочки подкачки **\_ \_ \_ \_ \_ \_ переключатель режим разрешения цепочки** для переключения режима ожидания. При автоматическом изменении режима показа DXGI выберет самый небольшой режим (размер и разрешение не изменятся, а глубина цвета может быть изменена). Изменение размера буферов цепочки подкачки не приведет к переключению в режим. Цепочка обмена делает неявным обещанием, что при выборе заднего буфера, который точно соответствует режиму отображения, поддерживаемому целевым выходом, то при входе в полноэкранный режим будет переключен на этот режим отображения. Следовательно, выберите режим экрана, выбрав размер и формат заднего буфера.

### <a name="full-screen-performance-tip"></a>Советы по повышению производительности в полноэкранном режиме

При вызове [**IDXGISwapChain1::P resent1**](/windows/win32/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) в полноэкранном приложении цепочка обмена переворачивается (а не блитс) содержимое заднего буфера в передний буфер. Для этого требуется, чтобы цепочка буферов была создана с помощью перечисленного режима просмотра (указанного в [**\_ \_ цепочке \_ DESC1**](/windows/win32/api/DXGI1_2/ns-dxgi1_2-dxgi_swap_chain_desc1)). Если не удается перечислить режимы дисплея или неправильно указать режим экрана в описании, то цепочка буфера обмена может выполнить перенаправление на блок-блокировку (BitBlt). BitBlt вызывает дополнительную растягивание, а также увеличение использования видеопамяти и трудно обнаружить. Чтобы избежать этой проблемы, перечислите режимы экрана и инициализируйте Описание цепочки буфера обмена, прежде чем создавать цепочку буферов. Это обеспечит максимальную производительность при зеркальном отображении в полноэкранном режиме и позволяет избежать дополнительной нагрузки на память.

### <a name="multithread-considerations"></a>Вопросы многопоточности

При использовании DXGI в приложении с несколькими потоками необходимо избегать создания взаимоблокировок, в которых два разных потока ожидают завершения друг друга. Это может произойти в двух ситуациях.

-   Поток отрисовки не является потоком приема сообщений.
-   Поток, который исполняет API DXGI, не является тем же потоком, который создал окно.

Будьте внимательны, чтобы поток передачи сообщений не ждал в потоке отрисовки при использовании цепочек подкачки в полноэкранном режиме. Например, вызов [**IDXGISwapChain1::P resent1**](/windows/win32/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) (из потока прорисовки) может привести к тому, что поток обработки сообщений будет ожидать поток насоса. Если происходит изменение режима, этот сценарий возможен, если **Present1** вызывает:: SetWindowPos () или:: сетвиндовстиле () и любой из этих методов вызывает:: SendMessage (). В этом сценарии, если поток приема сообщений имеет критически важный раздел, который защищает его или если поток прорисовки заблокирован, то эти два потока будут взаимоблокироваться.

Дополнительные сведения об использовании DXGI с несколькими потоками см. в разделе [многопоточность и DXGI](../direct3d11/overviews-direct3d-11-render-multi-thread-intro.md).

## <a name="dxgi-responses-from-dllmain"></a>Ответы DXGI из DLLMain

Поскольку функция [**DllMain**](../dlls/dllmain.md) не может гарантировать порядок загрузки и выгрузки библиотек DLL, рекомендуется, чтобы функция **DllMain** приложения не вызывала функции или методы Direct3D или DXGI, включая функции или методы, которые создают или освобождают объекты. Если функция **DllMain** приложения вызывает конкретный компонент, этот компонент может вызвать другую библиотеку DLL, которая отсутствует в операционной системе, что приводит к сбою операционной системы. Direct3D и DXGI могут загружать набор библиотек DLL, как правило, набор драйверов, которые отличаются от компьютера к компьютеру. Таким образом, даже если приложение не работает со сбоем на компьютерах разработки и тестирования, когда функция **DllMain** вызывает функции или методы Direct3D или DXGI, она может завершиться сбоем, если она выполняется на другом компьютере.

Чтобы предотвратить создание приложения, которое может привести к сбою операционной системы, DXGI предоставляет следующие ответы в указанных ситуациях.

-   Если функция [**DllMain**](../dlls/dllmain.md) приложения освобождает последнюю ссылку на фабрику DXGI, DXGI создает исключение.
-   Если функция [**DllMain**](../dlls/dllmain.md) приложения создает фабрику DXGI, DXGI возвращает код ошибки.

## <a name="dxgi-11-changes"></a>Изменения DXGI 1,1

Мы добавили в DXGI 1,1 следующие функциональные возможности.

-   Поддержка синхронизированных общих поверхностей

    Синхронизированные общие поверхности для Direct3D 10,1 и Direct3D 11 обеспечивают эффективное совместное использование поверхности чтения и записи между несколькими устройствами Direct3D (возможно совместное использование устройств Direct3D 10 и Direct3D 11). См. раздел [**идксгикэйедмутекс:: аккуиресинк**](/windows/win32/api/DXGI/nf-dxgi-idxgikeyedmutex-acquiresync) and [**Идксгикэйедмутекс:: релеасесинк**](/windows/win32/api/DXGI/nf-dxgi-idxgikeyedmutex-releasesync).

-   Поддержка высокого цвета

    Поддерживает формат DXGI \_ \_ R10G10B10 \_ XR \_ смещения \_ a2 \_ UNORM.

-   [**IDXGIDevice1:: сетмаксимумфрамелатенци**](/windows/win32/api/DXGI/nf-dxgi-idxgidevice1-setmaximumframelatency) и [ **IDXGIDevice1:: жетмаксимумфрамелатенци**](/windows/win32/api/DXGI/nf-dxgi-idxgidevice1-getmaximumframelatency)
-   [**IDXGIFactory1:: EnumAdapters1**](/windows/win32/api/DXGI/nf-dxgi-idxgifactory1-enumadapters1) перечисляет локальные адаптеры без подключенных мониторов или выходных данных, а также адаптеры с присоединенными выходами. Первым возвращенным адаптером будет локальный адаптер, на котором отображается основной компьютер.
-   Поддержка формата BGRA

    \_Формат DXGI \_ B8G8R8A8 \_ UNORM и DXGI \_ \_ B8G8R8A8 \_ UNORM \_ sRGB, см. в разделе [**IDXGISurface1:: GetDC**](/windows/win32/api/DXGI/nf-dxgi-idxgisurface1-getdc) и [**IDXGISurface1:: релеаседк**](/windows/win32/api/DXGI/nf-dxgi-idxgisurface1-releasedc).

## <a name="dxgi-12-changes"></a>Изменения DXGI 1,2

Мы добавили в DXGI 1,2 следующие функциональные возможности.

-   Цепочка стерео swap
-   [Цепочка перелистывания моделей](dxgi-flip-model.md)
-   Оптимизированная презентация (прокрутка, "грязные" прямоугольники и вращение)
-   Улучшенные общие ресурсы и синхронизация
-   [Дублирование рабочего стола](desktop-dup-api.md)
-   Оптимизированное использование видеопамяти
-   Поддержка 16 бит на пиксель (бит/с) ( \_ Формат DXGI \_ B5G6R5 \_ UNORM, \_ Формат DXGI \_ B5G5R5A1 \_ UNORM, \_ Формат DXGI \_ B4G4R4A4 \_ UNORM)
-   Отладка API

Дополнительные сведения о DXGI 1,2 см. в разделе [улучшения dxgi 1,2](dxgi-1-2-improvements.md).

## <a name="related-topics"></a>См. также

[Руководством по программированию для DXGI](dx-graphics-dxgi-overviews.md)
