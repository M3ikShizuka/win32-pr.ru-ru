---
title: Перелистывание моделей, "грязных" прямоугольников, прокручиваемых областей
description: DXGI 1,2 поддерживает новую цепочку перелистывания моделей, "грязных" прямоугольников и областей с прокруткой. Мы расскажем о преимуществах использования новой цепочки перелистывания моделей и оптимизации представления, указав «грязные» прямоугольники и области с прокруткой.
ms.assetid: 22236FBD-E881-49B5-8AE9-96FB526DFEF8
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1a3abbb784de82f5bf647a4b66503497edcd4f89
ms.sourcegitcommit: 5724b38883e518ac565e1b266defa85ad0941bb2
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 02/14/2021
ms.locfileid: "104555035"
---
# <a name="flip-model-dirty-rectangles-scrolled-areas"></a>Перелистывание моделей, "грязных" прямоугольников, прокручиваемых областей

DXGI 1,2 поддерживает новую цепочку перелистывания моделей, "грязных" прямоугольников и областей с прокруткой. Мы расскажем о преимуществах использования новой цепочки перелистывания моделей и оптимизации представления, указав «грязные» прямоугольники и области с прокруткой.

## <a name="dxgi-flip-model-presentation"></a>Представление "Зеркальная презентация" в виде модели

В DXGI 1,2 добавлена поддержка модели эргономичного представления для API-интерфейсов Direct3D 10 и более поздних версий. В Windows 7 технология Direct3D 9EX сначала предприняла [представление "переворот-модель](../direct3darticles/direct3d-9ex-improvements.md) ", чтобы избежать ненужного копирования буфера цепочки подкачки. При использовании модели перелистывания задние буферы переносятся между средой выполнения и диспетчер окон рабочего стола (DWM), поэтому DWM всегда объединяется непосредственно из заднего буфера, а не копирует содержимое заднего буфера.

API-интерфейсы DXGI 1,2 включают пересмотренный интерфейс цепочки замены DXGI, [**IDXGISwapChain1**](/windows/desktop/api/DXGI1_2/nn-dxgi1_2-idxgiswapchain1). Можно использовать несколько методов интерфейса [**IDXGIFactory2**](/windows/desktop/api/DXGI1_2/nn-dxgi1_2-idxgifactory2) , чтобы создать соответствующий объект **IDXGISwapChain1** для использования с дескриптором [**HWND**](../winprog/windows-data-types.md) , объектом [CoreWindow](/uwp/api/Windows.UI.Core.CoreWindow?view=winrt-19041) , [DirectComposition](../directcomp/directcomposition-portal.md)или платформой [**Windows. UI. XAML**](/uwp/api/Windows.UI.Xaml?view=winrt-19041) .

Можно выбрать модель зеркального отображения, указав значение [**\_ \_ \_ \_ последовательного перечисления эффекты подкачки для перелистывания**](/windows/desktop/api/DXGI/ne-dxgi-dxgi_swap_effect) в элементе **SwapEffect** структуры [**\_ \_ \_ DESC1 в цепочке**](/windows/desktop/api/DXGI1_2/ns-dxgi1_2-dxgi_swap_chain_desc1) , а также установив элемент **BufferCount** **\_ цепочки подкачки DXGI \_ \_ DESC1** в значение минимум 2. Дополнительные сведения об использовании модели перелистывания DXGI см. в разделе [модель перелистывания DXGI](dxgi-flip-model.md). Из-за более плавной презентации модели представления и других новых функций рекомендуется использовать функцию отражать модель представления для всех новых приложений, написанных с помощью API Direct3D 10 и более поздних версий.

## <a name="using-dirty-rectangles-and-the-scroll-rectangle-in-swap-chain-presentation"></a>Использование «грязных» прямоугольников и прямоугольника прокрутки в представлении цепочки буферов

Используя «грязные» прямоугольники и прямоугольник прокрутки в представлении цепочки буферов, вы экономите использование пропускной способности памяти и связанного использования системы, поскольку объем данных в пикселях, который операционная система должна нарисовать, уменьшается, если операционной системе не нужно рисовать весь фрейм. Для приложений, которые часто отображаются с помощью подключение к удаленному рабочему столу и других технологий удаленного доступа, экономия особенно заметна в соответствии с качеством отображения, так как эти технологии используют «грязные» прямоугольники и метаданные прокрутки.

Можно использовать только прокрутку с цепочками переключения DXGI, выполняемыми в с параметром отразить модель представления. Вы можете использовать "грязные" прямоугольники с цепочками переключения DXGI, которые выполняются как в модели отражения, так и в модели BitBlt (задаются с [**\_ \_ \_ последовательностью переключения DXGI**](/windows/desktop/api/DXGI/ne-dxgi-dxgi_swap_effect)).

В этом сценарии и иллюстрации показаны функциональные возможности использования «грязных» прямоугольников и прокрутки. Здесь прокручиваемое приложение содержит текст и анимацию видео. Приложение использует «грязные» прямоугольники, чтобы просто обновить анимацию видео и новую строку для окна, а не обновлять окно целиком. Прямоугольник прокрутки позволяет операционной системе копировать и переводить ранее визуализированное содержимое в новом фрейме и отображать только новую строку в новом фрейме.

Приложение выполняет презентацию, вызывая метод [**IDXGISwapChain1::P resent1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) . В этом вызове приложение передает указатель на структуру [**\_ \_ параметров DXGI**](/windows/desktop/api/DXGI1_2/ns-dxgi1_2-dxgi_present_parameters) , содержащую "грязные" прямоугольники и число "грязных" прямоугольников, а также прямоугольник прокрутки и соответствующее смещение прокрутки, либо как "грязные" прямоугольники, так и прямоугольник прокрутки. Наше приложение передает 2 "грязных" прямоугольников и прямоугольник прокрутки. Прямоугольник прокрутки — это область предыдущего кадра, которую операционная система должна скопировать в текущий кадр перед отрисовкой текущего кадра. Приложение задает анимацию видео и новую строку в качестве «грязных» прямоугольников, а операционная система отображает их в текущем кадре.

![Иллюстрация перекрывающихся прямоугольников прокрутки и "грязных"](images/dxgipresentparam.png)

``` syntax
DirtyRectsCount = 2
pDirtyRects[ 0 ] = { 10, 30, 40, 50 } // Video
pDirtyRects[ 1 ] = { 0, 70, 50, 80 } // New line
*pScrollRect = { 0, 0, 50, 70 }
*pScrollOffset = { 0, -10 }
```

Пунктирный прямоугольник показывает прямоугольник прокрутки в текущем кадре. Прямоугольник прокрутки задается  членом пскроллрект [**в \_ \_ параметрах DXGI Present**](/windows/desktop/api/DXGI1_2/ns-dxgi1_2-dxgi_present_parameters). Стрелка показывает смещение прокрутки. Смещение прокрутки задается  членом пскроллоффсет **в \_ \_ параметрах DXGI Present**. В заполненных прямоугольниках отображаются "грязные" прямоугольники, которые приложение обновило с новым содержимым. Закрашенные прямоугольники задаются членами **диртиректскаунт** и **пдиртиректс** в **\_ \_ параметрах DXGI Present**.

### <a name="sample-2-buffer-flip-model-swap-chain-with-dirty-rectangles-and-scroll-rectangle"></a>Пример 2. цепочка перелистывания моделей с "грязными" прямоугольниками и прямоугольником прокрутки

На следующем рисунке и последовательности показан пример операции представления "перелистывание DXGI", в которой используются «грязные» прямоугольники и прямоугольник прокрутки. В этом примере мы используем минимальное количество буферов для представления "Зеркальная модель", которое представляет собой число буферов, равное двум, одному интерфейсному буферу, содержащему отображаемое содержимое приложения, и одному обратному буферу, содержащему текущий кадр, который приложение хочет подготовить.

1.  Как показано в интерфейсе спереди в начале кадра, прокручиваемое приложение изначально отображает рамку с текстом и анимацией видео.
2.  Чтобы отобразить следующий кадр, приложение визуализирует в обратном буфере "грязные" прямоугольники, которые обновляют видео в анимации и новую строку для окна.
3.  Когда приложение вызывает [**IDXGISwapChain1::P resent1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1), оно указывает «грязные» прямоугольники, прямоугольник прокрутки и смещение. Затем среда выполнения копирует прямоугольник прокрутки из предыдущего кадра за вычетом обновленных «грязных» прямоугольников в текущий задний буфер.
4.  Среда выполнения наконец меняет местами передний и задний буферы.

![Пример цепочки перелистывания моделей с прямоугольниками прокрутки и "грязными"](images/2-buffer-flip-model-swap-chain.png)

### <a name="tracking-dirty-rectangles-and-scroll-rectangles-across-multiple-frames"></a>Отслеживание «грязных» прямоугольников и прямоугольников прокрутки в нескольких кадрах

При использовании «грязных» прямоугольников в приложении необходимо отслеживанию «грязных» прямоугольников для поддержки добавочной визуализации. Когда приложение вызывает [**IDXGISwapChain1::P resent1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) с "грязными" прямоугольниками, необходимо обеспечить актуальность каждого пикселя в "грязных" прямоугольниках. Если вы не полностью переготовите всю область "грязного" прямоугольника или не можете понять, какие области изменялся, необходимо скопировать некоторые данные из предыдущего полностью согласованного заднего буфера в текущий устаревший задний буфер до начала подготовки к просмотру.

Среда выполнения копирует только различия между обновленными областями предыдущего кадра и обновленными областями текущего кадра на текущий задний буфер. Если эти области пересекаются, среда выполнения копирует только разницу между ними. Как видно на следующей схеме и последовательности, необходимо скопировать пересечение между «грязным» прямоугольником из кадра 1 и «грязным» прямоугольником из фрейма 2 в «грязный» прямоугольник фрейма 2.

1.  Показать "грязный" прямоугольник в кадре 1.
2.  Скопируйте пересечение между «грязным» прямоугольником из фрейма 1 и «грязным» прямоугольником из фрейма 2 в «грязный» прямоугольник фрейма 2.
3.  Представление "грязных" прямоугольника в кадре 2.

![Отслеживание прямоугольников прокрутки и «грязных» рамок в нескольких кадрах](images/track-dirty-rects-scroll-rects.png)

Чтобы обобщить, для цепочки подкачки с N буферами область, которую среда выполнения копирует из последнего кадра в текущий кадр в текущем фрейме, — это:

![Уравнение для вычисления области, которую копирует среда выполнения](images/runtime-copy-equation.png)

где buffer указывает индекс буфера в цепочке буферов, начиная с текущего индекса буфера, равным нулю.

Вы можете отслеживать любые пересечения между предыдущим и грязными прямоугольниками текущего кадра, сохранив копию «грязных» прямоугольников предыдущего кадра или повторно выполнив визуализацию «грязных» прямоугольников нового кадра с соответствующим содержимым из предыдущего кадра.

Аналогично, в случаях, когда цепочка подкачки имеет более 2 задних буферов, необходимо обеспечить копирование и повторное отображение перекрывающихся областей между «грязными» прямоугольниками текущего буфера и «грязными» прямоугольниками всех предыдущих кадров.

### <a name="tracking-a-single-intersection-between-2-dirty-rectangles"></a>Отслеживание одного пересечения между 2 "грязными" прямоугольниками

В самом простом случае при обновлении одного «грязного» прямоугольника на кадр, «Грязные» прямоугольники в двух кадрах могут пересекаться. Чтобы узнать, перекрывается ли «грязный» прямоугольник предыдущего кадра и «грязный» прямоугольник текущего фрейма, необходимо проверить, пересекаются ли «грязный» прямоугольник предыдущего кадра с «грязным» прямоугольником текущего кадра. Чтобы определить, пересекаются ли две структуры [**Rect**](/previous-versions//dd162897(v=vs.85)) , представляющие два «грязных» прямоугольников, можно вызвать функцию GDI [**интерсектрект**](/windows/win32/api/winuser/nf-winuser-intersectrect) .

В этом фрагменте кода вызов [**интерсектрект**](/windows/win32/api/winuser/nf-winuser-intersectrect) возвращает пересечение двух «грязных» прямоугольников в другом [**Rect**](/previous-versions//dd162897(v=vs.85)) , именуемом диртиректкопи. После того как фрагмент кода определит, что два "грязных" прямоугольников пересекаются, он вызывает метод [**ID3D11DeviceContext1:: CopySubresourceRegion1**](/windows/win32/api/d3d11_1/nf-d3d11_1-id3d11devicecontext1-copysubresourceregion1) , чтобы скопировать область пересечения в текущий кадр.

```
RECT dirtyRectPrev, dirtyRectCurrent, dirtyRectCopy;
 
if (IntersectRect( &dirtyRectCopy, &dirtyRectPrev, &dirtyRectCurrent ))
{
       D3D11_BOX intersectBox;
       intersectBox.left    = dirtyRectCopy.left;
       intersectBox.top     = dirtyRectCopy.top;
       intersectBox.front   = 0;
       intersectBox.right   = dirtyRectCopy.right;
       intersectBox.bottom  = dirtyRectCopy.bottom;
       intersectBox.back    = 1;
 
       d3dContext->CopySubresourceRegion1(pBackbuffer,
                                    0,
                                    0,
                                    0,
                                    0,
                                    pPrevBackbuffer,
                                    0,
                                    &intersectBox,
                                    0
                                    );
}

// Render additional content to the current pBackbuffer and call Present1.
```

Если вы используете этот фрагмент кода в приложении, приложение будет готово вызвать [**IDXGISwapChain1::P resent1**](/windows/desktop/api/DXGI1_2/nf-dxgi1_2-idxgiswapchain1-present1) , чтобы обновить текущий кадр с текущим «грязным» прямоугольником.

### <a name="tracking-intersections-between-n-dirty-rectangles"></a>Отслеживание пересечения между N грязными прямоугольниками

Если указать несколько «грязных» прямоугольников, которые могут включать «грязный» прямоугольник для вновь обнаруженной прокрутки на кадр, необходимо проверить и отнести перекрытия, которые могут произойти между всеми «грязными» прямоугольниками предыдущего кадра, и всеми «грязными» прямоугольниками текущего кадра. Чтобы вычислить пересечения между «грязными» прямоугольниками предыдущего фрейма и «грязными» прямоугольниками текущего фрейма, можно сгруппировать «грязные» прямоугольники в регионы.

В этом фрагменте кода мы вызываем функцию GDI [**сетректргн**](/windows/win32/api/wingdi/nf-wingdi-setrectrgn) для преобразования каждого "грязного" прямоугольника в прямоугольную область, а затем ВЫЗЫВАЕМ функцию GDI [**комбинергн**](/windows/win32/api/wingdi/nf-wingdi-combinergn) , чтобы объединить все изменившиеся прямоугольные области в группу.

```
HRGN hDirtyRgnPrev, hDirtyRgnCurrent, hRectRgn; // Handles to regions 
// Save all the dirty rectangles from the previous frame.
 
RECT dirtyRect[N]; // N is the number of dirty rectangles in current frame, which includes newly scrolled area.
 
int iReturn;
SetRectRgn(hDirtyRgnCurrent, 
       dirtyRect[0].left, 
       dirtyRect[0].top, 
       dirtyRect[0].right, 
       dirtyRect[0].bottom 
       );

for (int i = 1; i<N; i++)
{
   SetRectRgn(hRectRgn, 
          dirtyRect[0].left, 
          dirtyRect[0].top, 
          dirtyRect[0].right, 
          dirtyRect[0].bottom 
          );

   iReturn = CombineRgn(hDirtyRgnCurrent,
                        hDirtyRgnCurrent,
                        hRectRgn,
                        RGN_OR
                        );
   // Handle the error that CombineRgn returns for iReturn.
}
```

Теперь можно использовать функцию GDI [**комбинергн**](/windows/win32/api/wingdi/nf-wingdi-combinergn) для определения пересечения между «грязной» областью предыдущего кадра и «грязной» областью текущего кадра. После получения пересекающейся области вызовите функцию GDI [**жетрегиондата**](/windows/win32/api/wingdi/nf-wingdi-getregiondata) , чтобы получить каждый отдельный прямоугольник из пересекающейся области, а затем вызовите метод [**ID3D11DeviceContext1:: CopySubresourceRegion1**](/windows/win32/api/d3d11_1/nf-d3d11_1-id3d11devicecontext1-copysubresourceregion1) , чтобы скопировать каждый пересекающийся прямоугольник в текущий задний буфер. В следующем фрагменте кода показано, как использовать эти функции GDI и Direct3D.

```
HRGN hIntersectRgn;
bool bRegionsIntersect;
iReturn = CombineRgn(hIntersectRgn, hDirtyRgnCurrent, hDirtyRgnPrev, RGN_AND);
if (iReturn == ERROR)
{
       // Handle error.
}
else if(iReturn == NULLREGION)
{
       bRegionsIntersect = false;
}
else
{
       bRegionsIntersect = true;
}
 
if (bRegionsIntersect)
{
       int rgnDataSize = GetRegionData(hIntersectRgn, 0, NULL);
       if (rgnDataSize)
       {
              char pMem[] = new char[size];
              RGNDATA* pRgnData = reinterpret_cast<RGNDATA*>(pMem);
              iReturn = GetRegionData(hIntersectRgn, rgnDataSize, pRgnData);
              // Handle iReturn failure.
 
              for (int rectcount = 0; rectcount < pRgnData->rdh.nCount; ++r)
              {
                     const RECT* pIntersectRect = reinterpret_cast<RECT*>(pRgnData->Buffer) +                                            
                                                  rectcount;                
                     D3D11_BOX intersectBox;
                     intersectBox.left    = pIntersectRect->left;
                     intersectBox.top     = pIntersectRect->top;
                     intersectBox.front   = 0;
                     intersectBox.right   = pIntersectRect->right;
                     intersectBox.bottom  = pIntersectRect->bottom;
                     intersectBox.back    = 1;
 
                     d3dContext->CopySubresourceRegion1(pBackbuffer,
                                                      0,
                                                      0,
                                                      0,
                                                      0,
                                                      pPrevBackbuffer,
                                                      0,
                                                      &intersectBox,
                                                      0
                                                      );
              }

              delete [] pMem;
       }
}
```

### <a name="bitblt-model-swap-chain-with-dirty-rectangles"></a>Цепочка перекачки модели BitBlt с "грязными" прямоугольниками

Вы можете использовать "грязные" прямоугольники с цепочками переключения DXGI, которые выполняются в модели BitBlt (задаются с [**\_ \_ \_ последовательностью переключения DXGI**](/windows/desktop/api/DXGI/ne-dxgi-dxgi_swap_effect)). Цепочки переключения моделей BitBlt, использующие более одного буфера, также должны отслеживать перекрывающиеся "грязные" прямоугольники в кадрах таким же образом, как описано в разделе [Отслеживание грязных прямоугольников и прямоугольники прокрутки в нескольких кадрах](#tracking-dirty-rectangles-and-scroll-rectangles-across-multiple-frames) для отражения цепочек перестановки моделей. Цепочки переключения моделей BitBlt только с одним буфером не должны откладывать перекрывающиеся "грязные" прямоугольники, так как весь буфер перерисовывается в каждом кадре.

## <a name="related-topics"></a>См. также

[Усовершенствования DXGI 1,2](dxgi-1-2-improvements.md)
