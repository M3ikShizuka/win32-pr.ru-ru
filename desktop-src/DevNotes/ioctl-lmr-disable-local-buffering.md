---
description: '\_ \_ \_ \_ При считывании данных из удаленного файла или записи данных в удаленный файл с помощью лмра ioctl Disabled Local буферизации отключает кэширование данных на стороне клиента в памяти. Это внутренний определенный код элемента управления, недоступный в общедоступном заголовке.'
ms.assetid: a464671b-253c-4f35-84a2-2619cb15b009
title: Код элемента управления IOCTL_LMR_DISABLE_LOCAL_BUFFERING
ms.topic: reference
ms.date: 05/31/2018
topic_type:
- APIRef
- kbSyntax
api_name:
- COPY_CHUNK
api_type:
- NA
api_location: ''
ms.openlocfilehash: 88a6fff0955fb9e0c57c7ea5fae99f532c7c6d4dcc3578a75e07da3f35867f9a
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "117827221"
---
# <a name="ioctl_lmr_disable_local_buffering-control-code"></a>IOCTL \_ ЛМР \_ отключение \_ \_ кода управления локальной буферизацией

При считывании данных из удаленного файла или записи данных в удаленный файл с помощью **\_ Лмра ioctl \_ disabled \_ Local \_ буферизации** отключает кэширование данных на стороне клиента в памяти. Это внутренний определенный код элемента управления, недоступный в общедоступном заголовке.

Чтобы выполнить эту операцию, вызовите функцию [**DeviceIoControl**](/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol) со следующими параметрами.


```C++
BOOL DeviceIoControl(
  (HANDLE) hDevice,             // handle to device
  IOCTL_LMR_DISABLE_LOCAL_BUFFERING, // dwIoControlCode
  (LPVOID) NULL,                // lpInBuffer
  (DWORD) 0,                    // nInBufferSize
  (LPVOID) NULL,                // lpOutBuffer
  (DWORD) 0,                    // nOutBufferSize
  (LPDWORD) lpBytesReturned,    // number of bytes returned
  (LPOVERLAPPED) lpOverlapped   // OVERLAPPED structure
);
```



## <a name="parameters"></a>Параметры

<dl> <dt>

*хдевице* \[ окне\]
</dt> <dd>

Маркер удаленного файла. Чтобы получить этот маркер, вызовите функцию [**CreateFile**](/windows/win32/api/fileapi/nf-fileapi-createfilea) .

</dd> <dt>

*двиоконтролкоде* \[ окне\]
</dt> <dd>

Управляющий код для операции. Используйте значение 0x140390 для этой операции.

</dd> <dt>

*лпинбуффер* 
</dt> <dd>

Не используется, должно иметь **значение NULL**.

</dd> <dt>

*нинбуфферсизе* \[ окне\]
</dt> <dd>

Размер входного буфера в байтах. Должен равняться нулю.

</dd> <dt>

*лпаутбуффер* \[ заполняет\]
</dt> <dd>

Не используется, должно иметь **значение NULL**.

</dd> <dt>

*наутбуфферсизе* \[ окне\]
</dt> <dd>

Размер выходного буфера в байтах. Должен равняться нулю.

</dd> <dt>

*лпбитесретурнед* \[ заполняет\]
</dt> <dd>

Указатель на переменную, которая получает размер данных, хранящихся в буфере вывода, в байтах.

Если выходной буфер слишком мал, вызов завершается неудачно, функция [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) возвращает **ошибку \_ недостаточный \_ Размер буфера**, а *лпбитесретурнед* равно нулю.

Если параметр *лповерлаппед* имеет **значение NULL**, *Лпбитесретурнед* не может иметь **значение NULL**. Даже если операция не возвращает выходные данные и параметр *лпаутбуффер* имеет **значение NULL**, [**DeviceIoControl**](/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol) использует *лпбитесретурнед*. После такой операции значение *лпбитесретурнед* не имеет смысла.

Если *лповерлаппед* не **равно NULL**, *лпбитесретурнед* может иметь **значение NULL**. Если *лповерлаппед* не равно **null** и операция возвращает данные, *лпбитесретурнед* не имеет смысла до тех пор, пока не завершится операция перекрытия. Чтобы получить число возвращаемых байтов, вызовите функцию [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) . Если параметр *хдевице* связан с портом завершения ввода-вывода, можно получить число байтов, возвращенных путем вызова функции [**жеткуеуедкомплетионстатус**](/windows/win32/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) .

</dd> <dt>

*лповерлаппед* \[ окне\]
</dt> <dd>

Указатель на структуру [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) .

Если параметр *хдевице* был открыт без указания **\_ флага файла \_ OVERLAPPED**, *лповерлаппед* игнорируется.

Если *хдевице* был открыт с флагом **File \_ Flag \_ OVERLAPPED** , операция выполняется как Перекрываемая (асинхронная) операция. В этом случае *лповерлаппед* должен указывать на допустимую структуру [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) , которая содержит указатель на объект события. В противном случае функция завершается ошибкой непредсказуемым образом.

Для операций с перекрытием [**DeviceIoControl**](/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol) возвращает значение немедленно, а объект события получает сигнал о завершении операции. В противном случае функция не возвращает значение до завершения операции или до возникновения ошибки.

</dd> </dl>

## <a name="return-value"></a>Возвращаемое значение

Если операция завершается успешно, [**DeviceIoControl**](/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol) возвращает ненулевое значение.

Если операция завершается неудачно или ожидает выполнения, [**DeviceIoControl**](/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol) возвращает ноль. Дополнительные сведения об ошибке можно получить, вызвав [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror).

## <a name="remarks"></a>Комментарии

**ЛМР ioctl \_ отключает код управления \_ \_ локальной \_ буферизации** внутри системы как 0x140390, а не в общедоступном файле заголовка. Он используется специальными приложениями для отключения локального кэширования данных на стороне клиента в памяти при считывании данных из удаленного файла или записи в него. После отключения локальной буферизации параметр остается в силе до тех пор, пока все открытые дескрипторы файла не будут закрыты и перенаправитель очистит внутренние структуры данных.

Приложения общего назначения не должны использовать **ioctl \_ ЛМР \_ Отключить \_ локальную \_ буферизацию**, так как это может привести к чрезмерному сетевому трафику и снижению производительности. **ЛМР ioctl отключает управляющий код \_ \_ \_ локальной \_ буферизации** , который следует использовать только в специализированных приложениях, перемещающих большие объемы данных по сети при попытке максимизировать использование пропускной способности сети. Например, функции [**CopyFile**](/windows/win32/api/winbase/nf-winbase-copyfile) и [**копифиликс**](/windows/win32/api/winbase/nf-winbase-copyfileexa) используют **ioctl \_ ЛМР \_ Отключить \_ локальную \_ буферизацию** для повышения производительности копирования больших файлов.

Запрос **ioctl \_ ЛМР \_ отключение \_ локальной \_ буферизации** не реализовано локальными файловыми системами и завершается с ошибкой **\_ недопустимой \_ функции**. Выдача **ioctl \_ ЛМР \_ Отключение кода управления \_ локальной \_ буферизацией** в дескрипторах удаленных каталогов завершится ошибкой, так как ошибка **не будет \_ \_ поддерживаться**.

## <a name="see-also"></a>См. также раздел

<dl> <dt>

[**DeviceIoControl**](/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol)
</dt> </dl>

 

 
