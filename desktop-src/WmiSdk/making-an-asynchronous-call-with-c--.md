---
description: Приложения WMI, написанные на C++, могут выполнять асинхронные вызовы с помощью многих методов интерфейса IWbemServices COM.
ms.assetid: 5179969f-bc7d-4408-84ef-7b003950a59f
ms.tgt_platform: multiple
title: Создание асинхронного вызова с помощью C++
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b7f093aef4b1a1b4dbede53333e77d737f8efd69
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "105713033"
---
# <a name="making-an-asynchronous-call-with-c"></a>Создание асинхронного вызова с помощью C++

Приложения WMI, написанные на C++, могут выполнять асинхронные вызовы с помощью многих методов интерфейса [**IWbemServices**](/windows/desktop/api/WbemCli/nn-wbemcli-iwbemservices) com. Однако Рекомендуемая процедура вызова [*метода WMI*](gloss-w.md) или [*метода поставщика*](gloss-p.md) заключается в использовании вызовов семисинчронаус, так как вызовы семисинчронаус более безопасны, чем асинхронные вызовы. Дополнительные сведения см. в статьях [выполнение вызова семисинчронаус с помощью C++](making-a-semisynchronous-call-with-c--.md) и [Настройка безопасности для асинхронного вызова](setting-security-on-an-asynchronous-call.md).

Следующая процедура описывает, как выполнить асинхронный вызов с помощью приемника в процессе.

**Выполнение асинхронного вызова с помощью C++**

1.  Реализуйте интерфейс [**ивбемобжектсинк**](iwbemobjectsink.md) .

    Все приложения, которые выполняют асинхронные вызовы, должны реализовывать [**ивбемобжектсинк**](iwbemobjectsink.md). Для получения уведомлений о событиях временные потребители событий также реализуют **ивбемобжектсинк** .

2.  Войдите в целевое пространство имен WMI.

    Приложениям всегда приходится вызывать COM-функцию [**CoInitializeSecurity**](/windows/win32/api/combaseapi/nf-combaseapi-coinitializesecurity) на этапе инициализации. Если это не сделано до выполнения асинхронного вызова, WMI освобождает приемник приложения, не завершая асинхронный вызов. Дополнительные сведения см. в разделе [Инициализация COM для приложения WMI](initializing-com-for-a-wmi-application.md).

3.  Настройте безопасность для приемника.

    Асинхронные вызовы создают множество проблем безопасности, с которыми может потребоваться работать, например, обеспечивая доступ WMI к приложению. Дополнительные сведения см. [в разделе Настройка безопасности при асинхронном вызове](setting-security-on-an-asynchronous-call.md).

4.  Выполните асинхронный вызов.

    Метод немедленно возвращает код **\_ ошибки WBEM \_ без \_ ошибок** . Приложение может продолжить работу с другими задачами, ожидая завершения операции. Инструментарий WMI сообщает в приложении, вызывая методы в реализации [**ивбемобжектсинк**](iwbemobjectsink.md) приложения.

5.  При необходимости периодически проверяйте свою реализацию на наличие обновлений.

    Приложения могут получать уведомления о промежуточном состоянии путем установки параметра *лфлагс* в асинхронном вызове **\_ флага WBEM " \_ \_ Состояние отправки**". Инструментарий WMI сообщает о состоянии вызова, присвоив  параметру лфлагс [**ивбемобжектсинк**](iwbemobjectsink.md) значение **\_ \_ Progress Status**.

6.  При необходимости можно отменить вызов до завершения обработки WMI, вызвав метод [**IWbemServices:: канцелкалласинк**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemservices-cancelasynccall) .

    Метод [**канцеласинккалл**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemservices-cancelasynccall) отменяет асинхронную обработку, немедленно освобождая указатель на интерфейс [**ивбемобжектсинк**](iwbemobjectsink.md) и гарантирует, что указатель освобождается перед возвратом **канцеласинккалл** .

    Если вы используете объект-оболочку, реализующий интерфейс **иунсекуред** для размещения [**ивбемобжектсинк**](iwbemobjectsink.md), может оказаться, что некоторые дополнительные сложности. Так как приложение должно передавать тот же указатель на [**канцеласинккалл**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemservices-cancelasynccall) , который был передан в исходном асинхронном вызове, приложение должно храниться на объекте-оболочке до тех пор, пока не станет ясно, что отмена не требуется. Дополнительные сведения см. [в разделе Настройка безопасности при асинхронном вызове](setting-security-on-an-asynchronous-call.md).

7.  По завершении очистите указатели и завершите работу приложения.

    Инструментарий WMI предоставляет окончательный вызов состояния с помощью метода [**SetStatus**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemproviderinitsink-setstatus) .

    > [!Note]  
    > После отправки окончательного обновления состояния WMI освобождает приемник объекта, вызывая метод **Release** для класса, реализующего интерфейс [**ивбемобжектсинк**](iwbemobjectsink.md) . В предыдущем примере это метод **куерисинк:: Release** . Если вы хотите контролировать время существования объекта приемника, можно реализовать приемник с начальным счетчиком ссылок, равным единице (1).

     

    Если клиентское приложение передает один и тот же интерфейс приемника в два разных перекрывающихся асинхронных вызова, WMI не гарантирует порядок обратного вызова. Клиентское приложение, выполняющее перекрывающиеся асинхронные вызовы, должно либо передавать разные объекты-приемники, либо выполнять сериализацию вызовов.

В следующем примере требуются следующие инструкции Reference и \# include.


```C++
#include <iostream>
using namespace std;
#pragma comment(lib, "wbemuuid.lib")
#include <wbemidl.h>
```



В следующем примере показано, как выполнить асинхронный запрос с помощью метода [**ексеккуерясинк**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemservices-execqueryasync) , но не создать параметры безопасности или освободить объект [**ивбемобжектсинк**](iwbemobjectsink.md) . Дополнительные сведения см. [в разделе Настройка безопасности при асинхронном вызове](setting-security-on-an-asynchronous-call.md).


```C++
// Set input parameters to ExecQueryAsync.
BSTR QueryLang = SysAllocString(L"WQL");
BSTR Query = SysAllocString(L"SELECT * FROM MyClass");

// Create IWbemObjectSink object and set pointer.
QuerySink *pSink = new QuerySink;

IWbemServices* pSvc = 0;

// Call ExecQueryAsync.
HRESULT hRes = pSvc->ExecQueryAsync(QueryLang, 
                                    Query, 
                                    0, 
                                    NULL, 
                                    pSink);

// Check for errors.
if (hRes)
{
    printf("ExecQueryAsync failed with = 0x%X\n", hRes);
    SysFreeString(QueryLang);
    SysFreeString(Query);
    delete pSink;    
    return ERROR;
}
```



> [!Note]  
> Приведенный выше код не компилируется без ошибок, так как класс **куерисинк** не определен. Дополнительные сведения о **куерисинк** см. в разделе [**ивбемобжектсинк**](iwbemobjectsink.md).

 

## <a name="related-topics"></a>См. также

<dl> <dt>

[Вызов метода](calling-a-method.md)
</dt> </dl>

 

 
