---
description: Асинхронное уведомление о событиях — это метод, позволяющий приложению постоянно отслеживать события без монопольного применения системных ресурсов.
ms.assetid: 69ec8ead-9073-4689-bc66-5134728ab147
ms.tgt_platform: multiple
title: Получение уведомлений о асинхронных событиях
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 4c84f6c441fc5c468b0ce7d39477d52911c6ae3becb1c4c15b5130ffb041040c
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119130896"
---
# <a name="receiving-asynchronous-event-notifications"></a>Получение уведомлений о асинхронных событиях

Асинхронное уведомление о событиях — это метод, позволяющий приложению постоянно отслеживать события без монопольного применения системных ресурсов. Асинхронные уведомления о событиях имеют те же ограничения безопасности, что и другие асинхронные вызовы. Вместо этого можно выполнять вызовы семисинчронаус. Дополнительные сведения см. [в разделе вызов метода](calling-a-method.md).

Очередь асинхронных событий, направляемых клиенту, имеет потенциал для увеличения исключительно большого объема. Поэтому Инструментарий WMI реализует политику на уровне системы, чтобы избежать нехватки памяти. WMI либо замедляет события, либо начинает удалять события из очереди, когда очередь растет до определенного размера.

Инструментарий WMI использует свойства [**ловсрешолдоневентс**](/windows/desktop/CIMWin32Prov/win32-wmisetting) и [**хигхсрешолдоневентс**](/windows/desktop/CIMWin32Prov/win32-wmisetting) класса [**Win32 \_ вмисеттинг**](/windows/desktop/CIMWin32Prov/win32-wmisetting) , чтобы задать ограничения для предотвращения нехватки памяти. Минимальное значение указывает, когда инструментарий WMI должен запустить задолгое уведомление о событии, а максимальное значение указывает, когда следует запускать удаление событий. Значения по умолчанию для нижнего и верхнего пороговых значений — 1000000 (10 МБ) и 2000000 (20 МБ). Кроме того, можно задать свойство [**максваитоневентс**](/windows/desktop/CIMWin32Prov/win32-wmisetting) , чтобы описать период времени, в течение которого WMI должен ожидать перед удалением событий. Значение по умолчанию для **максваитоневентс** — 2000, или 2 секунды.

## <a name="receiving-asynchronous-event-notifications-in-vbscript"></a>Получение асинхронных уведомлений о событиях в VBScript

Вызовы сценариев для получения уведомлений о событиях, по сути, одинаковы для всех асинхронных вызовов с теми же проблемами безопасности. Дополнительные сведения см. в разделе [выполнение асинхронного вызова с помощью VBScript](making-an-asynchronous-call-with-vbscript.md).

**Получение асинхронных уведомлений о событиях в VBScript**

1.  Создайте объект приемника, вызвав [WScript. CreateObject](/previous-versions//xzysf6hc(v=vs.85)) и указав ProgID "вбемскриптинг" и тип объекта [**свбемсинк**](swbemsink.md). Объект приемника получает уведомления.
2.  Напишите подпрограммы для каждого события, которое необходимо обменять. В следующей таблице перечислены события [**свбемсинк**](swbemsink.md) .

    

    | Событие                                            | Значение                                                                                                                         |
    |--------------------------------------------------|---------------------------------------------------------------------------------------------------------------------------------|
    | [**онобжектреади**](swbemsink-onobjectready.md) | Сообщает о возвратах объекта в приемник. Использование этого вызова возвращает один объект каждый раз, пока операция не будет завершена.     |
    | [**OnCompleted**](swbemsink-oncompleted.md)     | Сообщает о завершении асинхронного вызова. Это событие никогда не происходит, если операция является неопределенной.                          |
    | [**онобжектпут**](swbemsink-onobjectput.md)     | Сообщает о завершении асинхронной операции размещения. Это событие возвращает путь к объекту экземпляра или сохраненного класса. |
    | [**OnProgress**](swbemsink-onprogress.md)       | Сообщает состояние выполняемого асинхронного вызова. Не все поставщики поддерживают промежуточные отчеты о состоянии.             |
    | [**Отменить**](swbemsink-cancel.md)               | Отменяет все необработанные асинхронные операции, связанные с этим приемником объектов.                                        |

    

     

Следующий пример кода VBScript уведомляет об удалении процессов с интервалом опроса 10 секунд. В этом скрипте онобжектреади ПРИЕМНИКа подпрограммы \_ обрабатывает экземпляр события. В этом примере объект приемника называется "Sink", однако этот объект можно назвать по своему выбору.


```VB
strComputer = "." 
Set objWMIService = GetObject("winmgmts:\\" & strComputer & "\root\CIMV2") 
Set MySink = WScript.CreateObject( _
    "WbemScripting.SWbemSink","SINK_")

objWMIservice.ExecNotificationQueryAsync MySink, _
    "SELECT * FROM __InstanceDeletionEvent" _
    & " WITHIN 10 WHERE TargetInstance ISA 'Win32_Process'"


WScript.Echo "Waiting for events..."

While (True)
    Wscript.Sleep(1000)
Wend

Sub SINK_OnObjectReady(objObject, objAsyncContext)
    Wscript.Echo "__InstanceDeletionEvent event has occurred."
End Sub

Sub SINK_OnCompleted(objObject, objAsyncContext)
    WScript.Echo "Event call complete."
End Sub
```



## <a name="receiving-asynchronous-event-notifications-in-c"></a>Получение уведомлений о асинхронных событиях в C++

для выполнения асинхронного уведомления создается отдельный поток только для отслеживания и получения событий от инструментарий управления Windows (WMI) (WMI). Когда этот поток получает сообщение, поток уведомляет ваше основное приложение.

Нажимая отдельный поток, вы разрешаете основному процессу выполнять другие действия, ожидая прибытия события. Асинхронная доставка уведомлений повышает производительность, но может обеспечить меньшую безопасность, чем требуется. В C++ имеется возможность использовать интерфейс [**ивбемунсекуредапартмент**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemunsecuredapartment) или выполнять проверки доступа в дескрипторах безопасности. Дополнительные сведения см. [в разделе Настройка безопасности при асинхронном вызове](setting-security-on-an-asynchronous-call.md).

**Настройка уведомлений о асинхронных событиях**

1.  Перед инициализацией каких-либо асинхронных уведомлений убедитесь, что параметры предотвращения нехватки памяти правильно заданы в [**Win32 \_ вмисеттинг**](/windows/desktop/CIMWin32Prov/win32-wmisetting).

2.  Определите тип событий, которые вы хотите получить.

    Инструментарий WMI поддерживает внутренние и внешние события. Внутреннее событие — это событие, предопределенное WMI, в то время как внешнее событие является событием, определенным сторонним поставщиком. Дополнительные сведения см. [в разделе Определение типа получаемого события](determining-the-type-of-event-to-receive.md).

В следующей процедуре описывается получение асинхронных уведомлений о событиях в C++.

**Получение асинхронных уведомлений о событиях в C++**

1.  Настройте приложение с помощью вызовов функций [**CoInitializeEx**](/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex) и [**CoInitializeSecurity**](/windows/win32/api/combaseapi/nf-combaseapi-coinitializesecurity) .

    Вызов [**CoInitializeEx**](/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex) инициализирует COM, а [**CoInitializeSecurity**](/windows/win32/api/combaseapi/nf-combaseapi-coinitializesecurity) предоставляет WMI разрешение на вызов процесса потребителя. Функция **CoInitializeEx** также предоставляет возможность программировать многопоточное приложение, необходимое для асинхронного уведомления. Дополнительные сведения см. в разделе [обслуживание безопасности WMI](maintaining-wmi-security.md).

    Для правильной компиляции кода в этом разделе необходимы следующие ссылки и \# операторы include.

    ```C++
    #define _WIN32_DCOM
    #include <iostream>
    using namespace std;
    #include <wbemidl.h>
    ```

    

    В следующем примере кода показано, как настроить временный потребитель событий с помощью вызовов [**CoInitializeEx**](/windows/win32/api/combaseapi/nf-combaseapi-coinitializeex) и [**CoInitializeSecurity**](/windows/win32/api/combaseapi/nf-combaseapi-coinitializesecurity).

    ```C++
    void main(int argc, char **argv)
    {
        HRESULT hr = 0;
        hr = CoInitializeEx (0, COINIT_MULTITHREADED);
        hr = CoInitializeSecurity (NULL, 
           -1, 
           NULL, 
           NULL,   
           RPC_C_AUTHN_LEVEL_NONE, 
           RPC_C_IMP_LEVEL_IMPERSONATE, 
           NULL,
           EOAC_NONE,
           NULL); 

        if (FAILED(hr))
        {
           CoUninitialize();
           cout << "Failed to initialize security. Error code = 0x"
               << hex << hr << endl;
           return;
        }

    // ...
    }
    ```

    

2.  Создайте объект приемника с помощью интерфейса [**ивбемобжектсинк**](iwbemobjectsink.md) .

    Инструментарий WMI использует [**ивбемобжектсинк**](iwbemobjectsink.md) для отправки уведомлений о событиях и для сообщения о состоянии асинхронной операции или уведомления о событии.

3.  Зарегистрируйте потребителя событий с помощью вызова метода [**IWbemServices:: ExecNotificationQueryAsync**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemservices-execnotificationqueryasync) .

    Убедитесь, что параметр *преспонсехандлер* указывает на объект приемника, созданный на предыдущем шаге.

    Назначение регистрации — получение только необходимых уведомлений. Получение избыточных уведомлений тратит время на обработку и доставку; и не использует возможности фильтрации WMI с максимальной вероятностью.

    Однако временный потребитель может получить более одного типа события. В этом случае временный потребитель должен выполнить отдельные вызовы [**IWbemServices:: ExecNotificationQueryAsync**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemservices-execnotificationqueryasync) для каждого типа событий. Например, потребителю может требоваться уведомление при создании новых процессов (событие создания экземпляра или [**\_ \_ инстанцекреатионевент**](--instancecreationevent.md)), а также об изменениях в некоторых разделах реестра (событие реестра, например [**регистрикэйчанжеевент**](/previous-versions/windows/desktop/regprov/registrykeychangeevent)). Таким образом, потребитель выполняет один вызов [**ExecNotificationQueryAsync**](swbemservices-execnotificationqueryasync.md) для регистрации событий создания экземпляра и другой вызов **ExecNotificationQueryAsync** для регистрации событий реестра.

    Если вы решили создать потребитель событий, регистрирующий несколько событий, следует избегать регистрации нескольких классов с одним и тем же приемником. Вместо этого используйте отдельный приемник для каждого класса зарегистрированного события. Наличие выделенного приемника упрощает обработку и помогает в обслуживании, позволяя отменить одну регистрацию, не затрагивая другие.

4.  Выполните все необходимые действия в потребителе события.

    Этот шаг должен содержать большую часть кода и включать такие действия, как отображение событий в пользовательский интерфейс.

5.  По завершении отмените регистрацию временного потребителя событий, вызвав событие [**IWbemServices:: канцеласинккалл**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemservices-cancelasynccall) .

    Независимо от того, завершился ли вызов [**канцеласинккалл**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemservices-cancelasynccall) успешно или нет, не удаляйте объект приемника до тех пор, пока значение счетчика ссылок на объект не достигнет нуля. Дополнительные сведения см. [в разделе вызов метода](calling-a-method.md).

 

 
