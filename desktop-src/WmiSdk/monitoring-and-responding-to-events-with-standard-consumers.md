---
description: Установленные стандартные классы потребителей можно использовать для выполнения действий на основе событий в операционной системе.
ms.assetid: 1979dc55-a440-4c31-832b-36fa84def4c9
ms.tgt_platform: multiple
title: Мониторинг событий и реагирование на них с помощью стандартных потребителей
ms.topic: article
ms.date: 05/31/2018
topic_type:
- kbArticle
api_name: ''
api_type: ''
api_location: ''
ms.openlocfilehash: 5bd1d329cd861fa45c99851707177322d0b9d12f
ms.sourcegitcommit: 168d11879cb9fd89d26f826482725c0a626be00f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/16/2021
ms.locfileid: "103914839"
---
# <a name="monitoring-and-responding-to-events-with-standard-consumers"></a>Мониторинг событий и реагирование на них с помощью стандартных потребителей

Установленные [стандартные классы потребителей](standard-consumer-classes.md) можно использовать для выполнения действий на основе событий в операционной системе. Стандартные потребители — это простые классы, которые уже зарегистрированы и определяют постоянные классы потребителей. Каждый стандартный потребитель выполняет определенное действие после получения уведомления о событии. Например, можно определить экземпляр [**активескриптевентконсумер**](activescripteventconsumer.md) для выполнения сценария, если свободное место на компьютере отличается от указанного размера.

Инструментарий WMI компилирует стандартных потребителей в пространства имен по умолчанию, зависящие от операционной системы, например:

-   В Windows Server 2003 все стандартные потребители компилируются по умолчанию в \\ пространство имен "Корневая подписка".

> [!Note]  
> Сведения о пространствах имен по умолчанию и операционных системах, которые относятся к каждому классу WMI, см. в разделах примечания и требования каждого класса.

 

В следующей таблице перечислены и описаны стандартные потребители WMI.



| Стандартный потребитель                                              | Описание                                                                                                                                                                                                                                                                                                                                                                                                             |
|----------------------------------------------------------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| [**активескриптевентконсумер**](activescripteventconsumer.md) | Выполняет скрипт при получении уведомления о событии. Дополнительные сведения см. в разделе [выполнение сценария на основе события](running-a-script-based-on-an-event.md).                                                                                                                                                                                                                                                       |
| [**логфиливентконсумер**](logfileeventconsumer.md)           | Записывает измененные строки в текстовый файл журнала при получении уведомления о событии. Дополнительные сведения см. в разделе [запись в файл журнала на основе события](writing-to-a-log-file-based-on-an-event.md).                                                                                                                                                                                                                  |
| [**нтевентложевентконсумер**](nteventlogeventconsumer.md)     | Записывает в журнал событий приложений определенное сообщение. Дополнительные сведения см. в разделе [ведение журнала событий NT на основе события](logging-to-nt-event-log-based-on-an-event.md).                                                                                                                                                                                                                                             |
| [**смтпевентконсумер**](smtpeventconsumer.md)                 | Отправляет сообщение электронной почты по протоколу SMTP каждый раз, когда в него доставляется событие. Дополнительные сведения см. [в разделе Отправка сообщения электронной почты на основе события](sending-e-mail-based-on-an-event.md).                                                                                                                                                                                                                                          |
| [**коммандлинивентконсумер**](commandlineeventconsumer.md)   | Запускает процесс, когда событие доставляется в локальную систему. Исполняемый файл должен находиться в безопасном месте или быть защищен с помощью строгого списка управления доступом (ACL), чтобы предотвратить несанкционированный пользователь заменить исполняемый объект другим исполняемым файлом. Дополнительные сведения см. в разделе [Запуск программы из командной строки на основе события](running-a-program-from-the-command-line-based-on-an-event.md). |



 

Следующая процедура описывает, как отслеживать события и реагировать на них с помощью стандартного потребителя. Обратите внимание, что процедура одинакова для файла MOF-файл (MOF), сценария или приложения.

**Мониторинг событий и реагирование на них с помощью стандартного потребителя**

1.  Укажите пространство имен в MOF-файле, используя [ \# пространство имен pragma](pragma-namespace.md)команды препроцессора. В скрипте или приложении укажите пространство имен в коде, который подключается к WMI.

    В следующем примере кода MOF показано, как указать \\ пространство имен корневой подписки.

    ```syntax
    #pragma namespace ("\\\\.\\root\\subscription")
    ```

    Большинство [*внутренних событий*](gloss-i.md) связаны с изменениями экземпляров класса в корневом \\ пространстве имен CIMV2. Однако события реестра, такие как [**регистрикэйчанжеевент**](/previous-versions/windows/desktop/regprov/registrykeychangeevent) , срабатывают в корневом \\ пространстве имен по умолчанию [поставщиком системного реестра](/previous-versions/windows/desktop/regprov/system-registry-provider).

    Потребитель может включать классы событий, расположенные в других пространствах имен, указывая пространство имен в свойстве **евентнамеспаце** в запросе [**\_ \_ EventFilter**](--eventfilter.md) для событий. [*Внутренние классы событий*](gloss-i.md) , такие как [**\_ \_ инстанцеоператионевент**](--instanceoperationevent.md) , доступны в каждом пространстве имен.

2.  Создайте и заполните экземпляр класса стандартного потребителя.

    Этот экземпляр может иметь уникальное значение в свойстве **Name** . Существующий потребитель можно обновить, повторно используя то же имя.

    **Инсертионстрингтемплатес** содержит текст для вставки в событие, указанное в **EventType**. Можно использовать литеральные строки или напрямую обращаться к свойству. Дополнительные сведения см. в статьях [Использование стандартных строковых шаблонов](using-standard-string-templates.md) и [инструкция SELECT для запросов событий](select-statement-for-event-queries.md).

    Используйте существующий источник для журнала событий, который поддерживает строку вставки без связанного текста.

    В следующем примере кода MOF показано, как использовать существующий источник сценариев WSH и значение **EventID** , равное 8.

    ```syntax
    instance of NTEventLogEventConsumer as $Consumer
    {
        Name = "RunKeyEventlogConsumer";
        SourceName = "WSH";               
        EventID = 8;
        // Warning                              
        EventType = 2;
        // One string supplies the entire message          
        NumberOfInsertionStrings = 1;             
        // the %Hive% and %KeyPath% are properties of
        // the RegistryKeyChangeEvent instance 
        InsertionStringTemplates = 
            {"The key %Hive%\\%RootPath% has been modified."
            "Check if the change is intentional"};
    };
    ```

3.  Создайте экземпляр [**\_ \_ EventFilter**](--eventfilter.md) и определите запрос для событий.

    В следующем примере фильтр отслеживает раздел реестра, в котором зарегистрированы программы запуска. Наблюдение за этим ключом реестра может быть важным, так как несанкционированная программа может зарегистрироваться в ключе, что приводит к его запуску при загрузке компьютера.

    ```syntax
    instance of __EventFilter as $Filter
    {
    Name = "RunKeyFilter";
    QueryLanguage = "WQL"; 
    Query = "Select * from RegistryTreeChangeEvent"
        " where (Hive = \"HKEY_LOCAL_MACHINE\" and "
        "RootPath = \"Software\\\\Microsoft\\\\Windows"
        "\\\\CurrentVersion\\\\Run\")";

    // RegistryTreeChangeEvents only fire in root\default namespace
    EventNamespace = "root\\default";                       
    };
    ```

4.  Определяет событие для отслеживания и создания запроса события.

    Можно проверить, имеется ли внутреннее или внешнее событие, которое использует. Например, используйте класс [**регистритричанжеевент**](/previous-versions/windows/desktop/regprov/registrytreechangeevent) поставщика реестра для отслеживания изменений в системном реестре.

    Если класс не существует, описывающий событие, которое необходимо отслеживать, необходимо создать собственный поставщик событий и определить новые классы внешних событий. Дополнительные сведения см. в разделе [запись поставщика событий](writing-an-event-provider.md).

    В MOF-файле можно определить [*псевдоним*](gloss-a.md) для фильтра и потребителя, который предоставляет простой способ описания путей к экземплярам.

    В следующем примере показано, как определить [*псевдоним*](gloss-a.md) для фильтра и потребителя.

    ```syntax
    instance of __EventFilter as $FILTER
    instance of LogFileEventConsumer as $CONSUMER
    ```

5.  Создайте экземпляр [**\_ \_ филтертоконсумербиндинг**](--filtertoconsumerbinding.md) , чтобы связать классы Filter и Consumer. Этот экземпляр определяет, что при возникновении события, соответствующего указанному фильтру, должно произойти действие, указанное потребителем. [**\_ \_ EventFilter**](--eventfilter.md), [**\_ \_ евентконсумер**](--eventconsumer.md)и **\_ \_ филтертоконсумербиндинг** должны иметь один и тот же идентификатор безопасности (SID) в свойстве **креаторсид** . Дополнительные сведения см. в разделе [Привязка фильтра событий к логическому потребителю](binding-an-event-filter-with-a-logical-consumer.md).

    В следующем примере показано, как указать экземпляр по пути к объекту или использовать псевдоним в качестве краткого выражения для пути к объекту.

    ```syntax
    instance of __EventFilter as $FILTER
    instance of NTEventLogEventConsumer as $CONSUMER
    ```

    В следующем примере фильтр привязывается к потребителю с помощью псевдонимов.

    ```syntax
    instance of __FilterToConsumerBinding
    {
        Filter = $FILTER;
        Consumer = $CONSUMER;
        
    };
    ```

    Можно привязать один фильтр к нескольким потребителям, что означает, что при возникновении событий сопоставления необходимо выполнить несколько действий. или можно привязать одного потребителя к нескольким фильтрам, что означает, что действие должно выполняться при возникновении событий, соответствующих одному из фильтров.

    В зависимости от состояния потребителей и событий выполняются следующие действия.

    -   Если один из постоянных потребителей завершается сбоем, другие потребители, запрашивающие получение уведомления о событии.
    -   Если событие удаляется, WMI запускает [**\_ \_ евентдроппедевент**](--eventdroppedevent.md).
    -   Если вы подписались на это событие, он возвращает событие, которое удаляется, а ссылка на [**\_ \_ евентконсумер**](--eventconsumer.md) представляет неудачный потребитель.
    -   Если происходит сбой потребителя, Инструментарий WMI запускает [**\_ \_ консумерфаилуривент**](--consumerfailureevent.md), который может содержать дополнительные сведения в свойствах **ErrorCode**, **ErrorDescription** и **ерроробжект** .

    Дополнительные сведения см. в разделе [Привязка фильтра событий к логическому потребителю](binding-an-event-filter-with-a-logical-consumer.md).

## <a name="example"></a>Пример

В следующем примере показан MOF для экземпляра [**нтевентложевентконсумер**](nteventlogeventconsumer.md). После компиляции этого MOF-файла любая попытка создать, удалить или изменить значение в разделе реестра путь к файлу **hKey \_ Local \_ Machine \\ Software \\ Microsoft \\ Windows \\ CurrentVersion \\ выполнить** РЕГИСТРИРУЕТ запись в журнале событий приложения в исходном "WSH".


```mof
#pragma namespace ("\\\\.\\root\\subscription")
 
instance of __EventFilter as $Filter
{
    Name = "RunKeyFilter";
    QueryLanguage = "WQL";
    Query = "Select * from RegistryTreeChangeEvent"
            " where (Hive = \"HKEY_LOCAL_MACHINE\" and "
            "KeyPath = \"Software\\\\Microsoft\\\\Windows"
            "\\\\CurrentVersion\\\\Run\")";

    // RegistryTreeChangeEvents only fire
    // in root\default namespace
    EventNamespace = "root\\default";   
};
 
instance of NTEventLogEventConsumer as $Consumer
{
    Name = "RunKeyEventlogConsumer";
    SourceName = "WSH";               
    EventID = 8;
    EventType = 2;                            // Warning
    Category = 0;
    NumberOfInsertionStrings = 1;

    // the %Hive% and %KeyPath% are properties
    // of the RegistryKeyChangeEvent instance 
    InsertionStringTemplates = {"The key %Hive%\\%RootPath% "
        "has been modified. Check if the change is intentional"};
};
 

// Bind the filter to the consumer
instance of __FilterToConsumerBinding
{
    Filter = $Filter;
    Consumer = $Consumer;
};
```



## <a name="related-topics"></a>См. также

<dl> <dt>

[Безопасное получение событий](receiving-events-securely.md)
</dt> </dl>

 

 
