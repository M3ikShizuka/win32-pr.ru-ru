---
description: Чтобы создать метод WMI, определите входные и выходные параметры для метода.
ms.assetid: 71cbecde-33c4-4bf1-9793-bef6d823dcac
ms.tgt_platform: multiple
title: Создание метода WMI
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e2489a5dd4e97ed6c8d26eeb292c45fa66901cbe
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "104272229"
---
# <a name="creating-a-wmi-method"></a>Создание метода WMI

Чтобы создать метод WMI, определите входные и выходные параметры для метода. Входные и выходные параметры представлены специальными [**\_ \_ параметрами**](--parameters.md)системного класса WMI. Дополнительные сведения см. в разделе [вызов метода](calling-a-method.md) и [написание поставщика метода](writing-a-method-provider.md).

В этом разделе обсуждаются следующие разделы:

-   [Создание метода класса WMI в MOF](#creating-a-wmi-class-method-in-mof)
-   [Создание метода класса WMI в C++](#creating-a-wmi-class-method-in-c)
-   [См. также](#related-topics)

## <a name="creating-a-wmi-class-method-in-mof"></a>Создание метода класса WMI в MOF

В WMI методы поставщика обычно являются отдельными действиями, относящимися к объекту, который представляет класс. Вместо изменения значения свойства для выполнения действия необходимо создать метод. Например, можно включить или отключить сетевой центр обработки данных (NIC), представленный [**Win32 \_ сетевого адаптера**](/windows/desktop/CIMWin32Prov/win32-networkadapter) , с помощью методов [**Enable**](/windows/desktop/CIMWin32Prov/enable-method-in-class-win32-networkadapter) и [**Disable**](/windows/desktop/CIMWin32Prov/disable-method-in-class-win32-networkadapter) . Хотя эти действия могут быть представлены как свойства для чтения и записи, рекомендуется создать метод. Кроме того, если нужно сделать видимым для класса состояние или значение, рекомендуется создать свойство для чтения и записи, а не метод. В **Win32 \_ сетевого адаптера** свойство **NetEnabled** делает состояние адаптера видимым, но изменения между состояниями выполняются методами **включения** или **отключения** .

Объявления классов могут включать объявление одного или нескольких методов. Можно либо наследовать методы родительского класса, либо реализовать собственный. Если вы решили реализовать собственные методы, необходимо объявить метод и пометить метод специальными тегами квалификатора.

В следующей процедуре описывается объявление метода в классе, который не наследует от базового класса.

**Объявление метода**

1.  Определите имя метода между фигурными скобками объявления класса, за которыми следуют все квалификаторы.

    В следующем примере кода описывается синтаксис метода.

    ``` syntax
    [Dynamic, Provider ("ProviderName")]
    class ClassName
    {
        [Implemented] <ReturnType> <MethodName>
            ([ParameterDirection, IDQualifier] 
            <ParameterType> <ParameterName>);
    };
    ```

2.  По завершении вставьте код MOF-файл (MOF) в репозиторий WMI, вызвав компилятор MOF.

    Дополнительные сведения см. в разделе [Компиляция MOF-файлов](compiling-mof-files.md).

В следующем списке определяются элементы объявления метода.

<dl> <dt>

<span id="Provider"></span><span id="provider"></span><span id="PROVIDER"></span>[**Поставщики**](/windows/desktop/api/Provider/nl-provider-provider)
</dt> <dd>

Связывает определенного поставщика с описанием класса. Значение квалификатора [**поставщика**](/windows/desktop/api/Provider/nl-provider-provider) — это имя поставщика, которое сообщает инструментарию WMI, где находится код, поддерживающий метод. Поставщик должен также отмечаться **динамическим** квалификатором любого класса, имеющего динамические экземпляры. В отличие от этого, не используйте **динамический** квалификатор, чтобы пометить класс, содержащий статический экземпляр, с **реализованными** методами.

</dd> <dt>

<span id="Implemented"></span><span id="implemented"></span><span id="IMPLEMENTED"></span>**Применен**
</dt> <dd>

Объявляет, что вы реализуете метод, а не наследуете реализацию метода из родительского класса. По умолчанию WMI распространяет реализацию родительского класса в производный класс, если только производный класс не предоставляет реализацию. Пропуск **реализованного** квалификатора указывает, что метод не имеет реализации в этом классе. При повторном объявлении метода без **реализованного** квалификатора WMI по-прежнему предполагает, что вы не собираетесь реализовывать этот метод и вызываете реализацию метода родительского класса при вызове. Таким образом, повторное объявление метода в производном классе, не присоединяя квалификатор **Implements** , полезно только при добавлении или удалении квалификатора в метод или из него.

</dd> <dt>

<span id="ReturnType"></span><span id="returntype"></span><span id="RETURNTYPE"></span>ReturnType
</dt> <dd>

Описывает, какое значение возвращает метод. Возвращаемое значение для метода должно быть логическим, числовым, **символьным**, **строковым**, [DateTime](datetime.md)или объектом схемы. Можно также объявить возвращаемый тип как [void](void.md), указывая, что метод возвращает значение Nothing. Однако нельзя объявить массив как тип возвращаемого значения.

</dd> <dt>

<span id="MethodName"></span><span id="methodname"></span><span id="METHODNAME"></span>Имя_метода
</dt> <dd>

Определяет имя метода. Каждый метод должен иметь уникальное имя. Инструментарий WMI не допускает существование двух методов с одинаковыми именами и сигнатурами в одном классе или в иерархии классов. Таким образом, также невозможно перегрузить метод.

</dd> <dt>

<span id="ParameterDirection"></span><span id="parameterdirection"></span><span id="PARAMETERDIRECTION"></span>параметердиректион
</dt> <dd>

Содержит квалификаторы, описывающие, является ли параметр входным параметром, выходным параметром или обоими. Не используйте одно и то же имя параметра более одного раза в качестве входного параметра или более одного раза в качестве выходного параметра. Если одно и то же имя параметра отображается одновременно с квалификаторами [**in**](standard-qualifiers.md) и **out** , то функциональность будет аналогична использованию квалификаторов **in** **и out для** одного параметра. Однако при использовании отдельных объявлений входные и выходные параметры должны быть совершенно одинаковыми во всех отношениях, включая число и тип квалификаторов [**ID**](standard-wmi-qualifiers.md) , и квалификатор должен быть одинаковым и явно объявленным для обоих типов. Настоятельно рекомендуется использовать квалификаторы **in** и **out** в объявлении одного параметра.

</dd> <dt>

<span id="IDQualifier"></span><span id="idqualifier"></span><span id="IDQUALIFIER"></span>**идкуалифиер**
</dt> <dd>

Содержит квалификатор [**идентификатора**](standard-wmi-qualifiers.md) , уникально определяющий расположение каждого параметра в последовательности параметров в методе. По умолчанию компилятор MOF автоматически помечает параметры квалификатором **идентификатора** . Компилятор помечает первый параметр значением 0 (ноль), второй параметр — значением 1 (один) и т. д. При необходимости можно явно указать последовательность ИДЕНТИФИКАТОРов в коде MOF.

</dd> <dt>

<span id="ParameterType"></span><span id="parametertype"></span><span id="PARAMETERTYPE"></span>ParameterType
</dt> <dd>

Описывает тип данных, который может принимать метод. Тип параметра можно определить как любое значение типа данных MOF, включая массив, объект схемы или ссылку. При использовании массива в качестве параметра используйте массив как несвязанный или с явно заданным размером.

</dd> <dt>

<span id="ParameterName"></span><span id="parametername"></span><span id="PARAMETERNAME"></span>ParameterName
</dt> <dd>

Содержит имя параметра. На этом этапе можно также задать значение по умолчанию для параметра. Параметры, у которых нет начальных значений, остаются неназначенными.

</dd> </dl>

В следующем примере кода описывается список параметров и квалификаторы.

``` syntax
[Dynamic, Provider ("ProviderX")]
class MyClass
{
    [Implemented] 
    sint32 MyMethod1 ([in, id(0)] sint32 InParam);
    [Implemented] 
    void MyMethod2 ([in, id(0)] sint32 InParam, 
       [out, id(1)] sint32 OutParam);
    [Implemented] 
    sint32 MyMethod3 ([in, out, id(0)] sint32 InOutParam);
};
```

В следующем примере кода показано, как использовать массив в параметре MOF.

``` syntax
[Dynamic, Provider ("ProviderX")]
class MyClass
{
    [Implemented] 
    sint32 MyMethod1 ([in, id(0)] Win32_LogicalDisk DiskParam[]);
    [Implemented] 
    sint32 MyMethod2 ([in, id(0)] Win32_LogicalDisk DiskParam[32]);
};
```

В следующем примере кода описывается использование объекта схемы в качестве параметра и возвращаемого значения.

``` syntax
[Dynamic, Provider ("ProviderX")]
class MyClass
{
    [Implemented] sint32 MyMethod1 ([in, id(0)] Win32_LogicalDisk 
        DiskParam);
    [Implemented] 
    Win32_LogicalDisk MyMethod2 ([in, id(0)] string DiskVolLabel);
};
```

В следующем примере кода показано, как включить две ссылки: одну для экземпляра класса [**Win32 \_ LogicalDisk**](/windows/desktop/CIMWin32Prov/win32-logicaldisk) , а другую — для экземпляра неизвестного типа объекта.

``` syntax
[Dynamic, Provider("ProviderX")]
class MyClass
{
    [Implemented] 
    sint32 MyMethod1 ([in, id(0)] Win32_LogicalDisk ref DiskRef);
    [Implemented] 
    sint32 MyMethod2 ([in, id(0)] object ref AnyObject);
};
```

## <a name="creating-a-wmi-class-method-in-c"></a>Создание метода класса WMI в C++

Следующая процедура описывает, как создать метод класса WMI программным способом.

**Создание метода класса WMI программным способом**

1.  Создайте класс, которому будет принадлежать метод.

    Сначала необходимо создать класс для размещения метода перед созданием метода.

2.  Получите два дочерних класса системного класса [**\_ \_ Parameters**](--parameters.md) с помощью [**IWbemServices:: GetObject**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemservices-getobject) или [**жетобжектасинк**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemservices-getobjectasync).

    Используйте первый дочерний класс для описания входных параметров, а второй — для описания параметров out. При необходимости можно выполнить одно извлечение, за которым следует вызов метода [**ивбемклассобжект:: Clone**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemclassobject-clone) .

3.  Запишите входные параметры в первый класс и выходные параметры второго класса, используя один или несколько вызовов [**ивбемклассобжект::P UT**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemclassobject-put).

    При описании параметров для метода обратите внимание на следующие правила и ограничения.

    -   Обрабатывать \[ входные \] параметры как отдельные записи, один в объекте, который содержит параметры In, и один в объекте, который содержит параметры out.
    -   Остальные \[ \] квалификаторы, кроме квалификаторов in, должны совпадать.
    -   Укажите квалификаторы [**идентификатора**](standard-wmi-qualifiers.md) , начиная с 0 (нуль), по одному для каждого параметра.

        Порядок входных или выходных параметров устанавливается значением квалификатора [**ID**](standard-wmi-qualifiers.md) для каждого параметра. Все входные аргументы должны предшествовать любым выходным аргументам. Изменение порядка входных и выходных параметров метода при обновлении существующего поставщика методов может привести к сбою в приложениях, вызывающих этот метод. Добавьте новые входные параметры в конец существующих параметров вместо того, чтобы вставлять их в уже установленную последовательность.

        Не забудьте оставить пробелы в последовательности квалификаторов [**идентификаторов**](standard-wmi-qualifiers.md) .

    -   Поместите возвращаемое значение в класс out-Parameters в качестве свойства с именем **ReturnValue**.

        Это определяет свойство как возвращаемое значение метода. CIM-тип этого свойства является типом возвращаемого значения метода. Если метод имеет тип возвращаемого значения void, свойство **ReturnValue** не имеет значения. Кроме того, свойство **ReturnValue** не может иметь квалификатор [**идентификатора**](standard-wmi-qualifiers.md) , как и аргументы метода. Назначение квалификатора **идентификатора** свойству **RETURNVALUE** вызывает ошибку WMI.

    -   Выражать значения всех параметров по умолчанию для свойства в классе.

4.  Поместите оба объекта [**\_ \_ параметров**](--parameters.md) в родительский класс с помощью вызова [**ивбемклассобжект::P утмесод**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemclassobject-putmethod).

    Один вызов [**путмесод**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemclassobject-putmethod) может поместить оба объекта [**\_ \_ параметров**](--parameters.md) в класс.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Создание класса](creating-a-class.md)
</dt> </dl>

 

 
