---
description: После завершения работы инструментария WMI с поставщиком он выгружает поставщик из памяти.
ms.assetid: 6116769f-3402-42b3-835d-9bdb0fc27ce0
ms.tgt_platform: multiple
title: Выгрузка поставщика
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 123d8c4f6b9d9155cdc22dc435635466956bdb0a
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "104544647"
---
# <a name="unloading-a-provider"></a>Выгрузка поставщика

После завершения работы инструментария WMI с поставщиком он выгружает поставщик из памяти. Основная причина, по которой WMI выгружает поставщик, — это экономия системных ресурсов. Поэтому необходимо добавить код, позволяющий инструментарию WMI эффективно выгружать поставщик. Он занимает от интервала, указанного в элементе управления кэшем, дважды с интервалом, в течение которого WMI выгружает поставщик.

Инструментарий WMI выгружает поставщик одним из следующих способов:

-   Выгрузить поставщик после того, как поставщик завершит назначенные ему задачи.
-   Быстрая выгрузка всех поставщиков при завершении работы системы пользователем. Обратите внимание, что инструментарий WMI выгружает внутрипроцессный поставщик при завершении работы службы WMI из командной строки.

Хотя первый сценарий является наиболее распространенным, необходимо написать поставщик для обеих возможностей.

В этом разделе обсуждаются следующие разделы:

-   [Выгрузка неактивного поставщика](#unloading-an-idle-provider)
-   [Доступ к времени простоя для поставщика](#accessing-the-idle-time-for-a-provider)
-   [Выгрузка поставщика, который также является клиентом WMI](#unloading-a-provider-that-is-also-a-wmi-client)
-   [Выгрузка поставщика во время завершения работы](#unloading-a-provider-during-shutdown)
-   [См. также](#related-topics)

## <a name="unloading-an-idle-provider"></a>Выгрузка неактивного поставщика

При выгрузке неактивного поставщика Инструментарий WMI выполняет следующие действия:

-   Определяет, бездействует ли поставщик.

    Инструментарий WMI использует свойство **клеарафтер** , чтобы определить, как долго поставщик может остаться в состоянии простоя перед выгрузкой этого поставщика. Дополнительные сведения см. [в разделе доступ к времени простоя для поставщика](#accessing-the-idle-time-for-a-provider).

-   Вызывает метод [**выпуска**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) поставщика.

    Если поставщик был чистым поставщиком, то [**выпуск**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) полностью удаляет поставщик из активной памяти. Однако нечистый поставщик может продолжать работу после вызова метода WMI **Release**.

## <a name="accessing-the-idle-time-for-a-provider"></a>Доступ к времени простоя для поставщика

Минимальный период времени, в течение которого поставщик остается активным, определяется свойством **клеарафтер** . **Клеарафтер** можно найти в экземплярах классов, производных от класса системы WMI [**\_ \_ CacheControl**](--cachecontrol.md) в \\ корневом пространстве имен.

В следующем списке описываются классы, которые являются производными от [**\_ \_ CacheControl**](--cachecontrol.md), который управляет выгрузкой поставщика:

-   [**\_\_евентконсумерпровидеркачеконтрол**](--eventconsumerprovidercachecontrol.md)
-   [**\_\_евентпровидеркачеконтрол**](--eventprovidercachecontrol.md)
-   [**\_\_евентсинккачеконтрол**](--eventsinkcachecontrol.md)
-   [**\_\_обжектпровидеркачеконтрол**](--objectprovidercachecontrol.md)
-   [**\_\_пропертипровидеркачеконтрол**](--propertyprovidercachecontrol.md)

Вы можете изменить минимальное время, в течение которого WMI позволяет поставщику оставаться неактивным, изменив свойство **клеарафтер** в экземпляре управления кэшем для конкретного типа поставщика. Например, чтобы ограничить период времени, в течение которого поставщик свойств может оставаться бездействующим, можно изменить свойство **клеарафтер** экземпляра [**\_ \_ пропертипровидеркачеконтрол**](--propertyprovidercachecontrol.md) в \\ корневом пространстве имен.

## <a name="unloading-a-provider-that-is-also-a-wmi-client"></a>Выгрузка поставщика, который также является клиентом WMI

Поставщику может потребоваться оставить клиент WMI после того, как он завершит функции поставщика, для выполнения которых он был вызван. Например, поставщику push-уведомлений может потребоваться выдавать запросы к инструментарию WMI. Дополнительные сведения см. в разделе [Определение состояния принудительной отправки или извлечения](determining-push-or-pull-status.md). В этом случае для **чистого** свойства экземпляра [**\_ \_ Win32Provider**](--win32provider.md) , представляющего поставщик, должно быть задано **значение true**. Если для **чистого** свойства задано **значение false**, поставщик готовится к выгрузке путем вызова [**IUnknown:: Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) для всех необработанных точек интерфейса, когда WMI вызывает метод Release своего основного интерфейса. Дополнительные сведения см. в подразделе "Примечания" в [**\_ \_ Win32Provider**](--win32provider.md).

В следующей процедуре описывается реализация метода Release для основного интерфейса поставщика.

**Выгрузка поставщика**

1.  Выпустите все указатели на интерфейсы, удерживаемые WMI, когда WMI вызывает метод [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) основного интерфейса поставщика.

    Как правило, поставщик содержит указатели на интерфейсы [**IWbemServices**](/windows/desktop/api/WbemCli/nn-wbemcli-iwbemservices) и [**ивбемконтекст**](/windows/desktop/api/WbemCli/nn-wbemcli-iwbemcontext) , предоставляемые в [**ивбемпровидеринит:: Initialize**](/windows/desktop/api/Wbemprov/nf-wbemprov-iwbemproviderinit-initialize).

2.  Если для **чистого** свойства в связанном экземпляре [**\_ \_ Win32Provider**](--win32provider.md) задано **значение false**, поставщик может перейти к роли клиентского приложения после вызова метода WMI [**Release**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release). Однако Инструментарий WMI не может выгрузить поставщик, работающий в качестве клиентской системы, что повышает нагрузку на систему.

    Поставщик с **чистым** значением **true** существует только для запросов на обслуживание. Таким образом, этот тип поставщика не может принимать роль клиентского приложения, и инструментарий WMI может выгрузить его.

## <a name="unloading-a-provider-during-shutdown"></a>Выгрузка поставщика во время завершения работы

При нормальных обстоятельствах использование рекомендаций в [выгрузке поставщика, который также является клиентом WMI,](#unloading-a-provider-that-is-also-a-wmi-client) позволяет инструментарию WMI правильно выгружать поставщик. Однако можно столкнуться с ситуациями, когда WMI не может инстигате нормальные процедуры выгрузки, например, когда пользователь решает выключить систему. Используя модель хранения данных в транзакциях, помимо реализации хорошей стратегии очистки, можно убедиться, что поставщик правильно выгружен.

Пользователь может в любое время приостанавливает работу инструментария WMI. В такой ситуации Инструментарий WMI не выгружает поставщиков или не вызывает точку входа [**DllCanUnloadNow**](/windows/win32/api/combaseapi/nf-combaseapi-dllcanunloadnow) для любого внутрипроцессного поставщика. Более того, если внутрипроцессный поставщик находится в середине вызова метода во время завершения работы, WMI может, возможно, завершить выполнение потока в середине вызова. В этом случае Инструментарий WMI не вызывает подпрограммы, которые обычно обрабатывали очистку, например деструктор объекта. В большинстве случаев Инструментарий WMI будет вызывать только функцию [**DllMain**](/windows/desktop/Dlls/dllmain) .

Когда операционная система завершает работу инструментария WMI, система автоматически освобождает всю память, выделенную для внутрипроцессного поставщика. Операционная система также закрывает большинство ресурсов, удерживаемых поставщиком, например дескрипторы файлов, дескрипторы окон и т. д. Поставщику не нужно предпринимать никаких действий, чтобы сделать это.

Поскольку Инструментарий WMI может завершить работу в середине вызова, поставщик не должен оставлять источники данных в нестабильном состоянии. Нестабильное сохранение данных не является проблемой для поставщиков, предназначенных только для чтения. Однако поставщикам с возможностями записи может потребоваться реализовать некоторую модель транзакции, чтобы обеспечить надежный откат после внезапного завершения.

В то время как операционная система может освободить некоторые общие системные ресурсы, система не освобождает все ресурсы автоматически. Например, операционная система может не освободить сокет или подключение к базе данных. Вместо этого поставщик может потребоваться вручную очистить такие ресурсы. Чтобы избежать этих проблем, можно либо реализовать поставщик вне процесса, либо добавить код очистки.

Самым простым решением является реализация поставщика вне процесса. Поставщик вне процесса не был завершен, когда инструментарий WMI завершает работу, хотя WMI выпустит поставщик после истечения времени ожидания COM. Поставщики, для которых проблемы с надежностью и завершением очистки являются более важными, чем производительность может быть вне процесса.

Если необходимо поместить код очистки в поставщик, у вас есть два варианта. Одно из мест для выполнения такого рода очистки — [**DllMain**](/windows/desktop/Dlls/dllmain), функция точки входа библиотеки DLL, которая вызывается операционной системой при ВЫГРУЗКЕ библиотеки DLL. Код очистки можно добавить непосредственно в **DllMain**, выполняя его в ответ **на \_ \_ отсоединение процесса DLL**. Реализация кода очистки в **DllMain** может быть довольно сложной, особенно в средах программирования, таких как MFC или ATL. Дополнительные сведения см. в статье базы знаний Майкрософт Q148791 "*как предоставить собственную функцию DllMain в обычной библиотеке DLL MFC".* (Этот ресурс может быть недоступен в некоторых языках и странах или регионах.)

Кроме того, код очистки можно также разместить в деструкторе глобального класса. Дополнительные сведения см. в разделе выгрузка поставщика. Операционная система Windows не выделяет глобальные объекты в куче. Вместо этого операционная система вызывает деструкторы во время выгрузки библиотеки DLL.

Ниже приведена простая процедура очистки, которая может поместиться в глобальный объект для инструментария WMI.


```C++
class CMyCleanup
{
    ~CMyCleanup()
    {
        CloseHandle(m_hOpenFile);
        CloseDatabaseConnection(g_hDatabase);
    }
} g_Cleanup;
```



Существует множество ограничений на то, что можно сделать в коде очистки с помощью любого из подходов. Например, ни один из потоков, ни DLL-библиотек, которые не связаны неявно, могут быть доступны каким-либо образом. Кроме того, нельзя выполнять вызовы COM при любых обстоятельствах.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Настройка дескрипторов безопасности Намепаце](setting-namespace-security-descriptors.md)
</dt> <dt>

[Защита поставщика](securing-your-provider.md)
</dt> <dt>

[Разработка поставщика WMI](developing-a-wmi-provider.md)
</dt> </dl>

 

 
