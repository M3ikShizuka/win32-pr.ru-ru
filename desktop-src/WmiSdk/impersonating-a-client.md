---
description: Когда пользовательское приложение запрашивает данные из объектов в системе через поставщик WMI, олицетворение означает, что поставщик представляет учетные данные, представляющие уровень безопасности клиентов, а не поставщики.
ms.assetid: 6d54f234-45aa-445b-ad50-7d5a9946c134
ms.tgt_platform: multiple
title: Олицетворение клиента
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 04b6d1fe931a9e0620643d8b3f8a77c63d031a41f1dac9d17301e11c03d21bfd
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119757944"
---
# <a name="impersonating-a-client"></a>Олицетворение клиента

Когда пользовательское приложение запрашивает данные из объектов в системе через поставщик WMI, олицетворение означает, что поставщик представляет учетные данные, представляющие уровень безопасности клиента, а не поставщика. Олицетворение не позволяет клиенту получить несанкционированный доступ к информации в системе.

В этом разделе обсуждаются следующие разделы:

-   [Регистрация поставщика для олицетворения](#registering-a-provider-for-impersonation)
-   [Настройка уровней олицетворения в поставщике](#setting-impersonation-levels-within-a-provider)
-   [Обслуживание уровней безопасности в поставщике](#maintaining-security-levels-in-a-provider)
-   [Обработка сообщений об отказе в доступе в поставщике](#handling-access-denied-messages-in-a-provider)
-   [Создание отчетов с частичными экземплярами](#reporting-partial-instances)
-   [Создание отчетов о частичном перечислении](#reporting-partial-enumerations)
-   [Отладка кода, которым запрещен доступ](#debugging-your-access-denied-code)
-   [Связанные темы](#related-topics)

Как правило, WMI работает как административная служба на высоком уровне безопасности с помощью контекста безопасности Локалсервер. Использование административной службы предоставляет инструментарию WMI средства для доступа к привилегированным сведениям. При вызове поставщика для получения сведений Инструментарий WMI передает ему идентификатор безопасности (SID), позволяя поставщику получить доступ к информации на том же высоком уровне безопасности.

в процессе запуска приложения wmi Windowsная операционная система предоставляет приложению WMI контекст безопасности пользователя, запустившего процесс. Контекст безопасности пользователя обычно является более низким уровнем безопасности, чем Локалсервер, поэтому пользователь может не иметь разрешения на доступ ко всей информации, доступной инструментарию WMI. Когда пользовательское приложение запрашивает динамическую информацию, Инструментарий WMI передает идентификатор безопасности пользователя соответствующему поставщику. При соответствующей записи поставщик пытается получить доступ к информации с помощью идентификатора безопасности пользователя, а не идентификатора безопасности поставщика.

Чтобы поставщик был успешно олицетворять клиентское приложение, клиентское приложение и поставщик должны удовлетворять следующим критериям.

-   Клиентское приложение должно вызывать WMI с уровнем безопасности "COM-подключение" на уровне "RPC c", " **\_ \_ \_ \_ impersonate** " или " **RPC c" на \_ \_ \_ уровне \_ Imp**. Дополнительные сведения см. в разделе [обслуживание безопасности WMI](maintaining-wmi-security.md).
-   Поставщик должен зарегистрироваться в WMI как поставщик олицетворения. Дополнительные сведения см. [в разделе Регистрация поставщика для олицетворения](#registering-a-provider-for-impersonation).
-   Перед доступом к привилегированным сведениям поставщик должен переключиться на уровень безопасности клиентского приложения. Дополнительные сведения см. [в разделе Настройка уровней олицетворения в поставщике](#setting-impersonation-levels-within-a-provider).
-   Поставщик должен правильно обрабатывал ошибки, если доступ к этим данным запрещен. Дополнительные сведения см. [в разделе Обработка сообщений с запретом доступа в поставщике](#handling-access-denied-messages-in-a-provider).

## <a name="registering-a-provider-for-impersonation"></a>Регистрация поставщика для олицетворения

Инструментарий WMI передает только идентификатор безопасности клиентского приложения поставщикам, зарегистрированным в качестве поставщиков олицетворения. Чтобы разрешить поставщику выполнять олицетворение, необходимо изменить процесс регистрации поставщика.

В следующей процедуре описывается регистрация поставщика для олицетворения. Процедура предполагает, что вы уже понимаете процесс регистрации. Дополнительные сведения о процессе регистрации см. в разделе [Регистрация поставщика](registering-a-provider.md).

**Регистрация поставщика для олицетворения**

1.  Установите свойство [**имперсонатионлевел**](swbemsecurity-impersonationlevel.md) класса [**\_ \_ Win32Provider**](--win32provider.md) , который представляет поставщика, в значение 1.

    Свойство [**имперсонатионлевел**](swbemsecurity-impersonationlevel.md) документирует, поддерживает ли поставщик олицетворение. Установка значения 0 для **имперсонатионлевел** указывает, что поставщик не олицетворяет клиента и выполняет все запрошенные операции в том же контексте пользователя, что и WMI. Установка значения 1 для **имперсонатионлевел** указывает, что поставщик использует вызовы олицетворения для проверки операций, выполняемых от имени клиента.

2.  Задайте для свойства **перусеринитиализатион** одного и того же класса [**\_ \_ Win32Provider**](--win32provider.md) значение **true**.

> [!Note]  
> При регистрации поставщика со свойством [**\_ \_ Win32Provider**](--win32provider.md) **инитиализеасадминфирст** , установленным в **значение true**, поставщик использует токен безопасности потока уровня администрирования только на этапе инициализации. Хотя вызов [**коимперсонатеклиент**](/windows/win32/api/combaseapi/nf-combaseapi-coimpersonateclient) не завершается ошибкой, поставщик использует контекст безопасности WMI, а не клиент.

 

В следующем примере кода показано, как зарегистрировать поставщик для олицетворения.

``` syntax
instance of __Win32Provider
{
    CLSID = "{FD4F53E0-65DC-11d1-AB64-00C04FD9159E}";
    ImpersonationLevel = 1;
    Name = "MS_NT_EVENTLOG_PROVIDER";
    PerUserInitialization = TRUE;
};
```

## <a name="setting-impersonation-levels-within-a-provider"></a>Настройка уровней олицетворения в поставщике

При регистрации поставщика с помощью свойства класса [**\_ \_ Win32Provider**](--win32provider.md) [**имперсонатионлевел**](swbemsecurity-impersonationlevel.md) , установленного в значение 1, WMI вызывает поставщик для олицетворения различных клиентов. Чтобы обрабатывал эти вызовы, используйте функции COM [**коимперсонатеклиент**](/windows/win32/api/combaseapi/nf-combaseapi-coimpersonateclient) и [**кореверттоселф**](/windows/win32/api/combaseapi/nf-combaseapi-coreverttoself) в реализации интерфейса [**IWbemServices**](/windows/desktop/api/WbemCli/nn-wbemcli-iwbemservices) .

Функция [**коимперсонатеклиент**](/windows/win32/api/combaseapi/nf-combaseapi-coimpersonateclient) позволяет серверу олицетворять клиента, который сделал вызов. Поместив вызов **коимперсонатеклиент** в свою реализацию [**IWbemServices**](/windows/desktop/api/WbemCli/nn-wbemcli-iwbemservices), вы разрешаете поставщику установить маркер потока поставщика в соответствии с маркером потока клиента, а значит, олицетворять клиента. Если не вызвать **коимперсонатеклиент**, поставщик выполняет код на уровне администратора безопасности, тем самым создавая потенциальную уязвимость безопасности. Если поставщик временно должен работать от имени администратора или выполнить проверку доступа вручную, вызовите [**кореверттоселф**](/windows/win32/api/combaseapi/nf-combaseapi-coreverttoself).

В отличие от [**коимперсонатеклиент**](/windows/win32/api/combaseapi/nf-combaseapi-coimpersonateclient), [**кореверттоселф**](/windows/win32/api/combaseapi/nf-combaseapi-coreverttoself) является com-функцией, которая обрабатывает уровни олицетворения потоков. В этом случае **кореверттоселф** изменяет уровень олицетворения обратно на исходный параметр олицетворения. Как правило, поставщик изначально является администратором и перемещается между **коимперсонатеклиент** и **кореверттоселф** в зависимости от того, выполняется ли вызов, представляющий вызывающий объект, или его собственные вызовы. Поставщик должен правильно размещать эти вызовы, чтобы не предоставлять конечному пользователю брешь в системе безопасности. например, поставщик должен вызывать только собственные функции Windows в рамках последовательности с олицетворенным кодом.

> [!Note]  
> Назначение [**коимперсонатеклиент**](/windows/win32/api/combaseapi/nf-combaseapi-coimpersonateclient) и [**кореверттоселф**](/windows/win32/api/combaseapi/nf-combaseapi-coreverttoself) заключается в настройке безопасности для поставщика. Если вы определили, что произошел сбой олицетворения, следует вернуть соответствующий код завершения в WMI через [**ивбемобжектсинк:: SetStatus**](/windows/desktop/api/Wbemcli/nf-wbemcli-iwbemobjectsink-setstatus). Дополнительные сведения см. [в разделе Обработка сообщений с запретом доступа в поставщике](#handling-access-denied-messages-in-a-provider).

 

## <a name="maintaining-security-levels-in-a-provider"></a>Обслуживание уровней безопасности в поставщике

Поставщики не могут вызывать [**коимперсонатеклиент**](/windows/win32/api/combaseapi/nf-combaseapi-coimpersonateclient) один раз в реализации [**IWbemServices**](/windows/desktop/api/WbemCli/nn-wbemcli-iwbemservices) и предполагают, что учетные данные олицетворения остаются на месте в течение срока действия поставщика. Вместо этого вызывайте **коимперсонатеклиент** несколько раз во время реализации, чтобы предотвратить изменение учетных данных WMI.

Основная проблема при настройке олицетворения для поставщика — повторный вход. В этом контексте повторный вход происходит, когда поставщик вызывает WMI для получения сведений и ожидает, пока Инструментарий WMI не вернется к поставщику. По сути, поток выполнения покидает код поставщика, только для повторного ввода кода в следующий день. Повторная запись является частью структуры модели COM и, как правило, не является проблемой. Однако когда поток выполнения переходит в инструментарий WMI, поток принимает на себя уровни олицетворения WMI. Когда поток возвращается поставщику, необходимо сбросить уровни олицетворения с помощью другого вызова [**коимперсонатеклиент**](/windows/win32/api/combaseapi/nf-combaseapi-coimpersonateclient).

Чтобы защитить себя от брешей в системе безопасности поставщика, следует выполнять повторные вызовы в WMI только при олицетворении клиента. То есть вызовы WMI должны быть сделаны после вызова [**коимперсонатеклиент**](/windows/win32/api/combaseapi/nf-combaseapi-coimpersonateclient) и перед вызовом [**кореверттоселф**](/windows/win32/api/combaseapi/nf-combaseapi-coreverttoself). Так как **кореверттоселф** приводит к тому, что олицетворение устанавливается на уровне пользователя, то, как правило, используется учетная запись LocalSystem, повторное выполнение вызовов к инструментарию WMI после вызова **кореверттоселф** , может предоставить пользователю, а также все поставщики, вызываемые, гораздо больше возможностей, чем они должны быть.

> [!Note]  
> При вызове системной функции или другого метода интерфейса не гарантируется, что контекст вызова будет поддерживаться.

 

## <a name="handling-access-denied-messages-in-a-provider"></a>Обработка сообщений об отказе в доступе в поставщике

Большинство сообщений об ошибках отказа в доступе появляются, когда клиент запрашивает класс или сведения, к которым у них нет доступа. Если поставщик возвращает сообщение об ошибке отказа в доступе к инструментарию WMI и WMI передает его клиенту, клиент может определить, существует ли информация. В некоторых случаях это может привести к нарушению безопасности. Поэтому поставщик не должен распространять сообщение клиенту. Вместо этого набор классов, предоставленных поставщиком, не должен быть предоставлен. Аналогичным образом, поставщик динамического экземпляра должен вызвать базовый источник данных, чтобы определить, как обрабатывать сообщения с запретом доступа. Ответственность за репликацию этой философии в среду WMI несет поставщик. Дополнительные сведения см. в разделе [Создание отчетов с частичными экземплярами](#reporting-partial-instances) и [Создание отчетов о частичном перечислении](#reporting-partial-enumerations).

При определении того, как поставщик должен выполнять обработку сообщений об отказе в доступе, необходимо написать и отладить код. Во время отладки часто бывает удобно различать отработку отказа из-за недостаточного олицетворения и отказа из-за ошибки в коде. Для определения разницы можно использовать простой тест в коде. Дополнительные сведения см. [в разделе Отладка кода, которым запрещен доступ](#debugging-your-access-denied-code).

## <a name="reporting-partial-instances"></a>Создание отчетов с частичными экземплярами

Одно из распространенных событий отказа в доступе заключается в том, что инструментарий WMI не может предоставить всю информацию для заполнения экземпляра. Например, клиент может иметь полномочия на просмотр объекта жесткого диска, но может не иметь права видеть, сколько места доступно на жестком диске. Поставщик должен определить способ решения любой ситуации, когда поставщик не может полностью заполнить экземпляр свойствами из-за нарушения прав доступа.

Инструментарию WMI не требуется одиночный ответ клиентам с частичным доступом к экземпляру. Вместо этого WMI версии 1. x разрешает поставщику один из следующих вариантов:

-   Завершить всю операцию с **\_ \_ \_ отказом в доступе к WBEM E** и не возвращать экземпляры.

    Чтобы описать причину отказа, возвратите объект ошибки вместе с **\_ \_ \_ отказом в доступе к WBEM E**.

-   Возвращают все доступные свойства и заполняют недоступные свойства **значением NULL**.

> [!Note]  
> Убедитесь, что при возврате **\_ \_ доступа \_ WBEM E** не создается брешь в системе безопасности предприятия.

 

## <a name="reporting-partial-enumerations"></a>Создание отчетов о частичном перечислении

Другое распространенное возникновение нарушения прав доступа заключается в том, что WMI не может вернуть все перечисление. Например, клиент может иметь доступ для просмотра всех объектов локального сетевого компьютера, но может не иметь доступа для просмотра объектов компьютера за пределами своего домена. Поставщик должен определить, как обрабатывать ситуацию, когда перечисление не может быть завершено из-за нарушения прав доступа.

Как и у поставщика экземпляров, WMI не требует одного ответа на частичное перечисление. Вместо этого WMI версии 1. x предоставляет поставщику один из следующих вариантов:

-   Возвратите **WBEM \_ \_ без \_ ошибок** для всех экземпляров, к которым поставщик может получить доступ.

    При использовании этого параметра пользователь не знает, что некоторые экземпляры были недоступны. ряд поставщиков, например, с использованием язык SQL (SQL) с безопасностью на уровне строк, возвращают успешные частичные результаты, используя уровень безопасности вызывающего объекта для определения результирующего набора.

-   Завершить всю операцию с **\_ \_ \_ отказом в доступе к WBEM E** и не возвращать экземпляры.

    Поставщик может дополнительно включить объект Error, который описывает ситуацию для клиента. Обратите внимание, что некоторые поставщики могут обращаться к источникам данных последовательно и могут не столкнуться с отказами, пока не попадете через перечисление.

-   Возвращают все экземпляры, к которым возможен доступ, но также возвращают код состояния неошибки с кодом **WBEM \_ S \_ \_ отказано в доступе**.

    Поставщик должен отметить нарушение во время перечисления и может продолжать предоставлять экземпляры, завершая код состояния неошибки. Поставщик может также выбрать завершение перечисления при первом отказе. Обоснование этого параметра заключается в том, что разные поставщики имеют разные парадигмы извлечения. Поставщик может уже доставить экземпляры, прежде чем обнаруживать нарушение прав доступа. Некоторые поставщики могут продолжать предоставлять другие экземпляры, и другие могут быть готовы к завершению.

Из-за структуры COM невозможно выполнить упаковку обратной передачи информации во время ошибки, за исключением объекта ошибки. Поэтому нельзя вернуть обе сведения и код ошибки. Если вы решили вернуть сведения, необходимо использовать код состояния без ошибок.

## <a name="debugging-your-access-denied-code"></a>Отладка кода, которым запрещен доступ

Некоторые приложения могут использовать уровни олицетворения ниже, чем **RPC \_ C \_ на \_ уровне \_ Imp**. В этом случае большинство вызовов олицетворения, выполненных поставщиком для клиентского приложения, завершатся ошибкой. Для успешного проектирования и реализации поставщика необходимо учитывать эту идею.

По умолчанию единственным другим уровнем олицетворения, который может получить доступ к поставщику, **является \_ \_ Указание на \_ уровне \_ "RPC C**". В случаях, когда клиентское приложение использует **RPC \_ C на \_ \_ уровне Imp \_**, [**коимперсонатеклиент**](/windows/win32/api/combaseapi/nf-combaseapi-coimpersonateclient) не возвращает код ошибки. Вместо этого поставщик олицетворяет клиента только в целях идентификации. поэтому большинство методов Windows, вызванных поставщиком, будут возвращать сообщение об отказе в доступе. Это не является безопасным на практике, поскольку пользователям не будет разрешено делать что-либо неприемлемое. Однако это может быть полезно при разработке поставщика, чтобы определить, является ли клиент действительно олицетворенным.

Для правильной компиляции кода требуются следующие ссылки и \# операторы include.


```C++
#define _WIN32_DCOM
#include <iostream>
using namespace std;
#include <wbemidl.h>
```



В следующем примере кода показано, как определить, был ли поставщик успешно олицетворять клиентское приложение.


```C++
DWORD dwImp = 0;
HANDLE hThreadTok;
DWORD dwBytesReturned;
BOOL bRes;

// You must call this before trying to open a thread token!
CoImpersonateClient();

bRes = OpenThreadToken(
    GetCurrentThread(),
    TOKEN_QUERY,
    TRUE,
    &hThreadTok
);

if (bRes == FALSE)
{
    printf("Unable to read thread token (%d)\n", GetLastError());
    return 0;
}

bRes = GetTokenInformation(
    hThreadTok,
    TokenImpersonationLevel, 
    &dwImp,
    sizeof(DWORD),
    &dwBytesReturned
);

if (!bRes)
{
    printf("Unable to read impersonation level\n");
    CloseHandle(hThreadTok);
    return 0;
}

switch (dwImp)
{
case SecurityAnonymous:
    printf("SecurityAnonymous\n");
    break;

case SecurityIdentification:
    printf("SecurityIdentification\n");
    break;

case SecurityImpersonation:
    printf("SecurityImpersonation\n");
    break;

case SecurityDelegation:
    printf("SecurityDelegation\n");
    break;

default:
    printf("Error. Unable to determine impersonation level\n");
    break;
}

CloseHandle(hThreadTok);
```



## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Разработка поставщика WMI](developing-a-wmi-provider.md)
</dt> <dt>

[Настройка дескрипторов безопасности Намепаце](setting-namespace-security-descriptors.md)
</dt> <dt>

[Защита поставщика](securing-your-provider.md)
</dt> </dl>

 

 
