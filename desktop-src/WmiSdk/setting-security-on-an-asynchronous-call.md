---
description: Асинхронные вызовы представляют серьезную угрозу безопасности, так как обратный вызов приемника может не быть результатом асинхронного вызова исходного приложения или сценария.
ms.assetid: 2b839ea9-e1e6-4123-a98a-04ebee907b3b
ms.tgt_platform: multiple
title: Настройка безопасности при асинхронном вызове
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 228dbf5d84a85f28d5d57afb12823c93c95f9b259ebe95a15e949eec10543d84
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118992334"
---
# <a name="setting-security-on-an-asynchronous-call"></a>Настройка безопасности при асинхронном вызове

Асинхронные вызовы представляют серьезную угрозу безопасности, так как обратный вызов [*приемника*](gloss-s.md) может не быть результатом асинхронного вызова исходного приложения или сценария. Безопасность в удаленных подключениях основана на шифровании взаимодействия между клиентом и поставщиком на удаленном компьютере. В C++ можно задать шифрование с помощью параметра уровня проверки подлинности в вызове [**CoInitializeSecurity**](/windows/win32/api/combaseapi/nf-combaseapi-coinitializesecurity). В скриптах задайте *аусентикатионлевел* в соединении моникера или в объекте [**свбемсекурити**](swbemsecurity.md) . Дополнительные сведения см. [в разделе Задание уровня безопасности процесса по умолчанию с помощью VBScript](setting-the-default-process-security-level-using-vbscript.md).

Существуют угрозы безопасности для асинхронных вызовов, так как WMI понижает уровень проверки подлинности обратного вызова до тех пор, пока обратный вызов не завершится. При исходящем асинхронном вызове клиент может задать уровень проверки подлинности для соединения с WMI. Инструментарий WMI извлекает параметры безопасности в клиентском вызове и пытается выполнить обратный вызов с тем же уровнем проверки подлинности. Обратный вызов всегда инициируется на уровне **\_ конфиденциальности " \_ \_ \_ PKT \_ " RPC C AUTHN** . В случае сбоя обратного вызова Инструментарий WMI понижает уровень проверки подлинности до уровня, в котором обратный вызов может быть успешным, если это необходимо, на **\_ уровень RPC C \_ AUTHN \_ Level \_ None**. В контексте вызовов в локальной системе, где служба проверки подлинности не является протоколом Kerberos, обратный вызов всегда возвращается **на \_ уровне RPC C \_ AUTHN \_ уровня \_ None**.

Минимальный уровень проверки подлинности — **RPC \_ C \_ AUTHN \_ Level \_ PKT** (**вбемаусентикатионлевелпкт** для сценариев). Однако вы можете указать более высокий уровень, например **RPC \_ C \_ AUTHN \_ Level \_ PKT \_** (**вбемаусентикатионлевелпктприваци**). Рекомендуется, чтобы клиентские приложения или скрипты установили уровень проверки подлинности **RPC \_ C \_ AUTHN \_ уровня \_ по умолчанию** (**вбемаусентикатионлевелдефаулт**), что позволяет согласовать уровень проверки подлинности с уровнем, указанным сервером.

Значение реестра **hKey \_ Local \_ Machine** \\ **Software** \\ **Microsoft** \\ **WBEM** \\ **CIMOM** \\ **унсекаппакцессконтролдефаулт** определяет, будет ли Инструментарий WMI проверять наличие приемлемого уровня проверки подлинности в ответных вызовах. Это единственный механизм защиты приемника для асинхронных вызовов, выполняемых в сценариях или Visual Basic. По умолчанию этот раздел реестра имеет значение 0. Если раздел реестра равен нулю, Инструментарий WMI не проверяет уровни проверки подлинности. Чтобы защитить асинхронные вызовы в скриптах, установите для раздела реестра значение 1. Клиенты C++ могут вызывать [**ивбемунсекуредапартмент:: креатесинкстуб**](/windows/desktop/api/Wbemcli/nf-wbemcli-iwbemunsecuredapartment-createsinkstub) для управления доступом к приемнику. Значение по умолчанию создается в любой точке.

В следующих разделах приводятся примеры настройки безопасности асинхронных вызовов.

-   [Настройка безопасности при асинхронном вызове в VBScript](setting-security-on-an-asynchronous-call-in-vbscript.md)
-   Настройка безопасности асинхронных вызовов в C++

## <a name="setting-asynchronous-call-security-in-c"></a>Настройка безопасности асинхронных вызовов в C++

Метод [**ивбемунсекуредапартмент:: креатесинкстуб**](/windows/desktop/api/Wbemcli/nf-wbemcli-iwbemunsecuredapartment-createsinkstub) аналогичен методу [**Иунсекуредапартмент:: креатеобжектстуб**](/windows/desktop/api/Wbemcli/nf-wbemcli-iunsecuredapartment-createobjectstub) и создает приемник в отдельном процессе, Unsecapp.exe для получения обратных вызовов. Однако метод **креатесинкстуб** имеет параметр *dwFlag*, который определяет, как отдельный процесс обрабатывает управление доступом.

Параметр *dwFlag* задает одно из следующих действий для Unsecapp.exe.

-   Используйте параметр раздела реестра, чтобы определить, следует ли проверять доступ.
-   Проигнорируйте раздел реестра и всегда проверяйте доступ.
-   Проигнорируйте раздел реестра и не проверяйте доступ.

В примере кода в этом разделе \# для правильной компиляции требуется следующая инструкция include.


```C++
#include <wbemidl.h>
```



В следующей процедуре описывается выполнение асинхронного вызова с помощью [**ивбемунсекуредапартмент**](/windows/desktop/api/Wbemcli/nn-wbemcli-iwbemunsecuredapartment).

**Выполнение асинхронного вызова с помощью Ивбемунсекуредапартмент**

1.  Создайте выделенный процесс с вызовом [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance).

    В следующем примере кода метод [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) вызывается для создания выделенного процесса.

    ```C++
    CLSID                    CLSID_WbemUnsecuredApartment;
    IWbemUnsecuredApartment* pUnsecApp = NULL;

    CoCreateInstance(CLSID_WbemUnsecuredApartment, 
                     NULL, 
                     CLSCTX_LOCAL_SERVER, 
                     IID_IWbemUnsecuredApartment, 
                     (void**)&pUnsecApp);
    ```

    

2.  Создайте экземпляр объекта приемника.

    В следующем примере кода создается новый объект приемника.

    ```C++
    CMySink* pSink = new CMySink;
    pSink->AddRef();
    ```

    

3.  Создайте заглушку для приемника.

    Заглушка — это функция-оболочка, созданная из приемника.

    В следующем примере кода создается заглушка для приемника.

    ```C++
    LPCWSTR          wszReserved = NULL;           
    IWbemObjectSink* pStubSink   = NULL;
    IUnknown*        pStubUnk    = NULL; 

    pUnsecApp->CreateSinkStub(pSink,
                              WBEM_FLAG_UNSECAPP_CHECK_ACCESS,  //Authenticate callbacks regardless of registry key
                              wszReserved,
                              &pStubSink);
    ```

    

4.  Освободите указатель объекта приемника.

    Можно освободить указатель на объект, так как заглушка теперь является владельцем указателя.

    В следующем примере кода освобождается указатель на объект.

    ```C++
    pSink->Release();
    ```

    

5.  Используйте заглушку при любом асинхронном вызове.

    По завершении работы с вызовом Освободите локальный счетчик ссылок.

    В следующем примере кода заглушка используется в асинхронном вызове.

    ```C++
    // pServices is an IWbemServices* object
    pServices->CreateInstanceEnumAsync(strClassName, 0, NULL, pStubSink);
    ```

    

    Иногда может потребоваться отменить асинхронный вызов после выполнения вызова. Если необходимо отменить вызов, отмените вызов с тем же указателем, который был изначально выполнил вызов.

    В следующем примере кода показано, как отменить асинхронный вызов.

    ```C++
    pServices->CancelAsyncCall(pStubSink);
    ```

    

6.  При завершении использования асинхронного вызова Освободите локальный счетчик ссылок.

    Не забудьте освободить указатель *пстубсинк* только после того, как вы подтвердите, что асинхронный вызов не должен быть отменен. Кроме того, не освобождайте *пстубсинк* после того, как инструментарий WMI освобождает указатель приемника *псинк* . При освобождении *пстубсинк* после *псинк* создается циклическая ссылка, в которой приемник и заглушка постоянно остаются в памяти. Вместо этого можно освободить указатель в вызове [**ивбемобжектсинк:: SetStatus**](/windows/desktop/api/Wbemcli/nf-wbemcli-iwbemobjectsink-setstatus) , СДЕЛАНном WMI, чтобы сообщить о завершении исходного асинхронного вызова.

7.  После завершения выполните деинициализацию COM с помощью вызова метода [**Release ()**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release).

    В следующем примере кода показано, как вызвать метод [**Release ()**](/windows/win32/api/unknwn/nf-unknwn-iunknown-release) для указателя *пунсекапп* .

    ```C++
    pUnsecApp->Release();
    ```

    

Дополнительные сведения о функции и параметрах [**CoInitializeSecurity**](/windows/win32/api/combaseapi/nf-combaseapi-coinitializesecurity) см. в документации по [com](../cossdk/component-services-portal.md) .

 

 
