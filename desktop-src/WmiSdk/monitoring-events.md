---
description: Системные администраторы могут использовать инструментарий WMI для наблюдения за событиями в сети.
ms.assetid: 871d4add-a7b1-4ec9-a202-3821fdf09e9f
ms.tgt_platform: multiple
title: Отслеживание событий
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bb90a0a6eef87f88543e8f2414bc38bdea4f7d89c577471d79d23393f331b053
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118317118"
---
# <a name="monitoring-events"></a>Отслеживание событий

Системные администраторы могут использовать инструментарий WMI для наблюдения за событиями в сети. Пример:

-   Служба неожиданно останавливается.
-   Сервер становится недоступным.
-   Емкость диска будет заполнять до 80%.
-   События безопасности выводятся в журнал событий NT.

WMI поддерживает обнаружение событий и доставку потребителям событий, так как некоторые поставщики WMI являются поставщиками событий. Дополнительные сведения см. [в разделе Получение WMI-события](receiving-a-wmi-event.md).

[*Потребители событий*](gloss-e.md) — это приложения или скрипты, запрашивающие уведомления о событиях, а затем выполняющие задачи при возникновении конкретных событий. Можно создавать скрипты или приложения для мониторинга событий, которые временно отслеживают время возникновения событий. Инструментарий WMI также предоставляет набор предварительно установленных постоянных поставщиков событий и постоянных классов потребителей, позволяющих постоянно отслеживать события. Дополнительные сведения см. [в разделе Мониторинг и реагирование на события с помощью стандартных потребителей](monitoring-and-responding-to-events-with-standard-consumers.md).

В этом разделе обсуждаются следующие разделы:

-   [Использование временных потребителей событий](#using-temporary-event-consumers)
-   [Использование постоянных потребителей событий](#using-permanent-event-consumers)

## <a name="using-temporary-event-consumers"></a>Использование временных потребителей событий

Временные потребители событий — это скрипты или приложения, которые возвращают события, соответствующие запросу или фильтру событий. Временные запросы событий обычно используют [**IWbemServices:: ексекнотификатионкуери**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemservices-execnotificationquery) в приложениях C++ или [**SWbemServices.Exeкнотификатионкуери**](swbemservices-execnotificationquery.md) в скриптах и Visual Basic.

Запрос события запрашивает экземпляры класса событий, указывающего определенный тип события, например [**Win32 \_ Процесстраце**](/previous-versions/windows/desktop/krnlprov/win32-processtrace) или [**регистрикэйчанжеевент**](/previous-versions/windows/desktop/regprov/registrykeychangeevent).

Следующий пример кода VBScript запрашивает уведомление при создании экземпляра [**Win32 \_ процесстраце**](/previous-versions/windows/desktop/krnlprov/win32-processtrace) . Экземпляр этого класса создается при запуске или остановке процесса.

Чтобы выполнить сценарий, скопируйте его в файл с именем event.vbs и используйте следующую командную строку: **cscript event.vbs**. Выходные данные скрипта можно просмотреть, запустив Notepad.exe или любой другой процесс. Сценарий останавливается после запуска или остановки пяти процессов.

Этот скрипт вызывает [**SWbemServices.Exeкнотификатионкуери**](swbemservices-execnotificationquery.md), который является [*семисинчронаус*](gloss-s.md) версией метода. См. следующий скрипт для примера настройки асинхронной подписки на события, вызвав [**SWbemServices.Exeкнотификатионкуерясинк**](swbemservices-execnotificationqueryasync.md). Дополнительные сведения см. [в разделе вызов метода](calling-a-method.md). Скрипт вызывает [**свбемевентсаурце. некстевент**](swbemeventsource-nextevent.md) для получения и обработки каждого события по мере его поступления. Сохраните скрипт в файле с расширением vbs и выполните сценарий в командной строке с помощью CScript: **cscript file.vbs**.


```VB
strComputer = "." 
Set objWMIService = GetObject("winmgmts:\\" _
    & strComputer & "\root\CIMV2") 
Set objEvents = objWMIService.ExecNotificationQuery _
    ("SELECT * FROM Win32_ProcessTrace")

Wscript.Echo "Waiting for events ..."
i = 0
Do Until i=5
    Set objReceivedEvent = objEvents.NextEvent
    'report an event
    Wscript.Echo "Win32_ProcessTrace event occurred" & VBNewLine _
        & "Process Name = " _
            & objReceivedEvent.ProcessName & VBNewLine _
        & "Process ID = " _
            & objReceivedEvent.Processid & VBNewLine _
        & "Session ID = " & objReceivedEvent.SessionID 
i = i+ 1
Loop
```



Временные потребители событий должны запускаться вручную и не должны сохраняться при перезапуске WMI или перезапуске операционной системы. Временный потребитель событий может обрабатывать события только во время его выполнения.

В следующей процедуре описывается создание временного потребителя событий.

**Создание временного потребителя событий**

1.  Определите, какой язык программирования следует использовать.

    Язык программирования определяет используемый API.

    -   Для языка программирования C++ используйте [COM API для WMI](com-api-for-wmi.md).
    -   для Visual Basic или языков сценариев используйте [API скриптов для инструментария WMI](scripting-api-for-wmi.md).

2.  Начните программировать временное приложение-потребитель событий так же, как вы запускаете приложение WMI.

    Первые шаги написания кода зависят от языка программирования. Как правило, вы входите на WMI и устанавливаете параметры безопасности. Дополнительные сведения см. [в разделе Создание приложения WMI или скрипта](creating-a-wmi-application-or-script.md).

3.  Определите запрос события, который вы хотите использовать.

    Для получения некоторых типов данных о производительности может потребоваться использовать классы, предоставляемые высокопроизводительными поставщиками. Дополнительные сведения см. в статьях [мониторинг данных производительности](monitoring-performance-data.md), [Определение типа получаемого события](determining-the-type-of-event-to-receive.md)и [выполнение запросов с помощью WQL](querying-with-wql.md).

4.  Решите сделать либо асинхронный вызов, либо вызов семисинчронаус, а затем выберите метод API.

    Асинхронные вызовы позволяют избежать издержек при опросе данных. Однако вызовы семисинчронаус обеспечивают аналогичные производительность с большей безопасностью. Дополнительные сведения см. [в разделе вызов метода](calling-a-method.md).

5.  Сделайте вызов асинхронного или семисинчронаусного метода и включите в него запрос события в качестве параметра *стркуери* .

    Для приложений C++ вызовите следующие методы:

    -   [**IWbemServices:: Ексекнотификатионкуери**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemservices-execnotificationquery)
    -   [**IWbemServices:: ExecNotificationQueryAsync**](/windows/desktop/api/WbemCli/nf-wbemcli-iwbemservices-execnotificationqueryasync)

    Для скриптов вызовите следующие методы:

    -   [**SWbemServices.ExeКнотификатионкуери**](swbemservices-execnotificationquery.md)
    -   [**SWbemServices.ExeКнотификатионкуерясинк**](swbemservices-execnotificationqueryasync.md)

6.  Напишите код для обработки возвращенного объекта события.

    Для асинхронных запросов событий разместите код в различных методах или событиях приемника объекта. Для запросов событий семисинчронаус каждый объект возвращается, так как WMI получает его, поэтому код должен находиться в цикле, обрабатывающем каждый объект.

Следующий пример кода скрипта представляет собой асинхронную версию скрипта [**Win32 \_ процесстраце**](/previous-versions/windows/desktop/krnlprov/win32-processtrace) . Так как асинхронные операции возвращаются немедленно, диалоговое окно сохраняет активный скрипт, пока он ожидает событий.

Вместо вызова [**свбемевентсаурце. некстевент**](swbemeventsource-nextevent.md) для получения каждого события сценарий имеет обработчик события [**свбемсинк онобжектреади**](swbemsink-onobjectready.md) .


```VB
strComputer = "." 
Set objWMIService = GetObject("winmgmts:\\" & _
    strComputer & "\root\CIMV2") 
Set EventSink = WScript.CreateObject( _
    "WbemScripting.SWbemSink","SINK_")

objWMIservice.ExecNotificationQueryAsync EventSink, _
    "SELECT * FROM Win32_ProcessTrace WITHIN 10"
WScript.Echo "Waiting for events..."

i = 0
While (True)
    Wscript.Sleep(1000)
Wend

Sub SINK_OnObjectReady(objObject, objAsyncContext)
    Wscript.Echo "Win32_ProcessTrace event has occurred."
    i = i+1
    If i = 3 Then WScript.Quit 0 
End Sub

```



> [!Note]
>
> Асинхронный обратный вызов, такой как обратный вызов, обрабатываемый `SINK_OnObjectReady` подподпрограммой, позволяет пользователю, не прошедшему проверку подлинности, предоставлять данные в приемник. Для повышения безопасности используйте либо семисинчронаус связь, либо синхронное взаимодействие. Дополнительные сведения см. в следующих разделах:
>
> -   [Вызов Семисинчронаус с помощью C++](making-a-semisynchronous-call-with-c--.md)
> -   [Вызов Семисинчронаус с помощью VBScript](making-a-semisynchronous-call-with-vbscript.md)
> -   [Создание асинхронного вызова с помощью C++](making-an-asynchronous-call-with-c--.md)
> -   [Выполнение асинхронного вызова с помощью VBScript](making-an-asynchronous-call-with-vbscript.md)
> -   [Настройка безопасности при асинхронном вызове](setting-security-on-an-asynchronous-call.md)
> -   [Защита клиентов скриптов](securing-scripting-clients.md)

 

## <a name="using-permanent-event-consumers"></a>Использование постоянных потребителей событий

Постоянный потребитель событий выполняется до тех пор, пока регистрация не будет явно отменена, а затем запускается при перезапуске WMI или системы.

Постоянный потребитель событий — это сочетание классов WMI, фильтров и COM-объектов в системе.

В следующем списке указаны части, необходимые для создания постоянного потребителя событий.

-   COM-объект, содержащий код, реализующий постоянный потребитель.
-   Новый постоянный класс потребителя.
-   Экземпляр класса постоянного потребителя.
-   Фильтр, содержащий запрос для событий.
-   Связь между потребителем и фильтром.

Дополнительные сведения см. [в разделе Получение событий в любое время](--filtertoconsumerbinding.md).

Инструментарий WMI предоставляет несколько постоянных потребителей. Классы потребителей и COM-объекты, содержащие код, предварительно установлены. Например, можно создать и настроить экземпляр класса [**активескриптевентконсумер**](activescripteventconsumer.md) для выполнения скрипта при возникновении события. Дополнительные сведения см. [в разделе Мониторинг и реагирование на события с помощью стандартных потребителей](monitoring-and-responding-to-events-with-standard-consumers.md). Пример использования **активескриптевентконсумер** см. в разделе [выполнение сценария на основе события](running-a-script-based-on-an-event.md).

В следующей процедуре описывается создание постоянного потребителя событий.

**Создание постоянного потребителя событий**

1.  [Зарегистрируйте поставщика событий](registering-a-provider.md) в используемом пространстве имен.

    Некоторые поставщики событий могут использовать только определенное пространство имен. Например, [**\_ \_ инстанцекреатионевент**](--instancecreationevent.md) является внутренним событием, которое поддерживается [поставщиком Win32](/windows/desktop/CIMWin32Prov/win32-provider) и зарегистрировано по умолчанию с \\ корневым \\ пространством имен CIMV2.

    > [!Note]  
    > Для создания подписки между пространствами имен можно использовать свойство **евентнамеспаце** объекта [**\_ \_ EventFilter**](--eventfilter.md) , используемого в регистрации. Дополнительные сведения см. в разделе [Реализация постоянных подписок на события между пространствами имен](implementing-cross-namespace-permanent-event-subscriptions.md).

     

2.  [Зарегистрируйте поставщик потребителей событий](registering-an-event-consumer-provider.md) с пространством имен, в котором находятся классы событий.

    WMI использует поставщик объекта-получателя событий для поиска постоянного объекта-получателя события. Постоянный потребитель событий — это приложение, которое Инструментарий WMI запускает при получении события. Для регистрации объекта-получателя событий поставщики создают экземпляры [**\_ \_ евентконсумерпровидеррегистратион**](--eventconsumerproviderregistration.md).

3.  Создайте экземпляр класса, который представляет постоянный потребитель событий, который вы хотите использовать.

    Классы потребителей событий являются производными от класса [**\_ \_ евентконсумер**](--eventconsumer.md). Задайте свойства, необходимые для экземпляра потребителя событий.

4.  Зарегистрируйте потребитель в COM с помощью программы **regsvr32** .
5.  Создайте экземпляр класса фильтра событий [**\_ \_ EventFilter**](--eventfilter.md).

    Задайте обязательные поля для экземпляра фильтра событий. Обязательные поля для [**\_ \_ EventFilter**](--eventfilter.md) : **Name**, **куерилангуаже** и **Query**. Свойство **Name** может быть любым уникальным именем для экземпляра этого класса. Свойству **куерилангуаже** всегда присвоено значение WQL. Свойство **Query** представляет собой строку, содержащую запрос события. Событие создается при сбое запроса непостоянного потребителя событий. Источник события — WinMgmt, идентификатор события — 10, а тип события — ошибка.

6.  Создайте экземпляр класса [**\_ \_ филтертоконсумербиндинг**](--filtertoconsumerbinding.md) , чтобы связать логический объект-получатель события с фильтром событий.

    Инструментарий WMI использует ассоциацию для поиска объекта-получателя события, связанного с событием, которое соответствует критериям, заданным в фильтре событий. WMI использует поставщик потребителей событий, чтобы найти постоянное приложение-потребитель событий для запуска.

 

 
