---
description: Объект данных является центральным для всех операций передачи данных оболочки.
ms.assetid: c63d339e-ac62-4da1-b5ce-22d45a6a3413
title: Объект данных оболочки
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 69a6c411310b6c9e9f28df4de048d3b6909c44b9
ms.sourcegitcommit: 822413efb4a70dd464e5db4d9e8693ef74f8132f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 07/09/2021
ms.locfileid: "113581632"
---
# <a name="shell-data-object"></a><span data-ttu-id="3c4fd-103">Объект данных оболочки</span><span class="sxs-lookup"><span data-stu-id="3c4fd-103">Shell Data Object</span></span>

<span data-ttu-id="3c4fd-104">Объект данных является центральным для всех операций передачи данных оболочки.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-104">The data object is central to all Shell data transfers.</span></span> <span data-ttu-id="3c4fd-105">В основном это контейнер для хранения передаваемых данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-105">It is primarily a container to hold the transferred data.</span></span> <span data-ttu-id="3c4fd-106">Однако целевой объект также может взаимодействовать с объектом данных, чтобы упростить некоторые специализированные типы передачи данных оболочки, такие как оптимизированные перемещения.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-106">However, the target can also communicate with the data object to facilitate some specialized types of Shell data transfer such as optimized moves.</span></span> <span data-ttu-id="3c4fd-107">В этом разделе приводятся общие сведения о работе объектов данных оболочки, их создании в источнике и о том, как они обрабатываются целевым объектом.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-107">This topic provides a general discussion of how Shell data objects work, how they are constructed by a source, and how they are handled by a target.</span></span> <span data-ttu-id="3c4fd-108">Подробное описание использования объектов данных для перемещения различных типов данных оболочки см. в разделе [Обработка сценариев передача данных оболочки](datascenarios.md).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-108">For a detailed discussion of how to use data objects to transfer different types of Shell data, see [Handling Shell Data Transfer Scenarios](datascenarios.md).</span></span>

-   [<span data-ttu-id="3c4fd-109">Как работают объекты данных</span><span class="sxs-lookup"><span data-stu-id="3c4fd-109">How Data Objects Work</span></span>](#how-data-objects-work)
    -   [<span data-ttu-id="3c4fd-110">Форматы буфера обмена</span><span class="sxs-lookup"><span data-stu-id="3c4fd-110">Clipboard Formats</span></span>](#clipboard-formats)
    -   [<span data-ttu-id="3c4fd-111">Структура ФОРМАТЕТК</span><span class="sxs-lookup"><span data-stu-id="3c4fd-111">FORMATETC Structure</span></span>](#formatetc-structure)
    -   [<span data-ttu-id="3c4fd-112">Структура СТГМЕДИУМ</span><span class="sxs-lookup"><span data-stu-id="3c4fd-112">STGMEDIUM structure</span></span>](#stgmedium-structure)
-   [<span data-ttu-id="3c4fd-113">Как источник создает объект данных</span><span class="sxs-lookup"><span data-stu-id="3c4fd-113">How a Source Creates a Data Object</span></span>](#how-a-source-creates-a-data-object)
    -   [<span data-ttu-id="3c4fd-114">Добавление объекта глобальной памяти в объект данных</span><span class="sxs-lookup"><span data-stu-id="3c4fd-114">How to Add a Global Memory Object to a Data Object</span></span>](#how-to-add-a-global-memory-object-to-a-data-object)
    -   [<span data-ttu-id="3c4fd-115">Реализация интерфейса IDataObject</span><span class="sxs-lookup"><span data-stu-id="3c4fd-115">Implementing IDataObject</span></span>](#implementing-idataobject)
    -   [<span data-ttu-id="3c4fd-116">Реализация Идропсаурце</span><span class="sxs-lookup"><span data-stu-id="3c4fd-116">Implementing IDropSource</span></span>](#implementing-idropsource)
-   [<span data-ttu-id="3c4fd-117">Обработка объектом данных целевым объектом</span><span class="sxs-lookup"><span data-stu-id="3c4fd-117">How a Target Handles a Data Object</span></span>](#how-a-target-handles-a-data-object)
    -   [<span data-ttu-id="3c4fd-118">Извлечение данных оболочки из объекта данных</span><span class="sxs-lookup"><span data-stu-id="3c4fd-118">Extracting Shell Data from a Data Object</span></span>](#extracting-shell-data-from-a-data-object)
    -   [<span data-ttu-id="3c4fd-119">Реализация интерфейс IDropTarget</span><span class="sxs-lookup"><span data-stu-id="3c4fd-119">Implementing IDropTarget</span></span>](#implementing-idroptarget)
-   [<span data-ttu-id="3c4fd-120">Использование вспомогательного объекта перетаскивания</span><span class="sxs-lookup"><span data-stu-id="3c4fd-120">Using the Drag-and-Drop Helper Object</span></span>](#using-the-drag-and-drop-helper-object)
    -   [<span data-ttu-id="3c4fd-121">Использование интерфейса Идрагсаурцехелпер</span><span class="sxs-lookup"><span data-stu-id="3c4fd-121">Using the IDragSourceHelper Interface</span></span>](#using-the-idragsourcehelper-interface)
    -   [<span data-ttu-id="3c4fd-122">Использование интерфейса Идроптаржеселпер</span><span class="sxs-lookup"><span data-stu-id="3c4fd-122">Using the IDropTargetHelper Interface</span></span>](#using-the-idroptargethelper-interface)

## <a name="how-data-objects-work"></a><span data-ttu-id="3c4fd-123">Как работают объекты данных</span><span class="sxs-lookup"><span data-stu-id="3c4fd-123">How Data Objects Work</span></span>

<span data-ttu-id="3c4fd-124">Объекты данных являются объектами модели COM, созданными источником данных для перемещения данных в целевой объект.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-124">Data objects are Component Object Model (COM) objects, created by the data source to transfer data to a target.</span></span> <span data-ttu-id="3c4fd-125">Обычно они содержат более одного элемента данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-125">They typically carry more than one item of data.</span></span> <span data-ttu-id="3c4fd-126">Для этого используется две причины.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-126">There are two reasons for this practice:</span></span>

-   <span data-ttu-id="3c4fd-127">Хотя практически любой тип данных можно передать с помощью объекта данных, источник, как правило, не знает, какой тип данных может принимать целевой объект.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-127">While almost any type of data can be transferred with a data object, the source typically does not know what kind of data the target can accept.</span></span> <span data-ttu-id="3c4fd-128">Например, данные могут быть частью форматированного текстового документа.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-128">For instance, the data might be a portion of a formatted text document.</span></span> <span data-ttu-id="3c4fd-129">Хотя целевой объект может обрабатывать сложные сведения о форматировании, он может также принимать только текст в формате ANSI.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-129">While the target might be able to handle complex formatting information, it might also be able to accept only ANSI text.</span></span> <span data-ttu-id="3c4fd-130">По этой причине объекты данных часто содержат одни и те же данные в нескольких разных форматах.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-130">For this reason, data objects often include the same data in several different formats.</span></span> <span data-ttu-id="3c4fd-131">Затем целевой объект может извлекать данные в формате, который может быть обработано.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-131">The target can then extract the data in a format that it can handle.</span></span>
-   <span data-ttu-id="3c4fd-132">Объекты данных также могут содержать вспомогательные элементы данных, не являющиеся версиями исходных данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-132">Data objects can also contain auxiliary data items that are not versions of source data.</span></span> <span data-ttu-id="3c4fd-133">Этот тип элементов данных обычно предоставляет дополнительные сведения о операции обмена данными.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-133">This type of data item typically provides additional information about the data transfer operation.</span></span> <span data-ttu-id="3c4fd-134">Например, оболочка использует вспомогательные элементы данных, чтобы указать, следует ли копировать или перемещать файл.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-134">For instance, the Shell uses auxiliary data items to indicate whether a file is to be copied or moved.</span></span>

### <a name="clipboard-formats"></a><span data-ttu-id="3c4fd-135">Форматы буфера обмена</span><span class="sxs-lookup"><span data-stu-id="3c4fd-135">Clipboard Formats</span></span>

<span data-ttu-id="3c4fd-136">Каждый элемент данных в объекте данных имеет связанный формат, обычно называемый *форматом буфера обмена*.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-136">Each item of data in a data object has an associated format, usually called a *clipboard format*.</span></span> <span data-ttu-id="3c4fd-137">Существует ряд стандартных форматов буфера обмена, объявленных в файле WinUser. h, которые соответствуют часто используемым типам данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-137">There are a number of standard clipboard formats, declared in Winuser.h, that correspond to commonly used types of data.</span></span> <span data-ttu-id="3c4fd-138">Форматы буфера обмена — это целые числа, но обычно они называются их эквивалентными именами, которые имеют форму CF \_ *xxx*.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-138">Clipboard formats are integers, but they are normally referred to by their equivalent name, which has the form CF\_*XXX*.</span></span> <span data-ttu-id="3c4fd-139">Например, формат буфера обмена для текста ANSI — текст CF \_ .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-139">For instance, the clipboard format for ANSI text is CF\_TEXT.</span></span>

<span data-ttu-id="3c4fd-140">Приложения могут расширять диапазон доступных форматов буфера обмена, определяя закрытые форматы.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-140">Applications can extend the range of available clipboard formats by defining private formats.</span></span> <span data-ttu-id="3c4fd-141">Чтобы определить частный формат, приложение вызывает [регистерклипбоардформат](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) со строкой, определяющей формат.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-141">To define a private format, an application calls [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) with a string that identifies the format.</span></span> <span data-ttu-id="3c4fd-142">Целое число без знака, возвращаемое функцией, является допустимым значением формата, которое может использоваться так же, как стандартный формат буфера обмена.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-142">The unsigned integer that the function returns is a valid format value that can be used just like a standard clipboard format.</span></span> <span data-ttu-id="3c4fd-143">Однако исходный и целевой объекты должны зарегистрировать формат, чтобы его можно было использовать.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-143">However, both source and target must register the format in order to use it.</span></span> <span data-ttu-id="3c4fd-144">За одним исключением —[CF \_ HDROP](clipboard.md)— форматы буфера обмена, используемые для перемещения данных оболочки, определяются как частные форматы.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-144">With one exception—[CF\_HDROP](clipboard.md)—the clipboard formats used to transfer Shell data are defined as private formats.</span></span> <span data-ttu-id="3c4fd-145">Они должны быть зарегистрированы исходным и целевым объектом, прежде чем их можно будет использовать.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-145">They must be registered by the source and target before they can be used.</span></span> <span data-ttu-id="3c4fd-146">Описание доступных форматов буфера обмена оболочки см. в разделе форматы буфера обмена оболочки.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-146">For a description of the available Shell clipboard formats, see Shell Clipboard Formats.</span></span>

<span data-ttu-id="3c4fd-147">Хотя существуют некоторые исключения, объекты данных обычно содержат только один элемент данных для каждого поддерживаемого формата буфера обмена.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-147">Although there are some exceptions, data objects normally contain only one item of data for each clipboard format they support.</span></span> <span data-ttu-id="3c4fd-148">Эта корреляция "один к одному" между форматом и данными позволяет использовать значение формата в качестве идентификатора для связанного элемента данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-148">This one-to-one correlation between format and data allows the format value to be used as an identifier for the associated data item.</span></span> <span data-ttu-id="3c4fd-149">Фактически, при обсуждении содержимого объекта данных конкретный элемент данных обычно называется "форматом" и на него ссылается имя формата.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-149">In fact, when discussing the contents of a data object, a particular item of data is typically called a "format" and is referred to by its format name.</span></span> <span data-ttu-id="3c4fd-150">Например, такие фразы, как «извлечение \_ текстового формата CF...» обычно используются при обсуждении текстового элемента данных ANSI объекта данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-150">For example, phrases such as "Extract the CF\_TEXT format..." are typically used when discussing a data object's ANSI text data item.</span></span>

<span data-ttu-id="3c4fd-151">Когда целевой объект перетаскивания получает указатель на объект данных, цель перетаскивания перечисляет доступные форматы, чтобы определить, какие типы данных доступны.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-151">When the drop target receives the pointer to the data object, the drop target enumerates the available formats to determine what types of data are available.</span></span> <span data-ttu-id="3c4fd-152">Затем он запрашивает один или несколько доступных форматов и извлекает данные.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-152">It then requests one or more of the available formats and extracts the data.</span></span> <span data-ttu-id="3c4fd-153">Конкретный способ, которым целевой объект извлекает данные оболочки из объекта данных, зависит от формата. Это подробно описано в разделе [Обработка объектом данных целевым](#how-a-target-handles-a-data-object)объектом.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-153">The specific way that the target extracts Shell data from a data object varies with the format; this is discussed in detail in [How a Target Handles a Data Object](#how-a-target-handles-a-data-object).</span></span>

<span data-ttu-id="3c4fd-154">При простой передаче данных в буфер обмена данные помещаются в глобальный объект памяти.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-154">With simple clipboard data transfers, the data is placed in a global memory object.</span></span> <span data-ttu-id="3c4fd-155">Адрес этого объекта помещается в буфер обмена вместе с его форматом.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-155">The address of that object is placed on the Clipboard, along with its format.</span></span> <span data-ttu-id="3c4fd-156">Формат буфера обмена сообщает целевому объекту, какой тип данных будет найден по соответствующему адресу.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-156">The clipboard format tells the target what kind of data it will find at the associated address.</span></span> <span data-ttu-id="3c4fd-157">Хотя простые передачи в буфере обмена просты в реализации:</span><span class="sxs-lookup"><span data-stu-id="3c4fd-157">While simple clipboard transfers are easy to implement:</span></span>

-   <span data-ttu-id="3c4fd-158">Объекты данных предоставляют гораздо более гибкий способ передачи данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-158">Data objects provide a much more flexible way to transfer data.</span></span>
-   <span data-ttu-id="3c4fd-159">Объекты данных лучше подходят для передачи больших объемов данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-159">Data objects are better suited for transferring large amounts of data.</span></span>
-   <span data-ttu-id="3c4fd-160">Объекты данных должны использоваться для перемещения данных с помощью операции перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-160">Data objects must be used to transfer data with a drag-and-drop operation.</span></span>

<span data-ttu-id="3c4fd-161">По этим причинам все передачи данных в оболочке используют объекты данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-161">For these reasons, all Shell data transfers use data objects.</span></span> <span data-ttu-id="3c4fd-162">При использовании объектов данных форматы буфера обмена не используются напрямую.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-162">With data objects, clipboard formats are not used directly.</span></span> <span data-ttu-id="3c4fd-163">Вместо этого элементы данных определяются обобщением формата буфера обмена, структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-163">Instead, data items are identified with a generalization of the clipboard format, a [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure.</span></span>

### <a name="formatetc-structure"></a><span data-ttu-id="3c4fd-164">Структура ФОРМАТЕТК</span><span class="sxs-lookup"><span data-stu-id="3c4fd-164">FORMATETC Structure</span></span>

<span data-ttu-id="3c4fd-165">Структура [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) является расширенной версией формата буфера обмена.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-165">The [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure is an extended version of a clipboard format.</span></span> <span data-ttu-id="3c4fd-166">Структура **форматетк** , используемая для передачи данных оболочки, имеет следующие характеристики.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-166">As used for Shell data transfers, the **FORMATETC** structure has the following characteristics:</span></span>

-   <span data-ttu-id="3c4fd-167">Элемент данных по-прежнему определяется форматом буфера обмена в элементе **кфформат** .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-167">A data item is still identified by its clipboard format, in the **cfFormat** member.</span></span>
-   <span data-ttu-id="3c4fd-168">Передаваемые данные не ограничиваются глобальными объектами памяти.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-168">Data transfer is not limited to global memory objects.</span></span> <span data-ttu-id="3c4fd-169">Элемент **тимед** используется для указания механизма обмена данными, содержащегося в связанной структуре [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-169">The **tymed** member is used to indicate the data transfer mechanism contained in the associated [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span> <span data-ttu-id="3c4fd-170">Для него задано одно из значений [**тимед \_ xxx**](/windows/win32/api/objidl/ne-objidl-tymed) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-170">It is set to one of the [**TYMED\_XXX**](/windows/win32/api/objidl/ne-objidl-tymed) values.</span></span>
-   <span data-ttu-id="3c4fd-171">Оболочка использует элемент **Линдекс** с его форматом [кфстр \_ филеконтентс](clipboard.md) , чтобы разрешить объекту данных содержать более одного элемента данных в каждом формате.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-171">The Shell uses the **lIndex** member with its [CFSTR\_FILECONTENTS](clipboard.md) format to allow a data object to contain more than one data item per format.</span></span> <span data-ttu-id="3c4fd-172">Обсуждение того, как использовать этот формат, см. в разделе *Использование формата кфстр \_ Филеконтентс для извлечения данных из* раздела [Обработка передача данных сценариев оболочки](datascenarios.md).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-172">For a discussion of how to use this format, see the *Using the CFSTR\_FILECONTENTS Format to Extract Data from a File* section of [Handling Shell Data Transfer Scenarios](datascenarios.md).</span></span>
-   <span data-ttu-id="3c4fd-173">Для члена **дваспект** обычно задается \_ содержимое дваспект.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-173">The **dwAspect** member is typically set to DVASPECT\_CONTENT.</span></span> <span data-ttu-id="3c4fd-174">Однако в Шлобж. h есть три значения, которые можно использовать для обмена данными в оболочке.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-174">However, there are three values defined in Shlobj.h that can be used for Shell data transfer.</span></span> 

    | <span data-ttu-id="3c4fd-175">Значение</span><span class="sxs-lookup"><span data-stu-id="3c4fd-175">Value</span></span>               | <span data-ttu-id="3c4fd-176">Описание</span><span class="sxs-lookup"><span data-stu-id="3c4fd-176">Description</span></span>                                                                                       |
    |---------------------|---------------------------------------------------------------------------------------------------|
    | <span data-ttu-id="3c4fd-177">\_копирование дваспект</span><span class="sxs-lookup"><span data-stu-id="3c4fd-177">DVASPECT\_COPY</span></span>      | <span data-ttu-id="3c4fd-178">Используется для указания того, что формат представляет копию данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-178">Used to indicate that the format represents a copy of the data.</span></span>                                   |
    | <span data-ttu-id="3c4fd-179">Ссылка на ДВАСПЕКТ \_</span><span class="sxs-lookup"><span data-stu-id="3c4fd-179">DVASPECT\_LINK</span></span>      | <span data-ttu-id="3c4fd-180">Используется для указания того, что формат представляет ярлык данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-180">Used to indicate that the format represents a shortcut to the data.</span></span>                               |
    | <span data-ttu-id="3c4fd-181">ДВАСПЕКТ ( \_ SHORTNAME)</span><span class="sxs-lookup"><span data-stu-id="3c4fd-181">DVASPECT\_SHORTNAME</span></span> | <span data-ttu-id="3c4fd-182">Используется с \_ форматом CF HDROP для запроса пути к файлу с именами, сокращенными до формата 8,3.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-182">Used with the CF\_HDROP format to request a file path with the names shortened to the 8.3 format.</span></span> |

    

     

-   <span data-ttu-id="3c4fd-183">Элемент **ПТД** не используется для передачи данных оболочки и обычно имеет значение **null**.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-183">The **ptd** member is not used for Shell data transfers and is normally set to **NULL**.</span></span>

### <a name="stgmedium-structure"></a><span data-ttu-id="3c4fd-184">Структура СТГМЕДИУМ</span><span class="sxs-lookup"><span data-stu-id="3c4fd-184">STGMEDIUM structure</span></span>

<span data-ttu-id="3c4fd-185">Структура [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) предоставляет доступ к передаваемым данным.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-185">The [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure provides access to the data being transferred.</span></span> <span data-ttu-id="3c4fd-186">Для данных оболочки поддерживаются три механизма обмена данными:</span><span class="sxs-lookup"><span data-stu-id="3c4fd-186">Three data transfer mechanisms are supported for Shell data:</span></span>

-   <span data-ttu-id="3c4fd-187">Глобальный объект памяти.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-187">A global memory object.</span></span>
-   <span data-ttu-id="3c4fd-188">Интерфейс [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-188">An [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface.</span></span>
-   <span data-ttu-id="3c4fd-189">Интерфейс [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-189">An [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span>

<span data-ttu-id="3c4fd-190">Элемент **тимед** структуры [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) — это значение [**тимед \_ xxx**](/windows/win32/api/objidl/ne-objidl-tymed) , идентифицирующее механизм обмена данными.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-190">The **tymed** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure is a [**TYMED\_XXX**](/windows/win32/api/objidl/ne-objidl-tymed) value that identifies the data transfer mechanism.</span></span> <span data-ttu-id="3c4fd-191">Второй элемент — это указатель, используемый целевым объектом для извлечения данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-191">The second member is a pointer that is used by the target to extract the data.</span></span> <span data-ttu-id="3c4fd-192">Указатель может быть одним из множества типов, в зависимости от значения **тимед** .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-192">The pointer can be one of a variety of types, depending on the **tymed** value.</span></span> <span data-ttu-id="3c4fd-193">Три значения **тимед** , используемые для передачи данных оболочки, приведены в следующей таблице вместе с соответствующим именем **стгмедиум** элемента.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-193">The three **tymed** values that are used for Shell data transfers are summarized in the following table, along with their corresponding **STGMEDIUM** member name.</span></span>



| <span data-ttu-id="3c4fd-194">Значение тимед</span><span class="sxs-lookup"><span data-stu-id="3c4fd-194">tymed Value</span></span>     | <span data-ttu-id="3c4fd-195">Имя участника</span><span class="sxs-lookup"><span data-stu-id="3c4fd-195">Member name</span></span> | <span data-ttu-id="3c4fd-196">Описание</span><span class="sxs-lookup"><span data-stu-id="3c4fd-196">Description</span></span>                                                                                                                                                                                                                                                                                                       |
|-----------------|-------------|-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| <span data-ttu-id="3c4fd-197">ТИМЕД \_ хглобал</span><span class="sxs-lookup"><span data-stu-id="3c4fd-197">TYMED\_HGLOBAL</span></span>  | <span data-ttu-id="3c4fd-198">**хглобал**</span><span class="sxs-lookup"><span data-stu-id="3c4fd-198">**hGlobal**</span></span> | <span data-ttu-id="3c4fd-199">Указатель на объект глобальной памяти.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-199">A pointer to a global memory object.</span></span> <span data-ttu-id="3c4fd-200">Этот тип указателя обычно используется для передачи небольших объемов данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-200">This pointer type is typically used for transferring small amounts of data.</span></span> <span data-ttu-id="3c4fd-201">Например, оболочка использует объекты глобальной памяти для обмена короткими текстовыми строками, такими как имена файлов или URL-адреса.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-201">For instance, the Shell uses global memory objects to transfer short text strings such as file names or URLs.</span></span>                                                                                    |
| <span data-ttu-id="3c4fd-202">ТИМЕД \_ ISTREAM</span><span class="sxs-lookup"><span data-stu-id="3c4fd-202">TYMED\_ISTREAM</span></span>  | <span data-ttu-id="3c4fd-203">**пстм**</span><span class="sxs-lookup"><span data-stu-id="3c4fd-203">**pstm**</span></span>    | <span data-ttu-id="3c4fd-204">Указатель на интерфейс [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-204">A pointer to an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) interface.</span></span> <span data-ttu-id="3c4fd-205">Этот тип указателя предпочтителен для большинства операций передачи данных оболочки, так как он требует относительно мало памяти по сравнению с ТИМЕД \_ хглобал.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-205">This pointer type is preferred for most Shell data transfers because it requires relatively little memory compared to TYMED\_HGLOBAL.</span></span> <span data-ttu-id="3c4fd-206">Кроме того, \_ механизму обмена данными тимед ISTREAM не требуется, чтобы источник хранят свои данные каким бы то ни было определенным образом.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-206">Also, the TYMED\_ISTREAM data transfer mechanism does not require the source to store its data in any particular way.</span></span> |
| <span data-ttu-id="3c4fd-207">ТИМЕД \_ ISTORAGE</span><span class="sxs-lookup"><span data-stu-id="3c4fd-207">TYMED\_ISTORAGE</span></span> | <span data-ttu-id="3c4fd-208">**пстг**</span><span class="sxs-lookup"><span data-stu-id="3c4fd-208">**pstg**</span></span>    | <span data-ttu-id="3c4fd-209">Указатель на интерфейс [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-209">A pointer to an [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span> <span data-ttu-id="3c4fd-210">Целевой объект вызывает методы интерфейса для извлечения данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-210">The target calls the interface methods to extract the data.</span></span> <span data-ttu-id="3c4fd-211">Как и в ТИМЕД \_ ISTREAM, этот тип указателя требует относительно мало памяти.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-211">Like TYMED\_ISTREAM, this pointer type requires relatively little memory.</span></span> <span data-ttu-id="3c4fd-212">Однако поскольку ТИМЕД \_ ISTORAGE менее гибок, чем тимед \_ ISTREAM, он не так часто используется.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-212">However, because TYMED\_ISTORAGE is less flexible than TYMED\_ISTREAM, it is not as commonly used.</span></span>                  |



 

## <a name="how-a-source-creates-a-data-object"></a><span data-ttu-id="3c4fd-213">Как источник создает объект данных</span><span class="sxs-lookup"><span data-stu-id="3c4fd-213">How a Source Creates a Data Object</span></span>

<span data-ttu-id="3c4fd-214">Когда пользователь инициирует передаваемые данные оболочки, источник отвечает за создание объекта данных и его загрузку с данными.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-214">When a user initiates a Shell data transfer, the source is responsible for creating a data object and loading it with data.</span></span> <span data-ttu-id="3c4fd-215">Следующая процедура обобщает процесс:</span><span class="sxs-lookup"><span data-stu-id="3c4fd-215">The following procedure summarizes the process:</span></span>

1.  <span data-ttu-id="3c4fd-216">Вызовите [регистерклипбоардформат](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) , чтобы получить допустимое значение формата буфера обмена для каждого формата оболочки, который будет включаться в объект данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-216">Call [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) to obtain a valid clipboard format value for each Shell format that will be included in the data object.</span></span> <span data-ttu-id="3c4fd-217">Помните, [что \_ HDROP CF](clipboard.md) уже является допустимым форматом буфера обмена и не требует регистрации.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-217">Remember that [CF\_HDROP](clipboard.md) is already a valid clipboard format and does not need to be registered.</span></span>
2.  <span data-ttu-id="3c4fd-218">Для каждого формата, который должен быть передан, следует либо поместить связанные данные в глобальный объект памяти, либо создать объект, предоставляющий доступ к этим данным через интерфейс [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) или [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-218">For each format to be transferred, either put the associated data into a global memory object or create an object that provides access to that data through an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) or [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface.</span></span> <span data-ttu-id="3c4fd-219">Интерфейсы **IStream** и **IStorage** создаются с помощью стандартных методов COM.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-219">The **IStream** and **IStorage** interfaces are created using standard COM techniques.</span></span> <span data-ttu-id="3c4fd-220">Обсуждение способов управления объектами глобальной памяти см. в разделе [Добавление объекта глобальной памяти в объект данных](#how-to-add-a-global-memory-object-to-a-data-object).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-220">For a discussion of how to handle global memory objects, see [How to Add a Global Memory Object to a Data Object](#how-to-add-a-global-memory-object-to-a-data-object).</span></span>
3.  <span data-ttu-id="3c4fd-221">Создайте структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) и [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) для каждого формата.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-221">Create [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) and [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structures for each format.</span></span>
4.  <span data-ttu-id="3c4fd-222">Создайте экземпляр объекта данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-222">Instantiate a data object.</span></span>
5.  <span data-ttu-id="3c4fd-223">Загрузите данные в объект данных, вызвав метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) для каждого поддерживаемого формата и передав структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) и [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) формата.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-223">Load the data into the data object by calling the [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method for each supported format and passing in the format's [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) and [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structures.</span></span>
6.  <span data-ttu-id="3c4fd-224">При передаче данных из буфера обмена вызовите [**олесетклипбоард**](/windows/win32/api/ole2/nf-ole2-olesetclipboard) , чтобы поместить указатель на интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных в буфер обмена.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-224">With clipboard data transfers, call [**OleSetClipboard**](/windows/win32/api/ole2/nf-ole2-olesetclipboard) to place a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface on the Clipboard.</span></span> <span data-ttu-id="3c4fd-225">Для перемещения с помощью перетаскивания инициируйте *цикл перетаскивания* путем вызова [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-225">For drag-and-drop transfers, initiate a *drag loop* by calling [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).</span></span> <span data-ttu-id="3c4fd-226">Указатель **IDataObject** будет передан в цель перетаскивания при удалении данных, завершая цикл перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-226">The **IDataObject** pointer will be passed to the drop target when the data is dropped, ending the drag loop.</span></span>

<span data-ttu-id="3c4fd-227">Теперь объект данных готов к передаче в цель.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-227">The data object is now ready to be transferred to the target.</span></span> <span data-ttu-id="3c4fd-228">Для передачи данных из буфера обмена объект просто удерживается, пока целевой объект не запросит его, вызвав [**олежетклипбоард**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-228">For clipboard data transfers, the object is simply held until the target requests it by calling [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span></span> <span data-ttu-id="3c4fd-229">Для передачи данных при перетаскивании объект данных отвечает за создание значка для представления данных и их перемещение по мере того, как пользователь перемещает курсор.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-229">For drag-and-drop data transfers, the data object is responsible for creating an icon to represent the data and moving it as the user moves the cursor.</span></span> <span data-ttu-id="3c4fd-230">Пока объект находится в цикле перетаскивания, источник получает сведения о состоянии через свой интерфейс [**идропсаурце**](/windows/win32/api/oleidl/nn-oleidl-idropsource) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-230">While the object is in the drag loop, the source receives status information through its [**IDropSource**](/windows/win32/api/oleidl/nn-oleidl-idropsource) interface.</span></span> <span data-ttu-id="3c4fd-231">Дополнительные сведения см. в статье [Реализация идропсаурце](#implementing-idropsource).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-231">For further discussion, see [Implementing IDropSource](#implementing-idropsource).</span></span>

<span data-ttu-id="3c4fd-232">Источник не получает уведомления, если объект данных извлекается из буфера обмена целевым объектом.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-232">The source receives no notification if the data object is retrieved from the Clipboard by a target.</span></span> <span data-ttu-id="3c4fd-233">При удалении объекта в целевой объект с помощью операции перетаскивания функция [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) , которая была вызвана для инициации цикла перетаскивания, вернет.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-233">When an object is dropped on a target by a drag-and-drop operation, the [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) function that was called to initiate the drag loop will return.</span></span>

### <a name="how-to-add-a-global-memory-object-to-a-data-object"></a><span data-ttu-id="3c4fd-234">Добавление объекта глобальной памяти в объект данных</span><span class="sxs-lookup"><span data-stu-id="3c4fd-234">How to Add a Global Memory Object to a Data Object</span></span>

<span data-ttu-id="3c4fd-235">Многие форматы данных оболочки представлены в виде объекта глобальной памяти.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-235">Many of the Shell data formats are in the form of a global memory object.</span></span> <span data-ttu-id="3c4fd-236">Используйте следующую процедуру, чтобы создать формат, содержащий объект глобальной памяти, и загрузить его в объект данных:</span><span class="sxs-lookup"><span data-stu-id="3c4fd-236">Use the following procedure to create a format containing a global memory object and load it into the data object:</span></span>

1.  <span data-ttu-id="3c4fd-237">Создайте структуру [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-237">Create a [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure.</span></span> <span data-ttu-id="3c4fd-238">Задайте для элемента **кфформат** соответствующее значение формата буфера обмена, а для элемента **тимед** — тимед \_ хглобал.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-238">Set the **cfFormat** member to the appropriate clipboard format value and the **tymed** member to TYMED\_HGLOBAL.</span></span>
2.  <span data-ttu-id="3c4fd-239">Создайте структуру [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-239">Create an [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span> <span data-ttu-id="3c4fd-240">Задайте для элемента **тимед** значение тимед \_ хглобал.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-240">Set the **tymed** member to TYMED\_HGLOBAL.</span></span>
3.  <span data-ttu-id="3c4fd-241">Создайте объект глобальной памяти, вызвав [**GlobalAlloc**](/windows/win32/api/winbase/nf-winbase-globalalloc) для размещения блока памяти подходящего размера.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-241">Create a global memory object by calling [**GlobalAlloc**](/windows/win32/api/winbase/nf-winbase-globalalloc) to allocate a suitably sized block of memory.</span></span>
4.  <span data-ttu-id="3c4fd-242">Назначьте блок данных для передачи в адрес, возвращенный [**GlobalAlloc**](/windows/win32/api/winbase/nf-winbase-globalalloc).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-242">Assign the block of data to be transferred to the address returned by [**GlobalAlloc**](/windows/win32/api/winbase/nf-winbase-globalalloc).</span></span>
5.  <span data-ttu-id="3c4fd-243">Назначьте адрес объекта глобальной памяти элементу **хглобал** структуры [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-243">Assign the global memory object's address to the **hGlobal** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span>
6.  <span data-ttu-id="3c4fd-244">Загрузите формат в объект данных, вызвав [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) и передав структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) и [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) , созданные на предыдущих шагах.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-244">Load the format into the data object by calling [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) and passing in the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) and [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structures created in the previous steps.</span></span>

<span data-ttu-id="3c4fd-245">Следующий пример функции создает объект глобальной памяти, содержащий значение **DWORD** , и загружает его в объект данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-245">The following sample function creates a global memory object containing a **DWORD** value and loads it into a data object.</span></span> <span data-ttu-id="3c4fd-246">Параметр **пдтобж** — это указатель на интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных, **CF** — это значение формата буфера обмена, а **DW** — это значение данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-246">The **pdtobj** parameter is a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface, **cf** is the clipboard format value, and **dw** is the data value.</span></span>


```C++
STDAPI DataObj_SetDWORD(IDataObject *pdtobj, UINT cf, DWORD dw)
{
    FORMATETC fmte = {(CLIPFORMAT) cf, 
                      NULL, 
                      DVASPECT_CONTENT, 
                      -1, 
                      TYMED_HGLOBAL};
    STGMEDIUM medium;

    HRESULT hres = E_OUTOFMEMORY;
    DWORD *pdw = (DWORD *)GlobalAlloc(GPTR, sizeof(DWORD));
    
    if (pdw)
    {
        *pdw = dw;       
        medium.tymed = TYMED_HGLOBAL;
        medium.hGlobal = pdw;
        medium.pUnkForRelease = NULL;

        hres = pdtobj->SetData(&fmte, &medium, TRUE);
 
        if (FAILED(hres))
            GlobalFree((HGLOBAL)pdw);
    }
    return hres;
}
```



### <a name="implementing-idataobject"></a><span data-ttu-id="3c4fd-247">Реализация интерфейса IDataObject</span><span class="sxs-lookup"><span data-stu-id="3c4fd-247">Implementing IDataObject</span></span>

<span data-ttu-id="3c4fd-248">[**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) является основным интерфейсом объекта данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-248">[**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) is a data object's primary interface.</span></span> <span data-ttu-id="3c4fd-249">Он должен быть реализован всеми объектами данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-249">It must be implemented by all data objects.</span></span> <span data-ttu-id="3c4fd-250">Он используется как источником, так и целевым объектом для различных целей, в том числе:</span><span class="sxs-lookup"><span data-stu-id="3c4fd-250">It is used by both source and target for a variety of purposes, including:</span></span>

-   <span data-ttu-id="3c4fd-251">Загрузка данных в объект данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-251">Loading data into the data object.</span></span>
-   <span data-ttu-id="3c4fd-252">Извлечение данных из объекта данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-252">Extracting data from the data object.</span></span>
-   <span data-ttu-id="3c4fd-253">Определение типов данных, которые находятся в объекте данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-253">Determining what types of data are in the data object.</span></span>
-   <span data-ttu-id="3c4fd-254">Предоставление обратной связи с объектом данных в результате передаваемых данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-254">Providing feedback to the data object on outcome of the data transfer.</span></span>

<span data-ttu-id="3c4fd-255">[**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) поддерживает ряд методов.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-255">[**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) supports a number of methods.</span></span> <span data-ttu-id="3c4fd-256">В этом разделе описывается, как реализовать три наиболее важных метода для объектов данных оболочки, [SetData](#setdata-method), [енумформатетк](#enumformatetc-method)и [GetData](#getdata-method).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-256">This section discusses how to implement the three most important methods for Shell data objects, [SetData](#setdata-method), [EnumFormatEtc](#enumformatetc-method), and [GetData](#getdata-method).</span></span> <span data-ttu-id="3c4fd-257">Обсуждение других методов см. в справочнике по **IDataObject** .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-257">For a discussion of the other methods, see the **IDataObject** reference.</span></span>

### <a name="setdata-method"></a><span data-ttu-id="3c4fd-258">SetData - метод</span><span class="sxs-lookup"><span data-stu-id="3c4fd-258">SetData method</span></span>

<span data-ttu-id="3c4fd-259">Основная функция метода [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) заключается в том, чтобы разрешить источнику загрузку данных в объект данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-259">The primary function of the [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) method is to allow the source to load data into the data object.</span></span> <span data-ttu-id="3c4fd-260">Для каждого включаемого формата источник создает структуру [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) , которая определяет формат и структуру [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) для хранения указателя на данные.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-260">For each format to be included, the source creates a [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to identify the format and an [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure to hold a pointer to the data.</span></span> <span data-ttu-id="3c4fd-261">Затем источник вызывает метод **IDataObject:: SetData** объекта и передается в структурах **форматетк** и **стгмедиум** формата.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-261">The source then calls the object's **IDataObject::SetData** method and passes in the format's **FORMATETC** and **STGMEDIUM** structures.</span></span> <span data-ttu-id="3c4fd-262">Метод должен сохранять эти сведения, чтобы они были доступны, когда целевой объект вызывает метод [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) для извлечения данных из объекта.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-262">The method must store this information so that it is available when the target calls [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) to extract data from the object.</span></span>

<span data-ttu-id="3c4fd-263">Однако при передаче файлов оболочка часто помещает данные для каждого файла в отдельный формат [ \_ филеконтентс кфстр](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-263">However, when transferring files, the Shell often puts the information for each file to be transferred into a separate [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span> <span data-ttu-id="3c4fd-264">Чтобы отличить различные файлы, элементу **Линдекс** в структуре [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) каждого файла присваивается значение индекса, идентифицирующее конкретный файл.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-264">To distinguish the different files, the **lIndex** member of each file's [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure is set to an index value that identifies the particular file.</span></span> <span data-ttu-id="3c4fd-265">Реализация [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) должна поддерживать хранение нескольких \_ форматов кфстр филеконтентс, которые отличаются только их членами **Линдекс** .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-265">Your [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) implementation must be capable of storing multiple CFSTR\_FILECONTENTS formats that differ only by their **lIndex** members.</span></span>

<span data-ttu-id="3c4fd-266">Пока курсор находится над целевым окном, цель может использовать [вспомогательный объект перетаскивания](#using-the-drag-and-drop-helper-object) для указания изображения перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-266">While the cursor is over the target window, the target can use the [drag-and-drop helper object](#using-the-drag-and-drop-helper-object) to specify the drag image.</span></span> <span data-ttu-id="3c4fd-267">Вспомогательный объект перетаскивания вызывает метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) для загрузки закрытых форматов в объект данных, используемый для поддержки между процессами.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-267">The drag-and-drop helper object calls [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to load private formats into the data object that are used for cross-process support.</span></span> <span data-ttu-id="3c4fd-268">Для поддержки вспомогательного объекта, поддерживающего перетаскивание, реализация **IDataObject:: SetData** должна иметь возможность принимать и сохранять произвольные закрытые форматы.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-268">To support the drag-and-drop helper object, your **IDataObject::SetData** implementation must be able to accept and store arbitrary private formats.</span></span>

<span data-ttu-id="3c4fd-269">После удаления данных некоторые типы передачи данных оболочки должны вызывать функцию [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) , чтобы предоставить объекту данных сведения о результате операции удаления.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-269">After the data has been dropped, some types of Shell data transfer require the target to call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to provide the data object with information about the outcome of the drop operation.</span></span> <span data-ttu-id="3c4fd-270">Например, при перемещении файлов с оптимизированной операцией перемещения целевой объект обычно удаляет исходные файлы, но это не является обязательным.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-270">For example, when moving files with an optimized move operation, the target normally deletes the original files, but it is not required to do so.</span></span> <span data-ttu-id="3c4fd-271">Цель информирует объект данных о том, удалили ли они файлы путем вызова функции **IDataObject:: SetData** с форматом [ \_ логикалперформеддропеффект кфстр](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-271">The target informs the data object whether it deleted the files by calling **IDataObject::SetData** with a [CFSTR\_LOGICALPERFORMEDDROPEFFECT](clipboard.md) format.</span></span> <span data-ttu-id="3c4fd-272">Существует несколько других [форматов буфера обмена оболочки](clipboard.md) , которые также используются целевым объектом для передачи данных в объект данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-272">There are several other [Shell Clipboard Formats](clipboard.md) that are also used by the target to pass information to the data object.</span></span> <span data-ttu-id="3c4fd-273">Реализация **IDataObject:: SetData** должна иметь возможность распознать эти форматы и ответить соответствующим образом.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-273">Your **IDataObject::SetData** implementation must be able to recognize these formats and respond appropriately.</span></span> <span data-ttu-id="3c4fd-274">Дополнительные сведения см. в статье [Обработка сценариев передача данных оболочки](datascenarios.md).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-274">For further discussion, see [Handling Shell Data Transfer Scenarios](datascenarios.md).</span></span>

### <a name="enumformatetc-method"></a><span data-ttu-id="3c4fd-275">Метод Енумформатетк</span><span class="sxs-lookup"><span data-stu-id="3c4fd-275">EnumFormatEtc method</span></span>

<span data-ttu-id="3c4fd-276">Когда цель получает объект данных, она обычно вызывает [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) , чтобы определить, какие форматы содержит объект.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-276">When the target receives a data object, it commonly calls [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) to determine what formats the object contains.</span></span> <span data-ttu-id="3c4fd-277">Метод создает объект перечисления OLE и возвращает указатель на интерфейс [**иенумформатетк**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) объекта.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-277">The method creates an OLE enumeration object and returns a pointer to the object's [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) interface.</span></span> <span data-ttu-id="3c4fd-278">Затем целевой объект использует интерфейс для перечисления доступных форматов.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-278">The target then uses the interface to enumerate the available formats.</span></span>

<span data-ttu-id="3c4fd-279">Объект перечисления всегда должен перечислять доступные форматы в порядке их качества, начиная с наилучшего.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-279">An enumeration object should always enumerate the available formats in order of quality, starting with the best.</span></span> <span data-ttu-id="3c4fd-280">Относительное качество форматов определяется источником перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-280">The relative quality of formats is defined by the drop source.</span></span> <span data-ttu-id="3c4fd-281">Как правило, форматы самого высокого качества содержат самые широкие и наиболее полные данные.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-281">In general, the highest-quality formats contain the richest and most complete data.</span></span> <span data-ttu-id="3c4fd-282">Например, 24-разрядное изображение, как правило, будет считаться более высоким качеством, чем серая версия этого изображения.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-282">For instance, a 24-bit color image would normally be considered higher quality than a gray-scale version of that image.</span></span> <span data-ttu-id="3c4fd-283">Причина перечисления форматов в порядке их качества заключается в том, что целевые объекты обычно перечисляются до тех пор, пока они не получат поддерживаемый формат, а затем используют этот формат для извлечения данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-283">The reason for enumerating formats in order of their quality is that targets typically enumerate until they get to a format that they support, and then they use that format to extract the data.</span></span> <span data-ttu-id="3c4fd-284">Для этой процедуры, чтобы получить наилучший доступный формат, который может поддерживаться целью, необходимо перечислить форматы в порядке их качества.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-284">For this procedure to produce the best available format that the target can support, the formats must be enumerated in order of their quality.</span></span>

<span data-ttu-id="3c4fd-285">Объект перечисления для данных оболочки реализуется во многом так же, как и для других типов обмена данными, с одним заметным исключением.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-285">An enumeration object for Shell data is implemented in much the same way as for other types of data transfer, with one notable exception.</span></span> <span data-ttu-id="3c4fd-286">Поскольку объекты данных обычно содержат только один элемент данных в каждом формате, они обычно перечисляют каждый формат, который передается в [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-286">Because data objects typically contain only one data item per format, they normally enumerate every format that is passed to [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata).</span></span> <span data-ttu-id="3c4fd-287">Однако, как обсуждалось в разделе [метод SetData](#setdata-method) , объекты данных оболочки могут содержать несколько форматов [кфстр \_ филеконтентс](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-287">However, as discussed in the [SetData method](#setdata-method) section, Shell data objects can contain multiple [CFSTR\_FILECONTENTS](clipboard.md) formats.</span></span>

<span data-ttu-id="3c4fd-288">Так как для интерфейса [**IDataObject:: енумформатетк**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) можно разрешить целевому объекту определять, какие типы данных присутствуют, нет необходимости перечислять более одного формата [ \_ филеконтентс кфстр](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-288">Because the purpose of [**IDataObject::EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) is to allow the target to determine what types of data are present, there is no need to enumerate more than one [CFSTR\_FILECONTENTS](clipboard.md) format.</span></span> <span data-ttu-id="3c4fd-289">Если целевому объекту необходимо узнать, сколько из этих форматов содержит объект данных, целевой объект может получить эту информацию из соответствующего \_ формата кфстр филедескриптор.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-289">If the target needs to know how many of these formats the data object contains, the target can retrieve that information from the accompanying CFSTR\_FILEDESCRIPTOR format.</span></span> <span data-ttu-id="3c4fd-290">Более подробное описание реализации интерфейса **IDataObject:: енумформатетк** см. в справочной документации по методу.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-290">For further discussion of how to implement **IDataObject::EnumFormatEtc**, see the method's reference documentation.</span></span>

### <a name="getdata-method"></a><span data-ttu-id="3c4fd-291">Метод GetData</span><span class="sxs-lookup"><span data-stu-id="3c4fd-291">GetData method</span></span>

<span data-ttu-id="3c4fd-292">Цель вызывает метод [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) для извлечения определенного формата данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-292">The target calls [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) to extract a particular data format.</span></span> <span data-ttu-id="3c4fd-293">Целевой объект определяет формат, передавая соответствующую структуру [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-293">The target specifies the format by passing in the appropriate [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure.</span></span> <span data-ttu-id="3c4fd-294">**IDataObject:: GetData** возвращает структуру [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) формата.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-294">**IDataObject::GetData** returns the format's [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span>

<span data-ttu-id="3c4fd-295">Целевой объект может задать для элемента **тимед** структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) конкретное значение тимед \_ *xxx* , чтобы указать, какой механизм переноса данных будет использоваться для извлечения данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-295">The target can set the **tymed** member of the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to a specific TYMED\_*XXX* value to specify which data transfer mechanism it will use to extract the data.</span></span> <span data-ttu-id="3c4fd-296">Однако целевой объект также может сделать более общий запрос и позволить объекту данных принять решение.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-296">However, the target can also make a more generic request and let the data object decide.</span></span> <span data-ttu-id="3c4fd-297">Чтобы задать для объекта данных механизм обмена данными, целевой объект устанавливает все \_ поддерживаемые им значения тимед *xxx* .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-297">To ask the data object to select the data transfer mechanism, the target sets all the TYMED\_*XXX* values that it supports.</span></span> <span data-ttu-id="3c4fd-298">[**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) выбирает один из этих механизмов обмена данными и возвращает соответствующую структуру [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-298">[**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) selects one of these data transfer mechanisms and returns the appropriate [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span> <span data-ttu-id="3c4fd-299">Например, **тимед** обычно имеет значение тимед \_ хглобал \| тимед \_ ISTREAM \| тимед \_ ISTORAGE, чтобы запросить любой из трех механизмов обмена данными оболочки.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-299">For instance, **tymed** is commonly set to TYMED\_HGLOBAL \| TYMED\_ISTREAM \| TYMED\_ISTORAGE to request any of the three Shell data transfer mechanisms.</span></span>

> [!Note]  
> <span data-ttu-id="3c4fd-300">Поскольку может существовать несколько форматов [кфстр \_ филеконтентс](clipboard.md) , члены **Кфформат** и **тимед** структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) недостаточно, чтобы указать, какая [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) структура [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) должна возвращать.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-300">Because there can be multiple [CFSTR\_FILECONTENTS](clipboard.md) formats, the **cfFormat** and **tymed** members of the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure are not sufficient to indicate which [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) should return.</span></span> <span data-ttu-id="3c4fd-301">Для \_ формата ФИЛЕКОНТЕНТС Кфстр **IDataObject:: GetData** должен также изучить элемент **Линдекс** структуры **форматетк** , чтобы получить правильную структуру **стгмедиум** .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-301">For the CFSTR\_FILECONTENTS format, **IDataObject::GetData** must also examine the **FORMATETC** structure's **lIndex** member in order to return the correct **STGMEDIUM** structure.</span></span>

 

<span data-ttu-id="3c4fd-302">Формат [кфстр \_ индраглуп](clipboard.md) помещается в объекты данных, чтобы разрешить целевым объектам проверять состояние цикла перетаскивания, избегая интенсивного отображения данных объекта.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-302">The [CFSTR\_INDRAGLOOP](clipboard.md) format is placed in data objects to allow targets to check the status of the drag-and-drop loop while avoiding memory intensive rendering of the object's data.</span></span> <span data-ttu-id="3c4fd-303">Данные формата — это значение **типа DWORD** , равное ненулевому значению, если объект данных находится в пределах цикла перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-303">The format's data is a **DWORD** value that is set to a nonzero value if the data object is within a drag loop.</span></span> <span data-ttu-id="3c4fd-304">Значение данных формата задается равным нулю, если данные были удалены.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-304">The format's data value is set to zero if the data has been dropped.</span></span> <span data-ttu-id="3c4fd-305">Если целевой объект запрашивает этот формат и не был загружен источником, метод [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) должен реагировать так, как если бы источник загрузил формат со значением, равным нулю.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-305">If a target requests this format and it has not been loaded by the source, [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) should respond as if the source had loaded the format with a value of zero.</span></span>

<span data-ttu-id="3c4fd-306">Пока курсор находится над целевым окном, цель может использовать [вспомогательный объект перетаскивания](#using-the-drag-and-drop-helper-object) для указания изображения перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-306">While the cursor is over the target window, the target can use the [drag-and-drop helper object](#using-the-drag-and-drop-helper-object) to specify the drag image.</span></span> <span data-ttu-id="3c4fd-307">Вспомогательный объект перетаскивания вызывает метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) для загрузки закрытых форматов в объект данных, используемый для поддержки между процессами.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-307">The drag-and-drop helper object calls [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to load private formats into the data object that are used for cross-process support.</span></span> <span data-ttu-id="3c4fd-308">Позже он вызывает метод [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) , чтобы получить их.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-308">It later calls [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) to retrieve them.</span></span> <span data-ttu-id="3c4fd-309">Для поддержки вспомогательного объекта перетаскивания реализация объекта данных оболочки должна иметь возможность возвращать произвольные закрытые форматы при их запросе.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-309">To support the drag-and-drop helper object, your Shell Data Object implementation must be able to return arbitrary private formats when they are requested.</span></span>

### <a name="implementing-idropsource"></a><span data-ttu-id="3c4fd-310">Реализация Идропсаурце</span><span class="sxs-lookup"><span data-stu-id="3c4fd-310">Implementing IDropSource</span></span>

<span data-ttu-id="3c4fd-311">Источник должен создать объект, предоставляющий интерфейс [**идропсаурце**](/windows/win32/api/oleidl/nn-oleidl-idropsource) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-311">The source must create an object that exposes an [**IDropSource**](/windows/win32/api/oleidl/nn-oleidl-idropsource) interface.</span></span> <span data-ttu-id="3c4fd-312">Этот интерфейс позволяет источнику обновить *изображение перетаскивания* , указывающее текущую позицию курсора, и предоставить отзыв системе о том, как завершить операцию перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-312">This interface allows the source to update the *drag image* that indicates the current position of the cursor and to provide feedback to the system on how to terminate a drag-and-drop operation.</span></span> <span data-ttu-id="3c4fd-313">**Идропсаурце** имеет два метода: [**GiveFeedback**](/windows/win32/api/oleidl/nf-oleidl-idropsource-givefeedback) и [**QueryContinueDrag**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-313">**IDropSource** has two methods: [**GiveFeedback**](/windows/win32/api/oleidl/nf-oleidl-idropsource-givefeedback) and [**QueryContinueDrag**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag).</span></span>

### <a name="givefeedback-method"></a><span data-ttu-id="3c4fd-314">GiveFeedback - метод</span><span class="sxs-lookup"><span data-stu-id="3c4fd-314">GiveFeedback method</span></span>

<span data-ttu-id="3c4fd-315">В цикле перетаскивания источник перетаскивания отвечает за отслеживание положения курсора и отображение соответствующего изображения перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-315">While in the drag loop, a drop source is responsible for keeping track of the cursor position and displaying an appropriate drag image.</span></span> <span data-ttu-id="3c4fd-316">Однако в некоторых случаях может потребоваться изменить внешний вид изображения перетаскивания, если оно находится над окном назначения перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-316">However, in some cases you might want to change the appearance of the drag image when it is over the drop target's window.</span></span>

<span data-ttu-id="3c4fd-317">Когда курсор попадает в целевое окно или покидает его, а перемещается в целевое окно, система периодически вызывает интерфейс [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) целевого объекта.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-317">When the cursor enters or leaves the target window and while it is moving over the target window, the system periodically calls the target's [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface.</span></span> <span data-ttu-id="3c4fd-318">Целевой объект реагирует на значение [**дропеффект**](../com/dropeffect-constants.md) , которое перенаправляется в источник с помощью метода [**GiveFeedback**](/windows/win32/api/oleidl/nf-oleidl-idropsource-givefeedback) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-318">The target responds with a [**DROPEFFECT**](../com/dropeffect-constants.md) value that is forwarded to the source through the [**GiveFeedback**](/windows/win32/api/oleidl/nf-oleidl-idropsource-givefeedback) method.</span></span> <span data-ttu-id="3c4fd-319">При необходимости источник может изменить внешний вид курсора на основе значения **дропеффект** .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-319">If appropriate, the source can modify the appearance of the cursor based on the **DROPEFFECT** value.</span></span> <span data-ttu-id="3c4fd-320">Дополнительные сведения см. в справочниках по **GiveFeedback** и [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-320">For further details, see the **GiveFeedback** and [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) references.</span></span>

### <a name="querycontinuedrag-method"></a><span data-ttu-id="3c4fd-321">QueryContinueDrag - метод</span><span class="sxs-lookup"><span data-stu-id="3c4fd-321">QueryContinueDrag method</span></span>

<span data-ttu-id="3c4fd-322">Этот метод вызывается при изменении состояния кнопки мыши или клавиатуры, когда объект данных находится в цикле перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-322">This method is called if the mouse button or keyboard state changes while the data object is in the drag loop.</span></span> <span data-ttu-id="3c4fd-323">Он уведомляет источник о нажатии клавиши ESC и предоставляет текущее состояние клавиш с модификатором клавиатуры, таких как CTRL или SHIFT.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-323">It notifies the source whether the ESC key has been pressed and provides the current state of the keyboard modifier keys, such as CTRL or SHIFT.</span></span> <span data-ttu-id="3c4fd-324">Возвращаемое значение метода [**QueryContinueDrag**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag) указывает одно из трех действий:</span><span class="sxs-lookup"><span data-stu-id="3c4fd-324">The [**QueryContinueDrag**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag) method's return value specifies one of three actions:</span></span>

-   <span data-ttu-id="3c4fd-325">\_ОК.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-325">S\_OK.</span></span> <span data-ttu-id="3c4fd-326">Продолжить операцию перетаскивания</span><span class="sxs-lookup"><span data-stu-id="3c4fd-326">Continue the drag operation</span></span>
-   <span data-ttu-id="3c4fd-327">\_Удаление DRAGDROP \_ .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-327">DRAGDROP\_S\_DROP.</span></span> <span data-ttu-id="3c4fd-328">Удалите данные.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-328">Drop the data.</span></span> <span data-ttu-id="3c4fd-329">Затем система вызывает метод [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) целевого объекта.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-329">The system then calls the target's [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method.</span></span>
-   <span data-ttu-id="3c4fd-330">DRAGDROP \_ S \_ Отмена.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-330">DRAGDROP\_S\_CANCEL.</span></span> <span data-ttu-id="3c4fd-331">Завершите цикл перетаскивания без удаления данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-331">Terminate the drag loop without dropping the data.</span></span> <span data-ttu-id="3c4fd-332">Это значение обычно возвращается при нажатии клавиши ESCAPE.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-332">This value is normally returned if the ESCAPE key was pressed.</span></span>

<span data-ttu-id="3c4fd-333">Дополнительные сведения см. в справочниках по [**QueryContinueDrag**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag) и [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-333">For further discussion, see the [**QueryContinueDrag**](/windows/win32/api/oleidl/nf-oleidl-idropsource-querycontinuedrag) and [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) references.</span></span>

## <a name="how-a-target-handles-a-data-object"></a><span data-ttu-id="3c4fd-334">Обработка объектом данных целевым объектом</span><span class="sxs-lookup"><span data-stu-id="3c4fd-334">How a Target Handles a Data Object</span></span>

<span data-ttu-id="3c4fd-335">Цель получает объект данных, когда он либо получает объект данных из буфера обмена, либо отбрасывается пользователем в целевое окно.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-335">The target receives a data object when it either retrieves the data object from the Clipboard or has it dropped on the target window by the user.</span></span> <span data-ttu-id="3c4fd-336">Затем целевой объект может извлекать данные из объекта данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-336">The target can then extract data from the data object.</span></span> <span data-ttu-id="3c4fd-337">При необходимости цель также может уведомлять объект данных о результате операции.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-337">If necessary, the target can also notify the data object of the outcome of the operation.</span></span> <span data-ttu-id="3c4fd-338">Прежде чем передавать данные оболочки, цель перетаскивания должна подготовиться для выполнения операции:</span><span class="sxs-lookup"><span data-stu-id="3c4fd-338">Prior to a Shell data transfer, a drop target must prepare itself for the operation:</span></span>

1.  <span data-ttu-id="3c4fd-339">Цель должна вызвать [регистерклипбоардформат](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) , чтобы получить допустимое значение формата буфера обмена для всех форматов оболочки, отличных от [CF \_ HDROP](clipboard.md), которые могут быть добавлены в объект данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-339">The target must call [RegisterClipboardFormat](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) to obtain a valid clipboard format value for all Shell formats, other than [CF\_HDROP](clipboard.md), that might be included in the data object.</span></span> <span data-ttu-id="3c4fd-340">CF \_ HDROP уже является допустимым форматом буфера обмена и не требует регистрации.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-340">CF\_HDROP is already a valid clipboard format and does not need to be registered.</span></span>
2.  <span data-ttu-id="3c4fd-341">Для поддержки операции перетаскивания целевой объект должен реализовывать интерфейс [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) и регистрировать целевое окно.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-341">To support a drag-and-drop operation, the target must implement an [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface and register a target window.</span></span> <span data-ttu-id="3c4fd-342">Чтобы зарегистрировать целевое окно, целевой объект вызывает [**регистердрагдроп**](/windows/win32/api/ole2/nf-ole2-registerdragdrop) и передает маркер окна и указатель интерфейса **интерфейс IDropTarget** .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-342">To register a target window, the target calls [**RegisterDragDrop**](/windows/win32/api/ole2/nf-ole2-registerdragdrop) and passes in the window's handle and the **IDropTarget** interface pointer.</span></span>

<span data-ttu-id="3c4fd-343">Для перемещений из буфера обмена целевой объект не получает уведомления о том, что в буфере обмена помещены объекты данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-343">For clipboard transfers, the target does not receive any notification that a data object has been placed on the Clipboard.</span></span> <span data-ttu-id="3c4fd-344">Как правило, приложение уведомляет о том, что объект находится в буфере обмена с помощью действия пользователя, например нажатием кнопки Вставить на панели инструментов приложения.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-344">Typically, an application is notified that an object is on the Clipboard by a user action, such as clicking the Paste button on the application's toolbar.</span></span> <span data-ttu-id="3c4fd-345">Затем целевой объект получает указатель [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных из буфера обмена путем вызова [**олежетклипбоард**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-345">The target then retrieves the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) pointer from the Clipboard by calling [**OleGetClipboard**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).</span></span> <span data-ttu-id="3c4fd-346">Для передачи данных с помощью перетаскивания система использует интерфейс [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) целевого объекта для предоставления целевой информации о ходе передачи данных:</span><span class="sxs-lookup"><span data-stu-id="3c4fd-346">For drag-and-drop data transfers, the system uses the target's [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface to provide the target with information about the progress of the data transfer:</span></span>

-   <span data-ttu-id="3c4fd-347">Система вызывает [**интерфейс IDropTarget::D ражентер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) , когда курсор попадает в целевое окно.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-347">The system calls [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) when the cursor enters the target window.</span></span>
-   <span data-ttu-id="3c4fd-348">Система периодически вызывает [**интерфейс IDropTarget::D раговер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) по мере прохождения курсора в целевом окне, чтобы предоставить целевой объект текущей позиции курсора.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-348">The system periodically calls [**IDropTarget::DragOver**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) as the cursor passes over the target window, to give the target the current cursor position.</span></span>
-   <span data-ttu-id="3c4fd-349">Система вызывает [**интерфейс IDropTarget::D раглеаве**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragleave) , когда курсор покидает целевое окно.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-349">The system calls [**IDropTarget::DragLeave**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragleave) when the cursor leaves the target window.</span></span>
-   <span data-ttu-id="3c4fd-350">Система вызывает [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) , когда пользователь удаляет объект данных в целевом окне.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-350">The system calls [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) when the user drops the data object on the target window.</span></span>

<span data-ttu-id="3c4fd-351">Обсуждение реализации этих методов см. в разделе [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-351">For a discussion of how to implement these methods, see [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget).</span></span>

<span data-ttu-id="3c4fd-352">При удалении данных [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) предоставляет целевой объект с указателем на интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-352">When the data is dropped, [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) provides the target with a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface.</span></span> <span data-ttu-id="3c4fd-353">Затем целевой объект использует этот интерфейс для извлечения данных из объекта данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-353">The target then uses this interface to extract data from the data object.</span></span>

### <a name="extracting-shell-data-from-a-data-object"></a><span data-ttu-id="3c4fd-354">Извлечение данных оболочки из объекта данных</span><span class="sxs-lookup"><span data-stu-id="3c4fd-354">Extracting Shell Data from a Data Object</span></span>

<span data-ttu-id="3c4fd-355">После удаления или извлечения объекта данных из буфера обмена целевой объект может извлекать необходимые данные.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-355">Once a data object has been dropped or retrieved from the Clipboard, the target can extract the data it needs.</span></span> <span data-ttu-id="3c4fd-356">Первым шагом процесса извлечения обычно является перечисление форматов, содержащихся в объекте данных:</span><span class="sxs-lookup"><span data-stu-id="3c4fd-356">The first step in the extraction process is typically to enumerate the formats contained by the data object:</span></span>

-   <span data-ttu-id="3c4fd-357">Вызовите [**IDataObject:: енумформатетк**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-357">Call [**IDataObject::EnumFormatEtc**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc).</span></span> <span data-ttu-id="3c4fd-358">Объект данных создает стандартный объект перечисления OLE и возвращает указатель на его интерфейс [**иенумформатетк**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-358">The data object creates a standard OLE enumeration object and returns a pointer to its [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) interface.</span></span>
-   <span data-ttu-id="3c4fd-359">Используйте методы [**иенумформатетк**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) для перечисления форматов, содержащихся в объекте данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-359">Use the [**IEnumFORMATETC**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) methods to enumerate the formats contained by the data object.</span></span> <span data-ttu-id="3c4fd-360">Эта операция обычно получает одну структуру [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) для каждого формата, который содержит объект.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-360">This operation usually retrieves one [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure for each format that the object contains.</span></span> <span data-ttu-id="3c4fd-361">Однако объект перечисления обычно возвращает только одну структуру **форматетк** для формата [кфстр \_ филеконтентс](clipboard.md) , независимо от того, сколько таких форматов содержится в объекте данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-361">However, the enumeration object normally returns only a single **FORMATETC** structure for the [CFSTR\_FILECONTENTS](clipboard.md) format, regardless of how many such formats are contained by the data object.</span></span>
-   <span data-ttu-id="3c4fd-362">Выберите один или несколько форматов для извлечения и сохраните их структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-362">Select one or more formats to be extracted, and store their [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structures.</span></span>

<span data-ttu-id="3c4fd-363">Чтобы получить определенный формат, передайте связанную структуру [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) в [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-363">To retrieve a particular format, pass the associated [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure to [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata).</span></span> <span data-ttu-id="3c4fd-364">Этот метод возвращает структуру [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) , которая предоставляет доступ к данным.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-364">This method returns an [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure that provides access to the data.</span></span> <span data-ttu-id="3c4fd-365">Чтобы указать определенный механизм обмена данными, установите значение **тимед** структуры **форматетк** в соответствующее значение тимед \_ *xxx* .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-365">To specify a particular data transfer mechanism, set the **tymed** value of the **FORMATETC** structure to the corresponding TYMED\_*XXX* value.</span></span> <span data-ttu-id="3c4fd-366">Чтобы задать для объекта данных способ выбора механизма обмена данными, целевой объект устанавливает значения ТИМЕД \_ *xxx* для каждого механизма обмена данными, который может быть обработано целевым объектом.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-366">To ask the data object to select a data transfer mechanism, the target sets the TYMED\_*XXX* values for every data transfer mechanism that the target can handle.</span></span> <span data-ttu-id="3c4fd-367">Объект данных выбирает один из этих механизмов обмена данными и возвращает соответствующую структуру **стгмедиум** .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-367">The data object selects one of these data transfer mechanisms and returns the appropriate **STGMEDIUM** structure.</span></span>

<span data-ttu-id="3c4fd-368">Для большинства форматов целевой объект может получить данные, передав структуру [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) , полученную при перечислении доступных форматов.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-368">For most formats, the target can retrieve the data by passing the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure that it received when it enumerated the available formats.</span></span> <span data-ttu-id="3c4fd-369">Единственным исключением из этого правила является [кфстр \_ филеконтентс](clipboard.md).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-369">One exception to this rule is [CFSTR\_FILECONTENTS](clipboard.md).</span></span> <span data-ttu-id="3c4fd-370">Поскольку объект данных может содержать несколько экземпляров этого формата, структура **форматетк** , возвращаемая перечислителем, может не соответствовать конкретному формату, который необходимо извлечь.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-370">Because a data object can contain multiple instances of this format, the **FORMATETC** structure returned by the enumerator might not correspond to the particular format you want to extract.</span></span> <span data-ttu-id="3c4fd-371">Помимо указания членов **кфформат** и **тимед** , необходимо также задать для элемента **Линдекс** значение индекса файла.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-371">In addition to specifying the **cfFormat** and **tymed** members, you must also set the **lIndex** member to the file's index value.</span></span> <span data-ttu-id="3c4fd-372">Дополнительные сведения см. в разделе *Использование формата кфстр \_ Филеконтентс для извлечения данных из файла* , посвященного [обработке сценариев передача данных оболочки](datascenarios.md) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-372">For further discussion, see the *Using the CFSTR\_FILECONTENTS Format to Extract Data from a File* section of [Handling Shell Data Transfer Scenarios](datascenarios.md)</span></span>

<span data-ttu-id="3c4fd-373">Процесс извлечения данных зависит от типа указателя, содержащегося в возвращаемой структуре [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-373">The data extraction process depends on the type of pointer contained by the returned [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span> <span data-ttu-id="3c4fd-374">Если структура содержит указатель на интерфейс [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) или [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) , используйте методы интерфейса для извлечения данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-374">If the structure contains a pointer to an [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) or [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) interface, use the interface methods to extract the data.</span></span> <span data-ttu-id="3c4fd-375">Процесс извлечения данных из глобального объекта памяти обсуждается в следующем разделе.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-375">The process of extracting data from a global memory object is discussed in the next section.</span></span>

### <a name="extracting-a-global-memory-object-from-a-data-object"></a><span data-ttu-id="3c4fd-376">Извлечение объекта глобальной памяти из объекта данных</span><span class="sxs-lookup"><span data-stu-id="3c4fd-376">Extracting a global memory object from a data object</span></span>

<span data-ttu-id="3c4fd-377">Многие форматы данных оболочки представлены в виде объекта глобальной памяти.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-377">Many of the Shell data formats are in the form of a global memory object.</span></span> <span data-ttu-id="3c4fd-378">Следующая процедура используется для извлечения формата, содержащего объект глобальной памяти из объекта данных, и назначения его данных локальной переменной:</span><span class="sxs-lookup"><span data-stu-id="3c4fd-378">Use the following procedure to extract a format containing a global memory object from a data object and assign its data to a local variable:</span></span>

1.  <span data-ttu-id="3c4fd-379">Создайте структуру [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-379">Create a [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) structure.</span></span> <span data-ttu-id="3c4fd-380">Задайте для элемента **кфформат** соответствующее значение формата буфера обмена, а для элемента **тимед** — тимед \_ хглобал.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-380">Set the **cfFormat** member to the appropriate clipboard format value and the **tymed** member to TYMED\_HGLOBAL.</span></span>
2.  <span data-ttu-id="3c4fd-381">Создайте пустую структуру [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-381">Create an empty [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span>
3.  <span data-ttu-id="3c4fd-382">Вызовите [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata)и передайте указатели на структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) и [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-382">Call [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata), and pass in pointers to the [**FORMATETC**](/windows/win32/api/objidl/ns-objidl-formatetc) and [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structures.</span></span>

    <span data-ttu-id="3c4fd-383">Когда функция [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) возвращает значение, структура [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) будет содержать указатель на глобальный объект памяти, содержащий данные.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-383">When [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) returns, the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure will contain a pointer to the global memory object that contains the data.</span></span>

4.  <span data-ttu-id="3c4fd-384">Назначьте данные локальной переменной, вызвав [**глобаллокк**](/windows/win32/api/winbase/nf-winbase-globallock) и передав элемент **хглобал** структуры [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-384">Assign the data to a local variable by calling [**GlobalLock**](/windows/win32/api/winbase/nf-winbase-globallock) and passing in the **hGlobal** member of the [**STGMEDIUM**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) structure.</span></span>
5.  <span data-ttu-id="3c4fd-385">Вызовите [**глобалунлокк**](/windows/win32/api/winbase/nf-winbase-globalunlock) , чтобы снять блокировку объекта глобальной памяти.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-385">Call [**GlobalUnlock**](/windows/win32/api/winbase/nf-winbase-globalunlock) to release the lock on the global memory object.</span></span>
6.  <span data-ttu-id="3c4fd-386">Вызовите [**релеасестгмедиум**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) , чтобы освободить глобальный объект памяти.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-386">Call [**ReleaseStgMedium**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) to release the global memory object.</span></span>

> [!Note]  
> <span data-ttu-id="3c4fd-387">Для освобождения объекта глобальной памяти, а не [**GlobalFree**](/windows/win32/api/winbase/nf-winbase-globalfree), необходимо использовать [**релеасестгмедиум**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-387">You must use [**ReleaseStgMedium**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) to release the global memory object, not [**GlobalFree**](/windows/win32/api/winbase/nf-winbase-globalfree).</span></span>

 

<span data-ttu-id="3c4fd-388">В следующем примере показано извлечение значения **DWORD** , хранящегося в виде объекта глобальной памяти, из объекта данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-388">The following example shows how to extract a **DWORD** value stored as a global memory object from a data object.</span></span> <span data-ttu-id="3c4fd-389">Параметр **пдтобж** является указателем на интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных, **CF** — это формат буфера обмена, который определяет нужные данные, а **пдваут** используется для возвращения значения данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-389">The **pdtobj** parameter is a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface, **cf** is the clipboard format that identifies the desired data, and **pdwOut** is used to return the data value.</span></span>


```C++
STDAPI DataObj_GetDWORD(IDataObject *pdtobj, UINT cf, DWORD *pdwOut)
{    STGMEDIUM medium;
   FORMATETC fmte = {(CLIPFORMAT) cf, NULL, DVASPECT_CONTENT, -1, 
       TYMED_HGLOBAL};
    HRESULT hres = pdtobj->GetData(&fmte, &medium);
    if (SUCCEEDED(hres))
   {
       DWORD *pdw = (DWORD *)GlobalLock(medium.hGlobal);
       if (pdw)
       {
           *pdwOut = *pdw;
           GlobalUnlock(medium.hGlobal);
       }
       else
       {
           hres = E_UNEXPECTED;
       }
       ReleaseStgMedium(&medium);
   }
   return hres;
}
```



### <a name="implementing-idroptarget"></a><span data-ttu-id="3c4fd-390">Реализация интерфейс IDropTarget</span><span class="sxs-lookup"><span data-stu-id="3c4fd-390">Implementing IDropTarget</span></span>

<span data-ttu-id="3c4fd-391">Система использует интерфейс [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) для связи с целевым объектом, пока курсор находится над целевым окном.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-391">The system uses the [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface to communicate with the target while the cursor is over the target window.</span></span> <span data-ttu-id="3c4fd-392">Ответы целевого объекта перенаправляются в источник через его интерфейс [**идропсаурце**](/windows/win32/api/oleidl/nn-oleidl-idropsource) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-392">The target's responses are forwarded to the source through its [**IDropSource**](/windows/win32/api/oleidl/nn-oleidl-idropsource) interface.</span></span> <span data-ttu-id="3c4fd-393">В зависимости от ответа источник может изменить значок, представляющий данные.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-393">Depending on the response, the source can modify the icon that represents the data.</span></span> <span data-ttu-id="3c4fd-394">Если цель перетаскивания должна указать значок данных, это можно сделать, создав [вспомогательный объект перетаскивания](#using-the-drag-and-drop-helper-object).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-394">If the drop target needs to specify the data icon, it can do so by creating a [drag-and-drop helper object](#using-the-drag-and-drop-helper-object).</span></span>

<span data-ttu-id="3c4fd-395">С помощью обычных операций перетаскивания целевой объект сообщает объекту данных о результате операции, устанавливая для параметра *Пдвеффект* [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) соответствующее значение [**дропеффект**](../com/dropeffect-constants.md) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-395">With conventional drag-and-drop operations, the target informs the data object of the outcome of the operation by setting the *pdwEffect* parameter of [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) to the appropriate [**DROPEFFECT**](../com/dropeffect-constants.md) value.</span></span> <span data-ttu-id="3c4fd-396">Для объектов данных оболочки целевому объекту может также потребоваться вызов интерфейса [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-396">With Shell data objects, the target might also need to call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata).</span></span> <span data-ttu-id="3c4fd-397">Обсуждение того, как целевые объекты должны отвечать на различные сценарии обмена данными, см. в разделе [Обработка сценариев передача данных оболочки](datascenarios.md).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-397">For a discussion of how targets should respond for different data transfer scenarios, see [Handling Shell Data Transfer Scenarios](datascenarios.md).</span></span>

<span data-ttu-id="3c4fd-398">В следующих разделах кратко описано, как реализовать методы [**интерфейс IDropTarget::D ражентер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter), [**интерфейс IDropTarget::D раговер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover)и [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-398">The following sections briefly discuss how to implement the [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter), [**IDropTarget::DragOver**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover), and [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) methods.</span></span> <span data-ttu-id="3c4fd-399">Дополнительные сведения см. в справочной документации.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-399">For further details, see the reference documentation.</span></span>

### <a name="dragenter-method"></a><span data-ttu-id="3c4fd-400">Метод DragEnter</span><span class="sxs-lookup"><span data-stu-id="3c4fd-400">DragEnter method</span></span>

<span data-ttu-id="3c4fd-401">Система вызывает метод [**интерфейс IDropTarget::D ражентер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) , когда курсор попадает в целевое окно.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-401">The system calls the [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) method when the cursor enters the target window.</span></span> <span data-ttu-id="3c4fd-402">Его параметры предоставляют целевому объекту расположение курсора, состояние клавиш с модификатором клавиатуры, например клавишу CTRL, и указатель на интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-402">Its parameters provide the target with the location of the cursor, the state of keyboard modifier keys such as the CTRL key, and a pointer to the data object's [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) interface.</span></span> <span data-ttu-id="3c4fd-403">Цель несет ответственность за использование этого интерфейса, чтобы определить, может ли он принимать любой из форматов, содержащихся в объекте данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-403">The target is responsible for using that interface to determine whether it can accept any of the formats contained by the data object.</span></span> <span data-ttu-id="3c4fd-404">Если это возможно, значение *пдвеффект* остается неизменным.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-404">If it can, it normally leaves the value of *pdwEffect* unchanged.</span></span> <span data-ttu-id="3c4fd-405">Если он не может принимать какие бы то ни было данные из объекта данных, он устанавливает для параметра *пдвеффект* значение дропеффект \_ None.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-405">If it cannot accept any data from the data object, it sets the *pdwEffect* parameter to DROPEFFECT\_NONE.</span></span> <span data-ttu-id="3c4fd-406">Система передает значение этого параметра интерфейсу [**идропсаурце**](/windows/win32/api/oleidl/nn-oleidl-idropsource) объекта данных, чтобы позволить ему отображать соответствующее изображение перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-406">The system passes the value of this parameter to the data object's [**IDropSource**](/windows/win32/api/oleidl/nn-oleidl-idropsource) interface to allow it to display the appropriate drag image.</span></span>

<span data-ttu-id="3c4fd-407">Целевые объекты не должны использовать метод [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) для отображения данных оболочки перед их удалением.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-407">Targets should not use the [**IDataObject::GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) method to render Shell data before it has been dropped.</span></span> <span data-ttu-id="3c4fd-408">Полная визуализация данных объекта для каждого такого экземпляра может привести к зависанию курсора перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-408">Fully rendering the object's data for each such occurrence might cause the drag cursor to stall.</span></span> <span data-ttu-id="3c4fd-409">Чтобы избежать этой проблемы, некоторые объекты оболочки содержат формат [кфстр \_ индраглуп](clipboard.md) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-409">To avoid this problem, some Shell objects contain a [CFSTR\_INDRAGLOOP](clipboard.md) format.</span></span> <span data-ttu-id="3c4fd-410">Извлекая этот формат, целевые объекты могут проверить состояние цикла перетаскивания и избежать интенсивного отображения данных объекта в памяти.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-410">By extracting this format, targets can check the status of the drag loop while avoiding memory intensive rendering of the object's data.</span></span> <span data-ttu-id="3c4fd-411">Значение данных формата — **DWORD** , для которого задано ненулевое значение, если объект данных находится в пределах цикла перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-411">The format's data value is a **DWORD** that is set to a nonzero value if the data object is within a drag loop.</span></span> <span data-ttu-id="3c4fd-412">Значение данных формата задается равным нулю, если данные были удалены.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-412">The format's data value is set to zero if the data has been dropped.</span></span>

<span data-ttu-id="3c4fd-413">Если целевой объект может принимать данные из объекта данных, необходимо проверить **грфкэйстате** , чтобы определить, были ли нажаты клавиши CTRL для изменения нормального поведения при перетаскивании.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-413">If the target can accept data from the data object, it should examine **grfKeyState** to determine whether any modifier keys have been pressed to modify the normal drop behavior.</span></span> <span data-ttu-id="3c4fd-414">Например, операция по умолчанию обычно является перемещением, но нажатие клавиши CTRL обычно означает операцию копирования.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-414">For instance, the default operation is typically a move, but depressing the CTRL key usually indicates a copy operation.</span></span>

<span data-ttu-id="3c4fd-415">Пока курсор находится над целевым окном, цель может использовать [вспомогательный объект перетаскивания](#using-the-drag-and-drop-helper-object) для замены изображения перетаскивания объекта данных своим собственным.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-415">While the cursor is over the target window, the target can use the [drag-and-drop helper object](#using-the-drag-and-drop-helper-object) to replace the data object's drag image with its own.</span></span> <span data-ttu-id="3c4fd-416">Если это так, [**интерфейс IDropTarget::D ражентер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) должен вызвать [**Идроптаржеселпер::D ражентер**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragenter) , чтобы передать сведения, содержащиеся в параметрах *DragEnter* , в вспомогательный объект перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-416">If so, [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter) should call [**IDropTargetHelper::DragEnter**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragenter) to pass the information contained in the *DragEnter* parameters to the drag-and-drop helper object.</span></span>

### <a name="dragover-method"></a><span data-ttu-id="3c4fd-417">Метод DragOver</span><span class="sxs-lookup"><span data-stu-id="3c4fd-417">DragOver method</span></span>

<span data-ttu-id="3c4fd-418">Когда курсор перемещается в целевое окно, система периодически вызывает метод [**интерфейс IDropTarget::D раговер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-418">As the cursor moves within the target window, the system periodically calls the [**IDropTarget::DragOver**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) method.</span></span> <span data-ttu-id="3c4fd-419">Его параметры предоставляют целевому объекту расположение курсора и состояние клавиш с модификатором клавиатуры, например клавишу CTRL.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-419">Its parameters provide the target with the location of the cursor and the state of keyboard modifier keys such as the CTRL key.</span></span> <span data-ttu-id="3c4fd-420">**Интерфейс IDropTarget::D раговер** имеет почти те же обязанности, что и [**интерфейс IDropTarget::D ражентер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter), и реализации обычно очень похожи.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-420">**IDropTarget::DragOver** has much the same responsibilities as [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter), and the implementations are usually very similar.</span></span>

<span data-ttu-id="3c4fd-421">Если цель использует вспомогательный объект перетаскивания, [**интерфейс IDropTarget::D раговер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) должен вызывать [**Идроптаржеселпер::D раговер**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover) для пересылки сведений, содержащихся в параметрах *DragOver* , в вспомогательный объект перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-421">If the target is using the drag-and-drop helper object, [**IDropTarget::DragOver**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragover) should call [**IDropTargetHelper::DragOver**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover) to forward the information contained in the *DragOver* parameters to the drag-and-drop helper object.</span></span>

### <a name="drop-method"></a><span data-ttu-id="3c4fd-422">Drop, метод</span><span class="sxs-lookup"><span data-stu-id="3c4fd-422">Drop method</span></span>

<span data-ttu-id="3c4fd-423">Система вызывает метод [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) , чтобы уведомить целевой объект о том, что пользователь удалил данные, обычно отпустив кнопку мыши.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-423">The system calls the [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) method to notify the target that the user has dropped the data, typically by releasing the mouse button.</span></span> <span data-ttu-id="3c4fd-424">**Интерфейс IDropTarget::D верхнем** имеет те же параметры, что и [**интерфейс IDropTarget::D ражентер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-424">**IDropTarget::Drop** has the same parameters as [**IDropTarget::DragEnter**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter).</span></span> <span data-ttu-id="3c4fd-425">Целевой объект обычно отвечает путем извлечения одного или нескольких форматов из объекта данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-425">The target normally responds by extracting one or more formats from the data object.</span></span> <span data-ttu-id="3c4fd-426">По завершении целевой объект должен присвоить параметру *пдвеффект* значение [**дропеффект**](../com/dropeffect-constants.md) , указывающее результат операции.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-426">When finished, the target should set the *pdwEffect* parameter to a [**DROPEFFECT**](../com/dropeffect-constants.md) value that indicates the outcome of the operation.</span></span> <span data-ttu-id="3c4fd-427">Для некоторых типов передачи данных оболочки целевой объект должен также вызывать метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) , чтобы передать формат с дополнительной информацией о результате операции в объект данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-427">For some types of Shell data transfer, the target must also call [**IDataObject::SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) to pass a format with additional information on the outcome of the operation to the data object.</span></span> <span data-ttu-id="3c4fd-428">Подробное обсуждение см. в разделе [Обработка сценариев передача данных оболочки](datascenarios.md).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-428">For a detailed discussion, see [Handling Shell Data Transfer Scenarios](datascenarios.md).</span></span>

<span data-ttu-id="3c4fd-429">Если цель использует вспомогательный объект для перетаскивания, [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) должен вызывать [**идроптаржеселпер::D верхнем**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-drop) для пересылки сведений, содержащихся в параметрах идроптаржеселпер [**::D раговер**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover) , в вспомогательный объект перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-429">If the target is using the drag-and-drop helper object, [**IDropTarget::Drop**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) should call [**IDropTargetHelper::Drop**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-drop) to forward the information contained in the [**IDropTargetHelper::DragOver**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover) parameters to the drag-and-drop helper object.</span></span>

## <a name="using-the-drag-and-drop-helper-object"></a><span data-ttu-id="3c4fd-430">Использование вспомогательного объекта перетаскивания</span><span class="sxs-lookup"><span data-stu-id="3c4fd-430">Using the Drag-and-Drop Helper Object</span></span>

<span data-ttu-id="3c4fd-431">Вспомогательный объект перетаскивания (CLSID \_ DragDropHelper) экспортируется оболочкой, чтобы разрешить целевым объектам указывать изображение перетаскивания, пока оно находится над целевым окном.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-431">The drag-and-drop helper object (CLSID\_DragDropHelper) is exported by the Shell to allow targets to specify the drag image while it is over the target window.</span></span> <span data-ttu-id="3c4fd-432">Чтобы использовать вспомогательный объект для перетаскивания, создайте объект внутрипроцессного сервера, вызвав [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) с идентификатором класса (CLSID) CLSID \_ DragDropHelper.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-432">To use the drag-and-drop helper object, create an in-process server object by calling [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) with a class identifier (CLSID) of CLSID\_DragDropHelper.</span></span> <span data-ttu-id="3c4fd-433">Вспомогательный объект перетаскивания предоставляет два интерфейса, которые используются следующим образом:</span><span class="sxs-lookup"><span data-stu-id="3c4fd-433">The drag-and-drop helper object exposes two interfaces that are used in the following way:</span></span>

-   <span data-ttu-id="3c4fd-434">Интерфейс [**идрагсаурцехелпер**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idragsourcehelper) позволяет цели перетаскивания указать значок, который будет представлять объект данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-434">The [**IDragSourceHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idragsourcehelper) interface allows the drop target to specify an icon to represent the data object.</span></span>
-   <span data-ttu-id="3c4fd-435">Интерфейс [**идроптаржеселпер**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) позволяет цели перетаскивания уведомлять объект вспомогательной операции перетаскивания к положению курсора, а также отображать или скрывать значок данных.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-435">The [**IDropTargetHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) interface allows the drop target to inform the drag-and-drop helper object of the cursor location, and to show or hide the data icon.</span></span>

### <a name="using-the-idragsourcehelper-interface"></a><span data-ttu-id="3c4fd-436">Использование интерфейса Идрагсаурцехелпер</span><span class="sxs-lookup"><span data-stu-id="3c4fd-436">Using the IDragSourceHelper Interface</span></span>

<span data-ttu-id="3c4fd-437">Интерфейс [**идрагсаурцехелпер**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idragsourcehelper) предоставляется вспомогательным объектом перетаскивания, чтобы предоставить целевому объекту перетаскивания изображение, которое будет отображаться, пока курсор находится над целевым окном.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-437">The [**IDragSourceHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idragsourcehelper) interface is exposed by the drag-and-drop helper object to allow a drop target to provide the image that will be displayed while the cursor is over the target window.</span></span> <span data-ttu-id="3c4fd-438">**Идрагсаурцехелпер** предоставляет два альтернативных способа указания точечного рисунка для использования в качестве изображения перетаскивания:</span><span class="sxs-lookup"><span data-stu-id="3c4fd-438">**IDragSourceHelper** provides two alternative ways to specify the bitmap to be used as a drag image:</span></span>

-   <span data-ttu-id="3c4fd-439">Объекты перетаскивания, которые содержат окно, могут зарегистрировать \_ для него сообщение окна di жетдрагимаже, инициализируя вспомогательный объект перетаскивания с помощью [**идрагсаурцехелпер:: инитиализефромвиндов**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefromwindow).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-439">Drop targets that have a window can register a DI\_GETDRAGIMAGE window message for it by initializing the drag-and-drop helper object with [**IDragSourceHelper::InitializeFromWindow**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefromwindow).</span></span> <span data-ttu-id="3c4fd-440">Когда целевой объект получает сообщение DI \_ жетдрагимаже, обработчик помещает сведения об точечном рисунке изображения в структуру [**шдрагимаже**](/windows/desktop/api/Shobjidl_core/ns-shobjidl_core-shdragimage) , которая передается как значение *lParam* сообщения.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-440">When the target receives a DI\_GETDRAGIMAGE message, the handler puts the drag image bitmap information in the [**SHDRAGIMAGE**](/windows/desktop/api/Shobjidl_core/ns-shobjidl_core-shdragimage) structure that is passed as the message's *lParam* value.</span></span>
-   <span data-ttu-id="3c4fd-441">Цели перетаскивания без окон указывают точечный рисунок при инициализации вспомогательного объекта перетаскивания с помощью [**идрагсаурцехелпер:: инитиализефромбитмап**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefrombitmap).</span><span class="sxs-lookup"><span data-stu-id="3c4fd-441">Windowless drop targets specify a bitmap when they initialize the drag-and-drop helper object with [**IDragSourceHelper::InitializeFromBitmap**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idragsourcehelper-initializefrombitmap).</span></span>

### <a name="using-the-idroptargethelper-interface"></a><span data-ttu-id="3c4fd-442">Использование интерфейса Идроптаржеселпер</span><span class="sxs-lookup"><span data-stu-id="3c4fd-442">Using the IDropTargetHelper Interface</span></span>

<span data-ttu-id="3c4fd-443">Этот интерфейс позволяет целевому объекту перетаскивания уведомлять объект вспомогательной операции перетаскивания, когда курсор переходит или выходит из целевого объекта.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-443">This interface allows the drop target to notify the drag-and-drop helper object when the cursor enters or leaves the target.</span></span> <span data-ttu-id="3c4fd-444">Пока курсор находится над целевым окном, [**идроптаржеселпер**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) позволяет целевому объекту предоставить вспомогательной стороне перетаскивания сведения, получаемые целевым объектом через его интерфейс [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) .</span><span class="sxs-lookup"><span data-stu-id="3c4fd-444">While the cursor is over the target window, [**IDropTargetHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) allows the target to give the drag-and-drop helper object the information that the target receives through its [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) interface.</span></span>

<span data-ttu-id="3c4fd-445">Четыре метода [**идроптаржеселпер**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) —[**Идроптаржеселпер::D ражентер**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragenter), [**идроптаржеселпер::D Раглеаве**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragleave), [**идроптаржеселпер::D ragover**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover)и [**IDropTargetHelper::D верхнем**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-drop)— связаны с методом [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) с тем же именем.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-445">Four of the [**IDropTargetHelper**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-idroptargethelper) methods—[**IDropTargetHelper::DragEnter**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragenter), [**IDropTargetHelper::DragLeave**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragleave), [**IDropTargetHelper::DragOver**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-dragover), and [**IDropTargetHelper::Drop**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-drop)—are associated with the [**IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) method of the same name.</span></span> <span data-ttu-id="3c4fd-446">Чтобы использовать вспомогательный объект для перетаскивания, каждый из методов **интерфейс IDropTarget** должен вызывать соответствующий метод **идроптаржеселпер** для пересылки информации в вспомогательный объект перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-446">To use the drag-and-drop helper object, each of the **IDropTarget** methods should call the corresponding **IDropTargetHelper** method to forward the information to the drag-and-drop helper object.</span></span> <span data-ttu-id="3c4fd-447">Пятый метод **идроптаржеселпер** , [**Идроптаржеселпер:: Показать**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-show), уведомляет вспомогательный объект перетаскивания, чтобы показать или скрыть изображение перетаскивания.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-447">The fifth **IDropTargetHelper** method, [**IDropTargetHelper::Show**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-idroptargethelper-show), notifies the drag-and-drop helper object to show or hide the drag image.</span></span> <span data-ttu-id="3c4fd-448">Этот метод используется при перетаскивании на целевое окно в режиме низкого цветового изображения с глубиной цвета.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-448">This method is used when dragging over a target window in a low color-depth video mode.</span></span> <span data-ttu-id="3c4fd-449">Она позволяет целевому объекту скрывать изображение перетаскивания во время рисования окна.</span><span class="sxs-lookup"><span data-stu-id="3c4fd-449">It allows the target to hide the drag image while it is painting the window.</span></span>

 

 
