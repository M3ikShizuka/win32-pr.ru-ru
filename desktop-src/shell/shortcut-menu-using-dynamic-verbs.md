---
description: Обработчики контекстного меню также известны как обработчики контекстного меню или обработчики команд. Обработчик контекстного меню — это тип обработчика типа файлов.
ms.assetid: 7FC65C6F-3798-404c-B359-2BC75D3F54E7
title: Настройка контекстного меню с помощью динамических команд
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2b33361be5a89480e05bb42bd760b63517bf0b06c9828cae36a36ecddce1e9cc
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118968313"
---
# <a name="customizing-a-shortcut-menu-using-dynamic-verbs"></a>Настройка контекстного меню с помощью динамических команд

Обработчики контекстного меню также известны как обработчики контекстного меню или обработчики команд. Обработчик контекстного меню — это тип обработчика типа файлов.

Этот раздел организован следующим образом:

-   [О статических и динамических командах](#about-static-and-dynamic-verbs)
-   [Работа обработчиков контекстного меню с динамическими командами](#how-shortcut-menu-handlers-work-with-dynamic-verbs)
-   [Предотвращение конфликтов из-за неуточненных имен команд](#avoiding-collisions-due-to-unqualified-verb-names)
-   [Регистрация обработчика контекстного меню с динамической командой](#registering-a-shortcut-menu-handler-with-a-dynamic-verb)
-   [Реализация интерфейса IContextMenu](#implementing-the-icontextmenu-interface)
    -   [Метод IContextMenu:: Жеткоммандстринг](#icontextmenugetcommandstring-method)
    -   [Метод IContextMenu:: Инвокекомманд](#icontextmenuinvokecommand-method)
    -   [Метод IContextMenu:: Куериконтекстмену](#icontextmenuquerycontextmenu-method)
-   [Связанные темы](#related-topics)

## <a name="about-static-and-dynamic-verbs"></a>О статических и динамических командах

Мы настоятельно рекомендуем реализовать контекстное меню с помощью одного из статических методов глагола. Рекомендуется следовать инструкциям, приведенным в разделе "Настройка контекстного меню с помощью статических глаголов" раздела [Создание обработчиков контекстного меню](context-menu-handlers.md). чтобы получить динамическое поведение для статических глаголов в Windows 7 и более поздних версий, см. раздел «получение динамического поведения для статических глаголов» раздела [создание обработчиков контекстного меню](context-menu-handlers.md). Дополнительные сведения о реализации статических команд и о том, какие динамические команды следует избегать, см. в разделе [Выбор статической или динамической команды для контекстного меню](shortcut-choose-method.md).

Если необходимо расширить контекстное меню для типа файла, зарегистрировав динамическую команду для типа файла, следуйте инструкциям, приведенным далее в этом разделе.

> [!Note]  
> при регистрации обработчиков, работающих в контексте 32-разрядных приложений, существуют специальные рекомендации по 64-разрядным Windows: при вызове команд оболочки в контексте 32-разрядного приложения подсистема WOW64 перенаправляет доступ файловой системы к некоторым путям. Если обработчик .exe хранится в одном из этих путей, он недоступен в этом контексте. Поэтому в качестве решения сохраните .exe в пути, который не перенаправлен, или сохраните версию заглушки .exe, которая запускает реальную версию.

 

## <a name="how-shortcut-menu-handlers-work-with-dynamic-verbs"></a>Работа обработчиков контекстного меню с динамическими командами

Помимо [**IUnknown**](/windows/win32/api/unknwn/nn-unknwn-iunknown), обработчики контекстного меню экспортируют следующие дополнительные интерфейсы для обработки обмена сообщениями, необходимого для реализации элементов меню, рисуемых владельцем.

-   [**Ишеллекстинит**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellextinit) (обязательный)
-   [**IContextMenu**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-icontextmenu) (обязательный)
-   [**IContextMenu2**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu2) (необязательно)
-   [**IContextMenu3**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-icontextmenu3) (необязательно)

Дополнительные сведения об элементах меню, рисуемых владельцем, см. в разделе *создание Owner-Drawn пунктов меню* раздела [Использование меню](../menurc/using-menus.md).

Оболочка использует интерфейс [**ишеллекстинит**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-ishellextinit) для инициализации обработчика. Когда оболочка вызывает [**ишеллекстинит:: Initialize**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellextinit-initialize), она передает объект данных с именем объекта и указателем на список идентификаторов элементов (Пидл) папки, содержащей файл. Параметр *хкэйпрогид* — это расположение реестра, в котором зарегистрирован маркер контекстного меню. Метод **ишеллекстинит:: Initialize** должен извлечь имя файла из объекта данных и сохранить имя и указатель папки в списке идентификаторов элементов (Пидл) для последующего использования. Дополнительные сведения об инициализации обработчика см. в разделе [Реализация ишеллекстинит](handlers.md).

Когда глаголы представлены в контекстном меню, они сначала обнаруживаются, затем представляются пользователю, и, наконец, вызываются. В следующем списке приведено более подробное описание этих трех шагов.

1.  Оболочка вызывает метод [**IContextMenu:: куериконтекстмену**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-querycontextmenu), возвращающий набор команд, которые могут основываться на состоянии элементов или системы.
2.  Система передает в **HMENUный** обработчик, который метод может использовать для добавления элементов в контекстное меню.
3.  Если пользователь щелкает один из элементов обработчика, оболочка вызывает [**IContextMenu:: инвокекомманд**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-invokecommand). Затем обработчик может выполнить соответствующую команду.

## <a name="avoiding-collisions-due-to-unqualified-verb-names"></a>Предотвращение конфликтов из-за неуточненных имен команд

Так как глаголы зарегистрированы для каждого типа, одно и то же имя команды можно использовать для глаголов в различных элементах. Это позволяет приложениям ссылаться на общие глаголы независимо от типа элемента. Хотя эта функция полезна, использование неквалифицированных имен может привести к конфликтам с несколькими независимыми поставщиками программного обеспечения (ISV), которые выбирают одно и то же имя команды. Чтобы избежать этого, всегда добавляйте перед глаголами имя ISV следующим образом:

`ISV_Name.verb`

Всегда используйте идентификатор ProgID, зависящий от приложения. Применение соглашения о сопоставлении расширения имени файла с ProgID, предоставленным поставщиком программного обеспечения, позволяет избежать возможных конфликтов. Однако, поскольку некоторые типы элементов не используют это сопоставление, существует потребность в уникальных именах поставщиков. При добавлении команды к существующему идентификатору ProgID, который может уже зарегистрировать эту команду, необходимо сначала удалить раздел реестра для старой команды перед добавлением собственной команды. Это необходимо сделать, чтобы избежать объединения сведений о командах из двух глаголов. Несоблюдение этого действия приводит к непредсказуемому поведению.

## <a name="registering-a-shortcut-menu-handler-with-a-dynamic-verb"></a>Регистрация обработчика контекстного меню с динамической командой

Обработчики контекстного меню связаны либо с типом файла, либо с папкой. Для типов файлов обработчик регистрируется в следующем подразделе.

```
HKEY_CLASSES_ROOT
   Program ID
      shellex
         ContextMenuHandlers
```

Чтобы связать обработчик контекстного меню с типом файла или папкой, сначала создайте подраздел в подразделе **контекстменухандлерс** . Назовите подраздел для обработчика и задайте в качестве значения по умолчанию для подраздела строковое значение GUID идентификатора класса обработчика (CLSID).

Затем, чтобы связать обработчик контекстного меню с разными типами папок, зарегистрируйте обработчик таким же образом, как для типа файлов, но в подразделе *фолдертипе* , как показано в следующем примере.

```
HKEY_CLASSES_ROOT
   FolderType
      shellex
         ContextMenuHandlers
```

Дополнительные сведения о типах папок, для которых можно зарегистрировать обработчики, см. в разделе [Регистрация обработчиков расширений оболочки](handlers.md).

Если с типом файла связано контекстное меню, то при двойном щелчке объекта обычно запускается команда по умолчанию, а метод [**IContextMenu:: куериконтекстмену**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-querycontextmenu) обработчика не вызывается. Чтобы указать, что метод **IContextMenu:: куериконтекстмену** обработчика должен вызываться при двойном щелчке объекта, создайте подраздел в подразделе **CLSID** обработчика, как показано ниже.

```
HKEY_CLASSES_ROOT
   CLSID
      {00000000-1111-2222-3333-444444444444}
         shellex
            MayChangeDefaultMenu
```

При двойном щелчке объекта, связанного с обработчиком, вызывается [**IContextMenu:: куериконтекстмену**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-querycontextmenu) с флагом **КМФ \_ дефаултонли** , установленным в параметре *уфлагс* .

Обработчики контекстного меню должны задавать подраздел **майчанжедефаултмену** только в том случае, если им может потребоваться изменить команду по умолчанию в контекстном меню. Установка этого подраздела заставляет систему загружать DLL-библиотеку обработчика при двойном щелчке связанного элемента. Если обработчик не изменяет команду по умолчанию, этот подраздел задавать не следует, так как это приводит к тому, что система загружает библиотеку DLL без необходимости.

В следующем примере показаны записи реестра, которые включают обработчик контекстного меню для типа файла МИП. Подраздел **CLSID** обработчика включает подраздел **майчанжедефаултмену** , гарантирующий, что обработчик вызывается, когда пользователь дважды щелкает связанный объект.

```
HKEY_CLASSES_ROOT
   .myp
      (Default) = MyProgram.1
   CLSID
      {00000000-1111-2222-3333-444444444444}
         InProcServer32
            (Default) = C:\MyDir\MyCommand.dll
            ThreadingModel = Apartment
         shellex
            MayChangeDefaultMenu
   MyProgram.1
      (Default) = MyProgram Application
      shellex
         ContextMenuHandler
            MyCommand = {00000000-1111-2222-3333-444444444444}
```

## <a name="implementing-the-icontextmenu-interface"></a>Реализация интерфейса IContextMenu

[**IContextMenu**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-icontextmenu) является самым мощным, но и самым сложным методом для реализации. Настоятельно рекомендуется реализовать команду с помощью одного из статических методов глагола. Дополнительные сведения см. в разделе [Выбор статической или динамической команды для контекстного меню](shortcut-choose-method.md). [**IContextMenu**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-icontextmenu) содержит три метода: **жеткоммандстринг**, **инвокекомманд** и **куериконтекстмену**, которые подробно обсуждаются.

### <a name="icontextmenugetcommandstring-method"></a>Метод IContextMenu:: Жеткоммандстринг

Метод [**IContextMenu:: жеткоммандстринг**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-getcommandstring) обработчика используется для возврата канонического имени для команды. Этот метод является необязательным. в Windows XP и более ранних версиях Windows, если в обозревателе Windows есть строка состояния, этот метод используется для получения текста справки, который отображается в строке состояния для пункта меню.

Параметр *идкмд* содержит смещение идентификатора команды, которая была определена при вызове [**IContextMenu:: куериконтекстмену**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-querycontextmenu) . При запросе строки справки для *уфлагс* будет задано значение **GC \_ хелптекств**. Скопируйте строку справки в буфер *pszName* , приведя ее к **пвстр**. Строка команды запрашивается путем установки *уфлагс* в **GC \_ вербв**. Скопируйте соответствующую строку в *pszName*, точно так же, как и строку справки. Флаги валидатев **GC \_** и **GC \_** не используются обработчиками контекстного меню.

В следующем примере показана простая реализация [**IContextMenu:: жеткоммандстринг**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-getcommandstring) , которая соответствует примеру [**IContextMenu:: куериконтекстмену**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-querycontextmenu) , приведенному в разделе [метод IContextMenu:: куериконтекстмену](#icontextmenuquerycontextmenu-method) этой статьи. Поскольку обработчик добавляет только один пункт меню, можно вернуть только один набор строк. Метод проверяет, является ли *идкмд* допустимым, и, если это так, возвращает запрошенную строку.

Функция [**стрингкчкопи**](/windows/win32/api/strsafe/nf-strsafe-stringcchcopya) используется для копирования запрашиваемой строки в *pszName* , чтобы гарантировать, что копируемая строка не превысит размер буфера, указанного в *кчнаме*. в этом примере реализована поддержка только значений юникода для *уфлагс*, поскольку только они использовались в Windows Explorer с момента Windows 2000.


```C++
IFACEMETHODIMP CMenuExtension::GetCommandString(UINT idCommand, 
                                                UINT uFlags, 
                                                UINT *pReserved, 
                                                PSTR pszName, 
                                                UINT cchName)
{
    HRESULT hr = E_INVALIDARG;

    if (idCommand == IDM_DISPLAY)
    {
        switch (uFlags)
        {
            case GCS_HELPTEXTW:
                // Only useful for pre-Vista versions of Windows that 
                // have a Status bar.
                hr = StringCchCopyW(reinterpret_cast<PWSTR>(pszName), 
                                    cchName, 
                                    L"Display File Name");
                break; 

            case GCS_VERBW:
                // GCS_VERBW is an optional feature that enables a caller
                // to discover the canonical name for the verb passed in
                // through idCommand.
                hr = StringCchCopyW(reinterpret_cast<PWSTR>(pszName), 
                                    cchName, 
                                    L"DisplayFileName");
                break; 
        }
    }
    return hr;
}
```



### <a name="icontextmenuinvokecommand-method"></a>Метод IContextMenu:: Инвокекомманд

Этот метод вызывается, когда пользователь щелкает элемент меню, чтобы указать обработчику выполнить связанную команду. Параметр *пиЦи* указывает на структуру, содержащую необходимую информацию.

Хотя *пиЦи* объявляется в шлобж. h как структура [**кминвокекоммандинфо**](/windows/desktop/api/Shobjidl_core/ns-shobjidl_core-cminvokecommandinfo) , на практике он часто указывает на структуру [**кминвокекоммандинфоекс**](/windows/desktop/api/Shobjidl_core/ns-shobjidl_core-cminvokecommandinfoex) . Эта структура является расширенной версией **кминвокекоммандинфо** и содержит несколько дополнительных членов, которые позволяют передавать строки в Юникоде.

Проверьте член **кбсизе** объекта *пиЦи* , чтобы определить, какая структура была передана. Если это структура [**кминвокекоммандинфоекс**](/windows/desktop/api/Shobjidl_core/ns-shobjidl_core-cminvokecommandinfoex) , а у члена **фмаск** установлен флаг **\_ \_ Юникода Mask** , приведите *пиЦи* к **кминвокекоммандинфоекс**. Это позволяет приложению использовать сведения в Юникоде, содержащиеся в последних пяти элементах структуры.

Элемент **лпверб** или **лпвербв** структуры используется для задания выполняемой команды. Команды идентифицируются одним из следующих двух способов.

-   В строке команд команды
-   По смещению идентификатора команды

Чтобы отличить эти два варианта, проверьте, что в регистре Юникода или **лпвербв** используется слово высокого порядка **ЛПВЕРБ** для регистра ANSI. Если слово с высоким порядком не равно нулю, **лпверб** или **лпвербв** содержит строку команды. Если слово с высоким порядковым значением равно нулю, то смещение команды находится в слове **лпверб** нижнего порядка.

В следующем примере показана простая реализация [**IContextMenu:: инвокекомманд**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-invokecommand) , которая соответствует примерам [**IContextMenu:: куериконтекстмену**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-querycontextmenu) и [**IContextMenu:: жеткоммандстринг**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-getcommandstring) , заданным до и после этого раздела. Сначала метод определяет, какая структура передается. Затем он определяет, определена ли команда по смещению или ее команде. Если **лпверб** или **лпвербв** содержит допустимую глагол или смещение, метод отображает окно сообщения.


```C++
STDMETHODIMP CShellExtension::InvokeCommand(LPCMINVOKECOMMANDINFO lpcmi)
{
    BOOL fEx = FALSE;
    BOOL fUnicode = FALSE;

    if(lpcmi->cbSize == sizeof(CMINVOKECOMMANDINFOEX))
    {
        fEx = TRUE;
        if((lpcmi->fMask & CMIC_MASK_UNICODE))
        {
            fUnicode = TRUE;
        }
    }

    if( !fUnicode && HIWORD(lpcmi->lpVerb))
    {
        if(StrCmpIA(lpcmi->lpVerb, m_pszVerb))
        {
            return E_FAIL;
        }
    }

    else if( fUnicode && HIWORD(((CMINVOKECOMMANDINFOEX *) lpcmi)->lpVerbW))
    {
        if(StrCmpIW(((CMINVOKECOMMANDINFOEX *)lpcmi)->lpVerbW, m_pwszVerb))
        {
            return E_FAIL;
        }
    }

    else if(LOWORD(lpcmi->lpVerb) != IDM_DISPLAY)
    {
        return E_FAIL;
    }

    else
    {
        MessageBox(lpcmi->hwnd,
                   "The File Name",
                   "File Name",
                   MB_OK|MB_ICONINFORMATION);
    }

    return S_OK;
}
```



### <a name="icontextmenuquerycontextmenu-method"></a>Метод IContextMenu:: Куериконтекстмену

Оболочка вызывает [**IContextMenu:: куериконтекстмену**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-querycontextmenu) , чтобы обработчик контекстного меню добавим в меню соответствующие элементы меню. Он передает маркер **HMENU** в параметре *HMENU* . Для параметра *индексмену* задается индекс, используемый для первого добавляемого элемента меню.

Все элементы меню, добавленные обработчиком, должны иметь идентификаторы, попадающие в значения параметров *идкмдфирст* и *идкмдласт* . Как правило, первый идентификатор команды имеет значение *идкмдфирст*, что увеличивается на единицу (1) для каждой дополнительной команды. Такой подход позволяет избежать превышения *идкмдласт* и максимально увеличить количество доступных идентификаторов в случае, если оболочка вызывает более одного обработчика.

*Смещение команды* идентификатора элемента — это разница между идентификатором и значением в *идкмдфирст*. Сохраните смещение каждого элемента, добавляемого обработчиком, в контекстное меню, так как оболочка может использовать его для обнаружения элемента, если впоследствии вызывает [**IContextMenu:: жеткоммандстринг**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-getcommandstring) или [**IContextMenu:: инвокекомманд**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-invokecommand).

Необходимо также назначить [команду](launch.md) каждой добавляемой команде. Глагол — это строка, которую можно использовать вместо смещения для обнаружения команды при вызове [**IContextMenu:: инвокекомманд**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-invokecommand) . Он также используется такими функциями, как [**ShellExecuteEx**](/windows/desktop/api/Shellapi/nf-shellapi-shellexecuteexa) для выполнения команд контекстного меню.

Существует три флага, которые можно передать с помощью параметра *уфлагс* , относящегося к обработчикам контекстного меню. Они описаны в следующей таблице.



| Флаг             | Описание                                                                                                                                                                                                              |
|------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| КМФ \_ дефаултонли | Пользователь выбрал команду по умолчанию, обычно дважды щелкнув объект. [**IContextMenu:: куериконтекстмену**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-querycontextmenu) должен возвращать управление в оболочку без изменения меню. |
| КМФ \_ по умолчанию   | Ни один элемент в меню не должен быть элементом по умолчанию. Метод должен добавить в меню свои команды.                                                                                                                          |
| КМФ, \_ Обычная      | Контекстное меню будет отображаться в обычном режиме. Метод должен добавить в меню свои команды.                                                                                                                            |



 

Чтобы добавить пункты меню в список, используйте [**инсертмену**](/windows/win32/api/winuser/nf-winuser-insertmenua) или [**инсертменуитем**](/windows/win32/api/winuser/nf-winuser-insertmenuitema) . Затем возвращается значение **HRESULT** с уровнем серьезности " **\_ успешно**". В качестве значения кода задайте смещение самого крупного идентификатора команды, который был назначен, плюс один (1). Например, предположим, что *идкмдфирст* имеет значение 5, и в меню добавляются три элемента с идентификаторами команд 5, 7 и 8. Возвращаемое значение должно быть `MAKE_HRESULT(SEVERITY_SUCCESS, 0, 8 - 5 + 1)` .

В следующем примере показана простая реализация [**IContextMenu:: куериконтекстмену**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-querycontextmenu) , которая вставляет одну команду. Смещение идентификатора для команды равно \_ отображению IDM, для которого задано значение 0. Переменные **m \_ псзверб** и **m \_ пвсзверб** являются частными переменными, которые используются для хранения связанной с ними независимой от языка строки в форматах ANSI и Unicode.


```C++
#define IDM_DISPLAY 0

STDMETHODIMP CMenuExtension::QueryContextMenu(HMENU hMenu,
                                              UINT indexMenu,
                                              UINT idCmdFirst,
                                              UINT idCmdLast,
                                              UINT uFlags)
{
    HRESULT hr;
    
    if(!(CMF_DEFAULTONLY & uFlags))
    {
        InsertMenu(hMenu, 
                   indexMenu, 
                   MF_STRING | MF_BYPOSITION, 
                   idCmdFirst + IDM_DISPLAY, 
                   "&Display File Name");

    
        
        hr = StringCbCopyA(m_pszVerb, sizeof(m_pszVerb), "display");
        hr = StringCbCopyW(m_pwszVerb, sizeof(m_pwszVerb), L"display");

        return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(IDM_DISPLAY + 1));
    }

    return MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(0));
}
```



Сведения о других задачах реализации команд см. в разделе [Создание обработчиков контекстного меню](context-menu-handlers.md).

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Контекстное меню (контекст) и обработчики контекстного меню](context-menu.md)
</dt> <dt>

[Команды и сопоставления файлов](fa-verbs.md)
</dt> <dt>

[Выбор статической или динамической команды для контекстного меню](shortcut-choose-method.md)
</dt> <dt>

[Рекомендации по работе с обработчиками контекстного меню и несколькими командами выбора](verbs-best-practices.md)
</dt> <dt>

[Создание обработчиков контекстного меню](context-menu-handlers.md)
</dt> <dt>

[Справочник по контекстному меню](context-menu-reference.md)
</dt> </dl>

 

 
