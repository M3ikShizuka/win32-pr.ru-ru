---
description: Обработчики контекстного меню, также известные как обработчики контекстного меню или обработчиков команд, являются типом обработчика типов файлов. Как и все такие обработчики, они являются внутрипроцессный COM-объектами, реализованными в виде библиотек DLL.
ms.assetid: cff79cdc-8a01-4575-9af7-2a485c6a8e46
title: Создание обработчиков контекстного меню
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e3a6b6f812772b884e12c45a48bae8075d90df28fb3b60f895cfd4c4263be74c
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119715774"
---
# <a name="creating-shortcut-menu-handlers"></a>Создание обработчиков контекстного меню

Обработчики контекстного меню, также известные как обработчики контекстного меню или обработчиков команд, являются типом обработчика типов файлов. Эти обработчики могут быть импелментед, что приводит к их загрузке в собственном процессе или в обозревателе или других сторонних процессах. Следите за тем, чтобы создавать внутрипроцессный обработчики, так как они могут причинить вред процессу, который их загружает.

> [!Note]  
> существуют особые рекомендации по 64-разрядным версиям Windows при регистрации обработчиков, работающих в контексте 32-разрядных приложений: при вызове в контексте приложения с разной разрядностью подсистема WOW64 перенаправляет доступ файловой системы к некоторым путям. Если обработчик .exe хранится в одном из этих путей, он недоступен в этом контексте. Поэтому в качестве решения сохраните .exe в пути, который не перенаправлен, или сохраните версию заглушки .exe, которая запускает реальную версию.

Этот раздел организован следующим образом:

-   [Канонические команды](#canonical-verbs)
-   [Расширенные глаголы](#extended-verbs)
-   [Программный доступ только к командам](#programmaticaccessonly-verbs)
-   [Настройка контекстного меню с помощью статических команд](#customizing-a-shortcut-menu-using-static-verbs)
    -   [Активация обработчика с помощью интерфейса интерфейс IDropTarget](#activating-your-handler-using-the-idroptarget-interface)
    -   [Указание расположения и порядка статических глаголов](#specifying-the-position-and-order-of-static-verbs)
    -   [Размещение команд в верхней или нижней части меню](#positioning-verbs-at-the-top-or-bottom-of-the-menu)
    -   [Создание статических каскадных меню](#creating-static-cascading-menus)
    -   [Получение динамического поведения для статических команд с помощью расширенного синтаксиса запросов](#getting-dynamic-behavior-for-static-verbs-by-using-advanced-query-syntax)
    -   [не рекомендуется: связывание команд с командами Exchange платформа динамических данных](#deprecated-associating-verbs-with-dynamic-data-exchange-commands)
-   [Завершение задач реализации команд](#completing-verb-implementation-tasks)
    -   [Настройка контекстного меню для предопределенных объектов оболочки](#customizing-the-shortcut-menu-for-predefined-shell-objects)
    -   [Расширение нового подменю](#extending-a-new-submenu)
    -   [Подавление команд и управление видимостью](#suppressing-verbs-and-controlling-visibility)
    -   [Применение модели выбора глагола](#employing-the-verb-selection-model)
    -   [Использование атрибутов элементов](#using-item-attributes)
    -   [Реализация пользовательских команд для папок с помощью Desktop.ini](#implementing-custom-verbs-for-folders-through-desktopini)
-   [Связанные темы](#related-topics)

## <a name="canonical-verbs"></a>Канонические команды

Приложения обычно отвечают за предоставление локализованных отображаемых строк для глаголов, которые они определяют. Однако для обеспечения степени независимости от языка система определяет стандартный набор часто используемых глаголов, называемых каноническими глаголами. Каноническая команда никогда не отображается для пользователя и может использоваться с любым языком пользовательского интерфейса. Система использует каноническое имя для автоматического создания правильно локализованной отображаемой строки. Например, отображаемая строка команды открытия задается как **открытая** в системе на английском языке и как эквивалент немецкого в системе на немецком языке.


| Каноническая команда | Описание                                                          |
|----------------|----------------------------------------------------------------------|
| Открыть           | Открывает файл или папку.                                            |
| опеннев        | Открывает файл или папку в новом окне.                            |
| Печать          | Выводит файл.                                                     |
| принтто        | Разрешает пользователю печатать файл, перетаскивая его на объект принтера. |
| Анализ        | открывает Windows Explorer с выбранной папкой.                     |
| Свойства     | Открывает страницу свойств объекта.                                   |

> [!Note]  
> Команда **принтто** также является канонической, но никогда не отображается. Его включение позволяет пользователю распечатать файл, перетащив его в объект принтера.

Обработчики контекстного меню могут предоставлять собственные канонические команды через [**IContextMenu:: жеткоммандстринг**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-getcommandstring) с **GC \_ вербв** или **GC \_ verb**. Система будет использовать канонические команды в качестве второго параметра (*лпоператион*), переданного в [**ShellExecute**](/windows/desktop/api/Shellapi/nf-shellapi-shellexecutea), и является [**кминвокекоммандинфо**](/windows/desktop/api/Shobjidl_core/ns-shobjidl_core-cminvokecommandinfo). член **лпверб** , переданный в метод [**IContextMenu:: инвокекомманд**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-icontextmenu-invokecommand) .

## <a name="extended-verbs"></a>Расширенные глаголы

Когда пользователь щелкает правой кнопкой мыши объект, в контекстном меню отображаются команды по умолчанию. Может потребоваться добавить и поддерживать команды в некоторых контекстных меню, которые не отображаются в каждом из контекстных меню. Например, можно использовать команды, которые обычно не используются или предназначены для опытных пользователей. По этой причине можно также определить одну или несколько расширенных команд. Эти глаголы похожи на обычные глаголы, но отличаются от обычных глаголов способом их регистрации. Чтобы получить доступ к расширенным командам, пользователь должен щелкнуть объект правой кнопкой мыши и нажать клавишу SHIFT. Когда пользователь делает это, расширенные команды отображаются в дополнение к командам по умолчанию.

С помощью реестра можно определить одну или несколько расширенных команд. Связанные команды будут отображаться только в том случае, если пользователь щелкнет правой кнопкой мыши объект, а также нажмет клавишу SHIFT. Чтобы определить команду как расширенную, добавьте расширенное значение **reg \_ SZ** в подраздел команды. С этим значением не должно быть связано никаких данных.

## <a name="programmatic-access-only"></a>Только программный доступ

Эти команды никогда не отображаются в контекстном меню. Для доступа к ним можно использовать [**ShellExecuteEx**](/windows/desktop/api/Shellapi/nf-shellapi-shellexecuteexa) и указать поле **лпверб** параметра *пексеЦинфо* (объект [шеллексекутеинфо](/windows/win32/api/shellapi/ns-shellapi-shellexecuteinfoa) ). Чтобы определить команду как программный доступ, добавьте значение **reg \_ SZ** программатикакцессонли в подраздел команды. С этим значением не должно быть связано никаких данных.

С помощью реестра можно определить одну или несколько расширенных команд. Связанные команды будут отображаться только в том случае, если пользователь щелкнет правой кнопкой мыши объект, а также нажмет клавишу SHIFT. Чтобы определить команду как расширенную, добавьте расширенное значение **reg \_ SZ** в подраздел команды. С этим значением не должно быть связано никаких данных.

## <a name="customizing-a-shortcut-menu-using-static-verbs"></a>Настройка контекстного меню с помощью статических команд

После [выбора статической или динамической команды для контекстного меню](shortcut-choose-method.md) можно расширить контекстное меню для типа файла, зарегистрировав статическую команду для типа файла. Для этого добавьте подраздел **Shell** под подразделом для ProgID приложения, связанного с типом файла. При необходимости можно определить глагол по умолчанию для типа файла, сделав его значением по умолчанию для подраздела **Shell** .

Команда по умолчанию отображается в контекстном меню первой. Его назначение — предоставить оболочке команду, которую она может использовать при вызове функции [**ShellExecuteEx**](/windows/desktop/api/Shellapi/nf-shellapi-shellexecuteexa) , но команда не указана. Оболочка не обязательно выбирает команду по умолчанию, когда **ShellExecuteEx** используется таким образом.

Оболочка использует первую доступную команду в следующем порядке:

1.  Команда по умолчанию
2.  Первая команда в реестре, если указан порядок команд
3.  Команда **открытия**
4.  Команда **Open With**

Если ни одна из указанных команд не доступна, операция завершается ошибкой.

Создайте один подраздел для каждой команды, которую необходимо добавить в подраздел Shell. Для каждого из этих подразделов должно быть задано значение **reg \_ SZ** для отображаемой строки команды (локализованная строка). Для каждого подраздела команды создайте подраздел команды со значением по умолчанию, равным командной строке для активации элементов. Для канонических команд, таких как **Open** и **Print**, можно опустить отображаемую строку, так как система автоматически отображает правильно локализованную строку. Для неканонических глаголов, если не указана отображаемая строка, строка команды отображается.

В следующем примере реестра Обратите внимание на следующее:

-   Поскольку **доит** не является канонической командой, ей присваивается отображаемое имя, которое можно выбрать, нажав клавишу D.
-   Команда **принтто** не отображается в контекстном меню. Однако его включение в реестр позволяет пользователю печатать файлы путем их перетаскивания на значок принтера.
-   Для каждой команды отображается один подраздел. **%1** представляет имя файла и **%2** имя принтера.

```
HKEY_CLASSES_ROOT
   .myp-ms
      (Default) = MyProgram.1
      MyProgram.1
         (Default) = My Program Application
         Shell
            (Default) = doit
            doit
               (Default) = &Do It
               command
                  (Default) = c:\MyDir\MyProgram.exe /d "%1"
            open
               command
                  (Default) = c:\MyDir\MyProgram.exe /d "%1"
            print
               command
                  (Default) = c:\MyDir\MyProgram.exe /p "%1"
            printto
               command
                  (Default) = c:\MyDir\MyProgram.exe /p "%1" "%2"
```

На следующей схеме показано расширение контекстного меню в соответствии с приведенными выше записями реестра. Это контекстное **меню открыло**, **сделает его** и команды **печати** в своем меню, и **сделает его** в качестве глагола по умолчанию.

![снимок экрана контекстного меню выполнения команды по умолчанию](images/context-menu/context-doitdefaultverb.png)

### <a name="activating-your-handler-using-the-idroptarget-interface"></a>Активация обработчика с помощью интерфейса интерфейс IDropTarget

платформа динамических данных Exchange (DDE) является устаревшим. Вместо этого используйте [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) . **Интерфейс IDropTarget** является более надежным и обеспечивает лучшую поддержку активации, так как использует com-активацию обработчика. В случае выбора нескольких элементов **интерфейс IDropTarget** не зависит от ограничений размера буфера, находящихся как в DDE, так и в [**CreateProcess**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa). Кроме того, элементы передаются в приложение в виде объекта данных, который можно преобразовать в массив элементов с помощью функции [**шкреатешеллитемаррайфромдатаобжект**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromdataobject) . Это упрощается и не теряет сведения о пространстве имен, как это происходит при преобразовании элемента в путь для протоколов командной строки или DDE.

Дополнительные сведения о [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) и оболочке запросов для атрибутов сопоставления файлов см. в разделе [наблюдаемые типы и регистрация приложений](fa-perceivedtypes.md).

### <a name="specifying-the-position-and-order-of-static-verbs"></a>Указание расположения и порядка статических глаголов

Обычно команды упорядочиваются в контекстном меню в зависимости от того, как они перечислены. Сначала перечисление основано на порядке массива ассоциаций, а затем в порядке элементов в массиве ассоциаций, как определено в порядке сортировки реестра.

Команды можно упорядочить, указав значение по умолчанию для подраздела Shell для записи ассоциации. Это значение по умолчанию может включать один элемент, который будет отображаться в верхней части контекстного меню, или список элементов, разделенных пробелами или запятыми. В последнем случае первый элемент в списке является элементом по умолчанию, а остальные команды отображаются непосредственно под ним в указанном порядке.

Например, следующая запись реестра создает команды контекстного меню в следующем порядке:

1.  Отображение
2.  Приложения
3.  Personalization

```
HKEY_CLASSES_ROOT
   DesktopBackground
      Shell
         Display
         Gadgets
         Personalization
```

Аналогичным образом следующая запись реестра создает команды контекстного меню в следующем порядке:

1.  Personalization
2.  Приложения
3.  Отображение

```
HKEY_CLASSES_ROOT
   DesktopBackground
      Shell = "Personalization,Gadgets"
      Display
```

### <a name="positioning-verbs-at-the-top-or-bottom-of-the-menu"></a>Размещение команд в верхней или нижней части меню

Следующий атрибут реестра можно использовать для размещения команды в верхней или нижней части меню. Если существует несколько глаголов, указывающих этот атрибут, последний из них получает приоритет:

``` syntax
Position=Top | Bottom 
```

### <a name="creating-static-cascading-menus"></a>Создание статических каскадных меню

в Windows 7 и более поздних версиях реализация каскадного меню поддерживается с помощью параметров реестра. до Windows 7 создание каскадных меню возможно только с помощью реализации интерфейса [**IContextMenu**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-icontextmenu) . в Windows 7 и более поздних версиях следует прибегать к решениям на основе кода COM только в том случае, если статические методы недостаточны.

На следующем снимке экрана приведен пример каскадного меню.

![снимок экрана, демонстрирующий Пример каскадного меню](images/file-assoc/filecascademenu2ndex.png)

в Windows 7 и более поздних версиях существует три способа создания каскадных меню:

-   [Создание каскадных меню с записью реестра "подкоманды"](#creating-cascading-menus-with-the-subcommands-registry-entry)
-   [Создание каскадных меню с помощью записи реестра Екстендедсубкоммандскэй](#creating-cascading-menus-with-the-extendedsubcommandskey-registry-entry)
-   [Создание каскадных меню с помощью интерфейса Иексплореркомманд](#creating-cascading-menus-with-the-iexplorercommand-interface)

### <a name="creating-cascading-menus-with-the-subcommands-registry-entry"></a>Создание каскадных меню с записью реестра "подкоманды"

в Windows 7 и более поздних версиях можно использовать запись подкоманд для создания каскадных меню с помощью следующей процедуры.

**Создание каскадного меню с помощью записи подкоманд**

1.  Создайте подраздел в разделе **\_ Classes \_ root** \\ *ProgID* \\ **Shell** , чтобы представить свое каскадное меню. В этом примере мы присваиваем этому подразделу имя *каскадетест*. Убедитесь, что значение по умолчанию для подраздела *каскадетест* пусто и отображается как **(значение не задано)**.

    ```
    HKEY_CLASSES_ROOT
       *
          shell
             CascadeTest
                (Default)
    ```

2.  В подраздел *каскадетест* добавьте запись Муиверб типа **reg \_ SZ** и назначьте ей текст, который будет отображаться в контекстном меню как имя. В этом примере мы присваиваем его «тестировать каскадное меню».

    ```
    HKEY_CLASSES_ROOT
       *
          shell
             CascadeTest
                (Default)
                MUIVerb = Test Cascade Menu
    ```

3.  В подраздел *каскадетест* добавьте запись подкоманд с типом **reg \_ SZ** , назначенный List, демлимитед с точкой с запятой, для команд, которые должны отображаться в меню в порядке их отображения. Например, здесь мы присваиваем ряд команд, предоставляемых системой:

    ```
    HKEY_CLASSES_ROOT
       *
          Shell
             CascadeTest
                SubCommands
                Windows.delete;Windows.properties;Windows.rename;Windows.cut;Windows.copy;Windows.paste
    ```

4.  В случае с пользовательскими командами реализуйте их с помощью любого из методов реализации статических команд и перечислите их в подразделе **коммандсторе** , как показано в этом примере для вымышленной глагола *вербнаме*:

    ```
    HKEY_LOCAL_MACHINE
       Software
          Microsoft
             Windows
                CurrentVersion
                   Explorer
                      CommandStore
                         Shell
                            VerbName
                            command
                               (Default) = notepad.exe %1
    ```

> [!Note]  
> Этот метод имеет преимущество, что пользовательские команды могут быть зарегистрированы один раз и повторно использоваться путем перечисления имени команды в записи подкоманд. Однако для этого требуется, чтобы приложение имело разрешение на изменение реестра на **\_ локальном \_ компьютере** в разделе hKey.

 

### <a name="creating-cascading-menus-with-the-extendedsubcommandskey-registry-entry"></a>Создание каскадных меню с помощью записи реестра Екстендедсубкоммандскэй

в Windows 7 и более поздних версиях можно использовать запись екстендедсубкоммандкэй для создания расширенных каскадных меню: каскадные меню в каскадных меню.

На следующем снимке экрана показан пример расширенного каскадного меню.

![снимок экрана с расширенным каскадным меню для устройств](images/file-assoc/extendedsubcommandskey.png)

Поскольку **\_ \_ корневой класс hKey classes** является сочетанием **\_ текущего \_ пользователя hKey** и раздела **hKey \_ \_**, можно зарегистрировать любые пользовательские команды в подразделе "классы" программного обеспечения **\_ текущего \_ пользователя "hKey** \\  \\  . Основное преимущество этого подхода в том, что повышенное разрешение не требуется. Кроме того, другие сопоставления файлов могут повторно использовать этот полный набор команд, указав тот же подраздел Екстендедсубкоммандскэй. Если не требуется повторно использовать этот набор команд, можно вывести список команд в родительском объекте, но убедитесь, что значение по умолчанию родительского элемента пустое.

**Создание каскадного меню с помощью записи Екстендедсубкоммандскэй**

1.  Создайте подраздел в разделе **\_ Classes \_ root** \\ *ProgID* \\ **Shell** , чтобы представить свое каскадное меню. В этом примере мы присваиваем этому подразделу имя *CascadeTest2*. Убедитесь, что значение по умолчанию для подраздела *каскадетест* пусто и отображается как **(значение не задано)**.

    ```
    HKEY_CLASSES_ROOT
       *
          shell
             CascadeTest2
                (Default)
    ```

2.  В подраздел *каскадетест* добавьте запись Муиверб типа **reg \_ SZ** и назначьте ей текст, который будет отображаться в контекстном меню как имя. В этом примере мы присваиваем его «тестировать каскадное меню».

    ```
    HKEY_CLASSES_ROOT
       *
          shell
             CascadeTest
                (Default)
                MUIVerb = Test Cascade Menu 2
    ```

3.  В созданном вами подразделе *каскадетест* добавьте подраздел **екстендедсубкоммандскэй** , а затем добавьте подкоманды документа (типа **reg \_ SZ** ), например:

    ```
    HKEY_CLASSES_ROOT
       txtfile
          Shell
             Test Cascade Menu 2
                (Default)
                ExtendedSubCommandsKey
                   Layout
                   Properties
                   Select all
    ```

    Убедитесь, что значение по умолчанию для подраздела *тест Cascade меню 2* пусто и отображается как **(значение не задано)**.

4.  Заполните подкоманды с помощью любой из следующих статических реализаций глаголов. Обратите внимание, что подраздел Коммандфлагс представляет значения ЕКСПКМДФЛАГС. Если вы хотите добавить разделитель до или после пункта меню Cascade, используйте ЕКФ \_ сепараторбефоре (0x20) или ЕКФ \_ сепараторафтер (0x40). описание этих флагов Windows 7 и более поздних версий см. в разделе [**иексплореркомманд::-flags**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iexplorercommand-getflags). ЕКФ \_ сепараторбефоре работает только для пунктов меню верхнего уровня. Муиверб имеет тип **reg \_ SZ**, а Коммандфлагс имеет тип **reg \_ DWORD**.

    ```
    HKEY_CLASSES_ROOT
       txtile
          Shell
             Test Cascade Menu 2
                (Default)
                ExtendedSubCommandsKey
                   Shell
                      cmd1
                         MUIVerb = Notepad
                         command
                            (Default) = %SystemRoot%\system32\notepad.exe %1
                      cmd2
                         MUIVerb = Wordpad
                         CommandFlags = 0x20
                         command
                            (Default) = "C:\Program Files\Windows NT\Accessories\wordpad.exe" %1
    ```

На следующем снимке экрана показан пример записи предыдущего раздела реестра.

![снимок экрана, показывающий пример каскадного меню, в котором отображаются параметры блокнота и WordPad](images/file-assoc/testcascademenu2.png)

### <a name="creating-cascading-menus-with-the-iexplorercommand-interface"></a>Создание каскадных меню с помощью интерфейса Иексплореркомманд

Другим вариантом добавления команд в каскадное меню является [**иексплореркомманд:: енумсубкоммандс**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-iexplorercommand-enumsubcommands). Этот метод позволяет источникам данных, которые предоставляют команды командного модуля через [**иексплореркоммандпровидер**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-iexplorercommandprovider) , использовать эти команды в качестве команд в контекстном меню. в Windows 7 и более поздних версиях можно предоставить ту же реализацию команд с помощью [**иексплореркомманд**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-iexplorercommand) , что и в случае с [**IContextMenu**](/windows/win32/api/shobjidl_core/nn-shobjidl_core-icontextmenu).

Следующие два снимка экрана иллюстрируют использование каскадных меню в папке **Devices** .

![Снимок экрана, на котором показан пример каскадного меню в папке Devices.](images/file-assoc/filecascademenu.png)

На следующем снимке экрана показана другая реализация каскадного меню в папке **Devices** .

![снимок экрана, показывающий пример каскадного меню в папке "устройства"](images/file-assoc/cascadedevices2.png)

> [!Note]  
> Так как [**иексплореркомманд**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-iexplorercommand) поддерживает только внутрипроцессный активацию, рекомендуется использовать их в качестве источников данных оболочки, которые должны совместно использовать реализацию команд и контекстных меню.

 

### <a name="getting-dynamic-behavior-for-static-verbs-by-using-advanced-query-syntax"></a>Получение динамического поведения для статических команд с помощью расширенного синтаксиса запросов

Расширенный синтаксис запросов (АКС) может выразить условие, которое будет оцениваться с помощью свойств элемента, для которого создается экземпляр команды. Эта система работает только с быстрыми свойствами. Это свойства, которые источник данных оболочки сообщает быстро, не возвращая [* * * * школстате \_ медленный * *](/windows/win32/api/shtypes/ne-shtypes-shcolstate) * * из [**IShellFolder2:: жетдефаултколумнстате**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder2-getdefaultcolumnstate).

Windows 7 и более поздних версий поддерживают канонические значения, которые позволят избежать проблем в локализованных сборках. следующий канонический синтаксис необходим для локализованных сборок, чтобы воспользоваться преимуществами этого расширения Windows 7.

``` syntax
System.StructuredQueryType.Boolean#True
```

В следующем примере запись реестра:

-   Значение **appliesTo** определяет, отображается ли глагол или скрыт.
-   Значение Дефаултапплиесто определяет, какая команда является значением по умолчанию.
-   Значение Хаслуашиелд определяет, отображается ли экранирование контроля учетных записей (UAC).

В этом примере значение **дефаултапплиесто** делает эту команду по умолчанию для любого файла с словом "exampleText1" в имени файла. Значение **appliesTo** позволяет команде для любого файла с именем "exampleText1" в имени. Значение **хаслуашиелд** отображает экранирование для файлов с именем "exampleText2" в имени.

```
HKEY_CLASSES_ROOT
   txtile
      shell
         test.verb
            DefaultAppliesTo = System.ItemName:"exampleText1"
            HasLUAShield = System.ItemName:"exampleText2"
            AppliesTo = System.ItemName:"exampleText1"
```

Добавьте подраздел **Command** и значение:

```
HKEY_CLASSES_ROOT
   txtile
      shell
         test.verb
            Command
               (Default) = %SystemRoot%\system32\notepad.exe %1
```

в реестре Windows 7 ознакомьтесь с разделом **\_ \_ корневые диски классов HKEY** в \\  качестве примера команд bitlocker, использующих следующий подход:

-   AppliesTo = System. Volume. Битлоккерпротектион: = 2
-   System. Volume. Битлоккеррекуиресадмин: = System. Структуредкуеритипе. Boolean \# true

Дополнительные сведения о АКС см. в разделе [Расширенный синтаксис запросов](../search/-search-3x-advancedquerysyntax.md).

### <a name="deprecated-associating-verbs-with-dynamic-data-exchange-commands"></a>не рекомендуется: связывание команд с командами Exchange платформа динамических данных

DDE устарело; Вместо этого используйте [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) . Протокол DDE является устаревшим, так как он использует широковещательное сообщение окна для обнаружения сервера DDE. Зависание сервера DDE приводит к зависанию окна вещания и, следовательно, зависания диалога DDE для других приложений. Обычно для одного задержанного приложения возникает необходимость в последующем зависании в работе пользователя.

Метод [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) является более надежным и обеспечивает лучшую поддержку активации, поскольку он использует com-активацию обработчика. В случае выбора нескольких элементов **интерфейс IDropTarget** не зависит от ограничений размера буфера, находящихся как в DDE, так и в [**CreateProcess**](/windows/win32/api/processthreadsapi/nf-processthreadsapi-createprocessa). Кроме того, элементы передаются в приложение в виде объекта данных, который можно преобразовать в массив элементов с помощью функции [**шкреатешеллитемаррайфромдатаобжект**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromdataobject) . Это упрощается и не теряет сведения о пространстве имен, как это происходит при преобразовании элемента в путь для протоколов командной строки или DDE.

Дополнительные сведения о [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) и оболочке запросов для атрибутов сопоставления файлов см. в разделе [наблюдаемые типы и регистрация приложений](fa-perceivedtypes.md).

## <a name="completing-verb-implementation-tasks"></a>Завершение задач реализации команд

Следующие задачи для реализации команд относятся к реализации статических и динамических команд. Дополнительные сведения о динамических командах см. в разделе [Настройка контекстного меню с помощью динамических команд](shortcut-menu-using-dynamic-verbs.md).

### <a name="customizing-the-shortcut-menu-for-predefined-shell-objects"></a>Настройка контекстного меню для предопределенных объектов оболочки

У многих предопределенных объектов оболочки есть контекстные меню, которые можно настроить. Зарегистрируйте команду практически так же, как при регистрации типов файлов, но используйте имя предопределенного объекта в качестве имени типа файла.

Список предопределенных объектов находится в разделе *предопределенных объектов оболочки* , посвященном [созданию обработчиков расширений оболочки](handlers.md). Эти предопределенные объекты оболочки, контекстные меню которых можно настроить путем добавления команд в реестр, помечаются в таблице с помощью команды Word.

### <a name="extending-a-new-submenu"></a>Расширение нового подменю

когда пользователь открывает меню **файл** в Windows Explorer **, отображается одна из команд.** При выборе этой команды отображается подменю. По умолчанию подменю содержит две команды, **папку** и **ярлык**, которые позволяют пользователям создавать вложенные папки и ярлыки. Это подменю можно расширить, включив команды создания файлов для любого типа файлов.

Чтобы добавить команду создания файла в подменю **создать** , файлы приложения должны иметь связанный тип файлов. Включите подраздел **шеллнев** под именем файла. Если выбрана команда **создать** меню **файл** , оболочка добавляет тип файла в подменю **создать** . Отображаемая строка команды представляет собой описательную строку, назначенную ProgID программы.

Чтобы указать метод создания файла, назначьте одно или несколько значений данных подразделу **шеллнев** . Доступные значения перечислены в следующей таблице.



| Значение подраздела Шеллнев | Описание                                                                                                                                                              |
|-----------------------|--------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| Команда               | Выполняет приложение. Это значение **reg \_ SZ** указывает путь к выполняемому приложению. Например, можно задать запуск мастера.                  |
| Данные                  | Создает файл, содержащий указанные данные. Этот **\_ двоичный параметр reg** задает данные файла. **Данные** пропускаются, если указано либо **Нуллфиле** , либо **filename** . |
| FileName              | Создает файл, который является копией указанного файла. Это значение **reg \_ SZ** указывает полный путь к копируемому файлу.                                   |
| нуллфиле              | Создает пустой файл. **Нуллфиле** не имеет присвоенного значения. Если указан параметр **нуллфиле** , значения реестра **Data** и **filename** игнорируются.                    |



 

В следующем примере раздела реестра и снимке экрана показано **новое** подменю для типа файла МИП-MS. У него есть команда **MyProgram Application**.

```
HKEY_CLASSES_ROOT
   .myp
      (Default) = MyProgram.1
      MyProgram.1
         ShellNew
         NullFile
```

На снимке экрана показано **новое** подменю. Когда пользователь выбирает **приложение MyProgram** из подменю **создать** , оболочка создает файл с именем **New MyProgram Application. МИП-ms** и передает его в **MyProgram.exe**.

![снимок экрана Windows Explorer с новой командой "приложение MyProgram" в подменю "создать"](images/context-menu/context-myprogramexe.png)

### <a name="creating-drag-and-drop-handlers"></a>Создание обработчиков перетаскивания

Базовая процедура реализации обработчика перетаскивания аналогична процедуре для обычных обработчиков контекстного меню. Однако обработчики контекстного меню обычно используют только указатель [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) , передаваемый методу [**Ишеллекстинит:: Initialize**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellextinit-initialize) обработчика, для извлечения имени объекта. Обработчик перетаскивания может реализовать более сложный обработчик данных для изменения поведения перетаскиваемого объекта.

Когда пользователь щелкает правой кнопкой мыши объект оболочки для перетаскивания объекта, контекстное меню отображается, когда пользователь пытается удалить объект. На следующем снимке экрана показан типичный контекстный меню для перетаскивания.

![снимок экрана с контекстным меню перетаскивания](images/context-menu/context-dragdrop.png)

Обработчик перетаскивания — это обработчик контекстного меню, который может добавлять элементы в контекстное меню. Обработчики перетаскивания обычно регистрируются в следующем подразделе.

```
HKEY_CLASSES_ROOT
   Directory
      shellex
         DragDropHandlers
```

Добавьте подраздел в подраздел **драгдрофандлерс** с именем для обработчика перетаскивания и задайте в качестве значения по умолчанию для подраздела строковое значение GUID идентификатора класса обработчика (CLSID). В следующем примере активируется обработчик перетаскивания **мидд** .

```
HKEY_CLASSES_ROOT
   Directory
      shellex
         DragDropHandlers
            MyDD
               (Default) = {MyDD CLSID GUID}
```

### <a name="suppressing-verbs-and-controlling-visibility"></a>Подавление команд и управление видимостью

для управления видимостью команды можно использовать параметры политики Windows. Команды можно подавлять с помощью параметров политики, добавив значение **суппрессионполици** или значение GUID **суппрессионполициекс** в подраздел реестра команды. Присвойте параметру подраздела **СУППРЕССИОНПОЛИЦИ** идентификатор политики. Если политика включена, команда и связанная с ней запись контекстного меню подавляются. Возможные значения идентификатора политики см. в описании перечисления [**ограничений**](/windows/desktop/api/shlobj_core/ne-shlobj_core-restrictions) .

### <a name="employing-the-verb-selection-model"></a>Применение модели выбора глагола

Значения реестра должны быть заданы для команд, чтобы обрабатывать ситуации, когда пользователь может выбрать один элемент, несколько элементов или выбрать из элемента. Команда требует наличия отдельных значений реестра для каждой из трех ситуаций, поддерживаемых командой. Ниже приведены возможные значения для модели выбора команд.

-   Укажите значение Мултиселектмодел для всех команд. Если значение Мултиселектмодел не указано, оно выводится из выбранного типа реализации глагола. Для **методов,** основанных на com (например, Дроптаржет и **ExecuteCommand),** предполагается, а для других методов —.
-   Укажите **одну** для команд, поддерживающих только один выбор.
-   Укажите **проигрыватель** для команд, которые поддерживают любое количество элементов.
-   Укажите **документ** для команд, которые создают окно верхнего уровня для каждого элемента. Это ограничивает количество активированных элементов и помогает избежать переполнения системных ресурсов, если пользователь открывает слишком много окон.

Если выбранное число элементов не соответствует модели выбора глагола или превышает ограничения по умолчанию, описанные в следующей таблице, команда не отображается.



| Тип реализации глагола | Документ | Проигрыватель    |
|-----------------------------|----------|-----------|
| Прежняя версия                      | 15 элементов | 100 элементов |
| COM                         | 15 элементов | Без ограничений  |



 

Ниже приведены примеры записей реестра с использованием значения Мултиселектмодел.

```
HKEY_CLASSES_ROOT
   Folder
      shell
         open
             = MultiSelectModel = Document
```

```
HKEY_CLASSES_ROOT
   ProgID
      shell
         verb
             = MultiSelectModel = Single | Document | Player
```

### <a name="using-item-attributes"></a>Использование атрибутов элементов

Значения флагов [**сфгао**](sfgao.md) атрибутов оболочки для элемента можно проверить, чтобы определить, должна ли команда быть включена или отключена.

Чтобы использовать эту функцию атрибута, добавьте следующие значения **reg \_ DWORD** в команду:

-   Значение Аттрибутемаск указывает значение [**сфгао**](sfgao.md) для битовых значений маски для проверки.
-   Значение AttributeValue указывает значение [**сфгао**](sfgao.md) для проверяемых битов.
-   Имплиедселектионмодел указывает ноль для глаголов элемента или ненулевое значение для команд в контекстном меню фона.

В следующем примере записи реестра Аттрибутемаск имеет значение [**сфгао \_ ReadOnly**](sfgao.md) (0x40000).

```
HKEY_CLASSES_ROOT
   txtfile
      Shell
         test.verb2
            AttributeMask = 0x40000
            AttributeValue = 0x0
            ImpliedSelectionModel = 0x0
            command
               (Default) = %SystemRoot%\system32\notepad.exe %1
```

### <a name="implementing-custom-verbs-for-folders-through-desktopini"></a>Реализация пользовательских команд для папок с помощью Desktop.ini

в Windows 7 и более поздних версиях можно добавлять команды в папку с помощью Desktop.ini. Дополнительные сведения о Desktop.ini файлах см. [в статье Настройка папок с помощью Desktop.ini](how-to-customize-folders-with-desktop-ini.md).

> [!Note]  
> Desktop.ini файлы всегда должны быть помечены как   +  **скрытые** системой, чтобы они не отображались для пользователей.

 

**Чтобы добавить пользовательские команды для папок с помощью файла Desktop.ini, выполните следующие действия.**

1.  Создайте папку, которая помечена как доступная **только для чтения** или как **система**.
2.  Создайте файл Desktop.ini, содержащий \[ . Шеллклассинфо \] директорикласс = ProgID папки.
3.  В реестре создайте **класс hKey с \_ \_ корневой** \\ **папкой ProgID** со значением канусефордиректори. Значение Канусефордиректори позволяет избежать неправильного использования ProgID, которые не участвуют в реализации пользовательских команд для папок с помощью Desktop.ini.
4.  Добавьте команды в подключе ProgID **папки**, например:

    ```
    HKEY_CLASSES_ROOT
       CustomFolderType
          Shell
             MyVerb
                command
                   (Default) = %SystemRoot%\system32\notepad.exe %1\desktop.ini
    ```

> [!Note]  
> Эти глаголы могут быть глаголами по умолчанию. в этом случае двойной щелчок папки активирует команду.

 

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Рекомендации по работе с обработчиками контекстного меню и несколькими командами выбора](verbs-best-practices.md)
</dt> <dt>

[Выбор статической или динамической команды для контекстного меню](shortcut-choose-method.md)
</dt> <dt>

[Настройка контекстного меню с помощью динамических команд](shortcut-menu-using-dynamic-verbs.md)
</dt> <dt>

[Контекстное меню (контекст) и обработчики контекстного меню](context-menu.md)
</dt> <dt>

[Команды и сопоставления файлов](fa-verbs.md)
</dt> <dt>

[Справочник по контекстному меню](context-menu-reference.md)
</dt> </dl>

 

 
