---
description: В этом документе представлены распространенные сценарии обмена данными оболочки и обсуждается реализация каждого из них в приложении.
ms.assetid: 7fce555c-a93d-4414-9119-7ae9acdd4d89
title: Обработка сценариев передачи данных оболочки
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 35855b66e4108580d5bac305855837563ca59785
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "104984317"
---
# <a name="handling-shell-data-transfer-scenarios"></a>Обработка сценариев передачи данных оболочки

Документ [объекта данных оболочки](dataobject.md) , который обсуждал общий подход, используемый для переноса данных оболочки с помощью перетаскивания или буфера обмена. Однако, чтобы реализовать передачу данных оболочки в приложение, необходимо также понять, как применять эти общие принципы и методики к различным способам передачи данных оболочки. В этом документе представлены распространенные сценарии обмена данными оболочки и обсуждается реализация каждого из них в приложении.

-   [Общие рекомендации](#general-guidelines)
-   [Копирование имен файлов из буфера обмена в приложение](#copying-file-names-from-the-clipboard-to-an-application)
    -   [Извлечение имен файлов из объекта данных](#extracting-the-file-names-from-the-data-object)
-   [Копирование содержимого удаленного файла в приложение](#copying-the-contents-of-a-dropped-file-into-an-application)
    -   [Использование формата КФСТР \_ филеконтентс для извлечения данных из файла](/windows)
-   [Обработка оптимизированных операций перемещения](#handling-optimized-move-operations)
-   [Обработка операций удаления при вставке](#handling-delete-on-paste-operations)
-   [Перенос данных в виртуальные папки и из них](#transfering-data-to-and-from-virtual-folders)
    -   [Прием данных из виртуальной папки](#accepting-data-from-a-virtual-folder)
    -   [Передача данных в расширение пространства имен и обратно](#transferring-data-to-and-from-a-namespace-extension)
-   [Удаление файлов в корзине](#dropping-files-on-the-recycle-bin)
-   [Создание и импорт файлов отходов](#creating-and-importing-scrap-files)
    -   [Поддержка приема-передачи](#round-trip-support)
    -   [Форматы кэшированных данных](#cached-data-formats)
    -   [Отложенная визуализация](#delayed-rendering)
-   [Асинхронное перетаскивание объектов оболочки](#dragging-and-dropping-shell-objects-asynchronously)
    -   [Использование IASyncOperation и Идатаобжектасинккапабилити](#using-iasyncoperationidataobjectasynccapability)

> [!Note]  
> Несмотря на то, что каждый из этих сценариев обсуждает конкретную операцию по переносу данных, многие из них применяются к различным связанным сценариям. Например, основное различие между большинством буферов обмена и перемещением по операциям перетаскивания заключается в том, как объект данных прибывает в целевом объекте. После того как целевой объект имеет указатель на интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных, процедуры извлечения данных в основном одинаковы для обоих типов переноса данных. Однако некоторые сценарии ограничены определенным типом операции. Дополнительные сведения см. в отдельном сценарии.

 

## <a name="general-guidelines"></a>Общие рекомендации

В каждом из следующих разделов обсуждается один, довольно конкретный сценарий для обмена данными. Однако передача данных часто более сложна и может затрагивать различные сценарии. Как правило, вы не умеете знать, какой сценарий вам действительно нужно обменять. Ниже приведены некоторые общие рекомендации, которые следует учитывать.

Для источников данных:

-   Форматы буфера обмена оболочки, за исключением [CF \_ HDROP](clipboard.md), не являются стандартными. Каждый формат, который вы хотите использовать, должен быть зарегистрирован путем вызова [регистерклипбоардформат](/windows/win32/api/winuser/nf-winuser-registerclipboardformata).
-   Форматы объектов данных предоставляются в порядке предпочтения источника. Перечислите объект данных и выберите первый из них, который вы можете использовать.
-   Включите столько форматов, сколько вы можете поддерживать. Обычно неизвестно, куда будет удален объект данных. Такой подход повышает вероятность того, что объект данных будет содержать формат, который может быть принят целью перетаскивания.
-   Существующие файлы должны быть предложены в формате [CF \_ HDROP](clipboard.md) .
-   Предлагают данные, схожие с файлами, с форматами [кфстр \_ филеконтентс](clipboard.md) / [кфстр \_ филедескриптор](clipboard.md) . Такой подход позволяет целевому объекту создать файл из объекта данных, не зная ничего о базовом хранилище данных. Обычно данные следует представлять как интерфейс [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) . Этот механизм обмена данными более гибок, чем глобальный объект памяти, и использует гораздо меньше памяти.
-   При перетаскивании элементов оболочки источники перетаскивания должны предлагать формат [кфстр \_ шеллидлист](clipboard.md) . Объекты данных для элементов можно получить с помощью методов [**ишеллфолдер:: жетуиобжектоф**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellfolder-getuiobjectof) или [**интерфейса IShellItem:: биндтохандлер**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-ishellitem-bindtohandler) . Источники данных могут создать стандартную реализацию объекта данных, которая поддерживает [Формат \_ шеллидлист кфстр](clipboard.md) с помощью [**шкреатедатаобжект**](/windows/desktop/api/shlobj_core/nf-shlobj_core-shcreatedataobject).
-   Целевые объекты перетаскивания, которые хотят попытаться перетаскивать элементы с помощью модели программирования элемента оболочки, могут преобразовать IDataObject в [**ишеллитемаррай**](/windows/desktop/api/shobjidl_core/nn-shobjidl_core-ishellitemarray) с помощью [**шкреатешеллитемаррайфромдатаобжект**](/windows/desktop/api/shobjidl_core/nf-shobjidl_core-shcreateshellitemarrayfromdataobject).
-   Используйте стандартные курсоры обратной связи.
-   Поддержка перетаскивания слева и справа.
-   Используйте сам объект данных из внедренного объекта. Такой подход позволяет приложению извлекать любые дополнительные форматы, которые должен предоставить объект данных, и избегать создания дополнительного уровня вложения. Например, внедренный объект с сервера A перетаскивается с сервера или контейнера B и удаляется в контейнере C. C следует создать внедренный объект сервера A, а не внедренный объект сервера B, содержащий внедренный объект сервера A.
-   Помните, что оболочка может использовать [оптимизированные операции перемещения](#handling-optimized-move-operations) или [удаления](#handling-delete-on-paste-operations) при перемещении файлов. Приложение должно уметь распознавать эти операции и реагировать соответствующим образом.

Для целевых объектов данных:

-   Форматы буфера обмена оболочки, за исключением [CF \_ HDROP](clipboard.md), не являются стандартными. Каждый формат, который вы хотите использовать, должен быть зарегистрирован путем вызова [регистерклипбоардформат](/windows/win32/api/winuser/nf-winuser-registerclipboardformata).
-   Реализация и регистрация целевого объекта OLE Drop. Старайтесь не использовать целевые объекты Windows 3,1 или сообщение [**WM \_ дропфилес**](wm-dropfiles.md) , если это возможно.
-   Форматы, содержащиеся в объекте данных, зависят от того, откуда берется объект. Так как вы, как правило, не умеете заранее известно, откуда берется объект данных, не следует думать, какой формат будет представлен. Объект данных должен перечислять форматы в порядке их качества, начиная с лучшего. Таким образом, чтобы получить наилучший доступный формат, приложения обычно перечисляют доступные форматы и используют первый формат в перечислении, которое они могут поддерживать.
-   Поддерживает перетаскивание правой кнопкой мыши. Контекстное меню перетаскивания можно настроить, создав [обработчик перетаскивания](context-menu-handlers.md).
-   Если приложение будет принимать существующие файлы, оно должно иметь возможность обрабатывать формат [ \_ HDROP CF](clipboard.md) .
-   Как правило, приложения, принимающие файлы, должны также обрабатывать форматы [кфстр \_ филеконтентс](clipboard.md) / [кфстр \_ филедескриптор](clipboard.md) . Хотя файлы из файловой системы имеют формат [CF \_ HDROP](clipboard.md) , файлы из поставщиков, например расширения пространства имен, обычно используют [кфстр \_ филеконтентс](clipboard.md) / [кфстр \_ филедескриптор](clipboard.md). К примерам относятся Windows CE папки, папки протокол FTP (FTP), веб-папки и папки CAB. Источник обычно реализует интерфейс [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) для представления данных из своего хранилища в виде файла.
-   Помните, что оболочка может использовать [оптимизированные операции перемещения](#handling-optimized-move-operations) или [удаления](#handling-delete-on-paste-operations) при перемещении файлов. Приложение должно уметь распознавать эти операции и реагировать соответствующим образом.

## <a name="copying-file-names-from-the-clipboard-to-an-application"></a>Копирование имен файлов из буфера обмена в приложение

**Сценарий:** Пользователь выбирает один или несколько файлов в проводнике Windows и копирует их в буфер обмена. Приложение извлекает имена файлов и вставляет их в документ.

Этот сценарий можно использовать, например, чтобы разрешить пользователю создавать HTML-ссылки, выполнив копирование файла в приложение. Приложение может извлечь имя файла из объекта данных и обработать его для создания тега привязки.

Когда пользователь выбирает файл в проводнике Windows и копирует его в буфер обмена, оболочка создает объект данных. Затем он вызывает [**олесетклипбоард**](/windows/win32/api/ole2/nf-ole2-olesetclipboard) , чтобы поместить указатель на интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных в буфер обмена.

Когда пользователь выбирает команду **Вставить** в меню или на панели инструментов приложения:

1.  Вызовите [**олежетклипбоард**](/windows/win32/api/ole2/nf-ole2-olegetclipboard) , чтобы получить интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) объекта данных.
2.  Вызовите [**IDataObject:: енумформатетк**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) , чтобы запросить объект перечислителя.
3.  Используйте интерфейс [**иенумформатетк**](/windows/win32/api/objidl/nn-objidl-ienumformatetc) объекта Enumerator для перечисления форматов, содержащихся в объекте данных.

> [!Note]  
> Последние два шага в этой процедуре включены для полноты. Обычно они не требуются для простой передачи файлов. Все объекты данных, используемые для этого типа, должны содержать формат [CF \_ HDROP](clipboard.md) , который можно использовать для определения имен файлов, содержащихся в объекте. Однако для более общих операций передачи данных следует перечислить форматы и выбрать наилучший из них, который может быть обработано приложением.

 

### <a name="extracting-the-file-names-from-the-data-object"></a>Извлечение имен файлов из объекта данных

Следующим шагом является извлечение из объекта данных одного или нескольких имен файлов и их вставка в приложение. Обратите внимание, что процедура, описанная в этом разделе, для извлечения имени файла из объекта данных также применяется к передаче операций перетаскивания.

Самым простым способом получения имен файлов из объекта данных является формат [CF \_ HDROP](clipboard.md) :

1.  Вызовите [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata). Задайте для элемента **кфформат** структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) значение [CF \_ HDROP](clipboard.md) , а для элемента **тимед** — [тимед \_ хглобал](dataobject.md). Обычно для элемента **дваспект** задано содержимое дваспект \_ . Однако если необходимо, чтобы путь к файлу был в кратком формате (8,3), задайте для параметра **дваспект** значение дваспект \_ Short.

    Когда функция [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) возвращает значение, элемент **хглобал** структуры [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) указывает на глобальный объект памяти, содержащий данные.

2.  Создайте переменную HDROP и задайте ее элементу **хглобал** структуры [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) . Переменная HDROP теперь является обработчиком структуры [**дропфилес**](/windows/desktop/api/shlobj_core/ns-shlobj_core-dropfiles) , за которой следует строка с абсолютным нулем, которая содержит полные пути к файлам копируемых файлов.
3.  Определите, сколько путей к файлам находится в списке, вызвав [**драгкуерифиле**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) с параметром *ифиле* , имеющим значение 0xFFFFFFFF. Функция возвращает число путей к файлам в списке. Отсчитываемый от нуля индекс пути к файлу в этом списке используется на следующем шаге для задания определенного пути.
4.  Извлеките пути к файлам из объекта глобальной памяти, вызвав [**драгкуерифиле**](/windows/desktop/api/Shellapi/nf-shellapi-dragqueryfilea) один раз для каждого файла, где *ифиле* задается в индексе файла.
5.  Обработайте пути к файлам по мере необходимости и вставьте их в приложение.
6.  Вызовите [**релеасестгмедиум**](/windows/win32/api/ole2/nf-ole2-releasestgmedium) и передайте указатель на структуру [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) , которую вы передали в [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) на шаге 1. После выпуска структуры значение HDROP, созданное на шаге 2, больше не является допустимым и не должно использоваться.

## <a name="copying-the-contents-of-a-dropped-file-into-an-application"></a>Копирование содержимого удаленного файла в приложение

**Сценарий:** Пользователь перетаскивает один или несколько файлов из проводника Windows и удаляет их в окне приложения. Ваше приложение извлекает содержимое файлов и вставляет его в приложение.

В этом сценарии для переноса файлов из проводника Windows в приложение используется перетаскивание. Перед выполнением операции приложение должно:

1.  Вызовите [регистерклипбоардформат](/windows/win32/api/winuser/nf-winuser-registerclipboardformata) , чтобы зарегистрировать необходимые форматы буфера обмена оболочки.
2.  Вызовите [**регистердрагдроп**](/windows/win32/api/ole2/nf-ole2-registerdragdrop) , чтобы зарегистрировать целевое окно и интерфейс [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) вашего приложения.

После того, как пользователь инициирует операцию, выбрав один или несколько файлов и начав их перетаскивание:

1.  Проводник Windows создает объект данных и загружает в него Поддерживаемые форматы.
2.  Проводник Windows вызывает [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) для инициации цикла перетаскивания.
3.  Когда изображение перетаскивания достигает целевого окна, система уведомляет вас, вызывая [**интерфейс IDropTarget::D ражентер**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-dragenter).
4.  Чтобы определить, что содержит объект данных, вызовите метод [**IDataObject:: енумформатетк**](/windows/win32/api/objidl/nf-objidl-idataobject-enumformatetc) объекта данных. Используйте объект перечислителя, возвращенный методом, для перечисления форматов, содержащихся в объекте данных. Если приложению не требуется принимать какие либо из этих форматов, возвратите ДРОПЕФФЕКТ \_ None. В этом сценарии приложение должно игнорировать любые объекты данных, которые не содержат форматы, используемые для перемещения файлов, например [CF \_ HDROP](clipboard.md).
5.  Когда пользователь удаляет данные, система вызывает [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop).
6.  Используйте интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) для извлечения содержимого файлов.

Существует несколько различных способов извлечения содержимого объекта оболочки из объекта данных. В общем случае используйте следующий порядок:

-   Если файл содержит текстовый формат [CF \_ ](clipboard.md) , то данные содержат текст ANSI. Можно использовать \_ текстовый формат CF для извлечения данных, вместо того чтобы открывать сам файл.
-   Если файл содержит связанный или внедренный OLE-объект, объект данных содержит \_ Формат CF ембеддедобжект. Для извлечения данных используйте стандартные приемы OLE. [Файлы брака/отхода](#creating-and-importing-scrap-files) всегда содержат \_ Формат CF ембеддедобжект.
-   Если объект оболочки находится в файловой системе, объект данных содержит формат [CF \_ HDROP](clipboard.md) с именами файлов. Извлеките имя файла из [CF \_ HDROP](clipboard.md) и вызовите [**олекреатефромфиле**](/windows/win32/api/ole2/nf-ole2-olecreatefromfile) , чтобы создать новый связанный или внедренный объект. Обсуждение того, как получить имя файла из формата [ \_ HDROP CF](clipboard.md) , см. в разделе [Копирование имен файлов из буфера обмена в приложение](#copying-file-names-from-the-clipboard-to-an-application).
-   Если объект данных содержит формат [ \_ филедескриптор кфстр](clipboard.md) , содержимое файла можно извлечь из формата файла [кфстр \_ филеконтентс](clipboard.md) . Описание этой процедуры см. в разделе [использование \_ формата кфстр Филеконтентс для извлечения данных из файла](/windows).
-   До версии оболочки [4,71](versions.md)приложение указывало на то, что оно передавало тип файлов ярлыков, установив параметр филедескриптор **\_ линкуи** в элементе **dwFlags** структуры [](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) . Для более поздних версий оболочки предпочтительным способом указания того, что передаются ярлыки, является использование [кфстр \_ преферреддропеффект](clipboard.md) Format Set to дропеффект \_ Link. Этот подход гораздо эффективнее, чем извлечение структуры **филедескриптор** только для проверки флага.

Если процесс извлечения данных будет длительным, может потребоваться асинхронная операция в фоновом потоке. Основной поток может продолжать работу без задержек. Сведения об обработке асинхронного извлечения данных см. в статье [асинхронное перетаскивание объектов оболочки](#dragging-and-dropping-shell-objects-asynchronously).

### <a name="using-the-cfstr_filecontents-format-to-extract-data-from-a-file"></a>Использование формата КФСТР \_ филеконтентс для извлечения данных из файла

Формат [кфстр \_ филеконтентс](clipboard.md) предоставляет очень гибкий и эффективный способ перемещения содержимого файла. Даже не требуется, чтобы данные сохранялись в одном файле. Все, что необходимо для этого формата, заключается в том, что объект данных предоставляет данные целевому объекту, как если бы он был файлом. Например, фактические данные могут быть частью текстового документа или блоком данных, извлеченных из базы данных. Целевой объект может рассматривать данные как файл и не должен знать какие-либо сведения о базовом механизме хранения.

Расширения пространства имен обычно используют [кфстр \_ филеконтентс](clipboard.md) для перемещения данных, так как этот формат не предполагает какой-либо конкретный механизм хранения. Расширение пространства имен может использовать любой механизм хранения, и использовать этот формат для представления своих объектов приложениям, как если бы они были файлами.

Механизмом обмена данными для [кфстр \_ филеконтентс](clipboard.md) обычно является [тимед \_ ISTREAM](dataobject.md). Передача указателя интерфейса [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) требует гораздо меньше памяти, чем загрузка данных в глобальный объект памяти, а **IStream** является более простым способом представления данных, чем [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage).

Формат [ \_ филеконтентс кфстр](clipboard.md) всегда сопровождается форматом [кфстр \_ филедескриптор](clipboard.md) . Сначала необходимо изучить содержимое этого формата. Если передается несколько файлов, объект данных фактически будет содержать несколько [кфстр \_ филеконтентс](clipboard.md) форматов, по одному для каждого файла. Формат [кфстр \_ филедескриптор](clipboard.md) содержит имя и атрибуты каждого файла, а также предоставляет значение индекса для каждого файла, необходимого для извлечения формата [кфстр \_ филеконтентс](clipboard.md) определенного файла.

Чтобы извлечь формат [ \_ филеконтентс кфстр](clipboard.md) , выполните следующие действия.

1.  Извлеките формат [кфстр \_ филедескриптор](clipboard.md) как значение [тимед \_ хглобал](dataobject.md) .
2.  Элемент **хглобал** возвращенной структуры [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) указывает на объект глобальной памяти. Заблокируйте этот объект, передав значение **хглобал** в [**глобаллокк**](/windows/win32/api/winbase/nf-winbase-globallock).
3.  Приведите указатель, возвращенный функцией [**глобаллокк**](/windows/win32/api/winbase/nf-winbase-globallock) , к указателю [**филеграупдескриптор**](/windows/win32/api/shlobj_core/ns-shlobj_core-filegroupdescriptora) . Он будет указывать на структуру **филеграупдескриптор** , за которой следует одна или несколько структур [**филедескриптор**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) . Каждая структура **филедескриптор** содержит описание файла, который содержится в одном из соответствующих форматов [кфстр \_ филеконтентс](clipboard.md) .
4.  Изучите структуры [**филедескриптор**](/windows/win32/api/shlobj_core/ns-shlobj_core-filedescriptora) , чтобы определить, какая из них соответствует файлу, который необходимо извлечь. Отсчитываемый от нуля индекс этой структуры **филедескриптор** используется для задания формата файла [кфстр \_ филеконтентс](clipboard.md) . Поскольку размер глобального блока памяти не является точным, используйте члены структуры **нфилесизелов** и **нфилесизехигх** , чтобы определить, сколько байт представляет файл в глобальном объекте памяти.
5.  Вызовите [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) с элементом **кфформат** структуры [**форматетк**](/windows/win32/api/objidl/ns-objidl-formatetc) , для которого задано значение [Кфстр \_ филеконтентс](clipboard.md) , а в качестве элемента **Линдекс** — индекс, определенный на предыдущем шаге. Обычно элемент **тимед** имеет значение [тимед \_ хглобал](dataobject.md) \| тимед \_ ISTREAM \| тимед \_ ISTORAGE. Затем объект данных может выбрать предпочтительный механизм обмена данными.
6.  Структура [**стгмедиум**](/windows/win32/api/objidl/ns-objidl-ustgmedium-r1) , возвращаемая файлом [**IDataObject:: GetData**](/windows/win32/api/objidl/nf-objidl-idataobject-getdata) , будет содержать указатель на данные файла. Изучите элемент **тимед** структуры, чтобы определить механизм обмена данными.
7.  Если **тимед** имеет значение [ТИМЕД \_ ISTREAM](dataobject.md) или тимед \_ ISTORAGE, используйте интерфейс для извлечения данных. Если **тимед** имеет значение тимед \_ хглобал, данные содержатся в глобальном объекте памяти. Обсуждение извлечения данных из глобального объекта памяти см. в разделе *Извлечение объекта глобальной памяти из раздела объекта* данных [оболочки](dataobject.md).
8.  Вызовите [**глобаллокк**](/windows/win32/api/winbase/nf-winbase-globallock) , чтобы разблокировать объект глобальной памяти, заблокированный на шаге 2.

## <a name="handling-optimized-move-operations"></a>Обработка оптимизированных операций перемещения

**Сценарий:** Файл перемещается из файловой системы в расширение пространства имен с помощью оптимизированного перемещения.

В обычной операции перемещения целевой объект создает копию данных, а источник удаляет оригинал. Эта процедура может быть неэффективной, так как требует наличия двух копий данных. При использовании больших объектов, таких как базы данных, обычная операция перемещения может оказаться даже непрактичной.

При оптимизированном перемещении целевой объект использует понимание того, как хранятся данные для обработки всей операции перемещения. Вторая копия данных никогда не используется, и источник для удаления исходных данных не требуется. Данные оболочки хорошо подходят для оптимизированных перемещений, так как целевой объект может выполнять всю операцию с помощью API оболочки. Типичным примером является перемещение файлов. Если целевой объект содержит путь к перемещаемому файлу, он может использовать [**шфилеоператион**](/windows/desktop/api/Shellapi/nf-shellapi-shfileoperationa) для перемещения. Источник для удаления исходного файла не требуется.

> [!Note]  
> Для перемещения файлов оболочка обычно использует оптимизированное перемещение. Для правильной обработки передачи данных в оболочке приложение должно иметь возможность обнаружения и обработки оптимизированного перемещения.

 

Оптимизированные перемещения обрабатываются следующим образом:

1.  Источник вызывает [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) с параметром *двеффект* , установленным в дропеффект \_ Move, чтобы указать, что исходные объекты можно перемещать.
2.  Целевой объект получает \_ значение перемещения дропеффект через один из своих методов [**интерфейс IDropTarget**](/windows/win32/api/oleidl/nn-oleidl-idroptarget) , указывая, что перемещение разрешено.
3.  Цель либо копирует объект (неоптимизированное перемещение), либо перемещает объект (оптимизированное перемещение).
4.  Целевой объект сообщает источнику, нужно ли удалять исходные данные.

    Оптимизированное перемещение — это операция по умолчанию с данными, удаленными целевым объектом. Чтобы сообщить источнику, что было выполнено оптимизированное перемещение:

    -   -   Целевой объект задает значение *пдвеффект* , полученное через его метод [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) , к значению, отличному от дропеффект \_ Move. Обычно для него задано значение ДРОПЕФФЕКТ \_ None или дропеффект \_ Copy. Значение будет возвращено в источник с помощью [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).
        -   Целевой объект также вызывает метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) объекта данных и передает ему идентификатор формата [ \_ перформеддропеффект кфстр](clipboard.md) , установленный в дропеффект \_ None. Этот вызов метода необходим, так как некоторые целевые объекты Drop не могут правильно установить параметр *Пдвеффект* [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) . Формат [кфстр \_ перформеддропеффект](clipboard.md) является надежным способом указать, что было выполнено оптимизированное перемещение.

    Если целевой объект выполнил неоптимизированный перенос, данные должны быть удалены источником. Чтобы сообщить источнику о том, что было выполнено неоптимизированное перемещение:

    -   -   Целевой объект задает значение *пдвеффект* , полученное с помощью метода [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) дропеффект \_ Move. Значение будет возвращено в источник с помощью [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop).
        -   Целевой объект также вызывает метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) объекта данных и передает ему идентификатор формата [ \_ перформеддропеффект кфстр](clipboard.md) , установленный в дропеффект \_ Move. Этот вызов метода необходим, так как некоторые целевые объекты Drop не могут правильно установить параметр *Пдвеффект* [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) . Формат [кфстр \_ перформеддропеффект](clipboard.md) является надежным способом указать, что было выполнено неоптимизированное перемещение.

5.  Источник проверяет два значения, которые могут быть возвращены целевым объектом. Если для обоих свойств задано значение ДРОПЕФФЕКТ \_ Move, то он завершает неоптимизированное перемещение, удаляя исходные данные. В противном случае в целевом объекте было оптимизировано перемещение, а исходные данные удалены.

## <a name="handling-delete-on-paste-operations"></a>Обработка операций удаления при вставке

**Сценарий:** Один или несколько файлов будут вырезаны из папки в проводнике Windows и вставлены в расширение пространства имен. Проводник Windows оставляет выделенные файлы до тех пор, пока не получит отзыв о результатах операции вставки.

Обычно, когда пользователь вырезает данные, он сразу исчезает из представления. Это может оказаться неэффективным и может привести к проблемам с удобством использования, если пользователь позаботится о том, что произошло с данными. Альтернативный подход заключается в использовании операции удаления при вставке.

При использовании операции удаления при вставке выбранные данные не сразу удаляются из представления. Вместо этого исходное приложение помечает его как выбранное, возможно, путем изменения цвета шрифта или фона. После того как целевое приложение вставило данные, оно уведомляет источник о результатах операции. Если целевой объект выполнил [оптимизированное перемещение](#handling-optimized-move-operations), источник может просто обновить его отображение. Если целевой объект выполнил нормальное перемещение, то источник должен также удалить свою копию данных. Если вставка завершается неудачно, исходное приложение восстанавливает исходный вид данных.

> [!Note]  
> Оболочка обычно использует функцию «удалить при вставке», если для перемещения файлов используется операция вырезания или вставки. Операции удаления при вставке с помощью объектов оболочки обычно используют [оптимизированную операцию перемещения](#handling-optimized-move-operations) для перемещения файлов. Для правильной обработки данных оболочки приложение должно уметь обнаруживать и обрабатывать операции удаления операций вставки.

 

Основным требованием для удаления при вставке является то, что целевой объект должен сообщить результат операции с источником. Однако стандартные методы буфера обмена нельзя использовать для реализации удаления при вставке, так как они не обеспечивают способ взаимодействия целевого объекта с источником. Вместо этого целевое приложение использует метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) объекта данных для передачи результата в объект данных. Затем объект данных может взаимодействовать с источником через частный интерфейс.

Ниже приведена базовая процедура для операции удаления при вставке.

1.  Источник отмечает отображение выбранных данных на экране.
2.  Источник создает объект данных. Он указывает на операцию вырезания путем добавления формата [кфстр \_ преферреддропеффект](clipboard.md) со значением данных дропеффект \_ Move.
3.  Источник помещает объект данных в буфер обмена с помощью [**олесетклипбоард**](/windows/win32/api/ole2/nf-ole2-olesetclipboard).
4.  Цель получает объект данных из буфера обмена с помощью [**олежетклипбоард**](/windows/win32/api/ole2/nf-ole2-olegetclipboard).
5.  Целевой объект извлекает данные [ \_ преферреддропеффект кфстр](clipboard.md) . Если задано только \_ Перемещение дропеффект, целевой объект может либо выполнить оптимизированное перемещение, либо просто скопировать данные.
6.  Если целевой объект не выполняет оптимизированное перемещение, он вызывает метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) с форматом [ \_ перформеддропеффект кфстр](clipboard.md) , установленным в дропеффект \_ Move.
7.  После завершения вставки целевой объект вызывает метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) с форматом [ \_ пастесукцеедед кфстр](clipboard.md) , установленным в дропеффект \_ Move.
8.  При вызове метода [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) с форматом [кфстр \_ пастесукцеедед](clipboard.md) , установленным в дропеффект \_ Move, он должен проверить, получен ли также формат [кфстр \_ перформеддропеффект](clipboard.md) , установленный в дропеффект \_ Move. Если целевой объект отправляет оба формата, источнику потребуется удалить данные. Если получен только формат [кфстр \_ пастесукцеедед](clipboard.md) , источник может просто удалить данные из его дисплея. Если перемещение завершается неудачей, источник обновляет изображение до исходного вида.

## <a name="transfering-data-to-and-from-virtual-folders"></a>Перенос данных в виртуальные папки и из них

**Сценарий:** Пользователь перетаскивает объект из виртуальной папки или удаляет его.

Виртуальные папки содержат объекты, которые обычно не являются частью файловой системы. Некоторые виртуальные папки, например корзина, могут представлять данные, которые хранятся на жестком диске, но не являются обычными объектами файловой системы. Некоторые могут представлять сохраненные данные, находящиеся в удаленной системе, например на карманном ПК или на FTP-сайте. Другие, например папка «Принтеры», содержат объекты, не представляющие сохраненные данные. Хотя некоторые виртуальные папки являются частью системы, разработчики также могут создавать и устанавливать настраиваемые виртуальные папки, реализуя расширение пространства имен.

Независимо от типа данных и способа их хранения, файлы папок и файлов, содержащиеся в виртуальной папке, представляются оболочкой, как будто они являются обычными файлами и папками. Она отвечает за то, что виртуальная папка принимает все содержащиеся в ней данные и представляет ее в оболочке соответствующим образом. Это требование означает, что виртуальные папки обычно поддерживают перетаскивание и передачу данных в буфер обмена.

В связи с этим две группы разработчиков, которым необходимо заботиться о переносе данных в виртуальные папки и из них:

-   Разработчики, чьи приложения должны принимать данные, передаваемые из виртуальной папки.
-   Разработчики, расширения пространства имен которых должны должным образом поддерживать перенос данных.

### <a name="accepting-data-from-a-virtual-folder"></a>Прием данных из виртуальной папки

Виртуальные папки могут представлять практически любой тип данных и могут хранить эти данные любым способом. Некоторые виртуальные папки могут фактически содержать обычные файлы и папки файловой системы. Другие могут, например, упаковать все свои объекты в один документ или базу данных.

При передаче объекта файловой системы в приложение объект данных обычно содержит формат [CF \_ HDROP](clipboard.md) с полным путем к объекту. Приложение может извлекать эту строку и использовать обычные функции файловой системы для открытия файла и извлечения его данных. Однако так как виртуальные папки обычно не содержат обычные объекты файловой системы, они обычно не используют [CF \_ HDROP](clipboard.md).

Вместо [CF \_ HDROP](clipboard.md)данные обычно передаются из виртуальных папок с помощью форматов [кфстр \_ филедескриптор](clipboard.md) / [кфстр \_ филеконтентс](clipboard.md) . Формат [ \_ филеконтентс кфстр](clipboard.md) имеет два преимущества по сравнению с [CF \_ HDROP](clipboard.md):

-   Определенный метод хранения данных не предполагается.
-   Формат является более гибким. Он поддерживает три механизма обмена данными: глобальный объект памяти, интерфейс [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) или интерфейс [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) .

Объекты глобальной памяти редко используются для перемещения данных в виртуальные объекты или из них, поскольку данные должны быть скопированы в память целиком. Для передачи указателя интерфейса требуется почти не столько же памяти, что и более эффективно. При наличии очень больших файлов указатель интерфейса может быть единственным практическим механизмом для обмена данными. Как правило, данные представлены указателем [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) , так как этот интерфейс несколько более гибок, чем [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage). Целевой объект извлекает указатель из объекта данных и использует методы интерфейса для извлечения данных.

Дополнительные сведения о том, как обрабатывать форматы [кфстр \_ филедескриптор](clipboard.md) / [кфстр \_ филеконтентс](clipboard.md) , см. в статье [использование \_ формата кфстр филеконтентс для извлечения данных из файла](/windows).

### <a name="transferring-data-to-and-from-a-namespace-extension"></a>Передача данных в расширение пространства имен и обратно

При реализации расширения пространства имен обычно требуется поддержка возможностей перетаскивания. Следуйте рекомендациям по удалению источников и целевых объектов, описанным в разделе [Общие рекомендации](#general-guidelines). В частности, расширение пространства имен должно:

-   Иметь возможность обрабатывать форматы [кфстр \_ филедескриптор](clipboard.md) / [кфстр \_ филеконтентс](clipboard.md) . Эти два формата обычно используются для перемещения объектов в расширения пространства имен и из них.
-   Возможность обработки [оптимизированных перемещений](#handling-optimized-move-operations). Оболочка ждет, что объекты оболочки будут перемещены с оптимизированным перемещением.
-   Иметь возможность обрабатывать операции [удаления при вставке](#handling-delete-on-paste-operations) . Оболочка использует функцию "удалить при вставке" при перемещении объектов из оболочки в операцию вырезания или вставки.
-   Возможность обрабатывать обмен данными через интерфейс [**IStream**](/windows/win32/api/objidl/nn-objidl-istream) или [**IStorage**](/windows/win32/api/objidl/nn-objidl-istorage) . Передача данных в виртуальную папку или из нее обычно обрабатывается путем передачи одного из этих двух указателей интерфейса, обычно указателя **IStream** . Затем целевой объект вызывает методы интерфейса для извлечения данных:
    -   -   В качестве источника сброса расширение пространства имен должно извлекать данные из хранилища и передавать их в целевой объект через этот интерфейс.
        -   В качестве цели перетаскивания расширение пространства имен должно принимать данные из источника через этот интерфейс и сохранять их должным образом.

## <a name="dropping-files-on-the-recycle-bin"></a>Удаление файлов в корзине

**Сценарий:** Пользователь удаляет файл в **корзине**. Расширение приложения или пространства имен удаляет исходный файл.

Корзина — это виртуальная папка, которая используется в качестве репозитория для файлов, которые больше не нужны. Пока корзина не была очищена, пользователь может позже восстановить файл и вернуть его в файловую систему.

В большинстве случаев передача объектов оболочки в корзину работает во многом аналогично любой другой папке. Однако когда пользователь удаляет файл в **корзине**, источник должен удалить оригинал, даже если обратная связь из папки указывает на операцию копирования. Как правило, источник перетаскивания не может узнать, в какой папке был удален объект данных. Однако для систем Windows 2000 и более поздних версий при удалении объекта данных в **корзине** оболочка вызывает метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) объекта данных с форматом [кфстр \_ таржетклсид](clipboard.md) , установленным в идентификатор класса корзины (CLSID \_ RecycleBin). Чтобы правильно обрабатывать корзину, объект данных должен иметь возможность распознать этот формат и передать информацию в источник через частный интерфейс.

> [!Note]  
> Когда метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) вызывается с форматом [ \_ таржетклсид кфстр](clipboard.md) , установленным в значение CLSID \_ RecycleBin, источник данных должен закрыть все открытые дескрипторы объектов, которые передаются перед возвратом из метода. В противном случае вы можете создать нарушения совместного доступа.

 

## <a name="creating-and-importing-scrap-files"></a>Создание и импорт файлов отходов

**Сценарий:** Пользователь перетаскивает некоторые данные из файла данных OLE-приложения и удаляет их на рабочем столе или в проводнике Windows.

Windows позволяет пользователям перетащить объект из файла данных OLE-приложения и поместить его на Рабочий стол или в папку файловой системы. Эта операция создает *файл брака/отхода*, который содержит данные или ссылку на данные. Имя файла берется из краткого имени, зарегистрированного для идентификатора CLSID объекта и [ \_ текстовых данных CF](clipboard.md) . Чтобы оболочка создали файл брака/отхода, содержащий данные, интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) приложения должен поддерживать \_ Формат буфера обмена CF ембедсаурце. Для создания файла, содержащего ссылку, **IDataObject** должен поддерживать \_ Формат CF линксаурце.

Существуют также три дополнительные функции, которые приложение может реализовать для поддержки файлов брака/отхода:

-   Поддержка приема-передачи
-   Форматы кэшированных данных
-   Отложенная визуализация

### <a name="round-trip-support"></a>Поддержка приема-передачи

*Цикл обработки* включает передачу объекта данных в другой контейнер, а затем обратно в исходный документ. Например, пользователь может переместить группу ячеек из электронной таблицы на Рабочий стол, создавая файл брака/отхода с данными. Если пользователь затем перенесет отходы обратно в электронную таблицу, данные должны быть интегрированы в документ в том виде, в котором они находились до первоначальной передачи.

Когда оболочка создает файл брака/отхода, он представляет данные как объект внедрения. Когда отходы передаются в другой контейнер, он передается как объект внедрения, даже если он возвращается в исходный документ. Приложение отвечает за определение формата данных, содержащегося в отходах, и перевод данных обратно в собственный формат при необходимости.

Чтобы установить формат внедренного объекта, определите его идентификатор CLSID, извлекая \_ Формат обжектдескриптор объекта CF. Если идентификатор CLSID указывает на формат данных, принадлежащий приложению, он должен переносить собственные данные вместо вызова [**олекреатефромдата**](/windows/win32/api/ole2/nf-ole2-olecreatefromdata).

### <a name="cached-data-formats"></a>Форматы кэшированных данных

Когда оболочка создает файл брака/отхода, он проверяет реестр на наличие списка доступных форматов. По умолчанию доступны два формата: CF \_ ембедсаурце и CF \_ линксаурце. Однако существует ряд сценариев, в которых приложениям могут потребоваться файлы брака/отхода в разных форматах:

-   Значение, чтобы разрешить передачу отходов в контейнеры, отличные от OLE, которые не могут принимать внедренные форматы объектов.
-   Для обеспечения взаимодействия наборов приложений с частным форматом.
-   , Чтобы упростить обработку циклов обработки.

Приложения могут добавлять форматы в отходы путем их кэширования в реестре. Существует два типа кэшированных форматов:

-   Форматы кэша приоритета. Для этих форматов данные копируются целиком в отходы из объекта данных.
-   Форматы отложенной визуализации. Для этих форматов объект данных не копируется в отходы. Вместо этого отрисовка откладывается до тех пор, пока целевой объект не запросит данные. Более подробно в следующем разделе описывается отложенная визуализация.

Чтобы добавить в кэш приоритета или формат с отложенной отработкой, создайте подраздел " **Формат** данных" в ключе **CLSID** приложения, которое является исходным данными. В этом подразделе создайте подраздел **приоритикачеформатс** или **делайрендерформатс** . Для каждого кэша приоритетов или формата с отложенной просмотром создайте нумерованный подраздел, начинающийся с нуля. Установите значение этого параметра в виде строки с зарегистрированным именем формата или \# значения x, где X представляет номер формата стандартного формата буфера обмена.

В следующем примере показаны кэшированные форматы для двух приложений. Приложение MyProg1 имеет форматированный текст в формате кэша приоритетов и частный формат "мой формат" в виде формата с отложенной визуализацией. Приложение MyProg2 имеет \_ Формат битовой карты CF ( \# 8) в качестве формата кэша приоритета.

```
HKEY_CLASSES_ROOT
   CLSID
      {GUID}
         (Default) = MyProg1
         DataFormats
            PriorityCacheFormats
               0
                  (Default) = Rich Text Format
            DelayRenderFormats
               0
                  (Default) = My Format
      {GUID}
         (Default) = MyProg2
         DataFormats
            PriorityCacheFormats
               0
                  (Default) = #8
```

Дополнительные форматы можно добавить, создав дополнительные нумерованные подразделы.

### <a name="delayed-rendering"></a>Отложенная визуализация

Формат отложенной подготовки позволяет приложению создать файл брака/отхода, но отложить расходы на визуализацию данных до тех пор, пока они не будут запрошены целевым объектом. Интерфейс [**IDataObject**](/windows/win32/api/objidl/nn-objidl-idataobject) брака/отхода будет предлагать форматы отложенной отрисовки для целевого объекта вместе с собственными и кэшированными данными. Если целевой объект запрашивает формат отложенной подготовки, оболочка запустит приложение и предоставит данные целевому объекту из активного объекта.

> [!Note]  
> Поскольку отложенная визуализация довольно рискованна, ее следует использовать с осторожностью. Он не будет работать, если сервер недоступен, или для приложений, не поддерживающих OLE.

 

## <a name="dragging-and-dropping-shell-objects-asynchronously"></a>Асинхронное перетаскивание объектов оболочки

**Сценарий:** Пользователь передает большой блок данных из источника в целевую цель. Чтобы предотвратить блокировку обоих приложений в течение значительного промежутка времени, целевой объект извлекает данные асинхронно.

Как правило, операция перетаскивания выполняется в синхронном режиме. Краткое описание

1.  Drop Source вызывает [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) и блокирует его основной поток, пока функция не вернет значение. Блокировка основного потока обычно блокирует обработку пользовательского интерфейса.
2.  После вызова метода [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) целевой объект извлекает данные из объекта данных в своем основном потоке. Эта процедура обычно блокирует обработку пользовательского интерфейса целевого объекта на протяжении процесса извлечения.
3.  После извлечения данных целевой объект возвращает вызов [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) , система возвращает [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop), и оба потока могут продолжать работу.

В сокращенном случае синхронная передаваемые данные могут блокировать основные потоки обоих приложений в течение значительного промежутка времени. В частности, оба потока должны ждать, пока целевой объект извлечет данные. Для небольших объемов данных время, необходимое для извлечения данных, является небольшим, а синхронная — довольно хорошо. Однако синхронное извлечение больших объемов данных может привести к длительным задержкам и помешать пользовательскому интерфейсу как целевого, так и исходного кода.

Интерфейс [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**идатаобжектасинккапабилити**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) — это необязательный интерфейс, который может быть реализован объектом данных. Он дает цели перетаскивания возможность асинхронно извлекать данные из объекта данных в фоновом потоке. Когда извлечение данных передается в фоновый поток, основные потоки обоих приложений могут быть продолжены.

### <a name="using-iasyncoperationidataobjectasynccapability"></a>Использование IASyncOperation и Идатаобжектасинккапабилити

> [!Note]  
> Изначально интерфейс назывался [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)), но впоследствии он был изменен на [**идатаобжектасинккапабилити**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability). В противном случае два интерфейса идентичны.

 

Цель [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**идатаобжектасинккапабилити**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) заключается в том, чтобы разрешить источнику удаления и цели удаления согласованность данных, которые могут быть извлечены асинхронно. В следующей процедуре показано, как источник Drop использует интерфейс:

1.  Создайте объект данных, который предоставляет [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**идатаобжектасинккапабилити**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability).
2.  Вызовите [**сетасинкмоде**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-setasyncmode) с параметром *фдупасинк* , указав значение **Variant \_ true** , чтобы указать, что асинхронная операция поддерживается.
3.  После возврата [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) вызовет [**операцию**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation)вызова:
    -   Если при выполнении [**операции**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) происходит сбой или возвращается **\_ значение false**, выполняется обычная синхронная отправка данных и процесс извлечения данных завершается. Источник должен выполнить необходимую очистку и продолжать работу.
    -   Если функция [**OnOperation**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-inoperation) возвращает **\_ значение Variant true**, данные извлекаются асинхронно. Операции очистки должны обрабатываться [**ендоператион**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation).
4.  Освобождение объекта данных.
5.  По завершении асинхронной передаче данных объект данных обычно уведомляет источник через частный интерфейс.

В следующей процедуре показано, как цель Drop использует интерфейс [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**идатаобжектасинккапабилити**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) для асинхронного извлечения данных:

1.  Когда система вызывает [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop), вызовите [**IDataObject:: QueryInterface**](/windows/win32/api/unknwn/nf-unknwn-iunknown-queryinterface(q)) и запросите интерфейс [**IAsyncOperation**](/previous-versions//bb776309(v=vs.85)) / [**идатаобжектасинккапабилити**](/windows/desktop/api/Shldisp/nn-shldisp-idataobjectasynccapability) (IID \_ IAsyncOperation/IID \_ идатаобжектасинккапабилити) из объекта данных.
2.  Вызовите [**жетасинкмоде**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-getasyncmode). Если метод возвращает **\_ значение true**, объект данных поддерживает асинхронное извлечение данных.
3.  Создайте отдельный поток для обработки извлечения данных и вызова [**стартоператион**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-startoperation).
4.  Возвратите вызов [**интерфейс IDropTarget::D верхнем**](/windows/win32/api/oleidl/nf-oleidl-idroptarget-drop) , как и для обычной операции передачи данных. [**DoDragDrop**](/windows/win32/api/ole2/nf-ole2-dodragdrop) будет возвращать и разблокировать источник удаления. Не вызывайте метод [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) , чтобы указать результат оптимизированной операции перемещения или удаления. Дождитесь завершения операции.
5.  Извлечение данных в фоновом потоке. Основной поток целевого объекта разблокирован и свободен для продолжения.
6.  Если при переносе данных была [оптимизирована операция перемещения](#handling-optimized-move-operations) или [удаления при вставке](#handling-delete-on-paste-operations) , вызовите функцию [**IDataObject:: SetData**](/windows/win32/api/objidl/nf-objidl-idataobject-setdata) , чтобы указать результат.
7.  Уведомите объект данных о том, что извлечение завершено путем вызова [**ендоператион**](/windows/desktop/api/Shldisp/nf-shldisp-idataobjectasynccapability-endoperation).

 

 
