---
description: Функции обратного вызова из размещенных компонентов делают возможным размещение. Однако возможно, что размещенный компонент активировал другой контекст активации, используемый для доступа к подключаемым модулям или собственным компонентам.
ms.assetid: 794a2e2f-ba1f-48ad-a435-244fc7936097
title: Использование обратных вызовов из размещенных компонентов
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 8ef302601985bc7e56a296bc8f494e48e18d785e
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "104144497"
---
# <a name="using-callbacks-from-hosted-components"></a>Использование обратных вызовов из размещенных компонентов

Функции обратного вызова из размещенных компонентов делают возможным размещение. Однако возможно, что размещенный компонент активировал другой контекст активации, используемый для доступа к подключаемым модулям или собственным компонентам. В этом случае, если размещенный компонент оставляет в стеке контекст активации, ссылающийся на собственный COM-объект, приложение размещения может вызвать [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) , чтобы получить объект, который должен быть собственной реализацией, а вместо этого получить объект размещенного компонента. Чтобы предотвратить такое наследование контекстов активации, хорошим приложениям размещения следует сначала активировать свой собственный известный контекст активации во время обратного вызова.

Рассмотрим следующий пример, защищающий код ведущего приложения:

``` syntax
HRESULT STDCALL 
CHostingAppFirewall::ITheInterface::FunctWrapper()
{
    ULONG_PTR ulpCookie;
    HRESULT hRes = E_FAIL;
    if (!ActivateActCtx(this->m_hHostingAppContext, &ulpCookie))
        return HRESULT_FROM_WIN32(GetLastError());
    __try 
        {
        hRes = this->m_ITheInterface->Funct();
    } 
        __finally 
        {
        if (!DeactivateActCtx(0, ulpCookie))
            hRes = HRESULT_FROM_WIN32(GetLastError());
    }
    return hRes;
}
```

Это гарантирует, что правильный контекст активации будет установлен перед передачей запроса в некоторую внутреннюю реализацию **Func**. Ваша собственная реализация может иметь встроенную реализацию, но предыдущий метод обеспечивает более простое взаимодействие, просто создавая делегированные оболочки. Рекомендуется использовать аналогичный метод при предоставлении обычных обратных вызовов (не COM).

 

 
