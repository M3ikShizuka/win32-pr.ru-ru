---
description: Функции обратного вызова из размещенных компонентов делают возможным размещение. Однако возможно, что размещенный компонент активировал другой контекст активации, используемый для доступа к подключаемым модулям или собственным компонентам.
ms.assetid: 794a2e2f-ba1f-48ad-a435-244fc7936097
title: Использование обратных вызовов из размещенных компонентов
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 7fb13e61b83ba52f0f8dd5265b11585e8366c0e8558d45c5738f179d43df2eb5
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119884604"
---
# <a name="using-callbacks-from-hosted-components"></a>Использование обратных вызовов из размещенных компонентов

Функции обратного вызова из размещенных компонентов делают возможным размещение. Однако возможно, что размещенный компонент активировал другой контекст активации, используемый для доступа к подключаемым модулям или собственным компонентам. В этом случае, если размещенный компонент оставляет в стеке контекст активации, ссылающийся на собственный COM-объект, приложение размещения может вызвать [**CoCreateInstance**](/windows/win32/api/combaseapi/nf-combaseapi-cocreateinstance) , чтобы получить объект, который должен быть собственной реализацией, а вместо этого получить объект размещенного компонента. Чтобы предотвратить такое наследование контекстов активации, хорошим приложениям размещения следует сначала активировать свой собственный известный контекст активации во время обратного вызова.

Рассмотрим следующий пример, защищающий код ведущего приложения:

``` syntax
HRESULT STDCALL 
CHostingAppFirewall::ITheInterface::FunctWrapper()
{
    ULONG_PTR ulpCookie;
    HRESULT hRes = E_FAIL;
    if (!ActivateActCtx(this->m_hHostingAppContext, &ulpCookie))
        return HRESULT_FROM_WIN32(GetLastError());
    __try 
        {
        hRes = this->m_ITheInterface->Funct();
    } 
        __finally 
        {
        if (!DeactivateActCtx(0, ulpCookie))
            hRes = HRESULT_FROM_WIN32(GetLastError());
    }
    return hRes;
}
```

Это гарантирует, что правильный контекст активации будет установлен перед передачей запроса в некоторую внутреннюю реализацию **Func**. Ваша собственная реализация может иметь встроенную реализацию, но предыдущий метод обеспечивает более простое взаимодействие, просто создавая делегированные оболочки. Рекомендуется использовать аналогичный метод при предоставлении обычных обратных вызовов (не COM).

 

 
