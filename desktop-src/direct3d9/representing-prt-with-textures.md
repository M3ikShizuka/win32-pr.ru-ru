---
description: Пример Пртдемо и симулятор Прткмдлине, входящие в состав пакета SDK для DirectX, представляют векторы перемещения в вершинах сетки.
ms.assetid: cee049e8-3245-4fce-ab2f-ba251eacc72a
title: Представление PRT с текстурами (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e827e24258d75a91aa75c9eb51ed6563d476ab16f75fedc31a7071bca28a4a78
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118797928"
---
# <a name="representing-prt-with-textures-direct3d-9"></a>Представление PRT с текстурами (Direct3D 9)

Пример Пртдемо и симулятор Прткмдлине, входящие в состав пакета SDK для DirectX, представляют векторы перемещения в вершинах сетки. Чтобы точно представить сигнал PRT, это может потребовать тесселяции, которые могут оказаться непрактичными для текущих игр. Представление векторов перемещения в текстурных картах — это альтернативный подход, в котором стоимость данных зависит от сложности сетки. Существует несколько способов создания карт текстуры вектора перемещения с помощью библиотеки D3DX PRT.

## <a name="precomputing-transfer-vectors"></a>Предварительные вычисления векторов перемещения

Один из подходов — изменить примеры Пртдемо и Прткмдлине, чтобы вычислить вектор перемещения для каждого шаг текселя в параметризации поверхности. Для этого выполните следующие действия.

1.  Измените вызов [**D3DXCreatePRTEngine**](d3dxcreateprtengine.md) , чтобы извлечь координаты текстуры из сетки (екстрактувс должны иметь **значение true**).
2.  Замените вызовы [**D3DXCreatePRTBuffer**](d3dxcreateprtbuffer.md) на [**D3DXCreatePRTBufferTex**](d3dxcreateprtbuffertex.md) , используя тот же размер текстуры.

Все методы ID3DXPRTEngine работают с имитацией "на шаг текселя", за исключением: Компутебаунцеадаптиве, Компутессадаптиве, COMPUTE и Компутедиректлигхтингшадаптиве. В то время как имитация пространства текстуры создает правильный результат, он часто может оказаться довольно длительным, поскольку он, скорее всего, будет рассчитывать векторы перемещения с высокой плотностью.

Другой подход заключается в вычислении адаптивного имитации PRTа на вершину (с координатами текстуры, которые будут использоваться для каждого шаг текселя данных) и последующем вызове [**ID3DXPRTEngine:: ресамплебуффер**](id3dxprtengine--resamplebuffer.md) (с помощью выходного буфера, созданного с помощью [**D3DXCreatePRTBufferTex**](d3dxcreateprtbuffertex.md) с соответствующим разрешением). Это работает со всеми функциями D3DX PRT в пакете SDK и часто может быть гораздо более эффективным, чем прямое вычисление буфера обмена на шаг текселя.

## <a name="runtime-calculations"></a>Вычисления среды выполнения

Если используется один кластер, результаты могут быть отфильтрованы и MIP, как и любая другая текстура, и шейдер пикселей идентично коду шейдера вершин, который поставляется с Пртдемо.

Если сжатие создает несколько кластеров, вы не сможете фильтровать или mipmap данные, поскольку индексы кластеризации не являются непрерывными. Ниже приведены некоторые альтернативы для обработки нескольких кластерных данных.

-   Выполните все действия по фильтрации в шейдере пикселей. К сожалению, это непрактично для повышения производительности.
-   Если текстуры являются текстурами с низким разрешением, отличными от MIP, скорее всего, более эффективным будет просто вычислить освещение непосредственно в пространстве текстуры, где не будет выполняться фильтрация, и визуализировать объект с затененной текстурой. По сути, это динамическая Текстурная схема, которая полностью создана на GPU.
-   Если используется текстура Atlas (см. раздел [Использование уватлас (Direct3D 9)](using-uvatlas.md)), можно вручную выполнить кластеризацию сцены, получив все векторы перемещения в подключенном компоненте в пространстве текстуры в том же кластере. Таким образом можно отфильтровать текстуру, так как все пикселей текстуры, к которым осуществляется доступ, будут находиться в том же кластере, что и конструкция. ИДЕНТИФИКАТОР кластера для данного лица можно распространить из шейдера вершин.

Шейдеры пикселей имеют гораздо меньше постоянных регистров, которые не могут быть проиндексированы, поэтому построитель текстуры немного отличается от шейдера вершин. Хранение работы в кластере в динамической текстуре с низким разрешением и использование загрузок текстур является наиболее эффективным способом визуализации при использовании нескольких кластеров.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Предварительно вычисленный перенос Радианце](precomputed-radiance-transfer.md)
</dt> <dt>

[Демонстрационный пример PRT](https://msdn.microsoft.com/library/Ee418763(v=VS.85).aspx)
</dt> <dt>

[Симулятор PRT (prtcmdline.exe)](https://msdn.microsoft.com/library/Ee418766(v=VS.85).aspx)
</dt> </dl>

 

 



