---
description: Если у вас есть функциональное приложение Microsoft Direct3D и вы хотите повысить его производительность, обычно используется средство профилирования на полке или пользовательский метод измерения, чтобы измерять время, затрачиваемое на выполнение одного или нескольких вызовов интерфейса прикладного программирования (API). Если вы сделали это, но получаете результаты по времени, которые отличаются от одной последовательности отрисовки к следующей, или если вы выполняете такую проверку, которая не удерживает фактических результатов эксперимента, приведенные ниже сведения помогут понять причину.
ms.assetid: f969be42-d541-4e8d-aec4-eb9508bcc7cf
title: Точное профилирование вызовов API Direct3D (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: cdb6d60fcc1b3ace4112dbf7028d91e2c9c8b345
ms.sourcegitcommit: d75fc10b9f0825bbe5ce5045c90d4045e3c53243
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/13/2021
ms.locfileid: "127053044"
---
# <a name="accurately-profiling-direct3d-api-calls-direct3d-9"></a>Точное профилирование вызовов API Direct3D (Direct3D 9)

-   [Точное профилирование Direct3D сложно](#accurately-profiling-direct3d-is-difficult)
-   [Как точно пропрофилировать последовательность визуализации Direct3D](#how-to-accurately-profile-a-direct3d-render-sequence)
-   [Профилирование изменений состояния Direct3D](#profiling-direct3d-state-changes)
-   [Сводка](#summary)
-   [Приложение](#appendix)

Если у вас есть функциональное приложение Microsoft Direct3D и вы хотите повысить его производительность, обычно используется средство профилирования на полке или пользовательский метод измерения, чтобы измерять время, затрачиваемое на выполнение одного или нескольких вызовов интерфейса прикладного программирования (API). Если вы сделали это, но получаете результаты по времени, которые отличаются от одной последовательности отрисовки к следующей, или если вы выполняете такую проверку, которая не удерживает фактических результатов эксперимента, приведенные ниже сведения помогут понять причину.

Приведенные здесь сведения основаны на предположении, что у вас есть знания и опыт работы со следующими возможностями.

-   Программирование C/C++
-   Программирование Direct3D API
-   Измерение времени API
-   Видеоадаптер и его драйвер программного обеспечения
-   Возможные необъяснимые результаты из предыдущего процесса профилирования

## <a name="accurately-profiling-direct3d-is-difficult"></a>Точное профилирование Direct3D сложно

Профилировщик сообщает о количестве времени, затраченном на каждый вызов API. Это делается для повышения производительности путем поиска и настройки гиперобъектов. Существуют различные виды профилировщиков и методов профилирования.

-   Профилировщик с выборкой находится в неактивном состоянии, воздействующем на определенные интервалы времени на выборку (или на запись) выполняемых функций. Он возвращает процент времени, затраченного на каждый вызов. Как правило, профилирование с выборкой не очень негативно сказывается на работе приложения и оказывает минимальное влияние на нагрузку приложения.
-   Профилировщик инструментирования измеряет фактическое время, необходимое для возврата вызова. Для этого требуется компиляция начальных и системных разделителей в приложение. Инструментированный профилировщик сравнительно более неагрессивен для приложения, чем выборочный профилировщик.
-   Также можно использовать пользовательский метод профилирования с высокопроизводительным таймером. Это создает результаты очень похоже на инструментирование профилировщика.

Тип профайлера или используемого метода профилирования является лишь частью задачи создания точных измерений.

Профилирование дает ответы на вопросы, которые помогут вам в бюджетировании производительности. Предположим, что в результате вызова API будет вычисляться среднее время выполнения цикла, равное 1000. Вы можете утверждать некоторые выводы о производительности, например следующие:

-   ЦП с частотой 2 ГГц (который тратит 50% времени на отрисовку) ограничивается вызовом этого API 1 000 000 раз в секунду.
-   Для достижения 30 кадров в секунду Этот API нельзя вызывать более 33 000 раз в кадре.
-   В кадре можно обрабатывать только объекты 3.3 кбит (при условии, что 10 из этих вызовов API для каждой последовательности отрисовки объекта).

Иными словами, если у вас достаточно времени на вызов API, можно ответить на вопрос о бюджетировании, например число примитивов, которые могут быть отображены в интерактивном режиме. Но необработанные значения, возвращаемые инструментированным профилировщиком, не будут точно отвечать на вопросы о бюджетировании. Это связано с тем, что графический конвейер имеет сложные проблемы проектирования, такие как количество компонентов, которые должны выполнять работу, число процессоров, управляющих работой потоков между компонентами, и стратегии оптимизации, реализованные в среде выполнения, и в драйвере, предназначенном для повышения эффективности конвейера.

### <a name="each-api-call-goes-through-several-components"></a>Каждый вызов API проходит через несколько компонентов.

Каждый вызов обрабатывается несколькими компонентами по своему пути от приложения до видеоадаптера. Например, рассмотрим следующую последовательность отрисовки, содержащую два вызова для рисования одного треугольника:


```
SetTexture(...);
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
```



На следующей концептуальной схеме показаны различные компоненты, с помощью которых должны проходить вызовы.

![Схема графических компонентов, которые проходят вызовы API](images/microbenchmarkinstructionflow2.png)

Приложение вызывает Direct3D, который управляет сценой, обрабатывает взаимодействие с пользователем и определяет, как выполняется отрисовка. Вся эта работа указана в последовательности отрисовки, которая отправляется в среду выполнения с помощью вызовов API Direct3D. Последовательность прорисовки практически не зависит от оборудования (т. е. вызовы API являются аппаратно независимыми, но приложение имеет знания о том, какие функции поддерживает видеоадаптер).

Среда выполнения преобразует эти вызовы в независимый от устройства формат. Среда выполнения обрабатывает все взаимодействие между приложением и драйвером, чтобы приложение выполнялось на более чем одном совместимом оборудовании (в зависимости от необходимых функций). При измерении вызова функции инструментированный профилировщик измеряет время, затраченное на выполнение функции, а также время возвращения функции. Одно из ограничений инструментирования профилировщика состоит в том, что оно может не включать время, которое драйвер отправляет на видеокарту, а также время, когда видеоадаптер обрабатывает работу. Иными словами, профилировщику с инструментированием не удается присвоить атрибуту всю работу, связанную с каждым вызовом функции.

Драйвер программного обеспечения использует сведения о видеоадаптере для преобразования аппаратно-независимых команд в последовательность команд видеоадаптера. Драйверы также могут оптимизировать последовательность команд, отправляемых на видеоадаптер, чтобы визуализация на видеоадаптере была выполнена эффективно. Эти оптимизации могут вызвать проблемы с профилированием, так как объем выполненной работы не так, как кажется (вам, возможно, потребуется разобраться с оптимизацией для их учета). Драйвер, как правило, возвращает управление среде выполнения до того, как видеоадаптер завершит обработку всех команд.

Видеоадаптер выполняет большую часть отрисовки, объединяя данные из буферов вершин и индексов, текстур, сведения о состоянии отрисовки и команды графики. После завершения подготовки к просмотру видеоадаптера работа, созданная из последовательности отрисовки, завершена.

Каждый вызов API Direct3D должен обрабатываться каждым компонентом (средой выполнения, драйвером и видеоадаптером) для отрисовки любых данных.

### <a name="there-is-more-than-one-processor-controlling-the-components"></a>Существует несколько процессоров, управляющих компонентами

Связь между этими компонентами еще более сложна, так как приложение, среда выполнения и драйвер управляются одним процессором, а видеоадаптер управляется отдельным процессором. На следующей схеме показаны два типа процессоров: Центральный вычислительный блок (ЦП) и графический процессор (GPU).

![Схема ЦП и GPU и их компонентов](images/microbenchmarkprocessors.png)

Системы PC Systems имеют по крайней мере один ЦП и один GPU, но могут иметь несколько из них или оба. Процессоры находятся на материнской плате, а графические процессоры расположены на материнской плате или на видеоадаптере. Скорость ЦП определяется микросхемой часов на материнской плате, а скорость GPU определяется отдельной микросхемой. Часы ЦП определяют скорость работы, выполняемую приложением, средой выполнения и драйвером. Приложение отправляет работу на графический процессор через среду выполнения и драйвер.

ЦП и GPU обычно работают с разными скоростями, не зависящими друг от друга. GPU может реагировать на работу, как только будет доступна работа (предполагая, что GPU завершил обработку предыдущей работы). Работа GPU выполняется параллельно с работой ЦП, выделенной изогнутой линией на рисунке выше. Профилировщик обычно измеряет производительность ЦП, а не GPU. Это усложняет профилирование, поскольку измерения, выполняемые инструментированием профилировщика, включают время ЦП, но могут не включать время GPU.

Назначение графического процессора заключается в том, чтобы отключать обработку от ЦП к процессору, специально разработанному для работы графики. На современных видеоадаптерах графический процессор заменяет большую часть работы по преобразованию и освещению в конвейере от ЦП до GPU. Это значительно сокращает нагрузку на ЦП, освобождая больше циклов ЦП для другой обработки. Чтобы настроить графическое приложение для пиковой производительности, необходимо измерять производительность ЦП и GPU, а также распределять работу между двумя типами процессоров.

В этом документе не рассматриваются темы, связанные с измерением производительности GPU или балансировкой работы между ЦП и GPU. Если вы хотите лучше понять производительность GPU (или определенного видеоадаптера), посетите веб-сайт поставщика, чтобы найти дополнительные сведения о производительности GPU. Вместо этого этот документ посвящен работе, выполняемой средой выполнения и драйвером, уменьшая объем работы GPU до незначительного объема. Это, в части, основано на том, что приложения, на которых возникают проблемы с производительностью, обычно ограничены ЦП.

### <a name="runtime-and-driver-optimizations-can-mask-api-measurements"></a>Оптимизация среды выполнения и драйвера может маскировать измерения API

В среде выполнения встроена оптимизация производительности, которая может привести к переполнению измерения отдельного вызова. Ниже приведен пример сценария, демонстрирующий эту проблему. Рассмотрим следующую последовательность визуализации:


```
  BeginScene();
    ...
    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);
    ...
  EndScene();
  Present();
```



Пример 1. простая последовательность отображения

Просмотрев результаты двух вызовов в последовательности отрисовки, инструментированный профилировщик может вернуть результаты, аналогичные приведенным ниже.


```
Number of cycles for SetTexture       : 100
Number of cycles for DrawPrimitive    : 950,500
```



Профилировщик возвращает количество циклов ЦП, необходимых для обработки работы, связанной с каждым вызовом (Помните, что графический процессор не включен в эти числа, так как GPU еще не начал работать над этими командами). Поскольку [**IDirect3DDevice9::D равпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) требуется почти миллион циклов для обработки, можно заключить, что он не очень эффективен. Тем не менее вы вскоре узнаете, почему это заключение неверно и как можно создать результаты, которые можно использовать для бюджетирования.

### <a name="measuring-state-changes-requires-careful-render-sequences"></a>Измерение изменений состояния требует тщательного отображения последовательностей

Все вызовы, кроме [**IDirect3DDevice9::D равпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), [**дравиндекседпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive)или [**clear**](/windows/desktop/api) (например, [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), [**сетвертексдекларатион**](/windows/desktop/api)и [**сетрендерстате**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)) создают изменение состояния. Каждое изменение состояния задает состояние конвейера, которое определяет, как будет выполняться подготовка к просмотру.

Оптимизации в среде выполнения и (или) драйвере предназначены для ускорения подготовки к просмотру путем уменьшения объема требуемой работы. Ниже приведены две оптимизации изменения состояния, которые могут засоряла средние значения профиля:

-   Драйвер (или среда выполнения) может сохранить изменение состояния в локальном состоянии. Так как драйвер может работать в "ленивом" алгоритме (откладывать работу до абсолютной необходимости), работа, связанная с некоторыми изменениями состояния, может быть отложена.
-   Среда выполнения (или драйвер) может удалять изменения состояния путем оптимизации. Примером этого может быть удаление избыточного изменения состояния, которое отключает освещение, так как освещение ранее было отключено.

Нет никаких бесполезностей для просмотра последовательности отрисовки и выполнения изменений состояния, которые будут задавать «грязный» бит и откладывать работу, или просто будут удалены при оптимизации. Даже если вы могли бы определять оптимизированные изменения состояния в сегодняшней среде выполнения или драйвере, то, скорее всего, будет обновляться среда выполнения завтрашнего дня или драйвер. Вы также не знакомы с предыдущим состоянием, поэтому трудно определить избыточные изменения состояния. Единственным способом проверки затрат на изменение состояния является измерение последовательности отрисовки, включающей изменения состояния.

Как видите, сложность, вызванная наличием нескольких процессоров, команд, обрабатываемых более чем одним компонентом, и оптимизации, встроенные в компоненты, затрудняют прогнозирование. В следующем разделе будут рассмотрены все проблемы, связанные с профилированием. Примеры последовательностей визуализации Direct3D будут показаны с использованием сопутствующих методик измерения. С помощью этих знаний вы сможете создавать точные и повторяемые измерения для отдельных вызовов.

## <a name="how-to-accurately-profile-a-direct3d-render-sequence"></a>Как точно пропрофилировать последовательность визуализации Direct3D

Теперь, когда некоторые проблемы профилирования были выделены, в этом разделе будут показаны методы, которые помогут создать измерения профиля, которые можно использовать для бюджетирования. Точные, повторяемые измерения профилирования возможны, если вы понимаете связь между компонентами, управляемыми ЦП, и как избежать оптимизации производительности, реализованной средой выполнения и драйвером.

Для начала необходимо точно измерять время выполнения одного вызова API.

### <a name="pick-an-accurate-measurement-tool-like-queryperformancecounter"></a>Выберите точный инструмент измерения, например QueryPerformanceCounter

операционная система Microsoft Windows включает таймер высокого разрешения, который можно использовать для измерения времени, затраченного на высокое разрешение. Текущее значение одного такого таймера можно вернуть с помощью [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter). После вызова **QueryPerformanceCounter** для возврата начальных и системных значений разница между двумя значениями может быть преобразована в фактическое затраченное время (в секундах) с помощью **QueryPerformanceCounter**.

преимущества использования [**QueryPerformanceCounter**](/windows/win32/api/profileapi/nf-profileapi-queryperformancecounter) в том, что они доступны в Windows и просты в использовании. Просто заключите вызовы в вызов **QueryPerformanceCounter** и сохраните значения Start и останавливают. Поэтому в этом документе показано, как использовать **QueryPerformanceCounter** для профилирования времени выполнения, аналогично тому, как средство профилирования профилировщика будет его измерять. Ниже приведен пример, демонстрирующий внедрение **QueryPerformanceCounter** в исходный код:


```
  BeginScene();
    ...
    // Start profiling
    LARGE_INTEGER start, stop, freq;
    QueryPerformanceCounter(&start);

    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1); 

    QueryPerformanceCounter(&stop);
    stop.QuadPart -= start.QuadPart;
    QueryPerformanceFrequency(&freq);
    // Stop profiling
    ...
  EndScene();
  Present();
```



Пример 2. Реализация пользовательского профилирования с помощью QPC

Запуск и завершение — это два больших целых числа, которые будут содержать значения Start и остановки, возвращаемые высокопроизводительным таймером. Обратите внимание, что QueryPerformanceCounter (&Start) вызывается непосредственно перед [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) и QueryPerformanceCounter (&остановкой) вызывается сразу после [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive). После получения значения для параметра Куериперформанцефрекуенци вызывается метод, возвращающий freq, который является частотой таймера с высоким разрешением. В этом гипотетическом примере предположим, что вы получаете следующие результаты для Start, останавливаюте и FREQ:



| Локальная переменная | Число тактов |
|----------------|-----------------|
| start          | 1792998845094   |
| stop           | 1792998845102   |
| FREQ           | 3579545         |



 

Эти значения можно преобразовать в число циклов, требуемых для выполнения вызовов API следующим образом:


```
# ticks = (stop - start) = 1792998845102 - 1792998845094 = 8 ticks

# cycles = CPU speed * number of ticks / QPF
# 4568   = 2 GHz      * 8              / 3,579,545
```



Иными словами, для обработки [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) и [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) на этом компьютере с тактовой частотой 2 ГГц требуется около 4568 тактов процессора. Эти значения можно преобразовать в фактическое время, затраченное на выполнение всех вызовов, таких как:


```
(stop - start)/ freq = elapsed time
8 ticks / 3,579,545 = 2.2E-6 seconds or between 2 and 3 microseconds.
```



Для использования QueryPerformanceCounter необходимо добавить в последовательность отображения начальные и останавливаемые измерения и использовать Куериперформанцефрекуенци для преобразования разницы (количества тактов) в число циклов ЦП или в фактическое время. Определение метода измерения — хороший запуск для разработки пользовательской реализации профилирования. Но прежде чем начать делать измерения, необходимо знать, как работать с видеоадаптером.

### <a name="focus-on-cpu-measurements"></a>Сосредоточьтесь на измерениях ЦП

Как упоминалось ранее, ЦП и GPU работают параллельно для обработки работы, создаваемой вызовами API. Реальное приложение требует профилирования обоих типов процессоров, чтобы определить, ограничено ли приложение процессором или GPU. Так как производительность GPU зависит от поставщика, в этом документе будет очень сложно выдать результаты, охватывающие множество доступных видеоадаптеров.

Вместо этого в этом документе основное внимание уделяется профилированию работы, выполняемой ЦП, с помощью пользовательского метода измерения работы среды выполнения и драйвера. Работа GPU будет снижена до незначительного размера, чтобы результаты ЦП были более видны. Одним из преимуществ такого подхода является то, что этот метод дает результаты в приложении, которое можно сопоставить с вашими измерениями. Чтобы сократить объем работ, требуемый для видеоадаптера, на незначительный уровень, просто Сократите работу по отрисовке до минимально возможной суммы. Это можно сделать, ограничивая вызовы рисования для отрисовки одного треугольника, и можно дополнительно ограничить, чтобы каждый треугольник содержал только один пиксель.

Единица измерения, используемая в этом документе для измерения объема работы ЦП, зависит от количества тактов процессора, а не от фактического времени. Циклы тактовой частоты ЦП имеют преимущество для более переносимых (для приложений с ограниченным доступом к ЦП), чем прошедшее время на компьютерах с разными скоростями ЦП. При необходимости это можно легко преобразовать в реальное время.

В этом документе не рассматриваются темы, связанные с балансировкой рабочей нагрузки между ЦП и GPU. Помните, что цель этого документа — не измерять общую производительность приложения, но чтобы продемонстрировать, как точно измерять время, затрачиваемое средой выполнения и драйвером для обработки вызовов API. С помощью этих точных измерений можно выполнять задачи по бюджетированию ЦП, чтобы понять определенные сценарии производительности.

### <a name="controlling-runtime-and-driver-optimizations"></a>Управление оптимизацией среды выполнения и драйверов

При обнаружении методики измерения и стратегии сокращения работы GPU необходимо понимать, какие оптимизации среда выполнения и драйвер получаются при профилировании.

Работу ЦП можно разделить на три сегмента: приложение работает, работа среды выполнения и драйвер работает. Проигнорируйте работу приложения, так как она находится под контролем программиста. С точки зрения приложения среда выполнения и драйвер подобны черным прямоугольникам, так как приложение не контролирует то, что реализовано в них. Ключом является понимание методов оптимизации, которые могут быть реализованы в среде выполнения и драйвере. Если вы не понимаете эти оптимизации, очень просто перейти к неправильному завершению работы ЦП на основе измерений профиля. В частности, существует две темы, которые называются буфером команд и что можно сделать для маскировки профилирования. К ним относятся следующие.

-   Оптимизация среды выполнения с помощью буфера команд. Буфер команд — это оптимизация среды выполнения, которая сокращает влияние перехода режима на режимы. Сведения об управлении временем перехода режима см. в разделе [Управление буфером команд](#controlling-the-command-buffer).
-   Отрицание временных последствий буфера команд. Прошедшее время перехода режима может оказать значительное влияние на измерения профилирования. Стратегия для этого заключается в том, чтобы [сделать последовательность отрисовки значительной по сравнению с переходом режима](#make-the-render-sequence-large-compared-to-the-mode-transition).

### <a name="controlling-the-command-buffer"></a>Управление буфером команд

Когда приложение выполняет вызов API, среда выполнения преобразует вызов API в независимый от устройства формат (который мы вызываем команду) и сохраняет его в буфер команд. Буфер команд добавляется на следующую схему.

![Схема компонентов ЦП, включая буфер команд](images/microbenchmarkcommandbuffer2.png)

Каждый раз, когда приложение выполняет другой вызов API, среда выполнения повторяет эту последовательность и добавляет еще одну команду в буфер команд. В некоторый момент времени среда выполнения очищает буфер (отправляя команды в драйвер). в Windows XP очистка буфера команд приводит к переключению режима работы операционной системы из среды выполнения (выполняется в пользовательском режиме) на драйвер (работающий в режиме ядра), как показано на следующей схеме.

-   Пользовательский режим — непривилегированный процессорный режим, который выполняет код приложения. Приложения пользовательского режима не могут получить доступ к системным данным, за исключением системных служб.
-   режим ядра — привилегированный процессорный режим, в котором выполняется код, основанный на Windows. Драйвер или поток, работающий в режиме ядра, имеет доступ ко всей системной памяти, прямой доступ к оборудованию и инструкциям ЦП для выполнения операций ввода-вывода с оборудованием.

![схема переходов между пользовательским режимом и режимом ядра](images/microbenchmarkcommandbuffer3.png)

Переход происходит каждый раз, когда ЦП переключается от пользователя в режим ядра (и наоборот), а необходимое количество циклов — по сравнению с отдельным вызовом API. Если среда выполнения отправила каждый вызов API к драйверу при его вызове, каждый вызов API получит стоимость перехода в режим.

Вместо этого буфер команд представляет собой оптимизацию среды выполнения, предназначенную для уменьшения эффективных затрат на переход в режим. Буфер команд помещает в очередь множество команд драйвера при подготовке к переходу в одном режиме. Когда среда выполнения добавляет команду в буфер команд, управление возвращается в приложение. Профилировщик не может знать, что команды драйвера, вероятно, еще не были отправлены в драйвер. В результате результаты, возвращаемые профилировщиком для инструментирования от полки, являются недопустимыми, так как они измеряют работу среды выполнения, но не связаны с работой драйвера.

### <a name="profile-results-without-a-mode-transition"></a>Результаты профилирования без перехода в режим

С помощью последовательности отрисовки из примера 2 ниже приведены некоторые типичные измерения времени, иллюстрирующие величину перехода в режим режима. При условии, что вызовы [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) и [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) не приводят к переходу в режим, то профилировщик с инструментированием от полки может возвращать примерно такие результаты:


```
Number of cycles for SetTexture           : 100
Number of cycles for DrawPrimitive        : 900
```



Каждое из этих чисел — время, затрачиваемое средой выполнения на добавление этих вызовов в буфер команд. Поскольку переход в режим отсутствует, драйвер еще не выполнил никаких действий. Результаты работы профилировщика являются точными, но они не измеряют всю работу, которую последовательность визуализации в конечном итоге приведет к выполнению ЦП.

### <a name="profile-results-with-a-mode-transition"></a>Профилирование результатов с переходом режима

Теперь посмотрим, что происходит в том же примере, когда происходит переход в режим. На этот раз предположим, что [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) и [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) приводят к переходу в режим. Опять же, профилировщик с инструментированием от полки может вернуть результаты, аналогичные приведенным ниже.


```
Number of cycles for SetTexture           : 98 
Number of cycles for DrawPrimitive        : 946,900
```



Время, измеряемое для [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) , равно тому же, но значительное увеличение количества времени, затраченного на [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , связано с переходом в режим. Вот что происходит:

1.  Предположим, что буфер команд содержит место для одной команды перед началом последовательности отрисовки.
2.  [**Сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) преобразуется в независимый от устройства формат и добавляется в буфер команд. В этом сценарии этот вызов заполняет буфер команд.
3.  Среда выполнения пытается добавить [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) в буфер команд, но не может, так как заполнена. Вместо этого среда выполнения очищает буфер команд. Это приводит к переходу в режим ядра. Предположим, что переход занимает около 5000 циклов. На этот раз тратится время, потраченное на **дравпримитиве**.
4.  Затем драйвер обрабатывает работу, связанную со всеми командами, которые были очищены из буфера команд. Предположим, что время драйвера для обработки команд, почти заполненных буфером команд, составляет примерно 935 000 циклов. Предположим, что работа драйвера, связанная с [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) , составляет около 2750 циклов. На этот раз тратится время, потраченное на [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).
5.  Когда драйвер завершает свою работу, переход пользовательского режима возвращает управление среде выполнения. Буфер команд теперь пуст. Предположим, что переход занимает около 5000 циклов.
6.  Последовательность отрисовки завершается путем преобразования [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) и ее добавления в буфер команд. Предположим, что это займет около 900 циклов. На этот раз тратится время, потраченное на **дравпримитиве**.

Обобщая результаты, вы увидите следующее:


```
DrawPrimitive = kernel-transition + driver work    + user-transition + runtime work
DrawPrimitive = 5000              + 935,000 + 2750 + 5000            + 900
DrawPrimitive = 947,950  
```



Точно так же, как измерение для [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) без перехода в режим (900 циклов), измерение для **дравпримитиве** с переходом режима (947 950 циклов) является точным, но бесполезным в плане работы ЦП при бюджетировании. Результат содержит правильную работу среды выполнения, драйвер работает для [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture), драйвер работает для всех команд, предшествующих **сеттекстуре**, и режимов перехода в два режима. Однако в измерении отсутствует работа драйвера **дравпримитиве** .

Переход режима может произойти в ответ на любой вызов. Это зависит от того, что ранее было в буфере команд. Необходимо управлять переходом режима, чтобы понять, какой объем работы ЦП (среда выполнения и драйвер) связан с каждым вызовом. Для этого необходим механизм управления буфером команд и временем перехода в режим.

### <a name="the-query-mechanism"></a>Механизм запросов

Механизм запросов в Microsoft Direct3D 9 был разработан таким образом, чтобы среда выполнения выполняла запрос GPU для выполнения и возвращала определенные данные из GPU. При профилировании, если работа GPU сведена к минимальным последствиям для снижения производительности, вы можете вернуть состояние из графического процессора, чтобы помочь измерять работу драйвера. В конце концов, работа драйвера будет завершена, когда GPU просмотрел команды драйвера. Кроме того, механизм запросов может быть коаксед для управления двумя характеристиками буфера команд, которые важны для профилирования: когда буфер команд очищается и сколько работы находится в буфере.

Вот та же последовательность отрисовки, использующая механизм запросов:


```
// 1. Create an event query from the current device
IDirect3DQuery9* pEvent;
m_pD3DDevice->CreateQuery(D3DQUERYTYPE_EVENT, &pEvent);

// 2. Add an end marker to the command buffer queue.
pEvent->Issue(D3DISSUE_END);

// 3. Empty the command buffer and wait until the GPU is idle.
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;

// 4. Start profiling
LARGE_INTEGER start, stop;
QueryPerformanceCounter(&start);

// 5. Invoke the API calls to be profiled.
SetTexture(...);
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 1);

// 6. Add an end marker to the command buffer queue.
pEvent->Issue(D3DISSUE_END);

// 7. Force the driver to execute the commands from the command buffer.
// Empty the command buffer and wait until the GPU is idle.
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;
    
// 8. End profiling
QueryPerformanceCounter(&stop);
```



Пример 3. Использование запроса для управления буфером команд

Ниже приведено более подробное описание каждой из этих строк кода.

1.  Создайте запрос события, создав объект запроса с \_ событием D3DQUERYTYPE.
2.  Добавьте маркер события запроса в буфер команд, вызвав вызываемую [**ошибку**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue)([**D3DISSUE \_ End**](d3dissue-end.md)). Этот маркер сообщает драйверу о том, что GPU завершает выполнение команд, предшествующих маркеру.
3.  Первый вызов очищает буфер команд, так как вызов [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) с [**D3DGETDATA \_ flush**](d3dgetdata-flush.md) приводит к очистке буфера команд. Каждый последующий вызов выполняет проверку графического процессора, чтобы увидеть, когда он завершает обработку всех команд буфера работы. Этот цикл не возвращает \_ ОК, пока GPU не простаивает.
4.  Пример времени начала.
5.  Вызов API, для которого выполняется профилирование.
6.  Добавьте второй маркер события запроса в буфер команд. Этот маркер будет использоваться для отслеживания завершения вызовов.
7.  Первый вызов очищает буфер команд, так как вызов [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) с [**D3DGETDATA \_ flush**](d3dgetdata-flush.md) приводит к очистке буфера команд. Когда GPU заканчивает обработку всех команд для работы с буфером, метод **GetData** возвращает \_ ОК, а цикл завершается из-за бездействия GPU.
8.  Пример времени окончания.

Ниже приведены результаты, измеряемые с помощью QueryPerformanceCounter и Куериперформанцефрекуенци:



| Локальная переменная | Число тактов |
|----------------|-----------------|
| start          | 1792998845060   |
| stop           | 1792998845090   |
| FREQ           | 3579545         |



 

Повторное преобразование тактов в циклы (на компьютере с тактовой частотой 2 ГГц):


```
# ticks  = (stop - start) = 1792998845090 - 1792998845060 = 30 ticks
# cycles = CPU speed * number of ticks / QPF
# 16,450 = 2 GHz      * 30             / 3,579,545
```



Ниже приведена разбивка количества циклов на один вызов:


```
Number of cycles for SetTexture           : 100
Number of cycles for DrawPrimitive        : 900
Number of cycles for Issue                : 200
Number of cycles for GetData              : 16,450
```



Механизм запросов позволял нам управлять средой выполнения и измеряемой работой драйвера. Чтобы понять каждое из этих чисел, выполните следующие действия в ответ на каждый из вызовов API, а также предполагаемое время:

1.  Первый вызов очищает буфер команд путем вызова метода [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) с [**D3DGETDATA \_ flush**](d3dgetdata-flush.md). Когда GPU заканчивает обработку всех команд для работы с буфером, метод **GetData** возвращает \_ ОК, а цикл завершается из-за бездействия GPU.
2.  Последовательность отрисовки начинается с преобразования [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) в независимый от устройства формат и его добавления в буфер команд. Предположим, что это займет около 100 циклов.
3.  [**Дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) преобразуется и добавляется в буфер команд. Предположим, что это займет около 900 циклов.
4.  [**Ошибка**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) добавляет маркер запроса в буфер команд. Предположим, что это займет около 200 циклов.
5.  Метод [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) вызывает очистку буфера команд, что приводит к принудительному переходу в режиме ядра. Предположим, что это займет около 5000 циклов.
6.  Затем драйвер обрабатывает работу, связанную со всеми четырьмя вызовами. Предположим, что время драйвера для обработки [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) составляет около 2964 циклов, [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) составляет около 3600 циклов, [**выдается**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-issue) около 200 циклов. Поэтому общее время драйвера для всех четырех команд составляет примерно 6450 циклов.
    > [!Note]  
    > Драйвер также потребует немного времени для просмотра состояния GPU. Поскольку работа GPU является тривиальной, графический процессор уже должен быть выполнен. Метод [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) возвратит S \_ ОК в зависимости от вероятности завершения GPU.

     

7.  Когда драйвер завершает свою работу, переход пользовательского режима возвращает управление среде выполнения. Буфер команд теперь пуст. Предположим, что это займет около 5000 циклов.

К числу для [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) относятся:


```
GetData = kernel-transition + driver work + user-transition
GetData = 5000              + 6450        + 5000           
GetData = 16,450  

driver work = SetTexture + DrawPrimitive + Issue = 
driver work = 2964       + 3600          + 200   = 6450 cycles 
```



Механизм запросов, используемый в сочетании с QueryPerformanceCounter, измеряет всю работу ЦП. Это делается с помощью сочетания маркеров запросов и сравнения состояния запросов. Для управления объемом работы в буфере используются маркеры запроса запуска и завершения, добавленные в буфер команд. В ожидании, пока не будет возвращен правильный код возврата, начальное измерение будет выполнено непосредственно перед началом чистой последовательности отрисовки, а измерение «завершение» будет выполнено сразу после того, как драйвер завершит работу, связанную с содержимым буфера команд. Это эффективно захватывает работу ЦП, выполняемую средой выполнения, а также драйвером.

Теперь, когда вы узнаете о буфере команд и о том, что он может иметь при профилировании, следует иметь в курсе несколько других условий, которые могут вызвать очистку буфера команд средой выполнения. Их необходимо отслеживать в последовательностях рендеринга. Некоторые из этих условий выполняются в ответ на вызовы API, а другие — в ответ на изменения ресурсов в среде выполнения. Любое из следующих условий приведет к переходу в режим:

-   Когда один из методов блокировки ([**Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dvertexbuffer9-lock)) вызывается в буфере вершин, буфере индекса или текстуре (при определенных условиях с определенными флагами).
-   При создании буфера устройства или вершин, буфер индекса или текстуры.
-   Когда буфер устройства или вершина, буфер или текстура уничтожаются в последнем выпуске.
-   При вызове [**валидатедевице**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-validatedevice) .
-   При его [**наличии**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) вызывается.
-   При заполнении буфера команд.
-   Когда метод [**GetData**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dquery9-getdata) вызывается с D3DGETDATA \_ Flush.

Следите за этими условиями в последовательностях рендеринга. Каждый раз, когда добавляется переход в режим, в измерения профилирования будут добавлены 10 000 циклов работы драйвера. Кроме того, буфер команд не имеет статического размера. Среда выполнения может изменить размер буфера в ответ на объем работы, создаваемый приложением. Это еще одна оптимизация, зависящая от последовательности отрисовки.

Поэтому будьте внимательны при переходе в режим управления во время профилирования. Механизм запросов предлагает надежный метод для очистки буфера команд, чтобы можно было управлять временем перехода в режим, а также объемом работы, которую содержит буфер. Однако даже этот метод можно улучшить, уменьшая время перехода в режим, чтобы сделать его несущественным в отношении измеряемого результата.

### <a name="make-the-render-sequence-large-compared-to-the-mode-transition"></a>Сделать последовательность отрисовки значительной по сравнению с переходом режима

В предыдущем примере переключение режима ядра и коммутатора пользовательского режима потребляют около 10 000 циклов, не имеющих никаких действий со средой выполнения и драйвером. Так как переход режима встроен в операционную систему, его нельзя уменьшить до нуля. Чтобы обеспечить незначительное переключение режима, последовательность отрисовки должна быть скорректирована таким образом, чтобы драйвер и среда выполнения работали в порядке, отличном от переключения режима. Вы можете попытаться выполнить вычитание для удаления переходов, но амортизация на более крупную стоимость последовательности визуализации более надежна.

Стратегия уменьшения переходов в режиме, пока не становится несущественной, заключается в добавлении цикла в последовательность отрисовки. Например, рассмотрим результаты профилирования, если добавляется цикл, который повторяет последовательность отрисовки 1500 раз:


```
// Initialize the array with two textures, same size, same format
IDirect3DTexture* texArray[2];

CreateQuery(D3DQUERYTYPE_EVENT, pEvent);
pEvent->Issue(D3DISSUE_END);
while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;

LARGE_INTEGER start, stop;
// Now start counting because the video card is ready
QueryPerformanceCounter(&start);

// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  SetTexture(taxArray[i%2]);
  DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
}

pEvent->Issue(D3DISSUE_END);

while(S_FALSE == pEvent->GetData( NULL, 0, D3DGETDATA_FLUSH ))
    ;
QueryPerformanceCounter(&stop);
```



Пример 4. Добавление цикла в последовательность отрисовки

Ниже приведены результаты, измеряемые с помощью QueryPerformanceCounter и Куериперформанцефрекуенци:



| Локальная переменная | Число ТИКС |
|----------------|----------------|
| start          | 1792998845000  |
| stop           | 1792998847084  |
| FREQ           | 3579545        |



 

Использование QueryPerformanceCounter Measures 2 840 тактов. Преобразование тактов в циклы аналогично тому, что мы уже показали:


```
# ticks  = (stop - start) = 1792998847084 - 1792998845000 = 2840 ticks
# cycles    = machine speed * number of ticks / QPF
# 6,900,000 = 2 GHz          * 2840           / 3,579,545
```



Иными словами, для обработки вызовов 1500 в цикле подготовки требуется около 6 900 000 циклов на этом компьютере с тактовой частотой 2 ГГц. Из 6 900 000 циклов, время в режимах переходов составляет примерно 10 000, поэтому теперь результаты профиля почти полностью измеряют работу, связанную с [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) и [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive).

Обратите внимание, что для примера кода требуется массив из двух текстур. Чтобы избежать оптимизации среды выполнения, которая приведет к удалению [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) , если при каждом вызове задается один и тот же указатель текстуры, просто используйте массив из двух текстур. Таким образом, при каждом проходе через цикл изменяется указатель текстуры, и выполняется полная работа, связанная с **сеттекстуре** . Убедитесь, что обе текстуры имеют одинаковый размер и формат, поэтому другие состояния не изменятся при выполнении текстуры.

Теперь у вас есть методика для профилирования Direct3D. Он основывается на счетчике высокой производительности (QueryPerformanceCounter), чтобы записать число тактов, затрачиваемых ЦП на обработку работы. Работа тщательно контролируется, чтобы стать средой выполнения и драйвером, связанными с вызовами API с помощью механизма запросов. Запрос предоставляет два средства управления: сначала очистите буфер команд до начала последовательности отрисовки, а второй — после завершения работы GPU.

На данный момент в этой статье был показан способ профилирования последовательности отрисовки. Каждая последовательность отрисовки была довольно простой, содержащая один вызов [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) и вызов [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) . Это было сделано для того, чтобы сосредоточиться на буфере команд и использовании механизма запросов для управления им. Ниже приведена краткая сводка по профилированию произвольной последовательности визуализации.

-   Используйте высокопроизводительный счетчик, такой как QueryPerformanceCounter, для измерения времени, затрачиваемого на обработку каждого вызова API. Используйте Куериперформанцефрекуенци и тактовую частоту ЦП, чтобы преобразовать это значение в число циклов ЦП на вызов API.
-   Сократите объем работы GPU за счет отрисовки списков треугольников, где каждый треугольник содержит один пиксель.
-   Используйте механизм запросов, чтобы очистить буфер команд перед последовательностью отрисовки. Это гарантирует, что при профилировании будет захвачен правильный объем работы среды выполнения и драйвера, связанный с последовательностью отрисовки.
-   Управление объемом работы, добавляемой в буфер команд с маркерами событий запросов. Этот же запрос обнаруживает, когда GPU завершает свою работу. Поскольку работа GPU является тривиальной, это практически эквивалентно измерению времени завершения работы драйвера.

Все эти методы используются для профилирования изменений состояния. Если вы прочитали и поняли, как управлять буфером команд и успешно завершили базовые измерения в [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), вы можете добавлять изменения состояния в последовательности отрисовки. При добавлении изменений состояния в последовательность отрисовки необходимо выполнить несколько дополнительных задач по профилированию. Если вы собираетесь добавить изменения состояния в последовательности отрисовки, не забудьте перейти к следующему разделу.

## <a name="profiling-direct3d-state-changes"></a>Профилирование изменений состояния Direct3D

Direct3D использует много состояний рендеринга для управления практически всеми аспектами конвейера. API-интерфейсы, которые вызывают изменение состояния, включают в себя любую функцию или метод, отличные от \* примитивов рисования.

Изменения состояния очень сложны, так как вы не можете увидеть стоимость изменения состояния без подготовки к просмотру. Это результат неактивного алгоритма, который используется драйвером и графическим процессором для откладывание работы до тех пор, пока она не будет полностью завершена. Как правило, для измерения одного изменения состояния необходимо выполнить следующие действия.

1.  Сначала Profile [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) .
2.  Добавьте одно изменение состояния в последовательность отрисовки и пропрофилировать новую последовательность.
3.  Вычтите разность между двумя последовательностями, чтобы получить затраты на изменение состояния.

Естественно, все, что вы узнали об использовании механизма запросов и помещаете последовательность отрисовки в цикле, чтобы инвертировать затраты на переход в режим по-прежнему.

### <a name="profiling-a-simple-state-change"></a>Профилирование простого изменения состояния

Начиная с последовательности отрисовки, содержащей [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), ниже приведена последовательность кода для измерения затрат на добавление [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture):


```
// Get the start counter value as shown in Example 4 

// Initialize a texture array as shown in Example 4
IDirect3DTexture* texArray[2];

// Render sequence loop 
for(int i = 0; i < 1500; i++)
{
  SetTexture(0, texArray[i%2];
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
}

// Get the stop counter value as shown in Example 4 
```



Пример 5. измерение одного вызова API изменения состояния

Обратите внимание, что цикл содержит два вызова, [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) и [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive). Последовательность визуализации выполняет циклы 1500 раз и формирует результаты, аналогичные приведенным ниже.



| Локальная переменная | Число ТИКС |
|----------------|----------------|
| start          | 1792998860000  |
| stop           | 1792998870260  |
| FREQ           | 3579545        |



 

Преобразование тактов в циклы после повторного получения:


```
# ticks  = (stop - start) = 1792998870260 - 1792998860000 = 10,260 ticks
# cycles    = machine speed * number of ticks / QPF
5,775,000   = 2 GHz          * 10,260         / 3,579,545
```



Деление на число итераций в цикле дает следующее:


```
5,775,000 cycles / 1500 iterations = 3850 cycles for one iteration
```



Каждая итерация цикла содержит изменение состояния и вызов Draw. Вычитание результата последовательности отрисовки [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) оставляет:


```
3850 - 1100 = 2750 cycles for SetTexture
```



Среднее число циклов для добавления [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) к этой последовательности отрисовки. Этот же метод можно применить к другим изменениям состояния.

Почему [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) называется простым изменением состояния? Так как заданное состояние ограничено, так что конвейер выполняет тот же объем работы при каждом изменении состояния. Ограничение обеих текстур одинакового размера и формата гарантирует одинаковый объем работы для каждого вызова **сеттекстуре** .

### <a name="profiling-a-state-change-that-needs-to-be-toggled"></a>Профилирование изменения состояния, которое необходимо переключить

Существуют другие изменения состояния, которые приводят к изменению объема работы, выполняемой графическим конвейером, для каждой итерации цикла отрисовки. Например, если включено z-тестирование, каждый цвет пикселя обновляет целевой объект отрисовки только после того, как значение z нового пикселя будет проверено относительно z-значения существующего пикселя. Если z-тестирование отключено, этот тест не выполняется, и выходные данные записываются гораздо быстрее. Включение или отключение состояния z-тестирования значительно изменяет объем работы (ЦП и GPU) во время подготовки к просмотру.

[**Сетрендерстате**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) требует определенного состояния отрисовки и значения состояния для включения или отключения z-тестирования. Определенное значение состояния вычисляется во время выполнения, чтобы определить, сколько работы необходимо. Трудно измерить это изменение состояния в цикле подготовки к просмотру и по-прежнему выполнить предварительное условие состояния конвейера, чтобы оно было переключено. Единственное решение — переключить изменение состояния во время последовательности отрисовки.

Например, метод профилирования должен повторяться дважды следующим образом:

1.  Начните с профилирования последовательности отрисовки [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) . Вызовите этот базовый уровень.
2.  Профилирование второй последовательности отрисовки, которая переключает изменение состояния. Цикл визуализации последовательности содержит:
    -   Изменение состояния для установки состояния в состояние "false".
    -   [**Дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , как и исходная последовательность.
    -   Изменение состояния для задания состояния "true".
    -   Второй [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) для принудительного реализации второго изменения состояния.
3.  Найдите разницу между двумя последовательностями отрисовки. Это делается следующим образом.
    -   Умножьте базовую последовательность [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) на 2, так как в новой последовательности есть два вызова **дравпримитиве** .
    -   Вычтите результат новой последовательности из исходной последовательности.
    -   Разделите результат на 2, чтобы получить среднюю стоимость как "false", так и "истинное" изменение состояния.

При использовании метода цикла, используемого в последовательности отрисовки, стоимость изменения состояния конвейера должна измеряться путем переключения состояния с "true" на "false" и наоборот для каждой итерации в последовательности отрисовки. Значение "true" и "false" здесь не являются литералами, это просто означает, что состояние должно быть задано в противоположных условиях. Это приводит к измерению изменений состояния во время профилирования. Конечно, все, что вы узнали об использовании механизма запросов и помещаете последовательность отрисовки в цикле, чтобы инвертировать затраты на переход в режим по-прежнему.

Например, ниже приведена последовательность кода для измерения стоимости переключения или отключения z-тестирования.


```
// Get the start counter value as shown in Example 4 

// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  // Precondition the pipeline state to the "false" condition
  SetRenderState(D3DRS_ZENABLE, FALSE);
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 0)*3, 1);

  // Set the pipeline state to the "true" condition
  SetRenderState(D3DRS_ZENABLE, TRUE);

  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 1)*3, 1); 
}

// Get the stop counter value as shown in Example 4 
```



Пример 5. измерение изменения состояния переключения

Цикл переключает состояние, выполняя два вызова [**сетрендерстате**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) . Первый вызов **сетрендерстате** отключает z-тестирование, а второй **сетрендерстате** включает z-тестирование. За каждым **сетрендерстате** следует [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , чтобы работа, связанная с изменением состояния, была обработана драйвером вместо того, чтобы задавать «грязный» бит в драйвере.

Эти числа являются разумными для этой последовательности отображения:



| Локальная переменная | Число тактов |
|----------------|-----------------|
| start          | 1792998845000   |
| stop           | 1792998861740   |
| FREQ           | 3579545         |



 

Преобразование тактов в циклы после повторного получения:


```
# ticks  = (stop - start) = 1792998861740 - 1792998845000 = 15,120 ticks
# cycles    = machine speed * number of ticks / QPF
 9,300,000  = 2 GHz          * 16,740         / 3,579,545
```



Деление на число итераций в цикле дает следующее:


```
9,300,000 cycles / 1500 iterations = 6200 cycles for one iteration
```



Каждая итерация цикла содержит два изменения состояния и два вызова Draw. Вычитание вызовов Draw (при условии, что 1100 циклов) оставляет:


```
6200 - 1100 - 1100 = 4000 cycles for both state changes
```



Среднее число циклов для обоих изменений состояния, поэтому среднее время каждого изменения состояния:


```
4000 / 2  = 2000 cycles for each state change
```



Таким образом, среднее число циклов для включения или отключения z-тестирования составляет 2000 циклов. Стоит отметить, что QueryPerformanceCounter измеряет z-включение половины времени и z отключает половину времени. Этот метод фактически измеряет среднее значение обоих изменений состояния. Иными словами, вы измеряете время переключения состояния. Используя этот метод, вы не можете узнать, эквивалентны ли значения времени включения и отключения, так как вы измеряете среднее арифметическое обоих этих методов. Тем не менее, это разумное число, которое будет использоваться при бюджетировании переключения состояния в качестве приложения, которое вызывает это изменение состояния, это может сделать это только путем переключения этого состояния.

Итак, теперь вы можете применить эти методы и пропрофилировать все необходимые изменения состояния, верно? Пока нет. По-прежнему необходимо соблюдать осторожность при оптимизации, которые предназначены для уменьшения объема работы, которую необходимо выполнить. Существует два типа оптимизации, которые следует учитывать при проектировании последовательностей отрисовки.

### <a name="watch-out-for-state-change-optimizations"></a>Выследите за оптимизацией изменения состояния

В предыдущем разделе показано, как выполнять профилирование обоих видов изменений состояния: простое изменение состояния, которое ограничивается созданием одинакового объема работы для каждой итерации, и изменением состояния, которое значительно изменяет объем работы. Что произойдет, если выполнить предыдущую последовательность отрисовки и добавить в нее еще одно изменение состояния? Например, в этом примере берется последовательность отрисовки z>-Enable, а в нее добавляется сравнение z-Func:


```
// Add a loop to the render sequence 
for(int i = 0; i < 1500; i++)
{
  // Precondition the pipeline state to the opposite condition
  SetRenderState(D3DRS_ZFUNC, D3DCMP_NEVER);

  // Precondition the pipeline state to the opposite condition
  SetRenderState(D3DRS_ZENABLE, FALSE);
  
  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 0)*3, 1);

  // Now set the state change you want to measure
  SetRenderState(D3DRS_ZFUNC, D3DCMP_ALWAYS);

  // Now set the state change you want to measure
  SetRenderState(D3DRS_ZENABLE, TRUE);

  // Force the state change to propagate to the GPU
  DrawPrimitive(D3DPT_TRIANGLELIST, (2*i + 1)*3, 1); 
}
```



Состояние «z-Func» задает уровень сравнения при записи в z-буфер (между z-значением текущего пикселя и z-значением пикселя в буфере глубины). D3DCMP \_ никогда не выключает сравнение z-тестирования, в то время как D3DCMP \_ всегда устанавливает сравнение, выполняемое при каждом выполнении z-тестирования.

Профилирование одного из этих изменений состояния в последовательности отрисовки с помощью [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) приводит к следующим результатам:



| Изменение одного состояния | Среднее число циклов |
|---------------------|--------------------------|
| \_Только D3DRS зенабле | 2000                     |



 

или



| Изменение одного состояния | Среднее число циклов |
|---------------------|--------------------------|
| \_Только D3DRS зфунк   | 600                      |



 

Но при профилировании как D3DRS \_ зенабле, так и D3DRS \_ зфунк в одной и той же последовательности рендеринга, вы увидите примерно такие результаты:



| Оба изменения состояния            | Среднее число циклов |
|-------------------------------|--------------------------|
| D3DRS \_ зенабле + D3DRS \_ зфунк | 2000                     |



 

Результат может быть равен сумме циклов 2000 и 600 (или 2600), так как драйвер выполняет всю работу, связанную с заданием обоих состояний рендеринга. Вместо этого среднее значение составляет 2000 циклов.

Этот результат отражает оптимизацию изменения состояния, реализованную в среде выполнения, драйвере или GPU. В этом случае драйвер может увидеть первый [**сетрендерстате**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate) и задать "грязное" состояние, которое откладывает работу до последующего. Когда драйвер видит второй **сетрендерстате**, одно и то же состояние "грязного" может быть установлено избыточно, и та же работа будет отложена один раз. При вызове [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) работа, связанная с «грязным» состоянием, в итоге обрабатывается. Драйвер выполняет работу один раз, что означает, что первые два изменения состояния фактически консолидируются драйвером. Аналогичным образом, третье и четвертое изменения состояния фактически консолидируются драйвером в одно изменение состояния при вызове второй **дравпримитиве** . В итоге драйвер и GPU обрабатывают одно изменение состояния для каждого вызова Draw.

Это хороший пример оптимизации, зависящей от последовательности. Драйвер отложенной работы дважды настраивает состояние "грязный", а затем выполняет работу один раз, чтобы очистить "грязное" состояние. Это хороший пример улучшения эффективности, который может быть выполнен, когда работа откладывается до абсолютной необходимости.

Как узнать, какие изменения состояния задают состояние "грязное", и, следовательно, откладывать работу до последующего? Только путем тестирования последовательностей отрисовки (или общения с модулями записи драйверов). Драйверы обновляются и периодически улучшаются, поэтому список оптимизаций не является статическим. Существует только один способ абсолютно знать, какие затраты на изменение состояния в данной последовательности отрисовки находятся на конкретном наборе оборудования. и это необходимо для измерения.

### <a name="watch-out-for-drawprimitive-optimizations"></a>Просмотр оптимизаций для Дравпримитиве

Помимо оптимизации изменения состояния, среда выполнения попытается оптимизировать число вызовов Draw, которые драйвер должен обработать. Например, рассмотрим обратную передачу вызовов Draw:


```
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 3); // Draw 3 primitives, vertices 0 - 8
DrawPrimitive(D3DPT_TRIANGLELIST, 9, 4); // Draw 4 primitives, vertices 9 - 20
```



Пример 5A: два вызова Draw

Эта последовательность содержит два вызова Draw, которые среда выполнения будет объединять в один вызов, эквивалентный следующему:


```
DrawPrimitive(D3DPT_TRIANGLELIST, 0, 7); // Draw 7 primitives, vertices 0 - 20
```



Пример 5b: одиночный Объединенный вызов Draw

Среда выполнения объединит оба этих конкретного вызова Draw в один вызов, что сокращает скорость работы драйвера на 50%, так как драйвер теперь должен обрабатывать только один вызов Draw.

Как правило, среда выполнения объединяет два или более обратных вызова [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , когда:

1.  Тип-примитив — это список треугольников (D3DPT \_ трианглелист).
2.  Каждый последовательный вызов [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) должен ссылаться на последовательные вершины в буфере вершин.

Аналогично, верные условия объединения двух или более обратных вызовов [**дравиндекседпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) :

1.  Тип-примитив — это список треугольников (D3DPT \_ трианглелист).
2.  Каждый последовательный вызов [**дравиндекседпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) должен последовательно ссылаться на последовательные индексы в буфере индекса.
3.  Каждый последовательный вызов [**дравиндекседпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive) должен использовать одно и то же значение для басевертексиндекс.

Чтобы предотвратить объединение во время профилирования, измените последовательность отрисовки так, чтобы тип-примитив не был списком треугольников, или измените последовательность отрисовки таким образом, чтобы не существовали обратные вызовы Draw, использующие последовательные вершины (или индексы). В частности, среда выполнения также объединяет вызовы Draw, которые отвечают обоим следующим условиям:

-   Если предыдущий вызов — [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive), то при следующем вызове Draw:
    -   использует список треугольников и
    -   Указывает Стартвертекс = Previous Стартвертекс + предыдущее Примитивекаунт \* 3
-   При использовании [**дравиндекседпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawindexedprimitive)при следующем вызове Draw:
    -   использует список треугольников и
    -   Указывает значение StartIndex = предыдущий StartIndex + Previous Примитивекаунт \* 3, а
    -   Указывает Басевертексиндекс = Previous Басевертексиндекс

Ниже приведен более тонкий пример объединения вызовов Draw, который легко заметить при профилировании. Предположим, что последовательность визуализации выглядит следующим образом:


```
  for(int i = 0; i < 1500; i++)
  {
    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
  }
```



Пример 5C: одно изменение состояния и один вызов Draw

Цикл проходит через треугольники 1500, устанавливая текстуру и рисуя каждый треугольник. Этот цикл визуализации занимает примерно 2750 циклов для циклов [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) и 1100 для [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , как показано в предыдущих разделах. Можно интуитивно ожидать, что перемещение **сеттекстуре** за пределы цикла подготовки к просмотру должно уменьшить объем работы, выполненной драйвером, на 1500 \* 2750 тактов, то есть объем работы, связанный с вызовом **сеттекстуре** 1500 раз. Фрагмент кода будет выглядеть следующим образом:


```
  SetTexture(...); // Set the state outside the loop
  for(int i = 0; i < 1500; i++)
  {
//    SetTexture(...);
    DrawPrimitive(D3DPT_TRIANGLELIST, i*3, 1);
  }
```



Пример: 5D. пример 5C с изменением состояния вне цикла

Перемещение [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture) за пределы цикла подготовки к просмотру сокращает объем работы, связанный с **сеттекстуре** , так как он вызывается один раз вместо 1500 раз. Менее очевидный дополнительный результат заключается в том, что работа для [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) также сокращается с 1500 вызовов до 1, так как удовлетворяются все условия объединения вызовов Draw. При обработке последовательности отрисовки среда выполнения будет обрабатывать 1500 вызовов одного вызова драйвера. При перемещении этой одной строки кода объем работы драйвера значительно уменьшился:


```
total work done = runtime + driver work

Example 5c: with SetTexture in the loop:
runtime work = 1500 SetTextures + 1500 DrawPrimitives 
driver  work = 1500 SetTextures + 1500 DrawPrimitives 

Example 5d: with SetTexture outside of the loop:
runtime work = 1 SetTexture + 1 DrawPrimitive + 1499 Concatenated DrawPrimitives 
driver  work = 1 SetTexture + 1 DrawPrimitive 
```



Эти результаты являются полностью верными, но в контексте исходного вопроса они являются ошибочными. Оптимизация вызова Draw привела к значительному уменьшению объема работы драйвера. Это распространенная проблема при пользовательском профилировании. При устранении вызовов из последовательности прорисовки необходимо избегать объединения вызовов Draw. На самом деле, этот сценарий является мощным примером улучшения производительности драйвера, которое может реализовать эта оптимизация среды выполнения.

Итак, теперь вы умеете измерять изменения состояния. Начните с профилирования [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive). Затем добавьте каждое дополнительное изменение состояния в последовательность (в некоторых случаях — Добавление одного вызова, а в других случаях — добавление двух вызовов) и измерение разницы между двумя последовательностями. Результаты можно преобразовать в такты или циклы или время. Точно так же, как измерение последовательностей визуализации с помощью QueryPerformanceCounter, измерение отдельных изменений состояния основывается на механизме запросов для управления буфером команд и помещении изменений состояния в цикл, чтобы свести к сведению влияние переходов в режиме. Этот метод измеряет стоимость переключения состояния, так как профилировщик Возвращает среднее значение включения и отключения состояния.

С помощью этой возможности можно приступить к созданию произвольных последовательностей отрисовки и правильному измерению связанной работы среды выполнения и драйвера. Эти числа можно использовать для ответа на вопросы о бюджетировании, такие как «сколько других вызовов» можно сделать в последовательности отрисовки, сохраняя разумную частоту кадров, предоставляя сценарии с ограниченным использованием ЦП.

## <a name="summary"></a>Сводка

В этом документе показано, как управлять буфером команд, чтобы можно было точно выполнить профилирование отдельных вызовов. Числа профилирования могут создаваться в тактах, циклах или в абсолютном времени. Они представляют объем работы среды выполнения и драйвера, связанный с каждым вызовом API.

Начните с профилирования вызова рисования \* примитива в последовательности отрисовки. Запомните самое главное:

1.  Используйте QueryPerformanceCounter для измерения числа тактов на вызов API. При необходимости используйте Куериперформанцефрекуенци для преобразования результатов в циклы или время.
2.  Используйте механизм запросов, чтобы очистить буфер команд перед запуском.
3.  Включите последовательность отрисовки в цикл, чтобы уменьшить влияние перехода на режим.
4.  Используйте механизм запросов для измерения времени завершения работы GPU.
5.  Следите за сцеплением среды выполнения, которое может оказать значительное влияние на объем выполненной работы.

Это дает базовую производительность для [**дравпримитиве**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-drawprimitive) , которую можно использовать для построения из. Для профилирования одного изменения состояния выполните следующие дополнительные советы.

1.  Добавление изменения состояния в известный профиль последовательности отрисовки новая последовательность. Так как тестирование выполняется в цикле, для этого необходимо дважды установить состояние в противоположные значения (например, включить и отключить для экземпляра).
2.  Сравните разность времени цикла между двумя последовательностями.
3.  Для изменений состояния, которые значительно изменяют конвейер (например, [**сеттекстуре**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-settexture)), вычтите разность между двумя последовательностями, чтобы получить время на изменение состояния.
4.  Для изменений состояния, которые значительно изменяют конвейер (и поэтому требует переключения состояний, таких как [**сетрендерстате**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-setrenderstate)), вычтите разность между последовательностями отрисовки и делением на 2. Будет создано среднее количество циклов для каждого изменения состояния.

Но будьте внимательны при оптимизации, которые приводят к непредвиденным результатам при профилировании. Оптимизации изменения состояния могут задавать "грязные" состояния, что приводит к отложению работы. Это может привести к тому, что результаты профиля не так очевидны, как ожидалось. Сцепленные вызовы функций значительно снижают работу драйверов, что может привести к неверному получению. Тщательно запланированные последовательности рендеринга используются для предотвращения изменения состояния и объединения вызовов рисования. Хитрость заключается в предотвращении оптимизации во время профилирования, чтобы создаваемые вами числа были приемлемыми по числу бюджетных операций.

> [!Note]  
> Дублирование этой стратегии профилирования в приложении без механизма запросов усложняется. До Direct3D 9 единственным предсказуемым способом очистки буфера команд является блокировка активной поверхности (например, целевого объекта прорисовки) для ожидания простоя GPU. Это обусловлено тем, что блокировка поверхности заставляет среду выполнения очищать буфер команд в случае, если в буфере есть команды отрисовки, которые должны обновить поверхность до того, как она будет заблокирована. Этот метод работает, хотя он более незаметно для использования механизма запросов, представленного в Direct3D 9.

 

## <a name="appendix"></a>Приложение

Числа в этой таблице представляют собой диапазон приближений к объему работы среды выполнения и драйвера, связанной с каждым из этих изменений состояния. Приблизительные значения основываются на фактических измерениях, сделанных в драйверах, с использованием методов, показанных в документе. Эти числа были созданы с помощью среды выполнения Direct3D 9 и зависят от драйвера.

Методики, описанные в этом документе, предназначены для измерения работы среды выполнения и драйвера. Как правило, нецелесообразно предоставлять результаты, соответствующие производительности ЦП и GPU, в каждом приложении, так как это потребует исчерпывающего массива последовательностей отрисовки. Кроме того, особенно сложно протестировать производительность GPU, так как он сильно зависит от настройки состояния в конвейере перед последовательностью отрисовки. Например, Включение альфа-смешения практически не влияет на объем необходимых ресурсов ЦП, но может оказать значительное влияние на объем работы, выполненный GPU. Таким образом, методы в этой статье ограничивают работу GPU до минимально возможного объема, ограничивая объем данных, которые необходимо визуализировать. Это означает, что числа в таблице наиболее полно соответствуют результатам, полученным от приложений, которые ограничены ЦП (в отличие от приложения, ограниченного графическим процессором).

Рекомендуется использовать методы, представленные для того, чтобы охватить наиболее важные сценарии и конфигурации. Значения в таблице можно использовать для сравнения с создаваемыми числами. Поскольку каждый драйвер зависит друг от друга, единственный способ создать результаты профилирования можно с помощью сценариев.



| Вызов API                             | Среднее число циклов |
|--------------------------------------|--------------------------|
| сетвертексдекларатион                 | 6500-11250             |
| сетфвф                               | 6400-11200             |
| сетвертексшадер                      | 3000-12100             |
| сетпикселшадер                       | 6300-7000              |
| спекуларенабле                       | 1900-11200             |
| сетрендертаржет                      | 6000-6250              |
| Сетпикселшадерконстант (1 константа)  | 1500-9000              |
| нормализенормалс                     | 2200-8100              |
| Досветлить                          | 1300-9000              |
| сетстреамсаурце                      | 3700-5800              |
| СВЕТ                             | 1700-7500              |
| диффусематериалсаурце                | 900-8300               |
| амбиентматериалсаурце                | 900-8200               |
| колорвертекс                          | 800-7800               |
| сетлигхт                             | 2200-5100              |
| сеттрансформ                         | 3200-3750              |
| сетиндицес                           | 900-5600               |
| ШУМА                              | 1150-4800              |
| сеттекстуре                           | 2500-3100              |
| спекуларматериалсаурце               | 900-4600               |
| емиссивематериалсаурце               | 900-4500               |
| сетматериал                          | 1000-3700              |
| зенабле                              | 700-3900               |
| WRAP0                                | 1600-2700              |
| минфилтер                            | 1700-2500              |
| магфилтер                            | 1700-2400              |
| Сетвертексшадерконстант (1 константа) | 1000-2700              |
| колороп                              | 1500-2100              |
| COLORARG2                            | 1300-2000              |
| COLORARG1                            | 1300-1980              |
| куллмоде                             | 500-2570               |
| ВЫРЕЗАЯ                             | 500-2550               |
| дравиндекседпримитиве                 | 1200-1400              |
| аддрессв                             | 1090-1500              |
| аддрессу                             | 1070-1500              |
| дравпримитиве                        | 1050-1150              |
| сргбтекстуре                          | 150-1500               |
| стенЦилмаск                          | 570-700                |
| стенЦилзфаил                         | 500-800                |
| стенЦилреф                           | 550-700                |
| алфабленденабле                     | 550-700                |
| стенЦилфунк                          | 560-680                |
| стенЦилвритемаск                     | 520-700                |
| стенЦилфаил                          | 500-750                |
| зфунк                                | 510-700                |
| звритинабле                         | 520-680                |
| стенЦиленабле                        | 540-650                |
| стенЦилпасс                          | 560-630                |
| сркбленд                             | 500-685                |
| Двусторонняя \_ \_ стенЦилмоде              | 450-590                |
| алфатестенабле                      | 470-525                |
| алфареф                             | 460-530                |
| алфафунк                            | 450-540                |
| дестбленд                            | 475-510                |
| колорвритинабле                     | 465-515                |
| \_СТЕНЦИЛФАИЛ CCW                     | 340-560                |
| \_СТЕНЦИЛПАСС CCW                     | 340-545                |
| \_СТЕНЦИЛЗФАИЛ CCW                    | 330-495                |
| сЦиссортестенабле                    | 375-440                |
| \_СТЕНЦИЛФУНК CCW                     | 250-480                |
| сетсЦиссоррект                       | 150-340                |



 

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Дополнительные разделы](advanced-topics.md)
</dt> </dl>

 

 
