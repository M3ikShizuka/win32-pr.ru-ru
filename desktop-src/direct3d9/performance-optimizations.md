---
description: Все разработчики, создающие приложения в режиме реального времени, использующие трехмерную график, связаны с оптимизацией производительности. В этом разделе приводятся рекомендации по повышению производительности кода.
ms.assetid: 074f848e-4a42-48a2-adf7-4026b8967413
title: Оптимизация производительности (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3e22ff22e3cde3673a1fc5ccd1da1bdccd95c6a094d670f59742178b28954773
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118520432"
---
# <a name="performance-optimizations-direct3d-9"></a>Оптимизация производительности (Direct3D 9)

Все разработчики, создающие приложения в режиме реального времени, использующие трехмерную график, связаны с оптимизацией производительности. В этом разделе приводятся рекомендации по повышению производительности кода.

-   [общие Советы производительности](#general-performance-tips)
-   [Базы данных и отбор](#databases-and-culling)
-   [Пакетные примитивы](#batching-primitives)
-   [освещение Советы](#lighting-tips)
-   [Размер текстуры](#texture-size)
-   [Преобразования матрицы](#matrix-transforms)
-   [Использование динамических текстур](#using-dynamic-textures)
-   [Использование динамических буферов вершин и индексов](#using-dynamic-vertex-and-index-buffers)
-   [Использование сеток](#using-meshes)
-   [Производительность буфера Z](#z-buffer-performance)

## <a name="general-performance-tips"></a>общие Советы производительности

-   Очистить только при необходимости.
-   Сократите изменения состояния и сгруппируйте изменения в оставшейся области.
-   Если это возможно, используйте небольшие текстуры.
-   Рисование объектов в сцене с начала до конца.
-   Используйте ленты треугольников вместо списков и вентиляторов. Для оптимальной производительности кэша вершин разместите полосы для повторного использования вершин треугольников быстрее, а не позже.
-   Аккуратное снижение специальных эффектов, требующих непропорционального использования системных ресурсов.
-   Постоянно тестируйте производительность приложения.
-   Уменьшение параметров буфера вершин.
-   По возможности используйте статические буферы вершин.
-   Используйте один большой статический буфер вершин на ФВФ для статических объектов, а не по одному на каждый объект.
-   Если приложению требуется произвольный доступ к буферу вершин в памяти AGP, выберите размер формата вершин, кратный 32 байт. В противном случае выберите наименьший подходящий формат.
-   Рисование с помощью индексированных примитивов. Это может обеспечить более эффективное кэширование вершин в оборудовании.
-   Если формат буфера глубины содержит канал набора элементов, всегда снимайте каналы глубины и шаблона одновременно.
-   По возможности объедините инструкцию шейдера и выходные данные. Пример:
    ```
    // Rather than doing a multiply and add, and then output the data with 
    //   two instructions:
    mad r2, r1, v0, c0
    mov oD0, r2

    // Combine both in a single instruction, because this eliminates an  
    //   additional register copy.
    mad oD0, r1, v0, c0 
    ```

    

## <a name="databases-and-culling"></a>Базы данных и отбор

Создание надежной базы данных объектов в мире — это ключевая высокая производительность в Direct3D. Это важнее, чем усовершенствования растрирования или оборудования.

Вы должны поддерживать наименьшее количество многоугольников, которое можно управлять. Проектирование с небольшим количеством многоугольников путем создания моделей с низким многоугольником с начала. Добавьте многоугольники, если это возможно, не снижая производительность в процессе разработки. Помните, что самые быстрые многоугольники — это те, которые не рисуются.

## <a name="batching-primitives"></a>Пакетные примитивы

Чтобы обеспечить наилучшую производительность отрисовки во время выполнения, попробуйте работать с примитивами в пакетах и обеспечить минимально возможное количество изменений состояния визуализации. Например, если у вас есть объект с двумя текстурами, сгруппируйте треугольники, использующие первую текстуру, и следуйте им, чтобы изменить текстуру с помощью нужного состояния рендеринга. Затем сгруппируйте все треугольники, которые используют вторую текстуру. Простейшая аппаратная поддержка Direct3D вызвана пакетами состояний отрисовки и пакетами примитивов через слой абстрагирования оборудования (HAL). Чем более эффективно Пакетная обработка инструкций, тем меньше вызовов HAL выполняется во время выполнения.

## <a name="lighting-tips"></a>освещение Советы

Так как источники света добавляют стоимость за вершину к каждому отображаемому кадру, производительность может значительно повыситься, так как они используются в приложении. Большинство из следующих советов являются производными от мА, «самый быстрый код — это код, который никогда не вызывается».

-   Используйте как можно меньше источников освещения. Чтобы увеличить общий уровень освещения, например, используйте внешний свет вместо добавления нового источника света.
-   Направленный свет более эффективен, чем световые индикаторы или прожекторы. Для направленного освещения направление света фиксировано, и его не нужно рассчитывать на основе вершин.
-   Прожекторы могут оказаться более эффективными, чем световые источники света, так как быстро вычисляется область за пределами света. Является ли прожектор более эффективным или не зависит от того, какая часть сцены освещена фокусом.
-   Используйте параметр Range, чтобы ограничить свет только частями сцены, которые необходимы для освещения. Все типы освещения завершают работу довольно рано, если они выходят за пределы диапазона.
-   Отраженные блики почти вдвое изменяют стоимость освещения. Используйте их только при необходимости. Задайте \_ для состояния отрисовки D3DRS спекуларенабле значение 0 (по умолчанию), если это возможно. При определении материалов необходимо установить значение отраженной мощности равным нулю, чтобы отключить отраженные блики для этого материала. просто установить для отраженного цвета значение 0, 0, 0 — недостаточно.

## <a name="texture-size"></a>Размер текстуры

Производительность сопоставления текстур сильно зависит от скорости памяти. Существует несколько способов увеличить производительность кэша текстур приложения.

-   Используйте небольшие текстуры. Чем меньше текстуры, тем выше вероятность их поддержки в дополнительном кэше основного ЦП.
-   Не изменяйте текстуры для отдельных примитивов. Постарайтесь, чтобы многоугольники были сгруппированы по порядку используемых им текстур.
-   При возможности используйте квадратные текстуры. Текстуры, размеры которых являются 256x256, являются самым быстрым. Например, если ваше приложение использует четыре текстуры 128x128, попробуйте убедиться, что они используют одну и ту же палитру и размещают их в одной 256x256ной текстуре. Этот метод также сокращает объем перекачки текстур. Конечно, не следует использовать текстуры 256x256, если приложение не требует интенсивного текстурирования, поскольку, как уже упоминалось, текстуры должны быть максимально маленькими.

## <a name="matrix-transforms"></a>Преобразования матрицы

Direct3D использует установленные вами мировую матрицу и видовую матрицу для конфигурирования нескольких внутренних структур данных. Каждый раз, когда вы устанавливаете новую мировую или видовую матрицу, система пересчитывает соответствующие внутренние структуры. Частое задание этих матриц, например тысячи раз в кадре, — это вычисление длительного времени. Свести к минимуму количество необходимых вычислений можно путем конкатенации мировой и видовой матриц в мировую-видовую матрицу, задать ее в качестве мировой матрицы, а затем установить видовую матрицу в единичную. Сохраняйте кэшированные копии отдельных мировых и видовых матриц, чтобы вы могли изменять, объединять и сбрасывать мировую матрицу по необходимости. Для ясности в этой документации примеры Direct3D редко используют эту оптимизацию.

## <a name="using-dynamic-textures"></a>Использование динамических текстур

Чтобы узнать, поддерживает ли драйвер динамические текстуры, установите \_ флаг D3DCAPS2 динамиктекстурес в структуре [**D3DCAPS9**](/windows/desktop/api/D3D9Caps/ns-d3d9caps-d3dcaps9) .

При работе с динамическими текстурами учитывайте следующие моменты.

-   Они не могут управляться. Например, пул не может быть \_ управляемым D3DPOOL.
-   Динамические текстуры могут быть заблокированы, даже если они создаются в D3DPOOL \_ по умолчанию.
-   D3DLOCK \_ Discard — допустимый флаг блокировки для динамических текстур.

Рекомендуется создать только одну динамическую текстуру для каждого формата и, возможно, для каждого размера. Динамические MIP-карты, Кубы и тома не рекомендуются из-за дополнительных затрат на блокировку каждого уровня. Для MIP-карты D3DLOCK \_ Discard допускается только на верхнем уровне. Все уровни отбрасываются путем блокировки только верхнего уровня. Это поведение одинаково для томов и кубов. Для кубов верхний уровень и лицевая стороны 0 заблокированы.

В следующем псевдокоде показан пример использования динамической текстуры.


```
DrawProceduralTexture(pTex)
{
    // pTex should not be very small because overhead of 
    //   calling driver every D3DLOCK_DISCARD will not 
    //   justify the performance gain. Experimentation is encouraged.
    pTex->Lock(D3DLOCK_DISCARD);
    <Overwrite *entire* texture>
    pTex->Unlock();
    pDev->SetTexture();
    pDev->DrawPrimitive();
}
```



## <a name="using-dynamic-vertex-and-index-buffers"></a>Использование динамических буферов вершин и индексов

Блокировка статического буфера вершин во время использования буфером графическим процессором может существенно пострадает от производительности. Вызов блокировки должен ожидать, пока графический процессор не закончит считывание данных вершин или индексов из буфера, прежде чем он сможет вернуться к вызывающему приложению, выполняя значительную задержку. Блокировка и последующее отображение из статического буфера несколько раз в кадре также не позволяет графическому процессору выводить команды отрисовки, так как перед возвратом указателя блокировки должны быть завершены команды. Без буферизованных команд графический процессор остается неактивным до тех пор, пока приложение не завершит заполнение буфера вершин или буфера индексов и выдаст команду подготовки к просмотру.

В идеале данные вершин или индексов никогда не изменяются, однако это не всегда возможно. Существует множество ситуаций, в которых приложению необходимо изменять данные вершин или индексов для каждого кадра, возможно даже несколько раз в кадре. В таких ситуациях буфер вершин или индекс должен быть создан с помощью D3DUSAGE \_ dynamic. Этот флаг использования вызывает оптимизацию Direct3D для часто выполняемых операций блокировки. D3DUSAGE \_ dynamic полезен только в том случае, если буфер заблокирован часто. данные, которые остаются постоянными, должны размещаться в статическом буфере вершин или индексе.

Для получения улучшения производительности при использовании динамических буферов вершин приложение должно вызывать [**IDirect3DVertexBuffer9:: Lock**](/windows/desktop/api) или [**IDirect3DIndexBuffer9:: Lock**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3dindexbuffer9-lock) с соответствующими флагами. D3DLOCK \_ Discard указывает, что приложению не нужно сохранить в буфере старые данные вершин или индексов. Если графический процессор все еще использует буфер при вызове Lock с D3DLOCK \_ Discard, вместо старых данных буфера возвращается указатель на новый регион памяти. Это позволяет графическому процессору продолжать использовать старые данные, пока приложение поместит данные в новый буфер. В приложении не требуется дополнительное управление памятью; Старый буфер повторно используется или уничтожается автоматически после завершения работы графического процессора. Обратите внимание, что блокировка буфера с D3DLOCK \_ Discard всегда отбрасывает весь буфер, указывая ненулевое смещение или поле с ограниченным размером, не сохраняет сведения в разблокированных областях буфера.

Бывают случаи, когда объем данных, которые приложение должно хранить на блокировку, небольшой, например добавление четырех вершин для отрисовки спрайта. D3DLOCK \_ нуверврите указывает, что приложение не будет перезаписывать данные, уже используемые в динамическом буфере. Вызов блокировки вернет указатель на старые данные, позволяя приложению добавлять новые данные в неиспользуемые области вершин или буфера индекса. Приложение не должно изменять вершины или индексы, используемые в операции рисования, так как они по-прежнему используются графическим процессором. Приложение должно использовать D3DLOCK \_ Discard после заполнения динамического буфера для получения нового региона памяти, удаляя старые данные вершин или индексы после завершения работы графического процессора.

Механизм асинхронных запросов удобен для определения того, используются ли вершины графическим процессором. Выдайте запрос типа Event D3DQUERYTYPE \_ после последнего вызова дравпримитиве, использующего вершины. Вершины больше не используются, если [**IDirect3DQuery9:: GetData**](/windows/desktop/api) возвращает значение S \_ ОК. Блокировка буфера с D3DLOCK \_ Discard или без флагов всегда гарантирует, что вершины будут правильно синхронизированы с графическим процессором, однако использование блокировки без флагов приведет к снижению производительности, описанному выше. Другие вызовы API, такие как [**IDirect3DDevice9:: бегинсцене**](/windows/desktop/api), [**IDirect3DDevice9:: ендсцене**](/windows/desktop/api)и [**IDirect3DDevice9::P**](/windows/win32/api/d3d9helper/nf-d3d9helper-idirect3ddevice9-present) повторной отправки, не гарантируют, что графический процессор завершает работу с вершинами.

Ниже приведены способы использования динамических буферов и правильных флагов блокировки.


```
    // USAGE STYLE 1
    // Discard the entire vertex buffer and refill with thousands of vertices.
    // Might contain multiple objects and/or require multiple DrawPrimitive 
    //   calls separated by state changes, etc.
 
    // Determine the size of data to be moved into the vertex buffer.
    UINT nSizeOfData = nNumberOfVertices * m_nVertexStride;
 
    // Discard and refill the used portion of the vertex buffer.
    CONST DWORD dwLockFlags = D3DLOCK_DISCARD;
    
    // Lock the vertex buffer.
    BYTE* pBytes;
    if( FAILED( m_pVertexBuffer->Lock( 0, 0, &pBytes, dwLockFlags ) ) )
        return false;
    
    // Copy the vertices into the vertex buffer.
    memcpy( pBytes, pVertices, nSizeOfData );
    m_pVertexBuffer->Unlock();
 
    // Render the primitives.
    m_pDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 0, nNumberOfVertices/3)
```




```
    // USAGE STYLE 2
    // Reusing one vertex buffer for multiple objects
 
    // Determine the size of data to be moved into the vertex buffer.
    UINT nSizeOfData = nNumberOfVertices * m_nVertexStride;
 
    // No overwrite will be used if the vertices can fit into 
    //   the space remaining in the vertex buffer.
    DWORD dwLockFlags = D3DLOCK_NOOVERWRITE;
    
    // Check to see if the entire vertex buffer has been used up yet.
    if( m_nNextVertexData > m_nSizeOfVB - nSizeOfData )
    {
        // No space remains. Start over from the beginning 
        //   of the vertex buffer.
        dwLockFlags = D3DLOCK_DISCARD;
        m_nNextVertexData = 0;
    }
    
    // Lock the vertex buffer.
    BYTE* pBytes;
    if( FAILED( m_pVertexBuffer->Lock( (UINT)m_nNextVertexData, nSizeOfData, 
               &pBytes, dwLockFlags ) ) )
        return false;
    
    // Copy the vertices into the vertex buffer.
    memcpy( pBytes, pVertices, nSizeOfData );
    m_pVertexBuffer->Unlock();
 
    // Render the primitives.
    m_pDevice->DrawPrimitive( D3DPT_TRIANGLELIST, 
               m_nNextVertexData/m_nVertexStride, nNumberOfVertices/3)
 
    // Advance to the next position in the vertex buffer.
    m_nNextVertexData += nSizeOfData;
```



## <a name="using-meshes"></a>Использование сеток

Можно оптимизировать сетки с помощью индексированных треугольников Direct3D вместо проиндексированных лент треугольников. Оборудование обнаружит, что 95 процентов последовательных треугольников фактически формируют полосы и соответствующим образом корректирует их. Многие драйверы делают это для старого оборудования также.

Объекты сетки D3DX могут иметь каждый треугольник или лицо с меткой DWORD, называемое атрибутом этого лица. Семантика DWORD определяется пользователем. Они используются D3DX для классификации сетки на подмножества. Приложение устанавливает атрибуты для отдельных лиц с помощью вызова [**ID3DXMesh:: локкаттрибутебуффер**](id3dxmesh--lockattributebuffer.md) . Метод [**ID3DXMesh:: optimize**](id3dxmesh--optimize.md) имеет параметр для группирования вершин сетки и граней в атрибутах с помощью \_ параметра D3DXMESHOPT аттрсорт. Когда это будет сделано, объект сетки вычисляет таблицу атрибутов, которую приложение может получить, вызвав [**ID3DXBaseMesh:: жетаттрибутетабле**](id3dxbasemesh--getattributetable.md). Этот вызов возвращает 0, если сетка не отсортирована по атрибутам. Приложение не может установить таблицу атрибутов, так как она создается методом **ID3DXMesh:: optimize** . Атрибут Sort чувствителен к данным, поэтому, если приложение знает, что сетка имеет сортировку по атрибутам, ей по-прежнему нужно вызывать **ID3DXMesh:: optimize** для создания таблицы атрибутов.

В следующих разделах описываются различные атрибуты сетки.

### <a name="attribute-id"></a>Идентификатор атрибута

Идентификатор атрибута — это значение, связывающее группу лиц с группой атрибутов. Этот идентификатор описывает, какое подмножество фрагментов [**ID3DXBaseMesh::D равсубсет**](id3dxbasemesh--drawsubset.md) должно рисовать. Идентификаторы атрибутов указываются для граней в буфере атрибута. Фактические значения идентификаторов атрибутов могут быть любыми, которые помещаются в 32 бит, но часто используется 0 – n, где n — число атрибутов.

### <a name="attribute-buffer"></a>Буфер атрибутов

Буфер атрибутов — это массив DWORD (по одному на каждый элемент), указывающий, к какой группе атрибутов принадлежит каждая грань. Этот буфер инициализируется нулем при создании сетки, но либо заполняется подсистемой загрузки, либо должен быть заполнен пользователем, если требуется более одного атрибута с идентификатором 0. Этот буфер содержит сведения, используемые для сортировки сетки на основе атрибутов в [**ID3DXMesh:: optimize**](id3dxmesh--optimize.md). Если таблица атрибутов отсутствует, [**ID3DXBaseMesh::D равсубсет**](id3dxbasemesh--drawsubset.md) просматривает этот буфер, чтобы выбрать грани данного атрибута для рисования.

### <a name="attribute-table"></a>Таблица атрибутов

Таблица атрибутов — это структура, принадлежащая и обслуживаемая сеткой. Единственный способ создания одного из них — вызвать [**ID3DXMesh:: optimize**](id3dxmesh--optimize.md) с атрибутом Sort или более надежную оптимизацию. Таблица атрибутов используется для быстрого запуска одного простого вызова Draw в [**ID3DXBaseMesh::D равсубсет**](id3dxbasemesh--drawsubset.md). Единственным другим применением является то, что в таких сетках также поддерживается эта структура, поэтому можно увидеть, какие грани и вершины активны на текущем уровне детализации.

## <a name="z-buffer-performance"></a>Производительность буфера Z

Приложения могут работать быстрее при использовании z-буферизации и текстурирования за счет отрисовки сцен от передней части к задней. Текстурированные примитивы с z-буферизацией предварительно проверяются в сравнении с z-буфером на основе строк развертки. Если строка развертки скрыта ранее отрисованным полигоном, система быстро и эффективно отклоняет ее. Z-буферизация может повысить производительность, но этот метод особо эффективен при многократном отображении одних и тех же пикселей в сцене. Точные расчеты в этом случае сделать сложно, но можно добиться довольно точного приближения. Если одни и те же пиксели отображаются менее двух раз, максимальную производительность можно обеспечить путем отключения z-буферизации и отрисовки сцены от задней части к передней.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Советы программирования](programming-tips.md)
</dt> </dl>

 

 
