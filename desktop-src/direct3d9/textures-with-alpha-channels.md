---
description: Существует два способа кодирования карт текстур с более сложной прозрачностью.
ms.assetid: cae788f6-60f1-4987-8f06-bf4256bccd9b
title: Текстуры с альфа-каналами (Direct3D 9)
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e2c361b0335ef4f36b4efc9c90c71270e855f5db
ms.sourcegitcommit: a47bd86f517de76374e4fff33cfeb613eb259a7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/06/2021
ms.locfileid: "104567466"
---
# <a name="textures-with-alpha-channels-direct3d-9"></a>Текстуры с альфа-каналами (Direct3D 9)

Существует два способа кодирования карт текстур с более сложной прозрачностью. В каждом случае блок, описывающий прозрачность, предшествует 64-разрядному блоку, который уже был описан. Прозрачность представляется либо в виде точечного рисунка 4x4 с 4 битами на пиксель (явная кодировка) или с меньшим количеством битов и линейной интерполяцией, которая аналогична тому, что используется в кодировании цвета.

Блок прозрачности и цветовой блок упорядочиваются так, как показано в следующей таблице.



| Адрес слова | 64-разрядный блок                      |
|--------------|-----------------------------------|
| 3:0          | Блок прозрачности                |
| 7:4          | Вышеописанный 64-разрядный блок |



 

## <a name="explicit-texture-encoding"></a>Явная кодировка текстуры

Для явной кодировки текстуры (форматы DXT2 и DXT3) альфа-компоненты пикселей текстуры, описывающие прозрачность, кодируются в битовой карте 4x4 с 4 битами на шаг текселя. Эти четыре бита можно получить различными способами, например с помощью сглаживания или используя четыре наиболее важных бита данных альфа-канала. Как бы они ни были получены, они используются в текущем виде, без интерполяции в любой форме.

На следующей схеме показан блок 64-разрядной прозрачности.

![Диаграмма 64-разрядного блока прозрачности](images/colors4.png)

> [!Note]  
> Метод сжатия Direct3D использует четыре наиболее значимых бита.

 

В следующих таблицах показано, как размещены в памяти данные альфа-канала для каждого 16-разрядного слова.

Эта таблица содержит макет для Word 0.



| Bits          | Коэффициент альфа      |
|---------------|------------|
| 3:0 (ЛСБ \* )   | \[0 \] \[ 0\] |
| 7:4           | \[0 \] \[ 1\] |
| 11:8          | \[0 \] \[ 2\] |
| 15:12 (от старшего \* ) | \[0 \] \[ 3\] |



 

\*Наименьший значащий бит, самый значащий бит (старший)

Эта таблица содержит макет для Word 1.



| Bits        | Коэффициент альфа      |
|-------------|------------|
| 3:0 (LSB)   | \[1 \] \[ 0\] |
| 7:4         | \[1 \] \[ 1\] |
| 11:8        | \[1 \] \[ 2\] |
| 15:12 (MSB) | \[1 \] \[ 3\] |



 

Эта таблица содержит макет для Word 2.



| Bits        | Коэффициент альфа      |
|-------------|------------|
| 3:0 (LSB)   | \[2 \] \[ 0\] |
| 7:4         | \[2 \] \[ 1\] |
| 11:8        | \[2 \] \[ 2\] |
| 15:12 (MSB) | \[2 \] \[ 3\] |



 

Эта таблица содержит макет для Word 3.



| Bits        | Коэффициент альфа      |
|-------------|------------|
| 3:0 (LSB)   | \[3 \] \[ 0\] |
| 7:4         | \[3 \] \[ 1\] |
| 11:8        | \[3 \] \[ 2\] |
| 15:12 (MSB) | \[3 \] \[ 3\] |



 

Разница между DXT2 и DXT3 заключается в том, что в формате DXT2 предполагается, что данные цвета были предварительно умножены на альфа. В формате DXT3 предполагается, что цвет не является предварительно умноженным на альфа. Эти два формата необходимы, так как в большинстве случаев, когда используется текстура, простого изучения данных недостаточно, чтобы определить, были ли значения цвета умножены на альфа. Поскольку эти сведения необходимы во время выполнения, для различения этих случаев используются два кода FOURCC. Однако данные и метод интерполяции, используемые для этих двух форматов, идентичны.

Сравнение цветов, используемое в DXT1, чтобы определить, является ли шаг текселя прозрачным, не используется в этом формате. Предполагается, что без сравнения цвета цветовые данные всегда обрабатываются в четырехцветном режиме. Иными словами, оператор if в верхней части кода DXT1 должен быть следующим:


```
if ((color_0 > color_1) OR !DXT1) {
```



## <a name="three-bit-linear-alpha-interpolation"></a>Three-Bit линейная альфа-интерполяция

Кодировка прозрачности для форматов DXT4 и DXT5 основана на концепции, аналогичной линейной кодировке, используемой для цвета. Два 8-разрядных альфа-фактора и точечный рисунок 4x4 с тремя битами на пиксель хранятся в первых восьми байтах блока. Репрезентативные альфа-факторы используются для интерполяции промежуточных альфа-факторов. Дополнительная информация содержится в способе хранения двух альфа-факторов. Если альфа \_ 0 больше альфа \_ 1, то интерполяция создает шесть промежуточных альфа-значений. В противном случае четыре промежуточных альфа-фактора интерполируются между указанными крайними альфа-факторами. Два дополнительных неявных альфа-фактора: 0 (полностью прозрачный) и 255 (полностью непрозрачный).

Следующий пример кода иллюстрирует этот алгоритм.


```
// 8-alpha or 6-alpha block?    
if (alpha_0 > alpha_1) {    
    // 8-alpha block:  derive the other six alphas.    
    // Bit code 000 = alpha_0, 001 = alpha_1, others are interpolated.
    alpha_2 = (6 * alpha_0 + 1 * alpha_1 + 3) / 7;    // bit code 010
    alpha_3 = (5 * alpha_0 + 2 * alpha_1 + 3) / 7;    // bit code 011
    alpha_4 = (4 * alpha_0 + 3 * alpha_1 + 3) / 7;    // bit code 100
    alpha_5 = (3 * alpha_0 + 4 * alpha_1 + 3) / 7;    // bit code 101
    alpha_6 = (2 * alpha_0 + 5 * alpha_1 + 3) / 7;    // bit code 110
    alpha_7 = (1 * alpha_0 + 6 * alpha_1 + 3) / 7;    // bit code 111  
}    
else {  
    // 6-alpha block.    
    // Bit code 000 = alpha_0, 001 = alpha_1, others are interpolated.
    alpha_2 = (4 * alpha_0 + 1 * alpha_1 + 2) / 5;    // Bit code 010
    alpha_3 = (3 * alpha_0 + 2 * alpha_1 + 2) / 5;    // Bit code 011
    alpha_4 = (2 * alpha_0 + 3 * alpha_1 + 2) / 5;    // Bit code 100
    alpha_5 = (1 * alpha_0 + 4 * alpha_1 + 2) / 5;    // Bit code 101
    alpha_6 = 0;                                      // Bit code 110
    alpha_7 = 255;                                    // Bit code 111
}
```



Схема памяти альфа-блока выглядит следующим образом.



| Byte | Коэффициент альфа                                                          |
|------|----------------------------------------------------------------|
| 0    | Альфа \_ 0                                                       |
| 1    | Альфа \_ 1                                                       |
| 2    | \[0 \] \[ 2 \] (2 МСБС), \[ 0 \] \[ 1 \] , \[ 0 \] \[ 0\]                    |
| 3    | \[1 \] \[ 1 \] (1-е), \[ 1 \] \[ 0 \] , \[ 0 \] \[ 3 \] , \[ 0 \] \[ 2 \] (1 ЛСБ) |
| 4    | \[1 \] \[ 3 \] , \[ 1 \] \[ 2 \] , \[ 1 \] \[ 1 \] (2 лсбс)                    |
| 5    | \[2 \] \[ 2 \] (2 МСБС), \[ 2 \] \[ 1 \] , \[ 2 \] \[ 0\]                    |
| 6    | \[3 \] \[ 1 \] (1-е \[ \] \[ , 0 – 4, 2 \] \[ \] \[ 3 \] , 2 \[ \] \[ 2 \] (1 ЛСБ) |
| 7    | \[3 \] \[ 3 \] , \[ 3 \] \[ 2 \] , \[ 3 \] \[ 1 \] (2 лсбс)                    |



 

Разница между DXT4 и DXT5 заключается в том, что в формате DXT4 предполагается, что данные цвета были предварительно умножены на альфа. В формате DXT5 предполагается, что цвет не является предварительно умноженным на альфа. Эти два формата необходимы, так как в большинстве случаев, когда используется текстура, простого изучения данных недостаточно, чтобы определить, были ли значения цвета умножены на альфа. Поскольку эти сведения необходимы во время выполнения, для различения этих случаев используются два кода FOURCC. Однако данные и метод интерполяции, используемые для этих двух форматов, идентичны.

Сравнение цветов, используемое в DXT1, чтобы определить, является ли шаг текселя прозрачным, не используется в этих форматах. Предполагается, что без сравнения цвета цветовые данные всегда обрабатываются в четырехцветном режиме. Иными словами, оператор if в начале кода DXT1 должен быть следующим:


```
if ((color_0 > color_1) OR !DXT1) {
```



## <a name="related-topics"></a>См. также

<dl> <dt>

[Сжатые ресурсы текстуры](compressed-texture-resources.md)
</dt> </dl>

 

 



