---
description: После завершения концептуальной и логической моделей можно принимать решения о физической реализации приложения.
ms.assetid: 18c440f0-88c8-4738-9f29-c82772439b51
title: 'Физическая модель: архитектура приложения'
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2f0fab87d76e445a365958ab330f572f657d1505
ms.sourcegitcommit: c7add10d695482e1ceb72d62b8a4ebd84ea050f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/07/2021
ms.locfileid: "104142589"
---
# <a name="the-physical-model-application-architecture"></a>Физическая модель: архитектура приложения

После завершения концептуальной и логической моделей можно принимать решения о физической реализации приложения. Чтобы создать физическую модель, необходимо понять, где должны располагаться различные службы приложения и как они должны быть реализованы. Определение места, где должны находиться различные службы, перед реализацией служб.

Одно из основных правил определения места существования различных служб: размещение компонента, где она используется. Если, например, компонент отображает сведения для базового клиента, он должен переключиться на компьютер пользователя. Если компонент проверяет сведения от базового клиента, он также должен находиться на компьютере базового клиента. Если компонент обновляет сведения в базе данных, он должен находиться на сервере базы данных.

Конечно, есть и другие соображения, которые делают исключения из этого правила. Проблемы с производительностью и безопасностью также могут зависеть от того, где находится компонент. Рассмотрим следующий пример.

-   Происходит ли частое изменение компонента, что усложняет распространение обновлений?
-   Будет ли компонент использоваться другими приложениями, такими как общий компонент проверки безопасности?
-   Создает ли компонент длительные вычисления или выполняет такие функции, как печать, которые можно разгрузить на сервер?
-   Можно ли улучшить безопасность компонента, поместив его на сервер?

Правильное размещение компонентов приложения также может изолировать команду разработчиков от дорогостоящих перекодирования при изменении системы или расположения данных. Например, размещение правил доступа к данным на уровне данных, а не в хранимых процедурах, упрощает изолированность приложения от зависимости от конкретной СУБД. Не только изменения являются ограниченными и тестируются подразделяется, но источники данных могут быть изменены, и данные могут быть распределены без фундаментального изменения приложения.

Наконец, Поиск компонентов должен воспользоваться преимуществами повышения эффективности системы. Это время и экономичное размещение бизнес-объектов в централизованных расположениях в сети. Объекты могут совместно использоваться приложениями, а модульное тестирование можно выполнить до развертывания каких бы то ни было компонентов. Затраты на обслуживание также можно уменьшить, так как изменения правил происходят только в одной точке.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Концептуальная модель: требования к приложениям](the-conceptual-model--application-requirements.md)
</dt> <dt>

[Логическая модель: определение приложения и планирование](the-logical-model--application-definition-and-planning.md)
</dt> </dl>

 

 



