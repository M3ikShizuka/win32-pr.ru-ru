---
description: Безопасность на основе ролей используется для установки политики авторизации, определяющей клиента или клиентов, которые будут использоваться и с какими полномочиями. Вы решите, кто должен иметь возможность выполнять действия и получать доступ к ресурсам.
ms.assetid: 8fc27fe1-e50a-44ba-a595-70b1fe463e24
title: Использование ролей для авторизации клиентов
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 1a808abc08d5360ba0b7fae0a7c31af80a4cab28c43e6014076c549204e6f28e
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119499652"
---
# <a name="using-roles-for-client-authorization"></a>Использование ролей для авторизации клиентов

Безопасность на основе ролей используется для установки политики авторизации, определяющей клиента или клиентов, которые будут использоваться и с какими полномочиями. Вы решите, кто должен иметь возможность выполнять действия и получать доступ к ресурсам.

Роли упрощают это, выступая в качестве механизма управления доступом, вызываемого каждый раз, когда пользователь пытается получить доступ к любому ресурсу приложения. Роль, по сути, является списком пользователей — точнее, символьной категорией пользователей, имеющих одинаковые привилегии безопасности. При назначении роли для ресурса приложения пользователю предоставляется разрешение на доступ к этому ресурсу, который является членом этой роли.

Таким образом, можно определить очень определенные привилегии безопасности, объявив ее как роль и назначив ей определенные ресурсы. При развертывании приложения системный администратор может заполнить роль реальными пользователями и группами пользователей. При запуске приложения COM+ применяет политику, выполняя проверки ролей.

По сути, роли помогают защитить код, то есть методы, которые могут вызываться клиентами приложения COM+. Членство в роли проверяется каждый раз, когда клиент пытается вызвать метод, предоставляемый компонентом в приложении. Если вызывающий объект находится в роли, назначенной вызываемому методу или ресурсу, вызов будет выполнен. в противном случае произойдет сбой.

## <a name="declarative-role-based-security"></a>Декларативная Role-Based безопасность

Декларативная безопасность на основе ролей позволяет администратору объявлять роли с помощью средства администрирования служб компонентов или административных функций, а также административно назначать их ресурсам приложений. Где и как задается декларативная безопасность, определяет, где будут отображаться границы безопасности для вашего приложения. Дополнительные сведения см. в разделе [границы безопасности](security-boundaries.md).

Данную роль можно назначить всему приложению, конкретному компоненту, конкретному интерфейсу в компоненте или конкретному методу интерфейса. Назначения ролей наследуются от естественной цепочки включения, т. е. Если назначить роль компоненту, она неявно назначается каждому интерфейсу и методу, предоставляемым этим компонентом.

Благодаря доступности назначений ролей на уровне метода можно эффективно защищать компоненты и интерфейсы, которые не были разработаны с учетом требований безопасности. Однако если сами методы не являются защищаемыми с помощью декларативных назначений ролей, может потребоваться выполнить программную проверку ролей. Как правило, рекомендуется учитывать вопросы безопасности при принятии решения о том, как оценить возможности бизнеса с помощью методов; в противном случае вы могли бы добавить код, связанный с безопасностью, за последнюю минуту.

Подробные процедуры настройки безопасности на основе ролей см. в разделе [Настройка безопасности Role-Based](configuring-role-based-security.md).

## <a name="programmatic-security"></a>Программная безопасность

В некоторых случаях может потребоваться поместить логику безопасности в компоненты, не применяя безопасность на основе ролей. Возможно, у вас нет возможности (или нет) учитывать все решения для доступа с помощью методов. Например, у вас может быть частный ресурс приложения, возможно, конкретная база данных, в которой необходимо разрешить доступ только некоторым вызывающим объектам метода, исключая другие. Или у вас может быть один метод Трансфермонэй и необходимо ограничить некоторые вызывающие объекты, ограничивая объем, который они могут передавать.

В таких обстоятельствах можно выполнять проверку ролей в коде. Предоставляется простой API, позволяющий проверять, включена ли безопасность и является ли участник или конкретный пользователь данной ролью. Эта функция доступна, только если включена безопасность на основе ролей. Это означает, что вы все равно можете воспользоваться преимуществами декларативной безопасности на основе ролей, где это достаточно, а затем при необходимости можно программно расширить ее до более детального уровня детализации.

Кроме того, при использовании безопасности на основе ролей у вас есть программный доступ к информации о всех восходящих вызовах в цепочке вызовов компонента. Это особенно полезно, если требуется вести подробный журнал аудита.

Описание того, как выполнять проверку ролей в коде и как получить доступ к сведениям о контексте вызова безопасности, см. в разделе [Программная безопасность компонентов](programmatic-component-security.md).

## <a name="authorization-and-authentication"></a>Авторизация и проверка подлинности

Осмысленная авторизация предполагает, что клиенты на самом деле имеют уверенность в том, что они говорят. Проверка удостоверения клиента обрабатывается отдельно службой проверки подлинности. Без проверки подлинности вы, по сути, разрабатываюте вызывающие объекты в системе учета принятых систем. Описание проверки подлинности по мере воздействия на приложения COM+ см. в разделе [Проверка подлинности клиента](client-authentication.md).

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Эффективное проектирование ролей](designing-roles-effectively.md)
</dt> <dt>

[Границы безопасности](security-boundaries.md)
</dt> <dt>

[Сведения о контексте вызова безопасности](security-call-context-information.md)
</dt> <dt>

[Свойство контекста безопасности](security-context-property.md)
</dt> </dl>

 

 



