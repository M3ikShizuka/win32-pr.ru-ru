---
description: В этом разделе содержатся сведения о вопросах безопасности, связанных с международными возможностями поддержки.
ms.assetid: 4034f479-ad29-4c6f-82c6-977f420c4d4d
title: 'Вопросы безопасности: международные функции'
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: aeb9f8b849e9fb1a07f01031832449b9c9027ae5
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "104272813"
---
# <a name="security-considerations-international-features"></a>Вопросы безопасности: международные функции

В этом разделе содержатся сведения о вопросах безопасности, связанных с международными возможностями поддержки. Вы можете использовать его в качестве отправной точки, а затем просмотреть документацию по международной технологии, представляющей интерес в отношении безопасности, связанных с конкретными технологиями.

В этом разделе содержатся следующие подразделы.

-   [Вопросы безопасности для функций преобразования символов](#security-considerations-for-character-conversion-functions)
-   [Вопросы безопасности для функций сравнения](#security-considerations-for-comparison-functions)
-   [Вопросы безопасности для наборов символов в именах файлов](#security-considerations-for-character-sets-in-file-names)
-   [Вопросы безопасности для международных доменных имен](#security-considerations-for-internationalized-domain-names)
-   [Вопросы безопасности для функций ANSI](#security-considerations-for-ansi-functions)
-   [Вопросы безопасности при нормализации Юникода](#security-considerations-for-unicode-normalization)

## <a name="security-considerations-for-character-conversion-functions"></a>Вопросы безопасности для функций преобразования символов

[**MultiByteToWideChar**](/windows/desktop/api/Stringapiset/nf-stringapiset-multibytetowidechar) и [**WideCharToMultiByte**](/windows/desktop/api/Stringapiset/nf-stringapiset-widechartomultibyte) — это функции Юникода и кодировки, наиболее часто используемые для преобразования символов между ANSI и Unicode. Эти функции могут вызвать угрозы безопасности, так как они подсчитывают элементы входных и выходных буферов по-разному. Например, [**MultiByteToWideChar**](/windows/desktop/api/Stringapiset/nf-stringapiset-multibytetowidechar) получает входной буфер в байтах и преобразует преобразованные символы в размер буфера в символах Юникода. Когда приложение использует эту функцию, оно должно правильно изменить размер буферов, чтобы избежать переполнения буфера.

[**WideCharToMultiByte**](/windows/desktop/api/Stringapiset/nf-stringapiset-widechartomultibyte) по умолчанию имеет наилучшее сопоставление для кодовых страниц, например 1252. Однако этот тип сопоставления допускает несколько представлений одной и той же строки, что может привести к тому, что приложение будет уязвимо для атак. Например, Латинская прописная буква A с диересис ("Ä") может сопоставляться с Латинской прописной буквой а ("A"); символ Юникода в азиатском языке может соответствовать косой черте ("/"). \_ \_ \_ \_ С точки зрения безопасности предпочтительнее использовать флаг WC не подходит.

Некоторые кодовые страницы, например кодовые страницы 5022x (ISO-2022-x), по своей природе небезопасны, так как они позволяют использовать несколько представлений одной и той же строки. Правильно написанный код выполняет проверки безопасности в форме Юникода, но эти типы кодовых страниц расширяют атаку, уязвимости приложения, и их следует избегать по возможности.

## <a name="security-considerations-for-comparison-functions"></a>Вопросы безопасности для функций сравнения

Сравнение строк потенциально может представлять проблемы безопасности. Поскольку все функции сравнения немного различаются, одна функция может сообщать о двух строках как равных, а другая функция может считать их разными. Ниже приведены несколько функций, которые приложения могут использовать для сравнения строк.

-   [лстркмпи](/windows/win32/api/winbase/nf-winbase-lstrcmpia). Сравнивает две символьные строки в соответствии с правилами языкового стандарта без учета регистра. Функция сравнивает строки, проверяя первые символы друг от друга, вторые символы и т. д., пока не найдет неравенство или не достигнет конца строк.
-   [лстркмп](/windows/win32/api/winbase/nf-winbase-lstrcmpa). Сравнивает строки с помощью методов, аналогичных методам [лстркмпи](/windows/win32/api/winbase/nf-winbase-lstrcmpia). Единственное отличие заключается в том, что [лстркмп](/windows/win32/api/winbase/nf-winbase-lstrcmpa) выполняет сравнение строк с учетом регистра.
-   [**CompareString**](/windows/win32/api/stringapiset/nf-stringapiset-comparestringw), [**Компарестринжекс**](/windows/desktop/api/Stringapiset/nf-stringapiset-comparestringex) (Windows Vista и более поздние версии). Выполнить сравнение строк в языковом стандарте, предоставляемом приложением. [**Компарестринжекс**](/windows/desktop/api/Stringapiset/nf-stringapiset-comparestringex) аналогичен [**CompareString**](/windows/win32/api/stringapiset/nf-stringapiset-comparestringw), но он определяет языковой стандарт по [имени локали](locale-names.md) вместо [идентификатора локали](locale-identifiers.md). Эти функции похожи на [лстркмпи](/windows/win32/api/winbase/nf-winbase-lstrcmpia) и [лстркмп](/windows/win32/api/winbase/nf-winbase-lstrcmpa) , за исключением того, что они работают с конкретным языковым стандартом вместо языкового стандарта, выбранного пользователем.
-   [**CompareStringOrdinal**](/windows/desktop/api/Stringapiset/nf-stringapiset-comparestringordinal) (Windows Vista и более поздние версии). Сравнивает две строки Юникода для проверки эквивалентности двоичных файлов. За исключением случаев, когда параметр не учитывает регистр, эта функция игнорирует все недвоичные эквиваленты и проверяет все кодовые точки на равенство, включая кодовые точки, для которых не задан вес в лингвистических схемах [сортировки](sorting.md) . Обратите внимание, что другие функции сравнения, упомянутые в этом разделе, не проверяют все кодовые точки на равенство.
-   [**Финднлсстринг**](/windows/desktop/api/Winnls/nf-winnls-findnlsstring), [**Финднлсстринжекс**](/windows/desktop/api/Winnls/nf-winnls-findnlsstringex) (Windows Vista и более поздние версии). Находите строку в Юникоде в другой строке Юникода. [**Финднлсстринжекс**](/windows/desktop/api/Winnls/nf-winnls-findnlsstringex) похож на [**финднлсстринг**](/windows/desktop/api/Winnls/nf-winnls-findnlsstring), за исключением того, что он определяет языковой стандарт по имени локали вместо идентификатора локали.
-   [**Финдстрингординал**](/windows/desktop/api/Libloaderapi/nf-libloaderapi-findstringordinal) (Windows 7 и более поздние версии). Находит одну строку Юникода в другой строке Юникода. Приложение должно использовать эту функцию вместо [**финднлсстринг**](/windows/desktop/api/Winnls/nf-winnls-findnlsstring) для всех нелингвистических сравнений.

Как и [лстркмпи](/windows/win32/api/winbase/nf-winbase-lstrcmpia) и [лстркмп](/windows/win32/api/winbase/nf-winbase-lstrcmpa), [**CompareString**](/windows/win32/api/stringapiset/nf-stringapiset-comparestringw) вычисляет строки по символу. Однако многие языки содержат элементы с несколькими символами, например два символа "CH" в традиционном испанском. Поскольку [**CompareString**](/windows/win32/api/stringapiset/nf-stringapiset-comparestringw) использует языковой стандарт, предоставляемый приложением для обнаружения элементов с несколькими символами, а [лстркмпи](/windows/win32/api/winbase/nf-winbase-lstrcmpia) и [лстркмп](/windows/win32/api/winbase/nf-winbase-lstrcmpa) использует языковой стандарт потока, идентичные строки могут не сравниваться как равные.

[**CompareString**](/windows/win32/api/stringapiset/nf-stringapiset-comparestringw) игнорирует неопределенные символы и, таким словами, возвращает ноль (указывающий равные строки) для многих строковых пар, которые довольно уникальны. Строка может содержать значения, которые не сопоставлены ни с одним символом, либо могут содержать символы с семантикой вне домена приложения, например управляющие символы в URL-адресе. Приложения, использующие эту функцию, должны предоставлять обработчики ошибок и тестовые строки, чтобы убедиться, что они являются допустимыми, прежде чем использовать их.

> [!Note]  
> Для Windows Vista и более поздних версий [**компарестринжекс**](/windows/desktop/api/Stringapiset/nf-stringapiset-comparestringex) аналогичен [**CompareString**](/windows/win32/api/stringapiset/nf-stringapiset-comparestringw). Для этих функций существуют одинаковые проблемы безопасности.

 

Аналогичные проблемы безопасности относятся к функциям, таким как [**финднлсстринг**](/windows/desktop/api/Winnls/nf-winnls-findnlsstring), которые делают неявные сравнения. В зависимости от установленных флагов результаты вызова [**финднлсстринг**](/windows/desktop/api/Winnls/nf-winnls-findnlsstring) для поиска одной строки в другой строке могут значительно различаться.

> [!Note]  
> Для Windows Vista и более поздних версий [**финднлсстринжекс**](/windows/desktop/api/Winnls/nf-winnls-findnlsstringex) аналогичен [**финднлсстринг**](/windows/desktop/api/Winnls/nf-winnls-findnlsstring). Для этих функций существуют одинаковые проблемы безопасности.

 

## <a name="security-considerations-for-character-sets-in-file-names"></a>Вопросы безопасности для наборов символов в именах файлов

Кодовая страница Windows и наборы символов OEM, используемые в системах на японском языке, содержат символ [¥) вместо обратной косой черты ( \\ ). Таким словами, символ «символы» является запрещенным для файловых систем NTFS и FAT. При сопоставлении Юникода с кодовой страницей на японском языке функции преобразования сопоставляют обратную косую черту (U + 005C) и Стандартный символ Юникода в Юникоде (U + 00A5) к этому же символу. По соображениям безопасности приложения обычно не должны допускать символ U + 00A5 в строке Юникода, которую можно преобразовать для использования в качестве имени файла FAT.

## <a name="security-considerations-for-internationalized-domain-names"></a>Вопросы безопасности для международных доменных имен

Международные доменные имена (IDNs) указываются в сетевой рабочей группе [RFC 3490: Интернатионализинг Domain Names in Applications (IDNA)](http://www.faqs.org/rfcs/rfc3490.html). Стандарт представляет ряд проблем безопасности.

Глифы, представляющие определенные символы из разных скриптов, могут выглядеть одинаково или даже одинаково. Например, во многих шрифтах строчная буква а ("a") не различается в строчной букве а ("a"). Не существует способа сообщить визуально, что "example.com" и "example.com" — это два разных доменных имени, одна с Латинской строчной буквой A в имени, а другая — строчная буква A. Сайт узла неразборчивые может использовать эту визуальную неоднозначность для того, чтобы стать другим сайтом в атаке с подменой.

Расширенная кодировка, которую поддерживает IDNA для IDNs, также имеет возможность подмены в рамках конкретного сценария. Например, существует много сходства между дефисом-минусом ("-" U + 002D), дефис ("–" U + 2010), Неразрывный дефис ("-" U + 2011), рисунок, тире ("\u2012" U + 2012), короткое тире ("–" U + 2013) и знак "минус" ("−" U + 2212).

Аналогичные проблемы возникают при определенных композициях совместимости. Например, один символ Юникода с номером двадцать полной остановкой ("20.", U + 249B) преобразуется в "20". (U + 0032 u + 0030 U + 002E) на шаге Намепреп до преобразования в Punycode. Иными словами, эта композиция вставляет точку (полную точку). Такие композиции имеют возможность подмены.

Смешивание разных сценариев в IDN не обязательно означает подмену или намерение обмана. [Технический отчет \# 36. вопросы безопасности в Юникоде](https://www.unicode.org/reports/tr36/#international_domain_names) предоставляют несколько примеров разумных IDNs, которые содержат набор сценариев, например XML-документы. com ("документы" — Русский для документов).

Атаки с подменой не ограничиваются IDNs. Например, "rnicrosoft.com" выглядит так же, как "microsoft.com", но является именем ASCII. Кроме того, атака с подменой может быть вызвана повреждением имени. Добавление дополнительных меток после хорошо известного фирменного названия или включение фирменного названия в путь URL-адреса, помеченного как безопасный, может привести к путанице пользователей, независимо от использования IDN. Для некоторых языковых стандартов IDNs являются обязательными, и форма Punycode этих имен неприемлема, так как имена выглядят как вам.

Дополнительные сведения о вопросах безопасности, упомянутых здесь, и о большом количестве других проблем, связанных с IDNA, см. в [техническом отчете \# 36: вопросы безопасности в Юникоде](https://www.unicode.org/reports/tr36/#international_domain_names). Помимо подробного обсуждения проблем безопасности, связанных с IDNA, этот отчет предлагает рекомендации по работе с подозрительными IDNs в ваших приложениях.

## <a name="security-considerations-for-ansi-functions"></a>Вопросы безопасности для функций ANSI

> [!Note]  
> В глобальных приложениях рекомендуется использовать Юникод, особенно новые, если это возможно. Функции ANSI следует использовать только в том случае, если вы переопределяете причины отсутствия использования Юникода, например соответствие более старому протоколу, который не поддерживает Юникод.

 

Многие функции поддержки национальных языков (NLS), такие как [**GetLocaleInfo**](/windows/desktop/api/Winnls/nf-winnls-getlocaleinfoa) и [**жеткалендаринфо**](/windows/desktop/api/Winnls/nf-winnls-getcalendarinfoa), имеют определенные версии ANSI, в данном случае **жетлокалеинфоа** и **жеткалендаринфоа** соответственно. Если в приложении используется версия ANSI функции с операционной системой на основе Юникода, такой как Windows NT, Windows 2000, Windows XP или Windows Vista, функция может завершиться сбоем или получить неопределенные результаты. Если есть убедительная причина использования функций ANSI с такой операционной системой, убедитесь, что данные, передаваемые приложением, действительны для ANSI.

## <a name="security-considerations-for-unicode-normalization"></a>Вопросы безопасности при нормализации Юникода

Так как нормализация Юникода может изменить форму строки, механизмы безопасности или алгоритмы проверки символов, как правило, должны быть реализованы после нормализации. Например, рассмотрим приложение с веб-интерфейсом, который принимает имя файла, но не принимает имя пути. Полная ширина u + FF43 u + FF1A U + FF3C u + FF57 u + FF49 U + FF4E U + FF44 U + FF4F u + FF57 u + FF53. в u + 0063 u + 001A u + 003C u + 0077 u + 0069 u + u + 006E u + 0064 u + 006F `(c : \ w i n d o w s)` `(c:\windows)` . Если приложение проверяет наличие символа двоеточия и обратной косой черты перед реализацией нормализации, результатом может быть непреднамеренной доступ к файлу.

Хотя нормализация Юникода является элементом, обеспечивающим безопасность операционных систем, помните, что нормализация не является заменой для комплексной политики безопасности.

## <a name="related-topics"></a>См. также

<dl> <dt>

[Кодировки, используемые в именах файлов](character-sets-used-in-file-names.md)
</dt> <dt>

[Правила обозначения прототипов функций](conventions-for-function-prototypes.md)
</dt> <dt>

[Обработка сортировки в приложениях](handling-sorting-in-your-applications.md)
</dt> <dt>

[Обработка международных доменных имен (IDNs)](handling-internationalized-domain-names--idns.md)
</dt> <dt>

[Юникод](unicode.md)
</dt> </dl>

 

 
