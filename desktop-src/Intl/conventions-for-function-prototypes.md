---
description: Windows SDK предоставляет прототипы функций в универсальных, кодовых страницах Windows и версиях Юникода.
ms.assetid: 601d24b0-11bb-48fa-a257-207c3acee226
title: Правила обозначения прототипов функций
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 951860f72870dcbbcb88572f379e39dc843ecb11
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "103910123"
---
# <a name="conventions-for-function-prototypes"></a>Правила обозначения прототипов функций

Windows SDK предоставляет прототипы функций в универсальных, [кодовых страницах Windows](code-pages.md)и версиях [Юникода](unicode.md) . Прототипы могут быть скомпилированы для создания прототипов кодовых страниц Windows или прототипов Юникода. Все три прототипа обсуждаются в этом разделе и иллюстрируются примерами кода для функции [**SetWindowText**](/windows/win32/api/winuser/nf-winuser-setwindowtexta) .

Ниже приведен пример универсального прототипа.


```C++
BOOL SetWindowText(
  HWND hwnd,
  LPCTSTR lpText
);
```



Файл заголовка предоставляет универсальное имя функции, реализованное как макрос.


```C++
#ifdef UNICODE
#define SetWindowText SetWindowTextW
#else
#define SetWindowText SetWindowTextA
#endif // !UNICODE
```



Препроцессор расширяет макрос на кодовую страницу Windows или имя функции Юникода. Буква "A" (ANSI) или "W" (Юникод) добавляется в конце имени универсальной функции, если это необходимо. Затем файл заголовка предоставляет два отдельных прототипа: один для кодовых страниц Windows и один для Юникода, как показано в следующих примерах.


```C++
BOOL SetWindowTextA(
  HWND hwnd,
  LPCSTR lpText
);
```




```C++
BOOL SetWindowTextW(
  HWND hwnd,
  LPCWSTR lpText
);
```



Как описано в разделах [типы данных Windows для строк](windows-data-types-for-strings.md), прототип универсальной функции использует тип данных LPCTSTR для параметра Text. Однако прототип кодовой страницы Windows использует тип LPCSTR, а прототип Юникода — LPCWSTR.

Для всех функций с текстовыми аргументами приложения должны, как правило, использоваться универсальные прототипы функций. Если приложение определяет "UNICODE" перед инструкциями **\# include** для файлов заголовков или во время компиляции, инструкции будут скомпилированы в функции Юникода.

> [!Note]  
> Новые приложения Windows должны использовать Юникод, чтобы избежать несоответствий между различными кодовыми страницами и простотой локализации. Они должны быть написаны с помощью универсальных функций и должны определять Юникод, чтобы компилировать функции в функции Юникода. В некоторых местах, где приложение должно работать с 8-разрядными символьными данными, оно может явно использовать функции для кодовых страниц Windows.

 

Приложение должно всегда использовать универсальный прототип функции с универсальными строковыми и символьными типами. Все имена функций, оканчивающиеся на заглавную «W», принимают параметры в Юникоде (расширенные символы). Некоторые функции существуют только в версиях Юникода и могут использоваться только с соответствующими типами данных. Например, [**лЦидтолокаленаме**](/windows/desktop/api/Winnls/nf-winnls-lcidtolocalename) и [**локаленаметолЦид**](/windows/desktop/api/Winnls/nf-winnls-localenametolcid) имеют только версии Юникода.

В разделе "требования" в справочной документации по каждой функции Юникода и кодировки содержится информация о версиях функций, реализованных поддерживаемыми операционными системами. Если включена строка, начинающаяся с "Unicode", функция имеет отдельные версии кодовых страниц в Юникоде и Windows.

> [!Note]  
> Если функция имеет параметр длины для символьной строки, ее длина должна задокументирована как количество значений TCHAR в строке. Этот тип данных относится к байтам для версий кодовой страницы Windows функции или 16-разрядных слов для версий Юникода. Однако функции, требующие или возвращающие указатели на нетипизированные блоки памяти, такие как функция [**GlobalAlloc**](/windows/win32/api/winbase/nf-winbase-globalalloc) , обычно имеют размер в байтах, независимо от используемого прототипа. Если выделение нетипизированной памяти предназначено для строки, приложение должно умножить число символов на sizeof (TCHAR). Дополнительные сведения см. [в разделе Использование универсальных типов данных](using-generic-data-types.md).

 

## <a name="related-topics"></a>См. также

<dl> <dt>

[Юникод в Windows API](unicode-in-the-windows-api.md)
</dt> </dl>

 

 
