---
description: Windows SDK предоставляет прототипы функций в универсальных, Windows кодовой странице и версиях юникода.
ms.assetid: 601d24b0-11bb-48fa-a257-207c3acee226
title: Правила обозначения прототипов функций
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3cd37171ed4cd1f0f00267b935ec57f17ef2957514b63d770efdc851b9c08bb6
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119746144"
---
# <a name="conventions-for-function-prototypes"></a>Правила обозначения прототипов функций

Windows SDK предоставляет прототипы функций в универсальных, [Windows кодовой странице](code-pages.md)и версиях [юникода](unicode.md) . прототипы могут быть скомпилированы для создания либо Windows прототипов кодовых страниц, либо прототипов юникода. Все три прототипа обсуждаются в этом разделе и иллюстрируются примерами кода для функции [**SetWindowText**](/windows/win32/api/winuser/nf-winuser-setwindowtexta) .

Ниже приведен пример универсального прототипа.


```C++
BOOL SetWindowText(
  HWND hwnd,
  LPCTSTR lpText
);
```



Файл заголовка предоставляет универсальное имя функции, реализованное как макрос.


```C++
#ifdef UNICODE
#define SetWindowText SetWindowTextW
#else
#define SetWindowText SetWindowTextA
#endif // !UNICODE
```



препроцессор расширяет макрос на Windows кодовую страницу или имя функции юникода. Буква "A" (ANSI) или "W" (Юникод) добавляется в конце имени универсальной функции, если это необходимо. затем файл заголовка предоставляет два отдельных прототипа: один для кодовых страниц Windows и один для юникода, как показано в следующих примерах.


```C++
BOOL SetWindowTextA(
  HWND hwnd,
  LPCSTR lpText
);
```




```C++
BOOL SetWindowTextW(
  HWND hwnd,
  LPCWSTR lpText
);
```



как описано в [Windows типов данных для строк](windows-data-types-for-strings.md), прототип универсальной функции использует тип данных LPCTSTR для параметра text. Однако прототип кодовой страницы Windows использует тип LPCSTR, а прототип Юникода — LPCWSTR.

Для всех функций с текстовыми аргументами приложения должны, как правило, использоваться универсальные прототипы функций. Если приложение определяет "UNICODE" перед инструкциями **\# include** для файлов заголовков или во время компиляции, инструкции будут скомпилированы в функции Юникода.

> [!Note]  
> новые Windows приложения должны использовать юникод, чтобы избежать несоответствий между различными кодовыми страницами и простотой локализации. Они должны быть написаны с помощью универсальных функций и должны определять Юникод, чтобы компилировать функции в функции Юникода. в некоторых местах, где приложение должно работать с 8-разрядными символьными данными, оно может явно использовать функции для Windows кодовых страниц.

 

Приложение должно всегда использовать универсальный прототип функции с универсальными строковыми и символьными типами. Все имена функций, оканчивающиеся на заглавную «W», принимают параметры в Юникоде (расширенные символы). Некоторые функции существуют только в версиях Юникода и могут использоваться только с соответствующими типами данных. Например, [**лЦидтолокаленаме**](/windows/desktop/api/Winnls/nf-winnls-lcidtolocalename) и [**локаленаметолЦид**](/windows/desktop/api/Winnls/nf-winnls-localenametolcid) имеют только версии Юникода.

В разделе "требования" в справочной документации по каждой функции Юникода и кодировки содержится информация о версиях функций, реализованных поддерживаемыми операционными системами. если включена строка, начинающаяся с "Unicode", функция имеет отдельные версии юникода и Windows кодовых страниц.

> [!Note]  
> Если функция имеет параметр длины для символьной строки, ее длина должна задокументирована как количество значений TCHAR в строке. этот тип данных относится к байтам для Windows версий кодовой страницы функции или 16-разрядных слов для версий юникода. Однако функции, требующие или возвращающие указатели на нетипизированные блоки памяти, такие как функция [**GlobalAlloc**](/windows/win32/api/winbase/nf-winbase-globalalloc) , обычно имеют размер в байтах, независимо от используемого прототипа. Если выделение нетипизированной памяти предназначено для строки, приложение должно умножить число символов на sizeof (TCHAR). Дополнительные сведения см. [в разделе Использование универсальных типов данных](using-generic-data-types.md).

 

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Юникод в Windows API](unicode-in-the-windows-api.md)
</dt> </dl>

 

 
