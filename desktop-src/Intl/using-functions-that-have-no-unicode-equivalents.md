---
description: Функции, которые не были реализованы в версии Юникода, обычно заменены более мощными или расширенными функциями, поддерживающими Юникод.
ms.assetid: 9e02c8fe-4fed-4b77-9b09-35850350859a
title: Использование функций, не имеющих эквивалентов в Юникоде
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: b0850eea442b98c81918c7c6733da65f730936be
ms.sourcegitcommit: d75fc10b9f0825bbe5ce5045c90d4045e3c53243
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/13/2021
ms.locfileid: "127254869"
---
# <a name="using-functions-that-have-no-unicode-equivalents"></a>Использование функций, не имеющих эквивалентов в Юникоде

Функции, которые не были реализованы в версии [Юникода](unicode.md) , обычно заменены более мощными или расширенными функциями, поддерживающими Юникод. Например, при переносе кода, который вызывает функцию [**OpenFile**](/windows/win32/api/winbase/nf-winbase-openfile) , приложение может поддерживать Юникод с помощью функции [**CreateFile**](/windows/win32/api/fileapi/nf-fileapi-createfilea) .

Если функция не имеет эквивалента в Юникоде, приложение может сопоставлять символы и из 8-разрядных наборов символов до и после вызова функции. Например, функции форматирования чисел **atoi** и **Итоа** используют только цифры от 0 до 9. Как правило, сопоставление Юникода с 8-разрядными символами приводит к утрате данных, но это можно избежать, сделав независимым от типа кода и сделав выражения условными. Инструкции в следующем примере, написанные для 8-разрядных символов, зависят от типа и должны быть изменены для поддержки Юникода.


```C++
char str[4] = "137";

int num = atoi(str);
```



Эти инструкции можно переписывать следующим образом, чтобы сделать их независимыми от типов.


```C++
TCHAR tstr[4] = TEXT("137");

#ifdef UNICODE
size_t cCharsConverted;
CHAR strTmp[SIZE]; // SIZE equals (2*(sizeof(tstr)+1)). This ensures enough
                   // room for the multibyte characters if they are two 
                   // bytes long and a terminating null character. See Security 
                   // Alert below. 

wcstombs_s(&cCharsConverted, strTmp, sizeof(strTmp), (const wchar_t *)tstr, sizeof(strTmp));
num = atoi(strTmp);

#else

int num = atoi(tstr);

#endif 
```



В этом примере Стандартная функция библиотеки C **wcstombs** преобразует Юникод в ASCII. В этом примере используется тот факт, что цифры от 0 до 9 всегда могут быть преобразованы из Юникода в ASCII, даже если часть окружающего текста не может. Функция **atoi** останавливается на любом символе, который не является цифрой.

Приложение может использовать функцию [**LCMapString завершилось ошибкой**](/windows/desktop/api/Winnls/nf-winnls-lcmapstringa) национальных языков (NLS) для обработки текста, содержащего [собственные цифры](digit-shapes.md) , предоставленные для некоторых скриптов в Юникоде.

> [!Caution]  
> Неправильное использование функции **wcstombs** может привести к нарушению безопасности приложения. Убедитесь, что буфер приложения для строки 8-разрядных символов имеет размер не меньше 2 \* (*символьная \_ Длина* + 1), где *char \_ length* представляет длину строки в Юникоде. Это ограничение устанавливается потому, что с двухбайтовыми [наборами символов](double-byte-character-sets.md) (DBCS) каждый символ Юникода может быть сопоставлен с двумя последовательными 8-разрядными символами. Если буфер не содержит всю строку, результирующая строка не завершается нулем, что приводит к угрозе безопасности. Дополнительные сведения о безопасности приложений см. в разделе [вопросы безопасности: международные функции](security-considerations--international-features.md).

 

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Использование Юникода и кодировок](using-unicode-and-character-sets.md)
</dt> </dl>

 

 
