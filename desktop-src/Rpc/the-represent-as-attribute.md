---
title: Атрибут represent_as
description: Атрибут \ представить \_ как \ позволяет указать, каким образом в приложение будет представлен конкретный тип данных для передачи.
ms.assetid: 6f07ab90-b5bb-48ae-870c-5abaf80ce0e5
keywords:
- Удаленный вызов процедур RPC, атрибуты, represent_as
- represent_as
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3bbf217260f3d23f7390a2295d7db5a36174ae01a94f7368f8e7d2085d19ae0e
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118924003"
---
# <a name="the-represent_as-attribute"></a>Атрибут представления \_ как

Атрибут \[ [представить \_ как](/windows/desktop/Midl/represent-as) \] позволяет указать, каким образом в приложение будет представлен конкретный тип данных для передачи. Для этого нужно указать имя представленного типа для известного типа передающего объекта и предоставить подпрограммы преобразования. Кроме того, необходимо предоставить подпрограммы для высвобождения памяти, используемой объектами типа данных.

Используйте атрибут **\[ представить \_ как \]** для представления приложения с другим, возможно, недопустимым типом данных, а не типом, который фактически передается между клиентом и сервером. Также возможно, что тип, который манипулирует приложением, может быть неизвестным во время компиляции MIDL. При выборе хорошо определенного типа, передающего данные, не стоит беспокоиться о представлении данных в разнородной среде. Атрибут « **\[ представить \_ как \]** » может сделать приложение более эффективным, уменьшая объем данных, передаваемых по сети.

Атрибут « **\[ представить \_ как \]** » аналогичен \[ атрибуту « [передать \_ как](/windows/desktop/Midl/transmit-as) » \] . Однако при **\[ передаче \_ как \]** позволяет указать тип данных, который будет использоваться для передачи, **\[ представляется \_ как \]** позволяет указать, как тип данных представлен для приложения. Представленный тип не требуется определять в файлах, обработанных MIDL; его можно определить во время компиляции заглушек с помощью компилятора C. Для этого используйте директиву include в [файле конфигурации приложения (ACF)](the-application-configuration-file-acf-.md) , чтобы скомпилировать соответствующий файл заголовка. Например, следующий ACF определяет тип, локальный для приложения, **\_ тип репр**, для типа, поддающегося типу, **с именем \_ Type:**

``` syntax
typedef [represent_as(repr_type) [, type_attribute_list] named_type;
```

В следующей таблице описаны четыре подпрограммы, предоставляемые программистом.



| Подпрограмма                      | Описание                                                                                          |
|------------------------------|------------------------------------------------------------------------------------------------------|
| **именованный \_ тип \_ из \_ локальной** | Выделяет экземпляр типа сети и выполняет преобразование из локального типа в тип сети.      |
| **именованный \_ тип \_ в \_ Local**   | Преобразует тип сети в локальный тип.                                                    |
| **\_ \_ свободный \_ локальный именованный тип** | Освобождает память, выделенную с помощью вызова **именованного \_ типа, \_ в \_ локальную** подпрограммы, но не сам тип. |
| **\_ \_ свободный \_ inst именованного типа**  | Освобождает хранилище для типа сети (по обеим сторонам).                                                     |



 

В отличие от этих четырех подпрограмм, предоставленных программистом, именованный тип не обрабатывается приложением. Единственным типом, видимым для приложения, является представленный тип. Приложение использует имя представленного типа вместо имени переданного типа в прототипах и заглушках, созданных компилятором. Необходимо указать набор подпрограмм для обеих сторон.

Для временных объектов **именованного \_ типа** заглушка вызывает **именованный \_ тип \_ Free \_ inst** , чтобы освободить память, выделенную вызовом **именованного \_ типа \_ из \_ локальной** переменной.

Если представленный тип является указателем или содержит указатель, **именованный \_ тип \_ в \_ локальную** подпрограмму должен выделять память для данных, к которым точка указателя (объект представленного типа управляется заглушкой обычным способом). Для \[ [out](/windows/desktop/Midl/out-idl) \] и \[ [in](/windows/desktop/Midl/in)выходные \] Параметры типа, которые содержат элементы **\[ представления \_ как** или один из его компонентов, для объектов данных, содержащих атрибут, автоматически вызывается **\_ \_ \_ Локальная подпрограммы с именованным типом Free** . Для **\[ \] входных** параметров **\_ \_ \_ Локальная подпрограммы с именованным типом** вызывается, только если к параметру применен атрибут " **\[ представить \_ как \]** ". Если атрибут применен к компонентам параметра, то не вызывается *\* *** \_ бесплатная \_ Локальная* подпрограммы *. Свободные подпрограммы не вызываются для внедренных данных и параллельного вызова (связанного с атрибутом верхнего уровня) для параметра только **\[ в \]** .

> [!Note]  
> К одному и тому же типу можно применить как атрибуты **\[ передачи \_ \]** , так и **\[ представления \_ \]** . При упаковке данных сначала применяется преобразование типа **\[ представления \_ как \]** тип, а затем применяется преобразование « **\[ Передача \_ как \]** ». При демаршалировании данных порядок изменяется в противоположный. Таким словами, при упаковке \* *_\_ из \_ локальной_* области выделяется экземпляр именованного типа, который преобразуется из объекта локального типа в объект временного именованного типа. Этот объект представляет собой представленный объект типа, используемый для \* подпрограммы *_\_ to \_ xmit_* . \*Затем подпрограммы *_\_ to \_ xmit_* распределяют переданный объект типа и переводит его из представленного (именованного) объекта в переданный объект.

 

Для представления связанного списка можно использовать массив длинных целых чисел. Таким образом, приложение обрабатывает список, а передача использует массив длинных целых чисел при передаче списка этого типа. Можно начать с массива, но более удобно использовать конструкцию с открытым массивом длинных целых чисел. В приведенном ниже примере показано, как это сделать.

``` syntax
/* IDL definitions */
 
typedef struct_lbox 
{
    long        data;
    struct_lbox *        pNext;
} LOC_BOX, * PLOC_BOX;
 
/* The definition of the local type visible to the application, 
as shown above, can be omitted in the IDL file. See the include 
in the ACF file. */
 
typedef struct_xmit_lbox 
{
    short        Size;
    [size_is(Size)] long DaraArr[];
} LONGARR;
 
void WireTheList( [in,out] LONGARR * pData );
 
/* ACF definitions */
 
/* If the IDL file does not have a definition for PLOC_BOX, you 
can still ready it for C compilation with the following include 
statement (notice that this is not a C include): 
include "local.h";*/
 
typedef [represent_as(PLOC_BOX)] LONGARR;
```

Обратите внимание, что прототипы подпрограмм, использующих тип **лонгарр** , фактически отображаются в файле заглушек. h в качестве **Плок \_** вместо типа **лонгарр** . То же самое справедливо и для соответствующих заглушек в файле заглушки \_ c. c.

Необходимо указать следующие четыре функции:

``` syntax
void __RPC_USER
LONGARR_from_local(
    PLOC_BOX __RPC_FAR * pList,
    LONGARR __RPC_FAR * _RPC_FAR * ppDataArr );
 
void __RPC_USER
LONGARR_to_local(
    LONGARR __RPC_FAR * _RPC_FAR * ppDataArr,
    PLOC_BOX __RPC_FAR * pList );
 
void __RPC_USER
LONGARR_free_inst(
    LONGARR __RPC_FAR * pDataArr);
 
void __RPC_USER
LONGARR_free_local(
    PLOC_BOX __RPC_FAR * pList );
```

Приведенные выше подпрограммы выполняют следующие действия.

-   **Лонгарр \_ из \_ локальной** подпрограммы подсчитывает узлы списка, выделяет объект лонгарр с размером **sizeof**(**лонгарр**) + Count \* *_sizeof_*(**Long**), устанавливает в поле **size** значение Count и копирует данные в поле **датаарр** .
-   **Лонгарр \_ to \_ Local** подпрограммы создает список с размерами узлов и передает массив соответствующим узлам.
-   Подпрограммы **лонгарр \_ Free \_ inst** в этом случае не освобождаются.
-   **\_ Бесплатная \_ Локальная** подпрограммы лонгарр освобождает все узлы списка.

 

 