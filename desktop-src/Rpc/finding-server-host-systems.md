---
title: Поиск систем узлов сервера
description: Поиск систем узлов сервера с помощью строковых привязок и запрос к базе данных службы имен для расположения серверной программы.
ms.assetid: 4aadda88-2109-481f-aa4b-b1983d81dec5
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: d2357fcafa35d4f64cfb4f6841c0b56e1e94b7aa
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "103888535"
---
# <a name="finding-server-host-systems"></a>Поиск систем узлов сервера

Хост-система сервера — это компьютер, на котором выполняется серверная программа распределенного приложения. В сети может быть одна или несколько серверных систем размещения. Способ обнаружения сервера для подключения клиентской программой зависит от потребностей программы.

Существует два способа поиска систем размещения сервера:

-   Использование сведений, хранящихся в строках исходного кода клиента, переменных среды или файлов конфигурации приложения. Клиентское приложение может использовать данные в строке для создания привязки между клиентом и сервером.
-   Запрос к базе данных службы имен для расположения серверной программы.

В этом разделе представлены сведения об этих методах в следующих разделах.

-   [Использование строковых привязок](#using-string-bindings)
-   [Импорт из баз данных службы имен](#importing-from-name-service-databases)

## <a name="using-string-bindings"></a>Использование строковых привязок

Приложения могут создавать привязки из информации, хранящейся в строках. Клиентское приложение формирует эти сведения в виде строки, а затем вызывает функцию [**рпкбиндингфромстрингбиндинг**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingfromstringbinding) . Для обнаружения сервера клиент должен предоставить следующие сведения:

-   Имя интерфейса, глобальный уникальный идентификатор (GUID) объекта или UUID объекта. Дополнительные сведения см. в разделе [создание идентификаторов UUID интерфейса](generating-interface-uuids.md) и [строкового UUID](string-uuid.md).
-   Тип транспорта для взаимодействия, например именованные каналы или TCP/IP. Дополнительные сведения см. в разделе [Основная терминология привязки RPC](essential-rpc-binding-terminology.md) и [Выбор последовательности протокола](selecting-a-protocol-sequence.md).
-   Сетевой адрес или имя главного компьютера сервера.
-   Конечная точка серверной программы на главном компьютере сервера. Дополнительные сведения см. в разделе [Поиск конечных точек](finding-endpoints.md)и [Указание конечных точек](specifying-endpoints.md).

(Идентификатор объекта и сведения о конечной точке являются необязательными.)

В следующих примерах параметр *псзнетворкаддресс* и другие параметры включают в себя встроенные символы обратной косой черты. Обратная косая черта — это escape-символ в языке программирования C. Две обратные косые черты необходимы для представления каждого отдельного символа обратной косой черты. Структура строковой привязки должна содержать четыре символа обратной косой черты, представляющие два литерала обратной косой черты, предшествующие имени сервера.

В следующем примере показано, что перед именем сервера должны стоять восемь обратных косых черт, чтобы в структуре данных привязки строк отображались четыре литеральных символа обратной косой черты после того, как функция **sprintf \_ s** обработает строку.


```C++
/* client application */

char * pszUuid = "6B29FC40-CA47-1067-B31D-00DD010662DA";
char * pszProtocol = "ncacn_np";
char * pszNetworkAddress = "\\\\\\\\servername";
char * pszEndpoint = "\\\\pipe\\\\pipename";
char * pszString;
 
int len = 0;
 
len  = sprintf_s(pszString, strlen(pszUuid), "%s", pszUuid);
len += sprintf_s(pszString + len, strlen(pszProtocolSequence) + 2, "@%s:",
    pszProtocolSequence);
if (pszNetworkAddress != NULL)
    len += sprintf_s(pszString + len, strlen(pszNetworkAddress), "%s",
    pszNetworkAddress);
len += sprintf_s(pszString + len, strlen(pszEndpoint) + 2, "[%s]", pszEndpoint);
```



В следующем примере строковая привязка выглядит следующим образом:

6B29FC40-CA47-1067-B31D-00DD010662DA@ncacn\_NP: \\ \\ \\ \\ *имя_сервера* \[ \\ \\ pipe \\ \\ *pipeName*\]

Затем клиент вызывает [**рпкбиндингфромстрингбиндинг**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingfromstringbinding) для получения маркера привязки:


```C++
RPC_BINDING_HANDLE hBinding;
 
status = RpcBindingFromStringBinding(pszString, &hBinding);
//...
```



Для удобства работы [**рпкстрингбиндингкомпосе**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcstringbindingcompose) собирает идентификатор объекта, последовательность протокола, сетевой адрес и конечную точку в правильном синтаксисе для вызова [**рпкбиндингфромстрингбиндинг**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingfromstringbinding). Не нужно беспокоиться о размещении амперсанда, двоеточия и различных компонентов для каждой последовательности протоколов в нужном месте; Вы просто предоставляете строки в качестве параметров функции. Библиотека времени выполнения даже выделяет память, необходимую для привязки строк.


```C++
char * pszNetworkAddress = "\\\\server";
char * pszEndpoint = "\\pipe\\pipename";
status = RpcStringBindingCompose(
            pszUuid,
            pszProtocolSequence,
            pszNetworkAddress,
            pszEndpoint,
            pszOptions,
            &pszString);
//...
status = RpcBindingFromStringBinding(
            pszString,
            &hBinding);
//...
```



Другая удобная функция, [**рпкбиндингтострингбиндинг**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingtostringbinding), принимает в качестве входных данных обработчик привязки и создает соответствующую строковую привязку.

## <a name="importing-from-name-service-databases"></a>Импорт из баз данных службы имен

Службы Name databases сохраняют, помимо прочего, дескрипторы привязки и UUID. Клиентское приложение может выполнять поиск одного или обоих элементов, когда требуется выполнить привязку к серверу. Описание сведений, хранимых службой имен, и формата хранения см. в разделе [база данных службы имен RPC](the-rpc-name-service-database.md).

Библиотека RPC предоставляет два набора функций, которые клиентская программа может использовать для поиска в базе данных службы имен. Имена одного набора начинаются с Рпкнсбиндингимпорт. Имена других наборов начинаются с Рпкнсбиндинглукуп. Различие между двумя группами функций заключается в том, что функции Рпкнсбиндингимпорт возвращают один дескриптор привязки на вызов, а функции Рпкнсбиндинглукуп возвращают группы дескрипторов на вызов.

Чтобы начать поиск с помощью функций Рпкнсбиндингимпорт, сначала вызовите [**рпкнсбиндингимпортбегин**](/windows/desktop/api/Rpcnsi/nf-rpcnsi-rpcnsbindingimportbegina), как показано в следующем фрагменте кода.


```C++
RPC_STATUS status;
RPC_NS_HANDLE hNameServiceHandle;
 
status = RpcNsBindingImportBegin(
    RPC_C_NS_SYNTAX_DEFAULT,
    NULL,
    MyInterface_v1_0_c_ifspec,
    NULL,
    &hNameServiceHandle);
```



Когда функции RPC выполняют поиск в базе данных службы имен, им нужно место для начала поиска. В терминологии RPC это имя записи называется. Клиентская программа передает имя записи в качестве второго параметра в [**рпкнсбиндингимпортбегин**](/windows/desktop/api/Rpcnsi/nf-rpcnsi-rpcnsbindingimportbegina). Этот параметр может иметь **значение NULL** , если требуется выполнить поиск по всей базе данных службы имен. Кроме того, можно выполнить поиск записи на сервере, передав имя записи сервера или выполнив поиск в записи группы, передав имя записи группы. Если передать имя записи, поиск будет ограничен содержимым этой записи.

В приведенном выше примере значение \_ \_ \_ по умолчанию для синтаксиса RPC C NS \_ передается в качестве первого параметра в [**рпкнсбиндингимпортбегин**](/windows/desktop/api/Rpcnsi/nf-rpcnsi-rpcnsbindingimportbegina). При этом выбирается синтаксис имени записи по умолчанию. В настоящее время это единственный поддерживаемый синтаксис имени входа.

Клиентское приложение может искать в базе данных службы имен имя интерфейса, UUID или и то, и другое. Если требуется, чтобы он выполнял поиск интерфейса по имени, передайте глобальную переменную интерфейса, созданную компилятором MIDL, из IDL-файла в качестве третьего параметра в [**рпкнсбиндингимпортбегин**](/windows/desktop/api/Rpcnsi/nf-rpcnsi-rpcnsbindingimportbegina). Его объявление можно найти в файле заголовка, созданном компилятором MIDL при создании клиентской заглушки. Если требуется, чтобы клиентская программа была искать только по UUID, установите для третьего параметра **значение NULL**.

При поиске идентификатора UUID в базе данных службы имен установите четвертый параметр [**рпкнсбиндингимпортбегин**](/windows/desktop/api/Rpcnsi/nf-rpcnsi-rpcnsbindingimportbegina) на UUID, который требуется найти. Если вы не ищете UUID, присвойте этому параметру **значение NULL**.

Функция [**рпкнсбиндингимпортбегин**](/windows/desktop/api/Rpcnsi/nf-rpcnsi-rpcnsbindingimportbegina) передает адрес службы имен — обработчик контекста поиска через его пятый параметр. Этот параметр передается другим функциям Рпкнсбиндингимпорт.

В частности, следующая функция, которой будет вызываться клиентское приложение, — это [**рпкнсбиндингимпортнекст**](/windows/desktop/api/Rpcnsi/nf-rpcnsi-rpcnsbindingimportnext). Клиентские программы используют эту функцию для получения совместимых дескрипторов привязки из базы данных службы имен. В следующем фрагменте кода показано, как можно вызвать эту функцию:


```C++
RPC_STATUS status;
RPC_BINDING_HANDLE hBindingHandle;
// The variable hNameServiceHandle is a valid name service search 
// context handle obtained from the RpcNsBindingBegin function.
 
status = RpcNsBindingImportNext(hNameServiceHandle, &hBindingHandle);
```



После вызова функции [**рпкнсбиндингимпортнекст**](/windows/desktop/api/Rpcnsi/nf-rpcnsi-rpcnsbindingimportnext) для получения маркера привязки клиентское приложение может определить, приемлем ли полученный обработчик. В противном случае клиентская программа может выполнить цикл и вызвать **рпкнсбиндингимпортнекст** еще раз, чтобы узнать, содержит ли служба имен более подходящий обработчик. Для каждого вызова **рпкнсбиндингимпортнекст** должен быть соответствующий вызов рпкнсбиндингфри. По завершении поиска вызовите функцию [**рпкнсбиндингимпортдоне**](/windows/desktop/api/Rpcnsi/nf-rpcnsi-rpcnsbindingimportdone) , чтобы освободить контекст поиска.

После того как у клиентского приложения будет приемлемый маркер привязки, он должен проверить, что серверное приложение работает. Для выполнения этой проверки клиент может использовать два метода. Первый — вызов функции в клиентском интерфейсе. Если серверная программа запущена, вызов будет завершен. В противном случае вызов завершится ошибкой. Лучший способ убедиться, что сервер работает, — вызвать [**рпцепресолвебиндинг**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepresolvebinding), а затем вызвать [**рпкмгмтиссерверлистенинг**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtisserverlistening). Дополнительные сведения о базе данных службы имен см. [в разделе База данных службы имен RPC](the-rpc-name-service-database.md).

 

 




