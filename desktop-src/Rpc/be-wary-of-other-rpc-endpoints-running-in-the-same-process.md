---
title: Будьте осторожны с другими конечными точками RPC, работающими в том же процессе
description: Если приложение находится в процессе с другими серверами RPC, все приложения прослушивают все протоколы.
ms.assetid: edb20108-e0c3-4b9b-b57d-45a96d9472ba
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 5e2044b83de96a352546d90c45cd54879fc87923786b7852133ffeb28dbf9cbe
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118932355"
---
# <a name="be-wary-of-other-rpc-endpoints-running-in-the-same-process"></a>Будьте осторожны с другими конечными точками RPC, работающими в том же процессе

Если приложение находится в процессе с другими серверами RPC, все приложения прослушивают все протоколы. Таким образом, если компонент вызывает [**рпксерверусепротсек**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseq) \* только для лрпк, он не обязательно должен быть доступен только для лрпк. Он может быть доступен по другим протоколам, так как другие серверы RPC в процессе могут прослушивать каналы или сокеты (например,).

Как и в случае с ограниченными дескрипторами контекста, размещение другой конечной точки в процессе не означает, что другая конечная точка не существует. Независимо от способа регистрации сервера, между интерфейсом и конечной точкой не существует специальной связи. все интерфейсы вызываемы для всех конечных точек в этом процессе. Это еще одна причина, по которой модель безопасности конечной точки неэффективна; Если дескриптор безопасности размещается на конечной точке, злоумышленники могут вызвать интерфейс в другой конечной точке.

Чтобы процесс вызывался только в определенной последовательности протокола, зарегистрируйте функцию обратного вызова безопасности и в этой функции проверьте, какая последовательность протоколов вызывается.

 

 




