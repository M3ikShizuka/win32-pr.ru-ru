---
title: Будьте осторожны с другими конечными точками RPC, работающими в том же процессе
description: Если приложение находится в процессе с другими серверами RPC, все приложения прослушивают все протоколы.
ms.assetid: edb20108-e0c3-4b9b-b57d-45a96d9472ba
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 00828ddf95fd024069a8a535c95673eb014d84b9
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "103777108"
---
# <a name="be-wary-of-other-rpc-endpoints-running-in-the-same-process"></a>Будьте осторожны с другими конечными точками RPC, работающими в том же процессе

Если приложение находится в процессе с другими серверами RPC, все приложения прослушивают все протоколы. Таким образом, если компонент вызывает [**рпксерверусепротсек**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseq) \* только для лрпк, он не обязательно должен быть доступен только для лрпк. Он может быть доступен по другим протоколам, так как другие серверы RPC в процессе могут прослушивать каналы или сокеты (например,).

Как и в случае с ограниченными дескрипторами контекста, размещение другой конечной точки в процессе не означает, что другая конечная точка не существует. Независимо от способа регистрации сервера, между интерфейсом и конечной точкой не существует специальной связи. все интерфейсы вызываемы для всех конечных точек в этом процессе. Это еще одна причина, по которой модель безопасности конечной точки неэффективна; Если дескриптор безопасности размещается на конечной точке, злоумышленники могут вызвать интерфейс в другой конечной точке.

Чтобы процесс вызывался только в определенной последовательности протокола, зарегистрируйте функцию обратного вызова безопасности и в этой функции проверьте, какая последовательность протоколов вызывается.

 

 




