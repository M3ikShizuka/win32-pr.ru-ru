---
title: Разработка сервера с помощью дескрипторов контекста
description: С точки зрения разработки серверной программы, маркер контекста является нетипизированным указателем. Серверные программы инициализируют дескрипторы контекста, указывая их на данные в памяти или в другой форме хранилища (например, файлы на дисках).
ms.assetid: 6a1aabca-4cb9-401c-90c7-0cff7a69b7b6
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: db05441f7314fba628d1ec07db5f99266c595c84e672ada976b38f7576ab5d1d
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118925340"
---
# <a name="server-development-using-context-handles"></a>Разработка сервера с помощью дескрипторов контекста

С точки зрения разработки серверной программы, маркер контекста является нетипизированным указателем. Серверные программы инициализируют дескрипторы контекста, указывая их на данные в памяти или в другой форме хранилища (например, файлы на дисках).

Например, предположим, что клиент использует маркер контекста для запроса ряда обновлений записи в базе данных. Клиент вызывает удаленную процедуру на сервере и передает ей ключ поиска. Серверная программа ищет ключ поиска в базе данных и получает целочисленный номер записи для соответствующей записи. Затем сервер может указать указатель на void в расположении в памяти, содержащем номер записи. При возврате удаленной процедуре потребуется возврат указателя в виде контекстного контекста через его возвращаемое значение или список параметров. Клиенту необходимо передать указатель на сервер каждый раз, когда он вызывал удаленные процедуры для обновления записи. Во время каждой из этих операций обновления сервер преобразует указатель void в указатель на целое число.

После того как серверная программа указывает на контекстные данные, этот маркер считается открытым. Дескрипторы, содержащие значение **null** , закрываются. Сервер поддерживает открытый обработчик контекста до тех пор, пока клиент не вызовет удаленную процедуру, которая его закрывает. Если сеанс клиента завершается, пока открыт маркер, то во время выполнения RPC вызывается подпрограммы запуска сервера для освобождения маркера.

В следующем фрагменте кода показано, как сервер может реализовать контекстный маркер. В этом примере сервер поддерживает файл данных, который клиент записывает на использование удаленных процедур. Контекстная информация — это файловый обработчик, который отслеживает текущее расположение в файле, в котором сервер будет записывать данные. Этот файл упаковывается как обработчик контекста в список параметров для удаленных вызовов процедур. Структура содержит имя файла и файловый обработчик. Определение интерфейса для этого примера показано в области [разработки интерфейса с использованием дескрипторов контекста](interface-development-using-context-handles.md).


```C++
/* cxhndlp.c (fragment of file containing remote procedures) */
typedef struct 
{
     FILE* hFile;
     char   achFile[256];
} FILE_CONTEXT_TYPE;
```



Функция Ремотеопен открывает файл на сервере:


```C++
short RemoteOpen(
    PPCONTEXT_HANDLE_TYPE pphContext,
    unsigned char *pszFileName)
{
    FILE               *hFile;
    FILE_CONTEXT_TYPE  *pFileContext;
 
    if ((hFile = fopen(pszFileName, "r")) == NULL) 
    {
        *pphContext = (PCONTEXT_HANDLE_TYPE) NULL;
        return(-1);
    }
    else 
    {
        pFileContext = (FILE_CONTEXT_TYPE *) 
                       MIDL_user_allocate(sizeof(FILE_CONTEXT_TYPE));
        pFileContext->hFile = hFile;
        // check if pszFileName is longer than 256 and if yes, return
        // an error
        strcpy_s(pFileContext->achFile, srlen(pszFileName), pszFileName);
        *pphContext = (PCONTEXT_HANDLE_TYPE) pFileContext;
        return(0);
    }
}
```



Функция Ремотереад считывает файл на сервере.


```C++
short RemoteRead(
    PCONTEXT_HANDLE_TYPE phContext, 
    unsigned char *pbBuf, 
    short *pcbBuf) 
{ 
    FILE_CONTEXT_TYPE *pFileContext; 
    printf("in RemoteRead\n"); 
    pFileContext = (FILE_CONTEXT_TYPE *) phContext; 
    *pcbBuf = (short) fread(pbBuf, sizeof(char), 
                            BUFSIZE, 
                            pFileContext->hFile); 
    return(*pcbBuf); 
}
```



Функция Ремотеклосе закрывает файл на сервере. Обратите внимание, что серверному приложению необходимо назначить **значение NULL** для контекстного контекста как часть функции Close. Это подключается к заглушке сервера и библиотеке времени выполнения RPC, которая была удалена с помощью маркера контекста. В противном случае соединение будет оставаться открытым, и в конечном итоге будет выполняться контекст.


```C++
void RemoteClose(PPCONTEXT_HANDLE_TYPE pphContext)
{
    FILE_CONTEXT_TYPE *pFileContext;
 
    if (*pphContext == NULL)
    {
        //Log error, client tried to close a NULL handle.
        return;
    }
    pFileContext = (FILE_CONTEXT_TYPE *)*pphContext;
    printf("File %s closed.\n", pFileContext->achFile);
    fclose(pFileConext->hFile);
    MIDL_user_free(pFileContext);
 
    // This tells the run-time, when it is marshalling the out 
    // parameters, that the context handle has been closed normally.
    *pphContext = NULL;
}
```



> [!Note]  
> Хотя ожидается, что клиент передает допустимый дескриптор контекста в вызов с \[ \] атрибутами направления in, RPC не отклоняет дескрипторы контекста **null** для этого сочетания атрибутов направления. **Нулевой** маркер контекста передается на сервер в качестве указателя **null** . \[ \] Чтобы избежать нарушения прав доступа при получении указателя **null** , необходимо написать серверный код для вызовов, содержащих in, выходной обработчик контекста.

 

 

 




