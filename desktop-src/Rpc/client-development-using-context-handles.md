---
title: Разработка клиентов с помощью дескрипторов контекста
description: Только клиентская программа имеет доступ к контекстному обработчику — он передает его на сервер каждый раз, когда клиент выполняет удаленный вызов процедуры.
ms.assetid: fcbdfb1e-4f1e-4d22-9a3e-cf5a29d300d0
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: f7c7d2dfca901085c743b25eb233ee2493b893e7
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "104532366"
---
# <a name="client-development-using-context-handles"></a>Разработка клиентов с помощью дескрипторов контекста

Только клиентская программа имеет доступ к контекстному обработчику — он передает его на сервер каждый раз, когда клиент выполняет удаленный вызов процедуры. Клиентскому приложению не требуется доступ к содержимому маркера. Он не должен пытаться изменить данные обработчика контекста каким бы то ни было образом. Удаленные процедуры, которые клиент вызывает, выполняют все необходимые операции в контексте сервера.

Перед запросом маркера контекста с сервера клиенты должны установить привязку к серверу. Клиент может использовать автоматический, неявный или явный маркер привязки. С помощью допустимого маркера привязки клиент может вызвать удаленную процедуру на сервере, которая либо возвращает открытый (не **равный null**) обработчик контекста, либо передает один через параметр **\[ out \]** в списке параметров удаленной процедуры.

Клиенты могут использовать открытые дескрипторы контекста любым необходимым образом. Однако они должны сделать недействительным обработчик, если он больше не нужен. Это можно сделать двумя способами:

-   Для вызова удаленной процедуры, предлагаемой серверной программой, которая освобождает контекст и закрывает контекстный маркер (присваивает ему **значение NULL**).
-   Если сервер недоступен, вызовите функцию [**рпкссдестройклиентконтекст**](/windows/desktop/api/Rpcndr/nf-rpcndr-rpcssdestroyclientcontext) .

Второй подход очищает состояние на стороне клиента и не очищает состояние на стороне сервера, поэтому его следует использовать только в том случае, если обнаружена сетевая секция, и клиент и сервер будут выполнять независимую очистку. Сервер выполняет независимую очистку с помощью подпрограммы запуска, клиент делает это с помощью функции [**рпкссдестройклиентконтекст**](/windows/desktop/api/Rpcndr/nf-rpcndr-rpcssdestroyclientcontext) .

В следующем фрагменте кода представлен пример того, как клиент может использовать контекстный маркер. Сведения об определении интерфейса, используемого в этом примере, см. в разделе [Разработка интерфейса с использованием дескрипторов контекста](interface-development-using-context-handles.md). Сведения о реализации сервера см. в разделе [Разработка серверов с помощью дескрипторов контекста](server-development-using-context-handles.md).

В этом примере клиент вызывает Ремотеопен для получения маркера контекста, содержащего допустимые данные. Затем клиент может использовать маркер контекста в удаленных вызовах процедур. Так как больше не требуется маркер привязки, клиент может освободить явный обработчик, который использовался для создания маркера контекста:


```C++
// cxhndlc.c  (fragment of client side application)
printf("Calling the remote procedure RemoteOpen\n");
if (RemoteOpen(&phContext, pszFileName) < 0) 
{
    printf("Unable to open %s\n", pszFileName);
    Shutdown();
    exit(2);
}
 
// Now the context handle also manages the binding.
// The variable hBindingHandle is a valid binding handle.
status = RpcBindingFree(&hBindingHandle);
printf("RpcBindingFree returned 0x%x\n", status);
if (status) 
    exit(status);
```



Клиентское приложение в этом примере использует процедуру с именем Ремотереад для чтения файла данных на сервере до тех пор, пока не встретится конец файла. Затем он закрывает файл, вызывая Ремотеклосе. Контекстный маркер отображается как параметр в функциях Ремотереад и Ремотеклосе следующим образом:


```C++
printf("Calling the remote procedure RemoteRead\n");
do 
{
    cbRead = 1024; // Using a 1K buffer
    RemoteRead(phContext, pbBuf, &cbRead);
    // cbRead contains the number of bytes actually read.
    for (int i = 0; i < cbRead; i++)
        putchar(*(pbBuf+i));
} while(cbRead);
 
printf("Calling the remote procedure RemoteClose\n");
if (RemoteClose(&phContext) < 0 ) 
{
    printf("Close failed on %s\n", pszFileName);
    exit(2);
}
```



 

 




