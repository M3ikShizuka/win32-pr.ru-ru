---
title: Изменение интерфейсов с обратной совместимостью
description: Методы, описанные в теории управления версиями для RPC и COM, могут быть неприемлемыми по многим причинам.
ms.assetid: 7dec4b67-3d50-453f-b0ef-290d091186fd
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 8fbe06be3106b4c599baed2d625eefa1f9c7d035c70ef89ac325406bb8c2037d
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "120022964"
---
# <a name="changing-interfaces-in-a-backward-compatible-manner"></a>Изменение интерфейсов с обратной совместимостью

Методы, описанные в [теории управления версиями для RPC и com](the-versioning-theory-for-rpc-and-com.md) , могут быть неприемлемыми по многим причинам. Изменение версии интерфейса в соответствии с правилами требует, чтобы новые клиенты не могли взаимодействовать со старыми серверами. Это часто невозможно при использовании коммерческого программного обеспечения, развернутого в поле. в некоторых случаях в Windows появились изменения в интерфейсе, отсутствующие в измененных идентификаторах guid или версиях. Это было следствием того, что новые клиенты должны взаимодействовать с устаревшими серверами, а решение, которое новый клиент будет поддерживать как старый, так и новый интерфейс, было нежелательным.

## <a name="best-practice"></a>Рекомендации

Это разумные методы обхода проблемы несовместимости сети, когда идентификатор GUID и версия интерфейса не могут быть изменены.

1.  Приложение должно знать о возможностях другой стороны.

    Клиент и сервер имеют протокол, который позволяет каждому (или по крайней мере новому клиенту) установить удостоверение партнера. Как правило, для нового клиента достаточно знать о функциях, поддерживаемых старыми и новыми серверами. Это можно легко сделать, когда приложение придерживается к контексту соединения и поддерживается посредством типа *ксксксжетинфо* вызова функции, выполняемого клиентом перед выполнением любых операций RPC. Когда приложение управляет функциями в выпуске на сервер, вызов с несовместимостью со старым сервером или клиентом не может произойти, так как приложение управляет тем, какие вызовы выдаются серверу. В конце концов, приложение является упреждающим в предотвращении несоответствия. Это может быть выполнено вместе со второй практикой.

2.  Познакомьтесь с новым удаленным API.

    Новый удаленный метод не противоречит существующим методам, если он добавлен в конец интерфейса. Старые клиенты могут вызывать новые серверы, как они всегда имеют. Новый клиент может вызвать новый метод, не зная удостоверения сервера, при условии, что он наблюдает за ошибками, поступающими от вызываемого сервера. Во время выполнения RPC всегда проверяется номер метода для каждого интерфейса перед отправкой, чтобы гарантировать, что метод находится в соответствующей таблице v-table. Для метода, неизвестного для сервера, время выполнения RPC вызывает исключение RPC \_ S \_ прокнум \_ за пределами \_ \_ диапазона. Это исключение возникает только в данной конкретной ситуации. Таким образом, новый клиент может отслеживать исключение в виде подписи, что вызов перешел на старый сервер, и может правильно изменить его поведение.

3.  Новые параметры или новые типы данных вводятся только в новых методах.

    Одной из причин появления нового метода является избежание несовместимости данных. Если новый тип данных введен или просто изменен, в принципе он должен использоваться только в новом методе (или методах). См. [примеры несовместимых изменений](examples-of-incompatible-changes.md) для примеров несовместимых изменений типов данных. Единственным важным исключением из этого правила является описание в элементе 4.

4.  Сопоставьте новые параметры или новые типы данных с помощью оболочки.

    Это решение применимо, когда пользователю необходимо предоставить новый параметр или тип данных, но на самом деле нет необходимости в удаленной удаленном режиме или при сопоставлении со старыми типами данных или параметрами. Например, многие системные API-интерфейсы поочередно пополняют и выполняют удаленный вызов. Они могут или не выполнять некоторый тип сопоставления из известных типов данных для типов данных, фактически используемых в базовом вызове RPC. Поэтому всегда стоит проанализировать, нужно ли распространить изменения в пользовательском интерфейсе как изменение в удаленном интерфейсе.

    Подобная ситуация может возникнуть, когда пользователь напрямую обращается к удаленному API, но для создания нового сопоставления типа или некоторых других дополнительных действий, которые стали необходимыми, можно ввести программу-оболочку. В языке определения интерфейсов (IDL) предусмотрено несколько способов облегчения такого пересопоставления, а именно для \[ [**вызова метода \_ as**](/windows/desktop/Midl/call-as) \] , \[ [**передачи \_ как**](/windows/desktop/Midl/transmit-as) \] и \[ [**\_ маршалирования**](/windows/desktop/Midl/wire-marshal) \] . Атрибут \[ **вызвать \_ как** \] вводит обертку функции для клиента и сервера. Оба кода помещаются между пользовательским кодом и маршалером. Другие атрибуты связаны с прямым сопоставлением типов. Для проблем с расширением \[ **вызовите метод \_ как** , \] наиболее часто используемый, и проще всего понимать и манипулировать без каких-либо ловушек.

5.  Изменение типов данных с помощью объединения, используемого по умолчанию.

    Изменение атрибута или типа данных обычно приводит к несовместимости сети. Примеры [несовместимых изменений](examples-of-incompatible-changes.md) см. в примерах. Однако в случае объединения без предложения Default можно управлять несовместимостью так же, как и при использовании процедуры вне диапазона, как описано выше. Эта схема легко подходит для популярных типов *ксксксинфо* , использующих объединения.

    Например, вызов следующего вида

    ```C++
    XxxGetInfo( [in] level, [out] XxxINFO  * pInfo );
    ```

    

    может возвращать сведения на уровне 1, 2 или 3, где *ксксксинфо* является объединением с тремя ветвями: 1, 2 и 3.

6.  Используйте атрибут \[ [**Range**](/windows/desktop/Midl/range) \] для указания диапазона.

    Можно указать \[ [](/windows/desktop/Midl/range) \] атрибут Range для простого типа масштабирования без нарушения обратной совместимости. Этот атрибут не влияет на формат подключения, но во время немаршалинга RPC проверяет значение на канале, чтобы убедиться в том, что он находится в диапазоне, указанном в IDL-файле. В противном случае \_ \_ возникает исключение "Ошибка RPC X недопустимая \_ Привязка". Это особенно удобно, если сервер знает максимальный размер массива размеров.

    Например:

    ```C++
    HRESULT Method1( [in, range(0,100)] ULONG m, [size_is(m)] ULONG *plong); 
    ```

    

Поведение RPC, если указанный уровень равен 4, а ARM отсутствует, зависит от определения объединения. Для объединения с определенным предложением по умолчанию RPC передает тип, указанный в предложении по умолчанию, для любого значения, отличного от известных меток ARM (в данном случае любой другой, кроме 1, 2 или 3). Для объединения без заданной по умолчанию в результате распаковки возникает исключение, так как по определению нет значения по умолчанию, к которому будет возвращаться значение. Исключением является \_ \_ Недопустимый \_ тег RPC S.

Опять же, новый клиент может изменить его поведение при обнаружении, что он назывался старым сервером.

В следующих рекомендациях показано, что если необходимо разработать тип данных, поддерживающий удаленное взаимодействие, который можно расширить в будущем, используйте в IDL-файле нестандартное объединение. По выбору, инкапсулированное объединение является немного более понятным.

Из-за особенностей внутреннего представления сетевого протокола NDR64 рекомендации по добавлению подлокотников, приведенных выше в этом разделе, должны быть дополнены следующим образом: Новая добавляемая ARM не может изменить выравнивание объединения, а в частности, самое большое выравнивание не должно меняться. Обычно это не проблема, так как указатель в ARM приводит к выравниванию до 8. Конструкция, в которой каждая ARM является указателем на тип ARM, является одним из чистых способов удовлетворения требования.

 

 