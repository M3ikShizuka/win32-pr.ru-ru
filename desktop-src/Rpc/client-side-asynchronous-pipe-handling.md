---
title: Асинхронная обработка канала на стороне клиента
description: Перед выполнением асинхронного удаленного вызова клиент должен сначала инициализировать асинхронный обработчик.
ms.assetid: 3d54b233-d8b0-45d1-b759-0d2d24c1e247
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 11ff503f80c77b2403d683c2b644d89836365956
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "103888923"
---
# <a name="client-side-asynchronous-pipe-handling"></a>Асинхронная обработка канала на стороне клиента

Перед выполнением асинхронного удаленного вызова клиент должен сначала инициализировать асинхронный обработчик. Как и в случае с неконвейерными процедурами, клиент вызывает асинхронную функцию с асинхронным маркером в качестве первого параметра и использует асинхронный обработчик для отправки и получения данных канала, запроса состояния вызова и получения ответа.

Клиент выполняет асинхронный вызов удаленной процедуры с асинхронным маркером в качестве первого параметра. Клиент может использовать этот обработчик для запроса состояния вызова и получения ответа. Модель асинхронных каналов является симметричной. Клиентские и серверные приложения отправляют и получают данные канала активно (в отличие от синхронного RPC, в котором данные канала отправляются и получаются в пассивном режиме).

Клиент отправляет асинхронные данные канала, вызывая функцию **Push** в соответствующем асинхронном канале с переменной состояния канала в качестве первого параметра. Когда функция **Push** возвращает, клиент может изменить или освободить буфер отправки.

Если в \_ \_ \_ \_ \_ асинхронном обработчике установлен флаг RPC Async notify for Send Complete, и если в качестве механизма уведомления используются APC, то протокол APC помещается в очередь при завершении отправки канала. Можно воспользоваться преимуществами этого механизма для реализации управления потоком. Однако обратите внимание, что если клиент отправляет другой буфер до завершения предыдущей отправки, клиент может, в зависимости от скорости операции передачи, получать только одно уведомление об отправке, а не одно уведомление для каждого буфера или операции **принудительной** отправки. Когда клиент отправил все данные канала, он выполняет один окончательный вызов **Push** с числом элементов, равным 0.

Клиентская программа получает асинхронные данные канала, вызывая функцию **Pull** в соответствующем асинхронном канале с переменной состояния канала в качестве первого параметра. Если данные канала недоступны, функция **Pull** возвращает \_ \_ \_ ожидающий асинхронный вызов RPC S \_ .

Если механизм уведомления имеет значение APC и сервер вернул \_ \_ асинхронный вызов RPC S \_ \_ , клиент должен дождаться получения **рпкрецеивекомплете** APC из среды выполнения перед повторным вызовом **Pull** .

 

 




