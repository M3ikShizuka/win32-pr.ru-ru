---
title: Написание клиента с проверкой подлинности SSPI
description: Запись клиента SSPI с проверкой подлинности и удаленного вызова процедур (RPC).
ms.assetid: db39d3bf-84fa-466e-9ba1-ba17f64c8f8d
keywords:
- Удаленный вызов процедур RPC, задачи, написание клиента SSPI с проверкой подлинности
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 7445d5340b03f07805a9e2ab89deb8c915a76160db67b504259ae8de0bbabee5
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119010362"
---
# <a name="writing-an-authenticated-sspi-client"></a>Написание клиента с проверкой подлинности SSPI

Всем сеансам клиента или сервера RPC требуется привязка между клиентом и сервером. Чтобы добавить безопасность в клиентские и серверные приложения, программы должны использовать аутентифицированную привязку. В этом разделе описывается процесс создания привязок с проверкой подлинности между клиентом и сервером.

-   [Создание дескрипторов привязки на стороне клиента](#creating-client-side-binding-handles)
-   [Предоставление серверу учетных данных клиента](#providing-client-credentials-to-the-server)

Дополнительные сведения см. в разделе [процедуры, используемые с большинством пакетов безопасности и протоколов](/windows/desktop/SecAuthN/procedures-used-with-most-security-packages-and-protocols) в пакете SDK для платформы.

## <a name="creating-client-side-binding-handles"></a>Создание дескрипторов привязки на стороне клиента

Чтобы создать сеанс с проверкой подлинности в серверной программе, клиентские приложения должны предоставить сведения о проверке подлинности с помощью соответствующего маркера привязки. Чтобы настроить маркер привязки, прошедший проверку подлинности, клиенты вызывают функцию [**рпкбиндингсетаусинфо**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingsetauthinfo) или [**рпкбиндингсетаусинфоекс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingsetauthinfoexa) . Эти две функции практически идентичны. Единственное различие между ними заключается в том, что клиент может указать качество обслуживания с помощью функции **рпкбиндингсетаусинфоекс** .

В следующем фрагменте кода показано, как может выглядеть вызов [**рпкбиндингсетаусинфо**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingsetauthinfo) .


```C++
// This code fragment assumes that rpcBinding is a valid binding 
// handle between the client and the server. It also assumes that
// pAuthCredentials is a valid pointer to a data structure which
// contains the user's authentication credentials.

dwStatus = DsMakeSpn(
    "ldap",
    "ServerName.domain.com",
    NULL,
    0,
    NULL,
    &pcSpnLength,
    pszSpn);

//...

rpcStatus = RpcBindingSetAuthInfo(
    rpcBinding,                       // Valid binding handle
    pszSpn,                           // Principal name 
    RPC_C_AUTHN_LEVEL_PKT_INTEGRITY,  // Authentication level
    RPC_C_AUTHN_GSS_NEGOTIATE,        // Use Negotiate SSP
    NULL,                             // Authentication credentials <entity type="ndash"/> use current thread credentials
    RPC_C_AUTHZ_NAME);                // Authorization service
```



После успешного вызова клиентом функций [**рпкбиндингсетаусинфо**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingsetauthinfo) или [**рпкбиндингсетаусинфоекс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingsetauthinfoexa) библиотека времени выполнения RPC автоматически проверяет подлинность всех вызовов RPC для привязки. Уровень безопасности и проверки подлинности, который выбирает клиент, применяется только к этому маркеру привязки. Дескрипторы контекста, производные от дескриптора привязки, будут использовать одни и те же сведения о безопасности, но последующие изменения в дескрипторе привязки не будут отражены в дескрипторах контекста. Дополнительные сведения см. в разделе [дескрипторы контекста](context-handles.md).

Уровень проверки подлинности остается действительным до тех пор, пока клиент не выберет другой уровень или пока процесс не завершится. Для большинства приложений изменение уровня безопасности не требуется. Клиент может запросить любой маркер привязки, чтобы получить сведения об авторизации, вызвав [**рпкбиндингинкаусклиент**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindinginqauthclient) и передав ему маркер привязки.

## <a name="providing-client-credentials-to-the-server"></a>Предоставление серверу учетных данных клиента

Серверы используют сведения о привязке клиента для обеспечения безопасности. Клиенты всегда передают маркер привязки в качестве первого параметра удаленного вызова процедуры. Однако серверы не могут использовать этот обработчик, если он не объявлен как первый параметр для удаленных процедур в IDL-файле или в файле конфигурации приложения сервера (ACF). Можно выбрать список маркера привязки в IDL-файле, но это заставляет все клиенты объявлять и манипулировать маркером привязки, а не использовать автоматическую или неявную привязку. Дополнительные сведения см. [в файлах IDL и ACF](the-idl-and-acf-files.md).

Другой способ — оставить дескрипторы привязки из IDL-файла и поместить **явный атрибут \_ Handle** в ACF сервера. Таким образом клиент может использовать тип привязки, наиболее подходящий для приложения, в то время как сервер использует маркер привязки, как если бы он был объявлен явным образом.

Процесс извлечения учетных данных клиента из маркера привязки выполняется следующим образом:

-   Клиенты RPC вызывают [**рпкбиндингсетаусинфо**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingsetauthinfo) и включают сведения о проверке подлинности в составе сведений о привязке, передаваемых серверу.
-   Как правило, сервер вызывает [**рпЦимперсонатеклиент**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcimpersonateclient) , чтобы вести себя так, как если бы он был клиентом. Если маркер привязки не прошел проверку подлинности, вызов завершается с помощью RPC \_ S \_ \_ \_ . контекст недоступен. чтобы получить имя пользователя клиента, вызовите [**рпкбиндингинкаусклиент**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindinginqauthclient) при олицетворении или в Windows XP или более поздних версиях Windows, вызовите [**рпкжетаусоризатионконтекстфорклиент**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcgetauthorizationcontextforclient) , чтобы получить контекст авторизации, а затем используйте функции Authz для получения имени.
-   Сервер, как правило, вызывает [**креатеприватеобжектсекурити**](/windows/desktop/api/securitybaseapi/nf-securitybaseapi-createprivateobjectsecurity) для создания объектов с помощью списков ACL. После этого последующие проверки безопасности становятся автоматическими.

 

 