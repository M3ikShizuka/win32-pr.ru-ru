---
title: Управление памятью заглушки сервера
description: Управление памятью заглушки сервера
ms.assetid: 99e3ee56-5adb-4b25-bcf2-316d1bbdbdba
keywords:
- Управление памятью заглушки сервера
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2c772678e28a51c4d5162472bc7b0ef73e19888feefbd0e1890cb13f65650425
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118925191"
---
# <a name="server-stub-memory-management"></a>Управление памятью заглушки сервера

## <a name="an-introduction-to-server-stub-memory-management"></a>Введение в Server-Stub управления памятью

Созданные MIDL-заглушки действуют как интерфейс между клиентским процессом и серверным процессом. Клиентская заглушка маршалирует все данные, передаваемые в параметры, помеченные атрибутом [**\[ in \]**](../midl/in.md) , и отправляет их в заглушку сервера. Заглушка сервера при получении этих данных восстанавливает стек вызовов, а затем выполняет соответствующую функцию сервера, реализованную пользователем. Заглушка сервера также маршалирует данные параметров, отмеченные атрибутом [**\[ out \]**](../midl/out-idl.md) , и возвращает их клиентскому приложению.

32-битный формат упакованных данных, используемый MSRPC, — это совместимая версия синтаксиса передачи представления данных сети (NDR). Дополнительные сведения об этом формате см. [на веб-сайте Open Group](https://www.opengroup.org/). В 64-разрядных платформах для повышения производительности можно использовать расширение Microsoft 64-bit для преобразования NDR с именем NDR64.

## <a name="unmarshaling-inbound-data"></a>Распаковка входящих данных

В MSRPC клиентская заглушка маршалирует все данные параметров, помеченные как, [**\[ \] в один**](../midl/in.md) непрерывный буфер для передачи в заглушку сервера. Аналогичным образом заглушка сервера маршалирует все данные, отмеченные атрибутом [**\[ out \]**](../midl/out-idl.md) , в непрерывном буфере для возврата к клиентской заглушке. Хотя уровень сетевых протоколов, находящихся под RPC, может фрагментировать и паккетизе буфер для передачи, фрагментация прозрачна для заглушек RPC.

Выделение памяти для создания кадра вызовов сервера может быть дорогостоящей операцией. Заглушка сервера попытается уменьшить использование ненужного объема памяти, если это возможно, и предполагается, что серверная подпрограмма не будет освобождать или перераспределять данные **\[ , \]** помеченные атрибутами [**\[ in \]**](../midl/in.md) или in. Заглушка сервера пытается повторно использовать данные в буфере везде, где это возможно, чтобы избежать избыточного дублирования. Общее правило состоит в том, что если упакованный формат данных совпадает с форматом памяти, RPC будет использовать указатели на упакованные данные вместо выделения дополнительной памяти для одинаково отформатированных данных.

Например, следующий вызов RPC определяется структурой, упакованной формат которой идентичен его формату в памяти.

``` syntax
typedef struct RpcStructure
{
    long val;
    long val2;
}

void ProcessRpcStructure
(
    [in]  RpcStructure *plInStructure;
    [out] RpcStructure *plOutStructure;
);
```

В этом случае RPC не выделяет дополнительную память для данных, на которые ссылается *плинструктуре*; Вместо этого он просто передает указатель на упакованные данные в реализацию функции на стороне сервера. Заглушка сервера RPC проверяет буфер во время процесса распаковки, если заглушка компилируется с помощью флага "-устойчивости" (который является параметром по умолчанию в последней версии компилятора MIDL). RPC гарантирует, что данные, передаваемые в реализацию функции на стороне сервера, являются допустимыми.

Имейте в виду, что память выделяется для *плаутструктуре*, так как на сервер не передаются данные.

## <a name="memory-allocation-for-inbound-data"></a>Выделение памяти для входящих данных

Случаи могут возникать, когда заглушка сервера выделяет память для данных параметров, помеченных атрибутами [**\[ in \]**](../midl/in.md) или **\[ in \]** . Это происходит, когда формат упакованных данных отличается от формата памяти или если структуры, составляющие Упакованные данные, достаточно сложны и должны считываться в атомарном виде с помощью заглушки сервера RPC. Ниже приведено несколько типичных случаев, когда необходимо выделить память для данных, полученных заглушкой сервера.

-   Данные являются переменным массивом или согласованным переменным массивом. Это массивы (или указатели на массивы), для которых задан атрибут [**\[ length \_ () \]**](../midl/length-is.md) или [**\[ First \_ — () \]**](../midl/first-is.md) . В отчете NDR только первый элемент этих массивов маршалируется и передается. Например, в приведенном ниже фрагменте кода для данных, передаваемых в параметре *ПС* , будет выделена память.

    ``` syntax
    void RpcFunction
    (
        [in] long size,
        [in, out] long *pLength,
        [in, out, size_is(size), length_is(*pLength)] long *pv
    );
    ```

-   Данные представляют собой строку размера или несогласованную строку. Эти строки обычно являются указателями на символьные данные, помеченные атрибутом [**\[ size \_ — () \]**](../midl/size-is.md) . В приведенном ниже примере в строке, передаваемой в функцию на стороне сервера **сизедстринг** , будет выделена память, в то время как строка, передаваемая в функцию **нормалстринг** , будет использоваться повторно.

    ``` syntax
    void SizedString
    (
        [in] long size,
        [in, size_is(size), string] char *str
    );

    void NormalString
    (
        [in, string] char str
    );
    ```

-   Данные — это простой тип, размер памяти которого отличается от его упакованного размера, например **enum16** и **\_ \_ int3264**.
-   Данные определяются структурой, выравнивание памяти которого меньше естественного выравнивания, содержит любой из приведенных выше типов данных или имеет замыкающий байт. Например, Следующая сложная структура данных принудительно применяет 2-байтовое выравнивание, а в конце — заполнение.

    ``` syntax
#pragma pack(2)
    typedef struct ComplexPackedStructure
    {
        char c;  
        long l;   // alignment is forced at the second byte
        char c2;  // there will be a trailing one-byte pad to keep 2-byte alignment
    }
    ```

-   Данные содержат структуру, которая должна быть упакована в поле по полю. Эти поля включают в себя указатели интерфейса, определенные в интерфейсах DCOM. Игнорируемые указатели; целочисленные значения, заданные с помощью атрибута [**\[ \] Range**](../midl/range.md) ; элементы массивов, определенные с помощью [**\[ проводного \_ \] маршалирования**](../midl/wire-marshal.md), [**\[ пользовательского \_ маршалирования \]**](../midl/user-marshal.md), [**\[ передачи \_ как \]**](../midl/transmit-as.md) и [**\[ представления \_ в виде \]**](../midl/represent-as.md) атрибутов; и внедренных сложных структур данных.
-   Данные содержат объединение, структуру, содержащую объединение, или массив объединений. В связи с передачей маршалируется только конкретная ветвь объединения.
-   Данные содержат структуру с многомерным массивом, имеющим по крайней мере одно нефиксированное измерение.
-   Данные содержат массив сложных структур.
-   Данные содержат массив простых типов данных, таких как **enum16** и **\_ \_ int3264**.
-   Данные содержат массив указателей ссылок и интерфейсов.
-   К данным применяется атрибут [**\[ принудительного \_ выделения \]**](../midl/force-allocate.md) , примененный к указателю.
-   Данные имеют атрибут [**\[ выделения (все \_ узлы) \]**](../midl/allocate.md) , примененный к указателю.
-   Данные имеют атрибут [**\[ \_ количества \] байтов**](../midl/byte-count.md) , примененный к указателю.

## <a name="64-bit-data-and-ndr64-transfer-syntax"></a>64-разрядный синтаксис преобразования данных и NDR64

Как упоминалось ранее, 64-разрядные данные обработаны с использованием определенного синтаксиса 64-разрядной пересылки, именуемого NDR64. Этот синтаксис передачи был разработан для устранения конкретной проблемы, возникающей при маршалировании указателей по 32-разрядному NDR и передаче в заглушку сервера на 64-разрядной платформе. В этом случае упакованный 32-разрядный указатель данных не соответствует 64-бит, а выделение памяти будет неизменно. Чтобы создать более единообразное поведение на 64-разрядных платформах, корпорация Майкрософт разработала новый синтаксис перемещения, именуемый NDR64.

Ниже приведен пример, иллюстрирующий эту проблему.


```C++
typedef struct PtrStruct
{
  long l;
  long *pl;
}
```



Эта структура при маршалировании будет повторно использоваться заглушкой сервера в 32-разрядной системе. Однако если серверная заглушка находится в 64-разрядной системе, то данные, Упакованные NDR, имеют размер 4 байта, но требуемый объем памяти будет равен 8. В результате выделение памяти принудительно и повторное использование буфера будет происходить редко. NDR64 решает эту проблему, делая упакованный размер указателя 64-бит.

В отличие от 32-разрядных NDR, простые ТЕС данных, такие как **enum16** и **\_ \_ int3264** , не делают структуру или массив сложными в NDR64. Аналогично, начальные значения панели не делают структуру сложной. Указатели интерфейса обрабатываются как уникальные указатели на верхнем уровне. в результате структуры и массивы, содержащие указатели интерфейсов, не считаются сложными и не потребует определенного выделения памяти для их использования.

## <a name="initializing-outbound-data"></a>Инициализация исходящих данных

После того как все входящие данные будут отменены, заглушке сервера необходимо инициализировать указатели только для исходящих сообщений, помеченные атрибутом [**\[ out \]**](../midl/out-idl.md) .


```C++
typedef struct RpcStructure
{
    long val;
    long val2;
}

void ProcessRpcStructure
(
    [in]  RpcStructure *plInStructure;
    [out] RpcStructure *plOutStructure;
);
```



В приведенном выше вызове заглушка сервера должна инициализировать *плаутструктуре* , так как она отсутствовала в упакованных данных, и является подразумеваемым указателем [**\[ ссылки \]**](../midl/ref.md) , который должен быть доступен для реализации функции сервера. Заглушка RPC-сервера инициализирует и отменяет все ссылочные указатели верхнего уровня с атрибутом [**\[ out \]**](../midl/out-idl.md) . Все указатели на неиспользуемые ссылки, расположенные под ним, также рекурсивно инициализируются. **\[ \]** Рекурсия останавливается в любых указателях с установленными для них атрибутами [**\[ Unique \]**](../midl/unique.md) или [**\[ ptr \]**](../midl/ptr.md) .

Реализация серверной функции не может напрямую изменять значения указателей верхнего уровня и, таким же, не может перераспределять их. Например, в реализации **процессрпкструктуре** выше следующий код является недопустимым:


```C++
void ProcessRpcStructure(RpcStructure *plInStructure, rpcStructure *plOutStructure)
{
    plOutStructure = MIDL_user_allocate(sizeof(RpcStructure));
    Process(plOutStructure);
}
```



*плаутструктуре* — это значение стека, и его изменение не распространяется обратно в RPC. Реализация серверной функции может попытаться избежать распределения, пытаясь освободить *плаутструктуре*, что может привести к повреждению памяти. Заглушка сервера выделит место для указателя верхнего уровня в памяти (в случае указателя на указатель) и простой структуры верхнего уровня, размер которой в стеке меньше ожидаемого.

При определенных обстоятельствах клиент может указать размер выделяемой памяти на стороне сервера. В следующем примере клиент указывает размер исходящих данных в параметре входящего *размера* .

``` syntax
void VariableSizeData
(
    [in] long size,
    [out, size_is(size)] char *pv
);
```

После расмаршалинга входящих данных, включая *Размер*, заглушка сервера выделяет буфер для *ПС* с размером "sizeof (char) \* size". После выделения пространства заглушка сервера отменяет буфер. Обратите внимание, что в этом конкретном случае заглушка выделяет память с помощью **\_ \_ выделяющих пользователем MIDL ()**, так как размер буфера определяется во время выполнения.

Имейте в виду, что в случае интерфейсов DCOM созданные MIDL-заглушки могут не участвовать вообще, если клиент и сервер используют один и тот же контейнер COM или если **икаллфраме** реализован. В этом случае сервер не может зависеть от поведения при выделении и должен независимо проверять память на уровне клиента.

## <a name="server-side-function-implementations-and-outbound-data-marshaling"></a>Реализации функций на стороне сервера и маршалирование исходящих данных

Сразу после обработки входящих данных и инициализации памяти, выделенной для хранения исходящих данных, заглушка сервера RPC выполняет серверную реализацию функции, вызываемой клиентом. В настоящее время сервер может изменять данные, специально помеченные атрибутом **\[ in, out \]** , и заполнять память, выделенную для исходящих данных (данные, помеченные как [**\[ out \]**](../midl/out-idl.md)).

Общие правила обработки упакованных данных параметров просты: сервер может выделить только новый объем памяти или изменить память, специально выделенную заглушкой сервера. Перераспределение или освобождение существующей памяти для данных может негативно сказаться на результатах и производительности вызова функции, и его отладка может быть очень сложной.

Логически сервер RPC находится в адресном пространстве, отличном от клиента, и обычно предполагается, что они не используют общую память. В результате реализация функции сервера может использовать данные, помеченные атрибутом [**\[ in \]**](../midl/in.md) , как "вспомогательную" память, не влияя на адреса памяти клиента. С другой стороны, сервер не должен пытаться перераспределить или освободить **\[ \] данные, в результате** чего управление этими пробелами будет производиться заглушкой сервера RPC.

Как правило, реализация функции сервера не требует перераспределения или освобождения данных, помеченных атрибутом **\[ in, out \]** . Для данных фиксированного размера логика реализации функции может напрямую изменять данные. Аналогично, для данных с переменным размером реализация функции не должна изменять значение поля, передаваемое атрибуту [**\[ size, \_ ( \] )**](../midl/size-is.md) . Измените значение поля, используемое для изменения размера данных, в буфере меньшего или большего размера, возвращенного клиенту, который может быть недостаточным для работы с ненормальной длиной.

Если в ситуации возникает ситуация, когда Серверная подпрограмма должна перераспределить память, используемую данными, помеченными атрибутом **\[ in, \] out** , то вполне возможно, что реализация функции на стороне сервера не будет иметь знания о том, что в качестве указателя, предоставленного заглушкой, выделяется память, выделенная с помощью **\_ интерфейса пользователя MIDL \_ ()** или упакованного кабельного буфера. Чтобы обойти эту проблему, MS RPC может гарантировать отсутствие утечки памяти или повреждения, если для данных задан атрибут [**\[ принудительного \_ выделения \]**](../midl/force-allocate.md) . Если задано **\[ принудительное \_ выделение \]** , заглушка сервера всегда выделяет память для указателя, несмотря на то, что производительность будет снижаться при каждом использовании.

Когда вызов возвращается из реализации функции на стороне сервера, заглушка сервера маршалирует данные, помеченные атрибутом [**\[ out \]**](../midl/out-idl.md) , и отправляет их клиенту. Имейте в виду, что заглушка не маршалирует данные, если реализация функции на стороне сервера создает исключение.

## <a name="releasing-allocated-memory"></a>Освобождение выделенной памяти

Заглушка сервера RPC освободит стековую память после возврата вызова из функции на стороне сервера, независимо от того, возникает исключение или нет. Заглушка сервера освобождает всю память, выделенную заглушке, а также всю память, выделенную с помощью **\_ пользовательского \_ выделения MIDL ()**. Реализация функции на стороне сервера всегда должна обеспечить целостное состояние RPC, вызывая исключение или возвращая код ошибки. Если функция завершается ошибкой во время заполнения сложных структур данных, она должна гарантировать, что все указатели указывают на допустимые данные или имеют значение **null**.

Во время этого прохода заглушка сервера освобождает всю память, которая не является частью упакованного буфера, содержащего данные [**\[ в \]**](../midl/in.md) . Единственным исключением из этого поведения является данные с установленным для них атрибутом [**\[ выделения (не \_ свободен) \]**](../midl/allocate.md) . заглушка сервера не освобождает память, связанную с этими указателями.

После освобождения заглушки сервера памяти, выделенной заглушкой и реализацией функции, заглушка вызывает определенную функцию уведомления, если для конкретных данных указан атрибут [**\[ \_ флага \] Notify**](../midl/notify-flag.md) .

## <a name="marshalling-a-linked-list-over-rpc----an-example"></a>Пример маршалинга связанного списка через RPC


```C++
typedef struct _LINKEDLIST
{
    long lSize;
    [size_is(lSize)] char *pData;
    struct _LINKEDLIST *pNext;
} LINKEDLIST, *PLINKEDLIST;

void Test
(
    [in] LINKEDLIST *pIn,
    [in, out] PLINKEDLIST *pInOut,
    [out] LINKEDLIST *pOut
);
```



В приведенном выше примере формат памяти для **LINKEDLIST** будет идентичен формату упакованной связи. В результате Серверная заглушка не выделяет память для всей цепочки указателей данных под *закреплением*. Вместо этого RPC повторно использует кабельный буфер для всего связанного списка. Аналогичным образом заглушка не выделяет память для использования в *схеме*, а вместо этого повторно использует проводной буфер, упакованный клиентом.

Поскольку сигнатура функции содержит параметр исходящего трафика *тоска*, заглушка сервера выделяет память для хранения возвращаемых данных. Выделенная память изначально обнуляется, а параметр **пнекст** имеет значение **null**. Приложение может выделить память для нового связанного списка и указать *тоска* -> **пнекст** . закрепление и связанный список, который он содержит, можно использовать в качестве вспомогательной области, но приложение не должно изменять какие *-* либо указатели пнекст.

Приложение может свободно изменять содержимое связанного списка, на которое указывает *Схема контактов*, но не должно изменять ни один из **пнекстх** указателей, а только ссылку верхнего уровня. Если приложение принимает решение сократить связанный список, оно не сможет понять, есть ли ссылки на **пнекст** указатели, чтобы внутренний буфер RPC или буфер, специально выделенный с помощью **\_ пользовательского выделения MIDL \_ ()**. Чтобы обойти эту ошибку, необходимо добавить определенное объявление типа для указателей на связанные списки, которые принудительно задают выделение пользователей, как показано в приведенном ниже коде.

``` syntax
typedef [force_allocate] PLINKEDLIST;
```

Этот атрибут заставляет заглушку сервера распределять каждый узел связанного списка отдельно, и приложение может освободить сокращенную часть связанного списка, вызвав метод **MIDL \_ user \_ Free ()**. Затем приложение может безопасно установить указатель **пнекст** в конце нового сокращенного связанного списка до **значения NULL**.

 

 