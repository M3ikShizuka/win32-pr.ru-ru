---
title: Маркеры
description: Столько же, сколько в строке формата в описании дескрипторов адресов процедур.
ms.assetid: 11c6742c-b2f5-4201-8b1c-7e31ae52e0da
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2d1c1ce68b74440fc9339fb9cf9170bfdd1fdfcd
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104338716"
---
# <a name="handles"></a>Маркеры

Столько же, сколько в строке формата в описании дескрипторов адресов процедур. Первая часть — это тип дескриптора \_<1> поле описания процедуры, используемое для указания неявных дескрипторов. Эта часть всегда имеется. Вторая часть представляет собой описание параметра любого явного маркера в процедуре. Оба описания описаны в следующих разделах, а также описание дополнительной поддержки компилятора MIDL для структуры дескриптора-заглушки для проблем с дескрипторами привязки.

## <a name="implicit-handles"></a>Неявные дескрипторы

Если процедура использует неявный обработчик для привязки, тип обработки \_<1> поле описания процедуры содержит одно из трех допустимых ненулевых значений. Поддержка компилятора MIDL для неявных дескрипторов находится в поле неявных \_ сведений дескриптора в \_ структуре дескриптора-заглушки:

``` syntax
typedef  (__RPC_FAR * GENERIC_BINDING_ROUTINE)();

typedef struct 
  {
  GENERIC_BINDING_ROUTINE  pfnBind;
  GENERIC_BINDING_ROUTINE  pfnUnbind;
  } GENERIC_BINDING_ROUTINE_PAIR;
  
typedef struct __GENERIC_BINDING_INFO 
  {
  void __RPC_FAR*          pObj;
  unsigned char            Size;
  GENERIC_BINDING_ROUTINE  pfnBind;
  GENERIC_BINDING_ROUTINE    pfnUnbind;
  } GENERIC_BINDING_INFO,  *PGENERIC_BINDING_INFO;

union 
  {
  handle_t*                pAutoHandle;
  handle_t*                pPrimitiveHandle;
  PGENERIC_BINDING_INFO    pGenericBindingInfo;
  } IMPLICIT_HANDLE_INFO;
```

Если процедура использует автоматическую обработку, элемент **паутохандле** содержит адрес заданной заглушки — Auto Handles Variable.

Если в процедуре используется неявный примитивный маркер, элемент **ппримитивехандле** содержит адрес переменной-заглушки, заданной в качестве маркера.

Наконец, если в процедуре используется неявный универсальный маркер, элемент **пженерикбиндингинфо** содержит адрес указателя на соответствующую структуру **\_ \_ сведений об универсальной привязке** . Параметр- **\_ заглушка \_** структуры данных MIDL содержит указатель на коллекцию структурных **\_ \_ пар универсальных привязок** . Запись в нулевой положении этой коллекции зарезервирована для подпрограмм **привязки** и отмены **привязки** , соответствующих универсальному маркеру привязки, на который ссылается **пженерикбиндингинфо** в **неявных \_ \_ сведениях о обработчике**. Тип неявного маркера привязки указан в строке формата.

## <a name="explicit-handles"></a>Явные дескрипторы

Существует три возможных типа явных обработчиков: Context, Generic и примитив. В случае явного маркера (или \[ **выходного** \] обработчика, который обрабатывается таким же образом) сведения о обработчике привязки отображаются как один из параметров процедуры. Ниже приведены три возможных описания.

Примитивные

``` syntax
FC_BIND_PRIMITIVE, flag<1>, offset<2>.
```

Флаг<1> указывает, передается ли этот маркер указателем.

Смещение<2> предоставляет смещение от начала стека до маркера-примитива.

> [!Note]  
> Описание примитивного маркера в строке формата типа сокращается до одного раздела, который не учитывается в корпусе FC \_ .

 

Универсальный шаблон

``` syntax
FC_BIND_GENERIC, flag_and_size<1>, offset<2>, binding_routine_pair_index<1>, FC_PAD
```

Флаг \_ и \_ Размер<1> имеют верхний флаг и нижний размер. Флаг указывает, передается ли маркер указателем. В поле Размер указывается размер определяемого пользователем типа универсального маркера. Этот размер ограничен 1, 2 или 4 байтами на 32-разрядных системах и 1, 2, 4 или 8 байтами на 64-разрядных системах.

Поле offset<2> предоставляет смещение от начала стека указателя до данных заданного размера.

\_Индекс пары подпрограммы привязки \_ \_<1> поле предоставляет индекс в поле Аженерикбиндинграутинепаирс дескриптора заглушки для указателей функций **BIND** и **Unbind** для универсального дескриптора.

> [!Note]  
> Описание универсального маркера в формате типа является описанием только связанного типа данных.

 

Контекст

``` syntax
FC_BIND_CONTEXT flags<1> offset<2> context_rundown_routine_index<1> param_num<1>
```

Флаги<1> указать способ передачи маркера и его тип. В следующей таблице показаны допустимые флаги.



| Hex | Flag                                   |
|-----|----------------------------------------|
| 80  | параметр HANDLE обрабатывается \_ \_ \_ через \_ ptr.            |
| 40  | параметр ОБРАБОТЧИКа \_ \_ находится \_ в                  |
| 20  | параметр ОБРАБОТЧИКа \_ \_ \_ исходящий                 |
| 21  | \_ \_ \_ ВОЗВРАЩАЕМый параметр Handle              |
| 08  | \_четкий \_ маркер контекста NDR \_           |
| 04  | \_ \_ несериализуемый обработчик контекста \_ NDR \_    |
| 02  | \_ \_ сериализация обработчика контекста ОНД \_        |
| 01  | \_маркер контекста \_ ОНД \_ не может \_ иметь \_ значение null |



 

Первые четыре флага всегда присутствовали, последние четыре были добавлены в Windows 2000.

Поле offset<2> предоставляет смещение от начала стека до маркера контекста.

\_ \_ Индекс подпрограммы очистки контекста \_<1> предоставляет индекс в поле **апфнндррундовнраутинес** дескриптора заглушки для подпрограммы очистки, используемой для этого дескриптора контекста. Компилятор всегда создает индекс. Для подпрограмм, не имеющих подпрограммы очистки, это индекс для позиции таблицы, которая содержит значение null.

Для заглушек, встроенного в **– Oi2**, параметр \_ num<1> предоставляет порядковый номер, начинающийся с нуля, указывая, какой именно обработчик контекста находится в данной процедуре.

Для предыдущих версий интерпретатора параметр \_ num<1> предоставляет номер параметра маркера контекста, начинающийся с нуля, в процедуре.

> [!Note]  
> Описание обработчика контекста в строке формата типа не будет содержать смещение<2> в описании.

 

## <a name="the-new-oif-header"></a>Новый заголовок – ОИФ

Как упоминалось ранее, заголовок [**– ОИФ**](/windows/desktop/Midl/-oi) разворачивается в заголовке **– Oi** . Для удобства здесь показаны все поля:

(Старый заголовок)

``` syntax
handle_type<1> 
Oi_flags<1>
[rpc_flags<4>]
proc_num<2>  
stack_size<2>
[explicit_handle_description<>]
```

(Расширения [**– ОИФ**](/windows/desktop/Midl/-oi) )

``` syntax
constant_client_buffer_size<2>
constant_server_buffer_size<2>
INTERPRETER_OPT_FLAGS<1>
number_of_params<1>
```

Постоянный \_ \_ Размер буфера клиента \_<2> предоставляет размер буфера упаковки, который мог быть предварительно вычислен компилятором. Это может быть только частичный размер, так как флаг Клиентмустсизе инициирует изменение размера.

\_ \_ Размер буфера постоянного сервера \_<2> предоставляет размер буфера маршалирования в виде предварительно вычисленного компилятором. Это может быть только частичный размер, так как флаг Сервермустсизе инициирует изменение размера.

\_Флаги opt интерпретатора \_ определяются в ндртипес. h:

``` syntax
typedef struct
  {
  unsigned char   ServerMustSize      : 1;    // 0x01
  unsigned char   ClientMustSize      : 1;    // 0x02
  unsigned char   HasReturn           : 1;    // 0x04
  unsigned char   HasPipes            : 1;    // 0x08
  unsigned char   Unused              : 1;
  unsigned char   HasAsyncUuid        : 1;    // 0x20
  unsigned char   HasExtensions       : 1;    // 0x40
  unsigned char   HasAsyncHandle      : 1;    // 0x80
  } INTERPRETER_OPT_FLAGS, *PINTERPRETER_OPT_FLAGS;
```

-   Бит Сервермустсизе устанавливается, если серверу необходимо выполнить проход по размерам буфера.
-   Бит Клиентмустсизе устанавливается, если клиенту необходимо выполнить проход по размерам буфера.
-   Бит Хасретурн устанавливается, если процедура имеет возвращаемое значение.
-   Бит Хаспипес устанавливается, если необходимо использовать пакет канала для поддержки аргумента канала.
-   Бит Хасасинкууид устанавливается, если процедура является асинхронной процедурой DCOM.
-   Бит Хасекстенсионс указывает, что используются расширения Windows 2000 и более поздних версий.
-   Бит Хасасинчандле указывает асинхронную процедуру RPC.

Бит Хасасинчандле изначально использовался в качестве другой реализации модели асинхронной поддержки DCOM, и поэтому не может использоваться для асинхронной поддержки текущего стиля в DCOM. В настоящее время бит Хасасинкууид указывает на это.

 

 