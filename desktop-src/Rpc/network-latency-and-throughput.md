---
title: Задержка и пропускная способность сети
description: Задержка и пропускная способность сети с помощью удаленного вызова процедур (RPC).
ms.assetid: 8285fd73-eb54-4c06-b01a-1bffafb7e675
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: c5c51c4db75b904ac5feae8c4a1cc5965fc2b06e
ms.sourcegitcommit: 2d531328b6ed82d4ad971a45a5131b430c5866f7
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/16/2019
ms.locfileid: "104258902"
---
# <a name="network-latency-and-throughput"></a>Задержка и пропускная способность сети

Три основные проблемы связаны с оптимальным использованием сети:

-   Задержка в сети
-   Насыщенность сети
-   Последствия обработки пакетов

В этом разделе описывается задача программирования, которая требует использования RPC, затем проектирует два решения: один плохо написанный и один хорошо написанный. Затем оба решения изучены, и их влияние на производительность сети обсуждается.

Прежде чем обсуждать два решения, в следующих разделах обсуждаются и проявляются проблемы с производительностью, связанные с сетью.

## <a name="network-latency"></a>Задержка сети

Пропускная способность сети и задержка сети являются отдельными терминами. Сети с высокой пропускной способностью не гарантируют низкую задержку. Например, сетевой путь, обход вспомогательной ссылки, часто имеет высокую задержку, хотя пропускная способность очень высока. Нечастое сетевое время, прохождение по вспомогательной ссылке в течение пяти и более секунд с задержкой. Такая задержка заключается в том, что приложение, предназначенное для отправки запроса, ожидания ответа, отправки другого запроса, ожидания другого ответа и т. д., будет ожидать по меньшей мере пять секунд для каждого обмена пакетами, независимо от того, насколько быстро работает сервер. Несмотря на повышение скорости работы компьютеров, передача спутниковых данных и Сетевые носители основываются на скорости падения, которая обычно остается постоянной. Таким образом, маловероятно, что возникают задержки в существующих вспомогательных сетях.

## <a name="network-saturation"></a>Насыщенность сети

Некоторое насыщенность происходит во многих сетях. Наиболее простыми сетями, к которым наследуется насыщенность, являются медленные каналы связи, такие как стандартные аналоговые модемы 56K. Однако связи Ethernet с несколькими компьютерами в одном сегменте также могут быть насыщены. То же самое относится к глобальным сетям с низкой пропускной способностью или избыточным каналом связи, например маршрутизатором или коммутатором, который может управлять ограниченным объемом трафика. В таких случаях, если сеть отправляет больше пакетов, чем может справиться слабая ссылка, она удаляет пакеты. Чтобы избежать перегрузки, стек TCP Windows масштабируется обратно при обнаружении пропущенных пакетов, что может привести к значительным задержкам.

## <a name="packet-processing-implications"></a>Последствия обработки пакетов

Когда программы разрабатываются для сред более высокого уровня, таких как RPC, COM и даже сокеты Windows, разработчики, как правило, забывают, какой объем работы проходит в фоновом режиме для каждого отправленного или полученного пакета. Когда пакет поступает из сети, компьютер может обслуживать прерывание от сетевой карты. Затем отложенный вызов процедуры (DPC) помещается в очередь, и его необходимо использовать в драйверах. Если используется какая-либо форма безопасности, пакет может быть расшифрован или проверен криптографический хэш. Также необходимо выполнить проверку допустимости для каждого состояния. Только после этого пакет прибывает в окончательном месте назначения: серверный код. Отправка большого количества небольших фрагментов данных приводит к увеличению нагрузки на обработку пакетов для каждого небольшого фрагмента данных. Отправка одного большого фрагмента данных, как правило, потребляет значительно меньше времени ЦП во всей системе, несмотря на то, что стоимость выполнения для многих небольших фрагментов по сравнению с одним большим фрагментом может быть одинаковой для серверного приложения.

## <a name="example-1-a-poorly-designed-rpc-server"></a>Пример 1. плохо спроектированный сервер RPC

Представьте себе приложение, которое должно обращаться к удаленным файлам, а задача в наличии — проектирование интерфейса RPC для управления удаленным файлом. Самым простым решением является отражение файловых подпрограмм Studio для локальных файлов. Это может привести к появлению поясной очистки и знакомого интерфейса. Ниже приведен сокращенный IDL-файл:

``` syntax
typedef [context_handle] void *remote_file;
... .
interface remote_file
{
    remote_file remote_fopen(file_name);
    void remote_fclose(remote_file ...);
    size_t remote_fread(void *, size_t, size_t, remote_file ...);
    size_t remote_fwrite(const void *, size_t, size_t, remote_file ...);
    size_t remote_fseek(remote_file ..., long, int);
}
```

Это кажется достаточно элегантным, но на самом деле это набор, соблюдающий время для аварийного выполнения. В отличие от популярного мнения, удаленный вызов процедур не просто вызовом локальной процедуры с передачей связи между вызывающей и вызываемой стороной.

Чтобы увидеть, как этот рецепт задействует производительность, рассмотрите файл в формате 2000, где 20 байтов считываются с начала, а затем 20 байт с конца и посмотрим, как это работает. На стороне клиента выполняются следующие вызовы (для краткости опущено несколько путей кода):

``` syntax
rfp = remote_fopen("c:\\sample.txt");
remote_read(...);
remote_fseek(...);
remote_read(...);
remote_fclose(rfp);
```

Теперь представьте, что сервер отделен от клиента по вспомогательной ссылке с пятью секундами времени приема-передачи. Каждый из этих вызовов должен ожидать ответа, прежде чем он сможет продолжаться, что означает абсолютный минимум для выполнения этой последовательности, равной 25 секундам. Учитывая, что извлекается только 40 байт, это аутражеаусли снижение производительности. Клиенты этого приложения будут фуриаус.

Теперь представьте, что сеть перегружена, так как производительность маршрутизатора где-то находится в сетевом пути, перегружена. Такая схема заставляет маршрутизатор обрабатывать по крайней мере 10 пакетов, если нет безопасности (по одному для каждого запроса и по одному для каждого ответа). Это тоже неплохо.

Эта схема также заставляет сервер получать пять пакетов и отправлять пять пакетов. Опять же, не очень хорошая реализация.

## <a name="example-2-a-better-designed-rpc-server"></a>Пример 2. Улучшенный разработанный RPC-сервер

Давайте перейдем к интерфейсу, рассмотренному в примере 1, и посмотрим, можно ли улучшить его. Важно отметить, что предоставление этому серверу действительно хорошо требует знания шаблона использования для заданных файлов: в этом примере не предполагается, что такие знания не принимаются. Поэтому это более эффективный сервер RPC, но не оптимально разработанный сервер RPC.

Идея в этом примере состоит в том, чтобы свернуть максимально возможное количество удаленных операций в одну операцию. Первая последующая предпринятая ошибка:

``` syntax
typedef [context_handle] void *remote_file;
typedef struct
{
    long position;
    int origin;
} remote_seek_instruction;
... .
interface remote_file
{
    remote_fread(file_name, void *, size_t, size_t, [in, out] remote_file ..., BOOL CloseWhenDone, remote_seek_instruction *...);
    size_t remote_fwrite(file_name, const void *, size_t, size_t, [in, out] remote_file ..., BOOL CloseWhenDone, remote_seek_instruction *...);
}
```

В этом примере выполняется сворачивание всех операций для чтения и записи, что позволяет необязательно открыть одну операцию, а также необязательное закрытие и поиск.

Такая же последовательность операций, написанная в сокращенном виде, выглядит следующим образом:

``` syntax
remote_read("c:\\sample.txt", ..., &rfp, FALSE, NULL);
remote_read(NULL, ..., &rfp, TRUE, seek_to_20_bytes_before_end);
```

При рассмотрении лучшего спроектированного сервера RPC во втором вызове сервер проверяет, что *\_ имя файла* имеет **значение NULL**, и использует сохраненный открытый файл в запросах предложений. Затем он видит указания по поиску и помещает указатель файла на 20 байт перед концом, прежде чем он начнет чтение. По завершении он узнает, что флаг **клосевхендоне** имеет значение **true**, и закроет файл и закроет поле запроса предложений.

В сети с высокой задержкой эта лучшая версия занимает 10 секунд (в 2,5 раз быстрее) и требует обработки всего четырех пакетов. два получает от сервера и два отправляются с сервера. Дополнительные функции *IFS* и распаковка сервера выполняются незначительно по сравнению с остальными.

Если упорядочивание причин задано правильно, интерфейс можно даже сделать асинхронным, а два вызова могут отправляться параллельно. Когда используются вызовы порядка возникновения причин, они по-прежнему передаются по порядку, что означает, что в сети с высокой задержкой приободрилися только 5-секундная задержка, даже если количество отправленных и полученных пакетов одинаково.

Мы можем свернуть это еще больше, создав один метод, который принимает массив структур, каждый элемент массива, описывающий операцию с файлом. удаленный вариант точечной или собираемой операции ввода-вывода. Подход оплачивается при условии, что результат каждой операции не требует дальнейшей обработки на клиенте. Иными словами, приложение будет считывать 20 байт в конце, независимо от того, что прочитано первыми 20 байтами.

Однако если определенная обработка должна быть выполнена на первых 20 байтах после их считывания для определения следующей операции, то свертывание всего в одну операцию не работает (по крайней мере, не во всех случаях). Элегантность RPC заключается в том, что приложение может иметь оба метода в интерфейсе и вызывать любой из них в зависимости от потребностей.

Как правило, при использовании сети лучше объединять как можно больше вызовов в один вызов. Если приложение имеет два независимых действия, используйте асинхронные операции и разрешите их параллельное выполнение. По сути, не заключайте конвейер в полный режим.

 

 




