---
title: Обеспечение доступности сервера в сети
description: Прежде чем серверное приложение сможет принимать удаленные вызовы процедур, оно должно быть доступно в сети.
ms.assetid: 1fad55e2-7221-4153-b530-b36ea42e03e1
keywords:
- Удаленный вызов процедур RPC, задачи, обеспечение доступности сервера
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 55385a1ba10f7f8ca28622af0b145ce25ef1bbbd0ab8df327687ce7fd7db6f77
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "120020058"
---
# <a name="making-the-server-available-on-the-network"></a>Обеспечение доступности сервера в сети

Прежде чем серверное приложение сможет принимать удаленные вызовы процедур, оно должно быть доступно в сети. Для этого сервер сообщает времени выполнения RPC о том, что он желает принимать вызовы в одной или нескольких последовательностях протоколов. Выбор последовательностей протоколов, поддерживаемых серверным приложением, является важным решением. различные последовательности протоколов имеют очень разные возможности. Серверы, которые предполагают получение вызовов локально, должны использовать **нкалрпк**. Серверы, принимающие удаленные вызовы, должны использовать **нкакн \_ IP \_ TCP**. Серверы не должны проверять, что последовательность протокола, в которой они получают вызовы, — это последовательность протокола, в которой они хотят получить вызовы. Дополнительные сведения см. в статье будьте осторожны с другими конечными точками RPC, работающими в том же процессе.

В следующем примере используется **нкакн \_ IP \_ TCP**.

Большинство серверных программ используют все последовательности протоколов, доступные в сети. Для этого они вызывают функцию [**рпксерверусепротсек**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseq) , как показано в следующем фрагменте кода:


```C++
RPC_STATUS status;
status = RpcServerUseAllProtseq(
    L"ncacn_ip_tcp",
    RPC_C_PROTSEQ_MAX_REQS_DEFAULT,    // Protseq dependent parameter
    NULL);                             // Always specify NULL here.
```



Первым параметром функции [**рпксерверусепротсек**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseq) является последовательность протокола. Второй параметр зависит от последовательности протокола. Как показано в фрагменте кода, большинство серверных программ применяют этот параметр к **RPC \_ C \_ протсек \_ Max \_ запросов секунду \_ по умолчанию**. Это значение задает использование значения по умолчанию для библиотеки RPC. Третий параметр является дескриптором безопасности и не должен использоваться в приложениях. Дополнительные сведения см. в разделе [**Безопасность**](security.md).

Можно также использовать функции [**рпксерверусеаллпротсекс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseallprotseqs), [**рпксерверусепротсекекс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqex), [**рпксерверусепротсекеп**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqep)или [**рпксерверусепротсекепекс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqepex) .

Когда серверное приложение выбирает по крайней мере одну последовательность протоколов, серверы, использующие динамические конечные точки, должны создавать сведения о привязке для каждой используемой им последовательности протокола. Сервер хранит сведения о привязке в векторе привязки, который затем можно экспортировать в службу сопоставителя конечных точек.

Используйте функцию [**рпксерверинкбиндингс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserverinqbindings) для получения вектора привязки для серверного приложения, как показано в следующем примере:


```C++
RPC_STATUS status;
RPC_BINDING_VECTOR *rpcBindingVector;
 
status = RpcServerInqBindings(&rpcBindingVector);
```



Единственный параметр, передаваемый функции [**рпксерверинкбиндингс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserverinqbindings) , — это указатель на указатель на структуру [**\_ \_ вектора привязки RPC**](/windows/desktop/api/Rpcdce/ns-rpcdce-rpc_binding_vector) . Библиотека времени выполнения RPC динамически выделяет массив векторов привязки и сохраняет адрес массива в переменной параметра (в данном случае это **рпкбиндингвектор**). Каждое серверное приложение отвечает за освобождение этого вектора привязки с помощью функции [**рпкбиндингвекторфри**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingvectorfree) по завершении ее использования (например, после того, как она была передана соответствующим функциям).

 

 




