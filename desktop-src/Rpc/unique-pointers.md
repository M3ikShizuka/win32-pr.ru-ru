---
title: Уникальные указатели
description: В программах на языке C более одного указателя могут содержать адрес данных.
ms.assetid: da4f466d-2c59-4e48-b6c5-1a49b933621a
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3fc8cf9a45965c82416ec838f8598c2796ba621a
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104070040"
---
# <a name="unique-pointers"></a>Уникальные указатели

В программах на языке C более одного указателя могут содержать адрес данных. Указатели говорят, чтобы создать [*псевдоним*](a-glos.md) для данных. Псевдонимы также создаются при наведении указателя на объявленные переменные. В следующем фрагменте кода показаны оба метода присвоения псевдонимам.


```C++
int iAnInteger=50;

// The next statement makes ipAnIntegerPointer an
// alias for iAnInteger.
int *ipAnIntegerPointer = &iAnInteger;

// This statement creates an alias for ipAnIntegerPointer.
int *ipAnotherIntegerPointer = ipAnIntegerPointer;
```



В обычной программе на языке C можно указать двоичное дерево, используя следующее определение:


```C++
typedef struct _treetype 
{
    long               lValue;
    struct _treetype * left;
    struct _treetype * right;
} TREETYPE;

TREETYPE * troot;
```



Доступ к содержимому узла дерева может осуществляться более чем одним указателем. Как правило, это подходит для нераспределенных приложений. Однако этот стиль программирования создает более сложный код поддержки RPC. Заглушки клиента и сервера потребовали дополнительного кода для управления данными и указателями. Базовый код заглушки должен разрешать различные указатели на адреса и определять, какая копия данных представляет самую последнюю версию.

Объем обработки можно уменьшить, если вы гарантируете, что указатель является единственным способом, которым приложение может получить доступ к области памяти. Указатель может по-прежнему иметь множество функций указателя C. Например, он может изменяться между значениями **null** и отличными от **null** или остаться одинаковыми. Это показано в следующем примере. Указатель имеет **значение NULL** перед вызовом и указывает на допустимую строку после вызова:

![изменение указателя между значениями NULL и не NULL](images/prog-a01.png)

По умолчанию компилятор MIDL применяет \[ [уникальный](/windows/desktop/Midl/unique) \] атрибут указателя ко всем указателям, которые не являются параметрами. Этот параметр по умолчанию можно изменить с помощью \[ атрибута [указателя \_ по умолчанию](/windows/desktop/Midl/pointer-default) \] .

Уникальный указатель имеет следующие характеристики.

-   Оно может иметь значение **null**.
-   При вызове может измениться со **значения NULL на значение** , отличное **от NULL.** При изменении значения, отличного от **null**, выделяется новая память при возврате.
-   Во время вызова он может измениться с **значения** , отличного от **null** , на null. Когда значение изменяется на **null**, приложение отвечает за освобождение памяти.
-   Значение может изменяться от одного значения, отличного от **null** , к другому.
-   Хранилище, на которое указывает уникальный указатель, не может быть получено любым другим указателем или именем в операции.
-   Возвращаемые данные записываются в существующее хранилище, если указатель не имеет значения **null**.

В следующем примере показано, как определить уникальный указатель.

``` syntax
/* IDL file */
[ 
  uuid(ba209999-0c6c-11d2-97cf-00c04f8eea45),
  version(1.0)
]
interface RefPtrInterface
{
  void RemoteFn([in, unique] char *ach);
}
```

В этом примере параметр *платежи ACH* является уникальным указателем на символьные данные, которые отправляются на сервер для обработки с помощью подпрограммы ремотефн.

 

 