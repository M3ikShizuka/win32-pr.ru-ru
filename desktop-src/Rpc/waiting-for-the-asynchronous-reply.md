---
title: Ожидание асинхронного ответа
description: Клиент, выполняющий ожидание получения уведомления от сервера, зависит от механизма уведомления, который он выбирает.
ms.assetid: b1d4ea54-26bc-49f9-8cc1-a74fd4ffced3
keywords:
- Удаленный вызов процедур RPC, задачи, ожидание асинхронных ответов
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 0890b3024a05bb704f7b5a803c4b1e517c65ee21
ms.sourcegitcommit: 592c9bbd22ba69802dc353bcb5eb30699f9e9403
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/20/2020
ms.locfileid: "104338476"
---
# <a name="waiting-for-the-asynchronous-reply"></a>Ожидание асинхронного ответа

Клиент, выполняющий ожидание получения уведомления от сервера, зависит от механизма уведомления, который он выбирает.

Если клиент использует событие для уведомления, обычно вызывается функция [**WaitForSingleObject**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobject) или функция [**WaitForSingleObjectEx**](/windows/desktop/api/synchapi/nf-synchapi-waitforsingleobjectex) . Клиент переходит в состояние блокировки при вызове любой из этих функций. Это эффективно, так как клиент не потребляет циклы выполнения ЦП, пока он заблокирован.

При использовании опроса для ожидания его результатов клиентская программа вводит цикл, который многократно вызывает функцию [**рпкасинкжеткаллстатус**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcasyncgetcallstatus). Это эффективный метод ожидания, если клиентская программа выполняет другую обработку в цикле опроса. Например, он может подготовить данные в небольших блоках для последующего асинхронного вызова удаленной процедуры. После завершения каждого фрагмента клиент может опросить необработанный асинхронный вызов удаленной процедуры, чтобы убедиться, что он завершен.

Клиентская программа может предоставить асинхронный вызов процедур (APC), который представляет собой тип функции обратного вызова, которая будет вызываться библиотекой времени выполнения RPC при завершении асинхронного вызова удаленной процедуры. Клиентская программа должна находиться в состоянии ожидания с оповещением. Обычно это означает, что клиент вызывает функцию Windows API, чтобы перевести себя в заблокированное состояние. Дополнительные сведения см. в разделе [асинхронные вызовы процедур](/windows/desktop/Sync/asynchronous-procedure-calls).

> [!Note]  
> Уведомление о завершении не будет возвращено из асинхронной подпрограммы RPC, если во время асинхронного вызова возникает исключение RPC.

 

Если клиентская программа использует порт завершения ввода-вывода для получения уведомлений о завершении, он должен вызвать функцию [**жеткуеуедкомплетионстатус**](/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) . В этом случае он может либо подождать неограниченное время ответа, либо продолжить обработку. Если он выполняет другие операции обработки, ожидая ответа, он должен опросить порт завершения с помощью функции **жеткуеуедкомплетионстатус** . В этом случае, как правило, необходимо установить *dwMilliseconds* в нулевое значение. Это приводит к тому, что **жеткуеуедкомплетионстатус** будет возвращаться немедленно, даже если асинхронный вызов не завершен.

Клиентские программы также могут получить уведомление о завершении через очереди сообщений окна. В этом случае они просто обрабатывают сообщение о завершении, как и любое сообщение Windows.

В многопоточном приложении асинхронный вызов может быть отменен Клиентом только после того, как поток, порожденный вызов, успешно возвращался из вызова. Это гарантирует, что вызов не будет асинхронно отменен другим потоком после сбоя синхронного вызова. По стандартной практике асинхронный вызов, который завершается сбоем синхронно, не должен быть отменен асинхронно. Клиентское приложение должно наблюдать за этим поведением, если вызовы могут быть выданы и отменены в разных потоках. Кроме того, после отмены вызова клиентский код должен ждать уведомления о завершении и завершить вызов. Функция [**рпкасинкканцелкалл**](/windows/desktop/api/Rpcasync/nf-rpcasync-rpcasynccancelcall) просто пропускует уведомление о завершении; Это не является заменой выполнению вызова.

В следующем фрагменте кода показано, как клиентская программа может использовать событие для ожидания асинхронного ответа.


```C++
// This code fragment assumes that Async is a valid asynchronous
// RPC handle.
if (WaitForSingleObject(Async.u.hEvent, INFINITE) == WAIT_FAILED)
{
    RpcRaiseException(APP_ERROR);
}
```



Клиентские программы, использующие APC для получения уведомлений об асинхронном ответе, обычно переводят себя в заблокированное состояние. Это показано в следующем фрагменте кода.


```C++
if (SleepEx(INFINITE, TRUE) != WAIT_IO_COMPLETION)
{
    RpcRaiseException(APP_ERROR);
}
```



В этом случае клиентская программа переходит в спящий режим, использующий циклы ЦП, пока библиотека времени выполнения RPC не вызовет APC (не показано).

В следующем примере демонстрируется клиент, использующий порт завершения ввода-вывода для ожидания асинхронного ответа.


```C++
// This code fragment assumes that Async is a valid asynchronous
// RPC handle.
if (!GetQueuedCompletionStatus(
         Async.u.IOC.hIOPort,
         &Async.u.IOC.dwNumberOfBytesTransferred,
         &Async.u.IOC.dwCompletionKey,
         &Async.u.IOC.lpOverlapped,
         INFINITE))
{
    RpcRaiseException(APP_ERROR);
}
```



В предыдущем примере вызов [**жеткуеуедкомплетионстатус**](/windows/desktop/api/ioapiset/nf-ioapiset-getqueuedcompletionstatus) ожидает неограниченного времени до завершения асинхронного вызова удаленной процедуры.

При написании многопоточных приложений возникает одна потенциальная ловушка. Если поток вызывает удаленный вызов процедуры, а затем завершается перед получением уведомления о завершении отправки, вызов удаленной процедуры может завершиться ошибкой, и клиентская заглушка может закрыть соединение с сервером. Поэтому потоки, вызывающие удаленную процедуру, не должны завершаться до завершения или отмены вызова, если поведение нежелательно.

 

 