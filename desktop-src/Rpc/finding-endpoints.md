---
title: Поиск конечных точек
description: Серверные программы прослушивают конечные точки для клиентских запросов. Синтаксис строки конечной точки зависит от используемой последовательности протокола. Например, конечная точка TCP/IP является номером порта, а синтаксис конечной точки для именованных каналов — допустимое имя канала.
ms.assetid: 330bbe9f-b7e9-4a5b-86d8-824edec960d2
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 024a85704287db7e5f78bb67eee9b64a7c6dc84ce5724623450d36f743e5fa9a
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "120021284"
---
# <a name="finding-endpoints"></a>Поиск конечных точек

Серверные программы прослушивают конечные точки для клиентских запросов. Синтаксис строки конечной точки зависит от используемой последовательности протокола. Например, конечная точка TCP/IP является номером порта, а синтаксис конечной точки для именованных каналов — допустимое имя канала.

Существует два типа конечных точек: хорошо известные и динамические. Выбор типа конечной точки, используемой программой, определяет, указывает ли конечная точка распределенное приложение или библиотека времени выполнения.

В этом разделе обсуждаются конечные точки и предоставляются сведения о том, как их найти. Он состоит из следующих разделов:

-   [Использование конечных точек Well-Known](#using-well-known-endpoints)
-   [Использование динамических конечных точек](#using-dynamic-endpoints)
-   [Экспорт Well-Known конечных точек в базу данных карт конечных точек](#exporting-well-known-endpoints-into-the-endpoint-map-database)

> [!Note]  
> Термины *статические конечные точки* и *хорошо известные конечные точки* эквивалентны и взаимозаменяемы.

 

Клиентское приложение может использовать карту конечных точек для определения того, запущена ли в данный момент серверная программа. Клиент может вызвать [**рпкмгмтинкифидс**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtinqifids), [**рпкмгмтепелтинкбегин**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin)и [**рпкмгмтепелтинкдоне**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqdone) , чтобы узнать, зарегистрировал ли сервер конкретный интерфейс, требуемый на карте конечных точек.

## <a name="using-well-known-endpoints"></a>Использование хорошо известных конечных точек

Хорошо известные конечные точки — это предварительно назначенные конечные точки, которые серверная программа использует при каждом запуске. Поскольку сервер всегда прослушивает эту конкретную конечную точку, клиент всегда пытается подключиться к нему. Хорошо известные конечные точки обычно назначаются центром, ответственным за транспортный протокол. Поскольку компьютеры узлов сервера имеют конечное количество доступных конечных точек, разработчикам приложений настоятельно не рекомендуется использовать известные конечные точки. Другое преимущество динамических конечных точек заключается в том, что они упрощают долгосрочное управление и обслуживание системы.

Распределенное приложение может указать хорошо известную конечную точку в строке и передать эту строку в качестве параметра в функцию [**рпксерверусепротсекеп**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcserveruseprotseqep). Кроме того, строка конечной точки может отображаться в заголовке интерфейса IDL-файла как часть \[ атрибута интерфейса [конечной точки](/windows/desktop/Midl/endpoint) \] .

Для реализации хорошо известной конечной точки можно использовать два подхода:

-   Указать всю информацию в привязке строк
-   Хранение хорошо известной конечной точки в базе данных службы имен

Вы можете записать всю информацию, необходимую для установки привязки в распределенное приложение при разработке. Клиент может указать хорошо известную конечную точку непосредственно в строке, вызвать [**рпкстрингбиндингкомпосе**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcstringbindingcompose) , чтобы создать строку, содержащую все сведения о привязке, и предоставить эту строку функции [**рпкбиндингфромстрингбиндинг**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcbindingfromstringbinding) для получения маркера. Клиент и сервер могут быть жестко запрограммированы для использования хорошо известной конечной точки или написаны таким образом, чтобы информация о конечной точке поступила из командной строки, файла данных, файла конфигурации или IDL-файла.

Клиентское приложение также может запрашивать в базе данных службы имен сведения о известной конечной точке.

## <a name="using-dynamic-endpoints"></a>Использование динамических конечных точек

Количество конечных точек для конкретного сервера и определенной последовательности протоколов обычно ограничено. Например, при использовании последовательности протокола [ \_ IP \_ TCP нкакн](/windows/desktop/Midl/ncacn-ip-tcp) , указывающей на то, что сетевое взаимодействие RPC происходит по протоколу TCP/IP, доступно только ограниченное число портов (большинство систем имеют диапазон от 1025 до 5000). Библиотеки времени выполнения RPC позволяют назначать конечные точки динамически, по мере необходимости. Так как количество идентификаторов UUID интерфейса практически не ограничено, использование UUID интерфейса для направления вызова предоставляет больше места для расширения и повышает гибкость.

По умолчанию функции библиотеки времени выполнения RPC выполняют поиск сведений о конечной точке при запросе к базе данных службы имен. Если конечная точка является динамической, то база данных службы имен не будет содержать сведения о конечной точке. Однако запрос предоставит клиентской программе имя сервера. Затем он может выполнить поиск на карте конечных точек сервера.

Если клиенту необходимо выполнить удаленный вызов процедуры с помощью динамической конечной точки, предпочтительным методом является вызов в маркере привязки с частичным связыванием. Во время выполнения RPC конечная точка разрешается прозрачно. Этот метод является предпочтительным для использования функции [**рпцепресолвебиндинг**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcepresolvebinding) , так как он позволяет использовать расширенные механизмы кэширования во время выполнения RPC.

Если требуется более конкретный контроль над выбором конечной точки, клиенты могут выполнять поиск в конечной точке по одной записи за раз, вызывая функции [**рпкмгмтепелтинкбегин**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqbegin), [**рпкмгмтепелтинкнекст**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqnext)и [**рпкмгмтепелтинкдоне**](/windows/desktop/api/Rpcdce/nf-rpcdce-rpcmgmtepeltinqdone) .

## <a name="exporting-well-known-endpoints-into-the-endpoint-map-database"></a>Экспорт хорошо известных конечных точек в базу данных карт конечных точек

Можно смешивать два подхода к поиску конечных точек, особенно при переходе распределенной системы из хорошо известной модели конечных точек в модель динамической конечной точки. В таких переходах промежуточная версия сервера будет использовать хорошо известную конечную точку, но она также будет регистрировать хорошо известную конечную точку с базой данных с картой конечной точки. Такой подход позволяет клиентам, использующим хорошо известную конечную точку, и клиентам, использующим динамическую конечную точку, подключаться. После обновления всех серверов можно развернуть новую версию клиента, использующую только динамические конечные точки. После обновления всех клиентов окончательная версия сервера может завершиться с помощью хорошо известных конечных точек и начинать использовать только динамические конечные точки.

Такой подход позволяет использовать путь перехода для приложений, которые начали работать с хорошо известной конечной точкой, но выполнять миграцию на динамическую конечную точку без необходимости одновременного обновления всех серверов и клиентов.

 

 