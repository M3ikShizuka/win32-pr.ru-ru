---
title: Работа с шейдерами и ресурсами шейдера
description: Пора научиться работать с шейдерами и источниками текстур при разработке игры Microsoft DirectX для Windows 8.
ms.assetid: 25a11983-e3f6-4bd3-86f1-d660edc4cd4b
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: bbf0152ba74dcc8dd1c602b69d854634502c928a0deefe5521bcab8999954049
ms.sourcegitcommit: e858bbe701567d4583c50a11326e42d7ea51804b
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "118288554"
---
# <a name="work-with-shaders-and-shader-resources"></a>Работа с шейдерами и ресурсами шейдера

Пора научиться работать с шейдерами и источниками текстур при разработке игры Microsoft DirectX для Windows 8. Мы рассмотрели, как настроить графическое устройство и ресурсы, и, возможно, вы даже начали изменять его конвейер. Теперь давайте взглянем на шейдеры пикселей и вершин.

Если вы не знакомы с языками шейдеров, можно быстро обсуждать их в порядке. Шейдеры — это небольшие программы низкого уровня, которые компилируются и выполняются на конкретных этапах конвейера графики. Их специальность — это очень быстрые математические операции с плавающей точкой. Наиболее распространенные программы шейдеров:

-   **Шейдер вершин**— выполняется для каждой вершины в сцене. Этот шейдер работает с элементами буфера вершин, предоставленными ему вызывающим приложением, и, как минимум, приводит к постановке вектора расположения с 4 компонентами, который будет разделяться в пиксельном положении.
-   **Шейдер пикселей**— выполняется для каждого пикселя в целевом объекте прорисовки. Этот шейдер получает растровые координаты от предыдущих этапов шейдера (в простейших конвейерах это будет шейдер вершин) и возвращает цвет (или другое значение 4 компонентов) для этой точки в пикселях, которая затем записывается в целевой объект отрисовки.

Этот пример включает очень простые шейдеры вершин и пикселей, которые рисуют только геометрию и более сложные шейдеры, добавляющие базовые вычисления освещения.

Программы шейдеров написаны на языке шейдера высокого уровня (HLSL). Синтаксис HLSL выглядит очень похоже на C, но без указателей. Программы шейдеров должны быть очень компактными и эффективными. Если шейдер компилируется в слишком много инструкций, он не может быть выполнен и возвращается ошибка. (Обратите внимание, что точное допустимое количество инструкций является частью [уровня функций Direct3D](/windows/desktop/direct3d11/overviews-direct3d-11-devices-downlevel-intro).)

В Direct3D шейдеры не компилируются во время выполнения. они компилируются при компиляции остальной части программы. при компиляции приложения с Microsoft Visual Studio 2013 файлы HLSL компилируются в файлы cso (. CSO), которые приложение должно загрузить и поместить в память GPU перед прорисовкой. Убедитесь, что вы включили эти файлы CSO в свое приложение при упаковке. они представляют собой ресурсы, такие как сетки и текстуры.

## <a name="understand-hlsl-semantics"></a>Общие сведения о семантике HLSL

Прежде чем продолжить, важно обсудить семантику HLSL, так как они часто являются предметом путаницы для новых разработчиков Direct3D. Семантика HLSL — это строки, которые определяют значение, передаваемое между приложением и программой шейдера. Хотя они могут быть любыми различными возможными строками, рекомендуется использовать такую строку, как `POSITION` или `COLOR` , которая указывает на использование. Вы назначаете эту семантику при построении буфера констант или макета ввода. Можно также добавлять к семантике цифру от 0 до 7, чтобы использовать отдельные регистры для сходных значений. Например: COLOR0, COLOR1, COLOR2...

Семантика с префиксом «SV \_ » — это семантика *системных значений* , записываемая программой шейдера; сама игра (работающая на ЦП) не может изменить их. Как правило, эти семантики содержат значения, которые являются входными или выходными данными из другого этапа шейдера в графическом конвейере или полностью созданы графическим процессором.

Кроме того, `SV_` семантика имеет различные поведения, когда они используются для указания входных данных или выходных данных на этапе шейдера. Например, `SV_POSITION` (Output) содержит данные вершин, преобразованные на этапе шейдера вершин, а `SV_POSITION` (*входные* данные) содержат значения точек в пикселях, которые были интерполяции GPU во время этапа растрирования.

Ниже приведена общая семантика HLSL:

-   `POSITION`(*n*) для данных в буфере вершин. `SV_POSITION` Задает точку в пикселе шейдера пикселей и не может быть записана в игре.
-   `NORMAL`(*n*) для обычных данных, предоставляемых буфером вершин.
-   `TEXCOORD`(*n*) для данных текстуры UV-координат, предоставляемых шейдеру.
-   `COLOR`(n) для цветовых данных RGBA, предоставляемых шейдеру. Обратите внимание, что он обрабатывается одинаково для координации данных, включая интерполяцию значения во время растрирования. семантика просто помогает понять, что это данные цвета.
-   `SV_Target`\[n \] для записи из шейдера пикселей в целевую текстуру или другой буфер пикселей.

Мы рассмотрим некоторые примеры семантики HLSL, как мы рассмотрим пример.

## <a name="read-from-the-constant-buffers"></a>Чтение из буферов констант

Любой шейдер может считывать из буфера констант, если этот буфер присоединен к его этапу в качестве ресурса. В этом примере только шейдеру вершин назначен буфер констант.

Буфер константы объявляется в двух местах: в коде C++ и в соответствующих файлах HLSL, которые будут обращаться к нему.

Вот как объявляется структура буфера констант в коде C++.


```C++
typedef struct _constantBufferStruct {
    DirectX::XMFLOAT4X4 world;
    DirectX::XMFLOAT4X4 view;
    DirectX::XMFLOAT4X4 projection;
} ConstantBufferStruct;
```



При объявлении структуры для буфера констант в коде C++ Убедитесь, что все данные правильно выводятся по 16-байтным границам. Самый простой способ сделать это — использовать типы [директксмас](/windows/desktop/dxmath/directxmath-portal) , такие как **XMFLOAT4** или **XMFLOAT4X4**, как показано в примере кода. Можно также защититься от несогласованных буферов путем объявления статического утверждения:


```C++
// Assert that the constant buffer remains 16-byte aligned.
static_assert((sizeof(ConstantBufferStruct) % 16) == 0, "Constant Buffer size must be 16-byte aligned");
```



Эта строка кода вызовет ошибку во время компиляции, если **константбуфферструкт** не является 16-байтовым. Дополнительные сведения о выравнивании и упаковке буфера констант см. в разделе [правила упаковки для переменных констант](/windows/desktop/direct3dhlsl/dx-graphics-hlsl-packing-rules).

Теперь вот как объявляется буфер констант в шейдере вершин HLSL.


```C++
cbuffer ModelViewProjectionConstantBuffer : register(b0)
{
    matrix mWorld;      // world matrix for object
    matrix View;        // view matrix
    matrix Projection;  // projection matrix
};
```



Все буферы — константы, текстуры, образцы или другие — должны иметь определенный регистр, чтобы GPU мог получить к ним доступ. Каждый этап шейдера поддерживает до 15 буферов констант, и каждый буфер может содержать до 4 096 переменных констант. Синтаксис объявления использования регистра выглядит следующим образом:

-   **б** _\#_ : регистр для буфера констант (**кбуффер**).
-   **t** _\#_ : регистр для буфера текстуры (**тбуффер**).
-   **s** _\#_ : регистр для образца. (Образец определяет поведение поиска для пикселей текстуры в ресурсе текстуры.)

Например, HLSL для шейдера пикселей может взять текстуру и образец в качестве входных данных с объявлением, подобным этому.

``` syntax
Texture2D simpleTexture : register(t0);
SamplerState simpleSampler : register(s0);
```

Вы можете назначать постоянные буферы для регистрации — при настройке конвейера вы подключаете буфер константы к тому же слоту, в котором он был назначен в файле HLSL. Например, в предыдущем разделе вызов [**вссетконстантбуфферс**](/windows/desktop/api/d3d11/nf-d3d11-id3d11devicecontext-vssetconstantbuffers) указывает "0" для первого параметра. Это указывает Direct3D подключить ресурс буфера константы для регистрации 0, который соответствует назначению буфера для **регистрации (B0)** в файле HLSL.

## <a name="read-from-the-vertex-buffers"></a>Чтение из буферов вершин

Буфер вершин предоставляет данные треугольника для объектов сцены в шейдер вершин. Как и в случае с буфером констант, структура буфера вершин объявляется в коде C++ с использованием аналогичных правил упаковки.


```C++
typedef struct _vertexPositionColor
{
    DirectX::XMFLOAT3 pos;
    DirectX::XMFLOAT3 color;
} VertexPositionColor;
```



В Direct3D 11 нет стандартного формата для данных вершин. Вместо этого мы определяем собственный макет данных вершин с помощью дескриптора. поля данных определяются с помощью массива структур [**D3D11 \_ \_ элемента \_ input**](/windows/desktop/api/d3d11/ns-d3d11-d3d11_input_element_desc) . Здесь показан простой макет ввода, описывающий тот же формат вершин, что и в предыдущей структуре:


```C++
D3D11_INPUT_ELEMENT_DESC iaDesc [] =
{
    { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT,
    0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },

    { "COLOR", 0, DXGI_FORMAT_R32G32B32_FLOAT,
    0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
};

hr = device->CreateInputLayout(
    iaDesc,
    ARRAYSIZE(iaDesc),
    bytes,
    bytesRead,
    &m_pInputLayout
    );
```



Если вы добавляете данные в формат вершины при изменении кода примера, не забудьте также обновить макет ввода, или шейдер не сможет его интерпретировать. Вы можете изменить макет вершин следующим образом:


```C++
typedef struct _vertexPositionColorTangent
{
    DirectX::XMFLOAT3 pos;
    DirectX::XMFLOAT3 normal;
    DirectX::XMFLOAT3 tangent;
} VertexPositionColorTangent;
```



В этом случае необходимо изменить определение макета ввода следующим образом.


```C++
D3D11_INPUT_ELEMENT_DESC iaDescExtended[] =
{
    { "POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT,
    0, 0, D3D11_INPUT_PER_VERTEX_DATA, 0 },

    { "NORMAL", 0, DXGI_FORMAT_R32G32B32_FLOAT,
    0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },

    { "TANGENT", 0, DXGI_FORMAT_R32G32B32_FLOAT,
    0, 12, D3D11_INPUT_PER_VERTEX_DATA, 0 },
};

hr = device->CreateInputLayout(
    iaDesc,
    ARRAYSIZE(iaDesc),
    bytes,
    bytesRead,
    &m_pInputLayoutExtended
    );
```



Каждый из определений элементов входной компоновки имеет префикс String, например "положение" или "нормальный", который описан ранее в этом разделе. Он подобен обработчику, который позволяет графическому процессору обозначать этот элемент при обработке вершины. Выберите Общие, понятные имена для элементов вершин.

Точно так же, как и в случае с буфером констант, Вершинный шейдер имеет соответствующее определение буфера для входящих элементов вершины. (По этой причине мы предоставили ссылку на ресурс шейдера вершин при создании структуры входных данных. Direct3D проверяет компоновку с использованием входной структуры шейдера.) Обратите внимание, что семантика совпадает с определением входного макета и объявлением буфера HLSL. При этом `COLOR` к нему добавляется "0". Нет необходимости добавлять 0, если `COLOR` в макете объявлен только один элемент, но рекомендуется добавлять его в тот случай, если вы решили добавить дополнительные элементы цвета в будущем.


```C++
struct VS_INPUT
{
    float3 vPos   : POSITION;
    float3 vColor : COLOR0;
};
```



## <a name="pass-data-between-shaders"></a>Передача данных между шейдерами

Шейдеры принимают входные типы и возвращают выходные типы из своих основных функций при выполнении. Для шейдера вершин, определенного в предыдущем разделе, тип входных данных был \_ структурой ввода VS, и мы определили соответствующий макет входных данных и структуру C++. Массив этой структуры используется для создания буфера вершин в методе **CreateCube** .

Шейдер вершин возвращает \_ входную структуру PS, которая должна быть минимально содержать конечную точку вершины 4 компонента (float4). Значение этой должности должно иметь семантику системного значения, `SV_POSITION` , объявленную для нее, чтобы GPU имел данные, необходимые для выполнения следующего шага рисования. Обратите внимание, что отсутствует соответствие 1:1 между выходным шейдером вершин и входными данными шейдера пикселей. Шейдер вершин возвращает одну структуру для каждой указанной вершины, но шейдер пикселей выполняется один раз для каждого пикселя. Это обусловлено тем, что данные на вершине сначала проходят через этап растрирования. Этот этап определяет, на каких пикселях размещается геометрическая геометрия, вычисление интерполяции данных на вершину для каждого пикселя, а затем вызывает шейдер пикселей один раз для каждого из этих пикселов. Интерполяция является поведением по умолчанию при растрировании выходных значений и является обязательным в частности для правильной обработки данных вектора вывода (светлое векторы, нормали к вершинам, касательные и др.).


```C++
struct PS_INPUT
{
    float4 Position : SV_POSITION;  // interpolated vertex position (system value)
    float4 Color    : COLOR0;       // interpolated diffuse color
};
```



## <a name="review-the-vertex-shader"></a>Проверка шейдера вершин

Пример шейдера вершин очень прост: Возьмите вершину (расположение и цвет), преобразуйте позиции из координат модели в перспективные проецированные координаты и верните ее (вместе с цветом) в средство программной прорисовки. Обратите внимание, что значение цвета интерполяции выполняется справа вместе с данными о положении, что дает разные значения для каждого пикселя, несмотря на то, что шейдер вершин не выполняет вычисления по значению цвета.


```C++
VS_OUTPUT main(VS_INPUT input) // main is the default function name
{
    VS_OUTPUT Output;

    float4 pos = float4(input.vPos, 1.0f);

    // Transform the position from object space to homogeneous projection space
    pos = mul(pos, mWorld);
    pos = mul(pos, View);
    pos = mul(pos, Projection);
    Output.Position = pos;

    // Just pass through the color data
    Output.Color = float4(input.vColor, 1.0f);

    return Output;
}
```



Более сложный шейдер вершин, например, который настраивает вершины объекта для заливки по методу Фонга, может выглядеть примерно так. В этом случае мы используем тот факт, что векторы и нормали интерполируются для приблизительной привлекательной поверхности.

``` syntax
// A constant buffer that stores the three basic column-major matrices for composing geometry.
cbuffer ModelViewProjectionConstantBuffer : register(b0)
{
    matrix model;
    matrix view;
    matrix projection;
};

cbuffer LightConstantBuffer : register(b1)
{
    float4 lightPos;
};

struct VertexShaderInput
{
    float3 pos : POSITION;
    float3 normal : NORMAL;
};

// Per-pixel color data passed through the pixel shader.

struct PixelShaderInput
{
    float4 position : SV_POSITION; 
    float3 outVec : POSITION0;
    float3 outNormal : NORMAL0;
    float3 outLightVec : POSITION1;
};

PixelShaderInput main(VertexShaderInput input)
{
    // Inefficient -- doing this only for instruction. Normally, you would
 // premultiply them on the CPU and place them in the cbuffer.
    matrix mvMatrix = mul(model, view);
    matrix mvpMatrix = mul(mvMatrix, projection);

    PixelShaderInput output;

    float4 pos = float4(input.pos, 1.0f);
    float4 normal = float4(input.normal, 1.0f);
    float4 light = float4(lightPos.xyz, 1.0f);

    // 
    float4 eye = float4(0.0f, 0.0f, -2.0f, 1.0f);

    // Transform the vertex position into projected space.
    output.gl_Position = mul(pos, mvpMatrix);
    output.outNormal = mul(normal, mvMatrix).xyz;
    output.outVec = -(eye - mul(pos, mvMatrix)).xyz;
    output.outLightVec = mul(light, mvMatrix).xyz;

    return output;
}
```

## <a name="review-the-pixel-shader"></a>Проверка построителя текстуры

Этот построитель текстуры в этом примере довольно, возможно, является абсолютным минимальным объемом кода, который можно использовать в шейдере пикселей. Он принимает данные цвета с интерполяцией пикселя, созданные во время растрирования, и возвращает их в виде выходных данных, где они будут записаны в целевой объект отрисовки. Насколько скучными!


```C++
PS_OUTPUT main(PS_INPUT In)
{
    PS_OUTPUT Output;

    Output.RGBColor = In.Color;

    return Output;
}
```



Важной частью является `SV_TARGET` семантика системного значения для возвращаемого значения. Он указывает, что выходные данные должны быть записаны в основной целевой объект отрисовки, который является буфером текстуры, переданным в цепочку подкачки для отображения. Это требуется для шейдеров пикселей — без цветовых данных из шейдера пикселей в Direct3D ничего не отображается!

Пример более сложного шейдера пикселей для выполнения заливки по методу Фонга может выглядеть следующим образом. Так как векторы и нормали были интерполируются, нам не нужно вычислять их на основе каждого пикселя. Однако нам придется повторно нормализовать их из-за того, как работает интерполяция. по сути, нам нужно постепенно «прокрутить» вектор от направления к концу а к направлению на вершину B, сохранив его длину — вхерас интерполяцию, а не горизонтальную линию между двумя конечными точками вектора.

``` syntax
cbuffer MaterialConstantBuffer : register(b2)
{
    float4 lightColor;
    float4 Ka;
    float4 Kd;
    float4 Ks;
    float4 shininess;
};

struct PixelShaderInput
{
    float4 position : SV_POSITION;
    float3 outVec : POSITION0;
    float3 normal : NORMAL0;
    float3 light : POSITION1;
};

float4 main(PixelShaderInput input) : SV_TARGET
{
    float3 L = normalize(input.light);
    float3 V = normalize(input.outVec);
    float3 R = normalize(reflect(L, input.normal));

    float4 diffuse = Ka + (lightColor * Kd * max(dot(input.normal, L), 0.0f));
    diffuse = saturate(diffuse);

    float4 specular = Ks * pow(max(dot(R, V), 0.0f), shininess.x - 50.0f);
    specular = saturate(specular);

    float4 finalColor = diffuse + specular;

    return finalColor;
}
```

В другом примере шейдер пикселей принимает собственные буферы констант, которые содержат сведения о легких и материальных точках. Входной макет шейдера вершин будет расширен, чтобы включить обычные данные, а выходные данные этого шейдера вершин должны включать преобразованные векторы для вершины, освещение и нормальную вершину в системе координат представления.

Если у вас есть буферы текстур и пробы с назначенными регистрами (**t** и **s** соответственно), к ним можно обращаться также в шейдере пикселей.

``` syntax
Texture2D simpleTexture : register(t0);
SamplerState simpleSampler : register(s0);

struct PixelShaderInput
{
    float4 pos : SV_POSITION;
    float3 norm : NORMAL;
    float2 tex : TEXCOORD0;
};

float4 SimplePixelShader(PixelShaderInput input) : SV_TARGET
{
    float3 lightDirection = normalize(float3(1, -1, 0));
    float4 texelColor = simpleTexture.Sample(simpleSampler, input.tex);
    float lightMagnitude = 0.8f * saturate(dot(input.norm, -lightDirection)) + 0.2f;
    return texelColor * lightMagnitude;
}
```

Шейдеры — это мощные средства, которые можно использовать для создания процедурных ресурсов, таких как теневые карты или текстуры шума. На самом деле, для расширенных методик требуется, чтобы текстуры были более абстрактными, а не как визуальные элементы, но как буферы. Они хранят данные, такие как сведения о высоте, или другие данные, которые могут быть выделены в заключительном фрагменте шейдера пикселей, или в этом конкретном кадре в составе многоэтапных эффектов. Множественная выборка — это мощный инструмент и основа многих современных визуальных эффектов.

## <a name="next-steps"></a>Дальнейшие действия

Надеюсь, вы уже знакомы с DirectX 11at на этом этапе и готовы приступить к работе над проектом. Ниже приведены ссылки на другие вопросы, которые могут возникнуть при разработке с помощью DirectX и C++.

-   [Разработка игр](/previous-versions/windows/apps/hh452744(v=win.10))
-   [использование средств Visual Studio для программирования игр DirectX](/previous-versions/windows/apps/dn166877(v=win.10))
-   [Разработка игр DirectX и примеры пошаговых руководств](/previous-versions/windows/apps/hh465149(v=win.10))
-   [Дополнительные ресурсы по программированию игр](/previous-versions/windows/apps/dn194515(v=win.10))

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Работа с ресурсами устройств DirectX](work-with-dxgi.md)
</dt> <dt>

[Общие сведения о конвейере визуализации Direct3D 11](understand-the-directx-11-2-graphics-pipeline.md)
</dt> </dl>

 

 