---
description: Приложения могут столкнуться с проблемами при запуске в многопроцессорных системах из-за допущений, которые они допускаются только в однопроцессорных системах.
ms.assetid: b20a1d2c-b795-4ed8-ac33-539a347020c8
title: Проблемы синхронизации и многопроцессорности
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 3896dc240e76f1506bac2a6a2e95f101b05beca7
ms.sourcegitcommit: 9c8ddec1e955f181beecad0478c1fb79013b5e9d
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/21/2021
ms.locfileid: "105664783"
---
# <a name="synchronization-and-multiprocessor-issues"></a>Проблемы синхронизации и многопроцессорности

Приложения могут столкнуться с проблемами при запуске в многопроцессорных системах из-за допущений, которые они допускаются только в однопроцессорных системах.

## <a name="thread-priorities"></a>Приоритеты потоков

Рассмотрим программу с двумя потоками, одна с более высоким приоритетом, чем другая. В системе с одним процессором поток с более высоким приоритетом не будет предоставлять управление потоку с более низким приоритетом, так как планировщик дает предпочтение потокам с более высоким приоритетом. В многопроцессорной системе оба потока могут выполняться одновременно, каждый на собственном процессоре.

Приложения должны синхронизировать доступ к структурам данных, чтобы избежать конкуренции. Код, который предполагает, что потоки с более высоким приоритетом выполняются без помех в потоках с более низким приоритетом, завершатся сбоем в многопроцессорных системах.

## <a name="memory-ordering"></a>Упорядочение памяти

Когда процессор записывает данные в место в памяти, значение кэшируется для повышения производительности. Аналогичным образом, процессор пытается удовлетворить запросы чтения из кэша, чтобы повысить производительность. Более того, процессоры начинают извлекать значения из памяти до того, как они запрашиваются приложением. Это может произойти в рамках гипотетического выполнения или из-за проблем, связанных со строками кэша.

Кэш ЦП можно секционировать на банки, к которым можно получить доступ параллельно. Это означает, что операции с памятью могут выполняться не по порядку. Чтобы гарантировать, что операции с памятью выполняются по порядку, большинство процессоров предоставляет инструкции по барьеру памяти. *Переполнение памяти* гарантирует, что операции чтения и записи памяти, которые отображаются перед инструкцией барьера памяти, фиксируются в памяти до выполнения операций чтения и записи в памяти, появляющихся после инструкции барьера памяти. *Барьер памяти для чтения* упорядочивает только операции чтения памяти, а *барьер памяти для записи* упорядочивает только операции записи в память. Эти инструкции также гарантируют, что компилятор отключает любые оптимизации, которые могут переупорядочивать операции с памятью во всех барьерах.

Процессоры могут поддерживать инструкции для барьеров памяти с семантикой получения, выпуска и ограждения. Эти семантики описывают порядок, в котором результаты операции становятся доступными. При использовании семантики получения результаты операции доступны до результатов любой операции, которая отображается после нее в коде. При использовании семантики выпуска результаты операции становятся доступными после выполнения любой операции, которая отображается перед ней в коде. Семантика ограждения сочетает семантику получения и освобождения. Результаты операции с семантикой ограждения доступны до тех пор, пока они не появятся в коде и после любой операции, которая отображается перед ней.

В процессорах x86 и x64, поддерживающих SSE2, инструкции **мфенце** (ограждение памяти), **лфенце** (Load забор) и **сфенце** (ограждение хранилища). В процессорах ARM инструтионс — это **ДМБ** и **ДСБ**. Дополнительные сведения см. в документации к процессору.

Следующие функции синхронизации используют соответствующие барьеры для обеспечения упорядочения памяти:

-   Функции, которые вводят или оставляют критические секции
-   Функции, которые получают или освобождают блокировки SRW
-   Начало и завершение однократной инициализации
-   Функция **ентерсинчронизатионбарриер**
-   Функции, которые сообщают об объектах синхронизации
-   Функции Wait
-   Блокируемые функции (за исключением функций с суффиксом " _ограждения_ " или встроенных компонентов с суффиксом _\_ NF_ )

## <a name="fixing-a-race-condition"></a>Исправление состояния гонки

Следующий код имеет состояние гонки в многопроцессорных системах, так как процессор, который выполняет `CacheComputedValue` первый раз, может записывать `fValueHasBeenComputed` в основную память перед записью `iValue` в основную память. Следовательно, второй процессор, выполняющийся в `FetchComputedValue` то же время `fValueHasBeenComputed` , считывает значение **true**, но новое значение `iValue` остается в кэше первого процессора и не записывается в память.

``` syntax
int iValue;
BOOL fValueHasBeenComputed = FALSE;
extern int ComputeValue();

void CacheComputedValue()
{
  if (!fValueHasBeenComputed) 
  {
    iValue = ComputeValue();
    fValueHasBeenComputed = TRUE;
  }
}
 
BOOL FetchComputedValue(int *piResult)
{
  if (fValueHasBeenComputed) 
  {
    *piResult = iValue;
    return TRUE;
  } 

  else return FALSE;
}
```

Приведенное выше состояние гонки можно исправить с помощью ключевого слова **volatile** или функции [**интерлоккедексчанже**](/windows/desktop/api/winnt/nf-winnt-interlockedexchange.md) , чтобы гарантировать, что значение `iValue` обновляется для всех процессоров, прежде чем значение `fValueHasBeenComputed` будет равно **true**.

Запуск Visual Studio 2005, если скомпилирован в режиме **/volatile: MS** , компилятор использует семантику получения для операций чтения с **временными** переменными и семантику выпуска для операций записи **в переменных с переменными** (если они поддерживаются ЦП). Таким образом, можно исправить пример следующим образом:

``` syntax
volatile int iValue;
volatile BOOL fValueHasBeenComputed = FALSE;
extern int ComputeValue();

void CacheComputedValue()
{
  if (!fValueHasBeenComputed) 
  {
    iValue = ComputeValue();
    fValueHasBeenComputed = TRUE;
  }
}
 
BOOL FetchComputedValue(int *piResult)
{
  if (fValueHasBeenComputed) 
  {
    *piResult = iValue;
    return TRUE;
  } 

  else return FALSE;
}
```

В Visual Studio 2003 упорядочиваются **временные ссылки на** **переменные** . компилятор не будет изменять порядок доступа к переменным с **постоянным** доступом. Однако эти операции могут быть переупорядочены процессором. Таким образом, можно исправить пример следующим образом:

``` syntax
int iValue;
BOOL fValueHasBeenComputed = FALSE;
extern int ComputeValue();

void CacheComputedValue()
{
  if (InterlockedCompareExchange((LONG*)&fValueHasBeenComputed, 
          FALSE, FALSE)==FALSE) 
  {
    InterlockedExchange ((LONG*)&iValue, (LONG)ComputeValue());
    InterlockedExchange ((LONG*)&fValueHasBeenComputed, TRUE);
  }
}
 
BOOL FetchComputedValue(int *piResult)
{
  if (InterlockedCompareExchange((LONG*)&fValueHasBeenComputed, 
          TRUE, TRUE)==TRUE) 
  {
    InterlockedExchange((LONG*)piResult, (LONG)iValue);
    return TRUE;
  } 

  else return FALSE;
}
```

## <a name="related-topics"></a>См. также

<dl> <dt>

[Объекты критических секций](critical-section-objects.md)
</dt> <dt>

[Доступ к блокируемым переменным](interlocked-variable-access.md)
</dt> <dt>

[Функции Wait](wait-functions.md)
</dt> </dl>

 

 



