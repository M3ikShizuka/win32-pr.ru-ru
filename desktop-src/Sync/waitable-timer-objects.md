---
description: Ожидающий объект таймера — это объект синхронизации, состояние которого задается сигнальным по наступлении указанного времени выполнения.
ms.assetid: 5d39ada0-ea31-40d7-b075-aeb657ee508c
title: Ожидающие объекты таймера
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 2b9597617705fcd78bb71f63e33a475e3bca78e3
ms.sourcegitcommit: d75fc10b9f0825bbe5ce5045c90d4045e3c53243
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 09/13/2021
ms.locfileid: "127146042"
---
# <a name="waitable-timer-objects"></a>Ожидающие объекты таймера

*Ожидающий объект таймера* — это объект синхронизации, состояние которого задается сигнальным по наступлении указанного времени выполнения. Существует два типа таймеров ожидания, которые можно создать: сброс и синхронизация вручную. Таймер любого типа также может быть периодическим таймером.



| Объект                | Описание                                                                                                                                                                                             |
|-----------------------|---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------|
| таймер сброса вручную    | Таймер, состояние которого остается сигнальным до вызова [**сетваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) для установки нового времени выполнения.                                                                          |
| таймер синхронизации | Таймер, состояние которого остается сигнальным до тех пор, пока поток не завершит операцию ожидания объекта Timer.                                                                                                     |
| периодический таймер        | Таймер, который активируется каждый раз, когда истекает указанный период, пока таймер не будет сброшен или отменен. Периодическим таймером является период таймера сброса вручную или периодическая синхронизация. |



 

> [!Note]  
> При сигнале таймера процессор должен запуститься для обработки связанных инструкций. Периодические таймеры с высокой частотой заключают, что процессор постоянно занят, что предотвращает остающуюся систему в более низком [энергопотреблении](../power/system-power-states.md) в течение любого значимого времени. Это может негативно повлиять на время работы батареи портативного компьютера и на сценарии, которые зависят от эффективного управления питанием, например больших центров обработки данных. Для повышения эффективности энергопотребления рассмотрите возможность использования уведомлений на основе событий вместо уведомлений на основе времени в приложении. Если требуется таймер, используйте таймер, сигнальный один раз, а не периодический таймер, или установите для интервала значение больше одной секунды.

 

Поток использует функцию [**сбой createwaitabletimer**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerw) или [**креатеваитаблетимерекс**](/windows/win32/api/synchapi/nf-synchapi-createwaitabletimerexw) для создания объекта Timer. Создание потока указывает, является ли таймер таймером сброса вручную или таймером синхронизации. Создающий поток может указать имя для объекта Timer. Потоки в других процессах могут открыть обработчик для существующего таймера, указав его имя в вызове функции [**опенваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-openwaitabletimerw) . Любой поток с дескриптором объекта Timer может использовать одну из [функций ожидания](wait-functions.md) , чтобы ждать, пока состояние таймера не станет сигнальным.

-   Поток вызывает функцию [**сетваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) для активации таймера. Обратите внимание на использование следующих параметров для **сетваитаблетимер**:
-   Используйте параметр *лпдуетиме* , чтобы указать время, когда таймер должен быть установлен в сигнальное состояние. Если таймер сброса вручную установлен в сигнальное состояние, он остается в этом состоянии до тех пор, пока [**сетваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) не установит новое время выполнения. Если таймер синхронизации установлен в сигнальное состояние, он остается в этом состоянии до тех пор, пока поток не завершит операцию ожидания объекта Timer.
-   Используйте параметр *лпериод* функции [**сетваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer) , чтобы указать период таймера. Если период не равен нулю, таймер является периодическим таймером; она активируется повторно при каждом истечении периода времени, пока таймер не будет сброшен или отменен. Если точка равна нулю, таймер не является периодическим таймером; Она сообщается один раз, а затем деактивируется.

Поток может использовать функцию [**канцелваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-cancelwaitabletimer) , чтобы установить таймер в неактивное состояние. Чтобы сбросить таймер, вызовите [**сетваитаблетимер**](/windows/win32/api/synchapi/nf-synchapi-setwaitabletimer). По завершении работы с объектом Timer вызовите функцию [**CloseHandle**](/windows/win32/api/handleapi/nf-handleapi-closehandle) , чтобы закрыть маркер объекта Timer.

Поведение таймера ожидания можно суммировать следующим образом:

-   Если таймер установлен, он отменяется, если он уже активен, состояние таймера не сигнальное, а таймер помещается в очередь таймера ядра.
-   По истечении времени таймера устанавливается сигнальное состояние. Если таймер содержит подпрограммы завершения, он помещается в очередь потока, который устанавливает таймер. Процедура завершения остается в очереди потока [асинхронного вызова процедур](asynchronous-procedure-calls.md) (APC), пока поток не введет состояние ожидания с оповещением. В это время отправляется компания APC, и вызывается подпрограммы завершения. Если таймер является периодическим, он помещается обратно в очередь таймера ядра.
-   При отмене таймера он удаляется из очереди таймера ядра, если он находится в состоянии ожидания. Если срок действия таймера истек и по-прежнему имеется очередь APC в очереди для потока, который устанавливает таймер, то APC удаляется из очереди APC потока. Состояние сигнала таймера не изменяется.

## <a name="related-topics"></a>Связанные темы

<dl> <dt>

[Асинхронные вызовы процедур](asynchronous-procedure-calls.md)
</dt> <dt>

[Использование ожидающих объектов таймера](using-waitable-timer-objects.md)
</dt> </dl>

 

 
