---
description: Можно выполнять как синхронные, так и асинхронные (также называемые перекрывающиеся) операции ввода-вывода для файлов, именованных каналов и устройств с последовательным подключением.
ms.assetid: db44990e-5a0f-4153-8ff6-79dd7cda48af
title: Синхронизация и перекрытие входных и выходных данных
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: e263bb39badc7cbfadd67d80eb169dc1fe6d6c35
ms.sourcegitcommit: 831e8f3db78ab820e1710cede244553c70e50500
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/08/2021
ms.locfileid: "105664355"
---
# <a name="synchronization-and-overlapped-input-and-output"></a>Синхронизация и перекрытие входных и выходных данных

Можно выполнять как синхронные, так и асинхронные (также называемые перекрывающиеся) операции ввода-вывода для файлов, именованных каналов и устройств с последовательным подключением. Функции [**WriteFile**](/windows/win32/api/fileapi/nf-fileapi-writefile), [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile), [**DeviceIoControl**](/windows/win32/api/ioapiset/nf-ioapiset-deviceiocontrol), [**ваиткоммевент**](/windows/win32/api/winbase/nf-winbase-waitcommevent), [**коннектнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-connectnamedpipe)и [**трансактнамедпипе**](/windows/win32/api/namedpipeapi/nf-namedpipeapi-transactnamedpipe) могут выполняться синхронно или асинхронно. Функции [**реадфиликс**](/windows/win32/api/fileapi/nf-fileapi-readfileex) и [**вритефиликс**](/windows/win32/api/fileapi/nf-fileapi-writefileex) могут выполняться только асинхронно.

Когда функция выполняется синхронно, она не возвращает значение до завершения операции. Это означает, что выполнение вызывающего потока может быть заблокировано в течение неопределенного периода времени, пока оно ожидает завершения длительной операции. Функции, вызываемые для перекрывающейся операции, могут возвращаться немедленно, даже если операция не была завершена. Это позволяет выполнять трудоемкую операцию ввода-вывода в фоновом режиме, в то время как вызывающий поток может выполнять другие задачи. Например, один поток может выполнять одновременные операции ввода-вывода с разными дескрипторами или даже одновременные операции чтения и записи с одним и тем же дескриптором.

Чтобы синхронизировать выполнение с завершением перекрывающейся операции, вызывающий поток использует функцию [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) , функцию [**жетоверлаппедресултекс**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) или одну из [функций ожидания](wait-functions.md) , чтобы определить, когда была завершена операция перекрытия. Можно также использовать макрос [**хасоверлаппедиокомплетед**](/windows/desktop/api/WinBase/nf-winbase-hasoverlappediocompleted) для опроса завершения.

Чтобы отменить все ожидающие асинхронные операции ввода-вывода, используйте функцию [**канцелиоекс**](/windows/win32/api/ioapiset/nf-ioapiset-cancelioex) и предоставьте структуру [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) , указывающую запрос на отмену. Используйте функцию [**канцелио**](/windows/win32/api/ioapiset/nf-ioapiset-cancelio) для отмены ожидающих асинхронных операций ввода-вывода, выданных вызывающим потоком для указанного маркера файла.

Для операций с перекрытием требуется файл, именованный канал или коммуникационное устройство, созданное с флагом " **\_ \_ Перекрытие флага файла** ". Когда поток вызывает функцию (например, функцию [**ReadFile**](/windows/win32/api/fileapi/nf-fileapi-readfile) ) для выполнения операции перекрытия, вызывающий поток должен указать указатель на структуру [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) . (Если этот указатель равен **null**, возвращаемое значение функции может неправильно указывать на завершение операции.) Все члены **ПЕРЕкрывающейся** структуры должны быть инициализированы нулем, если только событие не будет использоваться для сигнализации о завершении операции ввода-вывода. Если используется событие, элемент **Хевент** структуры **OVERLAPPED** задает маркер для выделенного объекта события. Система Задает несигнальное состояние объекта события, когда вызов функции ввода-вывода возвращается до завершения операции. Система устанавливает состояние объекта события, чтобы сообщить о завершении операции. Событие требуется только в том случае, если в одно и то же время будет выполняться несколько необработанных операций ввода-вывода. Если событие не используется, то каждая выполненная операция ввода-вывода будет сообщать файлу, именованному каналу или коммуникационному устройству.

При вызове функции для выполнения операции перекрытия операция может быть завершена перед возвратом функции. В этом случае результаты обрабатываются так, как если бы операция выполнялась синхронно. Однако если операция не была завершена, возвращаемое значение функции равно **false**, а функция [**GetLastError**](/windows/win32/api/errhandlingapi/nf-errhandlingapi-getlasterror) возвращает **\_ \_ Ожидание ввода-вывода ошибки**.

Поток может управлять перекрывающейся операциями одним из двух методов:

-   Используйте функцию [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) или [**жетоверлаппедресултекс**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex) , чтобы дождаться завершения перекрывающейся операции. Если используется **жетоверлаппедресултекс** , вызывающий поток может указать время ожидания для операции перекрытия или выполнить предупреждение.
-   Укажите маркер для объекта события ручного [**сброса структуры в**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) одной из [функций ожидания](wait-functions.md) , а затем после возврата функции Wait вызовите [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) или [**жетоверлаппедресултекс**](/windows/desktop/api/Ioapiset/nf-ioapiset-getoverlappedresultex). Функция возвращает результаты завершенной операции перекрытия и для функций, в которых такая информация подходит, сообщает фактическое число переданных байтов.

При выполнении нескольких одновременных операций перекрытия в одном потоке вызывающий поток должен указать структуру [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) для каждой операции. Каждая **ПЕРЕкрывающаяся** структура должна задавать маркер для другого объекта события ручного сброса. Чтобы дождаться завершения любой из перекрывающихся операций, поток указывает все обработчики событий ручного сброса в качестве критериев ожидания в одной из [функций ожидания](wait-functions.md)с несколькими объектами. Возвращаемое значение функции ожидания с несколькими объектами указывает, какой объект события ручного сброса был сигнальным, поэтому поток может определить, какая операция перекрытия привела к завершению операции ожидания.

Безопаснее использовать отдельный объект события для каждой перекрывающейся операции, а не указывать ни одного объекта события или повторно использовать один и тот же объект события для нескольких операций. Если в структуре [**OVERLAPPED**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) не указан объект события, система сообщает о состоянии файла, именованного канала или коммуникационного устройства при завершении операции перекрытия. Таким образом, эти обработчики можно указать как объекты синхронизации в функции Wait, хотя их использование для этой цели может быть затруднено в управлении, так как при выполнении одновременных операций перекрытия на одном и том же файле, именованном канале или коммуникационном устройстве нет способа определить, какая операция привела к тому, что состояние объекта будет сигнальным.

Поток не должен повторно использовать событие с предположением, что событие будет сигнальным только операцией перекрытия этого потока. Событие получает сигнал в том же потоке, что и перекрывающаяся операция, которая завершается. Использование одного и того же события в нескольких потоках может привести к возникновению состояния гонки, в котором событие правильно сообщается для потока, операция которого завершается в первый и преждевременно для других потоков, использующих это событие. Затем, когда завершается следующая операция перекрытия, событие снова получает сигнал для всех потоков, использующих это событие, и так далее до тех пор, пока все перекрывающиеся операции не будут выполнены.

Примеры, иллюстрирующие использование перекрывающихся операций, подпрограмм завершения и функции [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) , см. в разделе [использование каналов](../ipc/using-pipes.md).

* * Windows Vista, Windows Server 2003 и Windows XP: * *

Будьте внимательны при повторном использовании структур с [**ПЕРЕкрытием**](/windows/win32/api/minwinbase/ns-minwinbase-overlapped) . Если **перекрывающиеся** структуры используются повторно в нескольких потоках, а [**GetOverlappedResult**](/windows/win32/api/ioapiset/nf-ioapiset-getoverlappedresult) вызывается с параметром *Бваит* , для которого установлено **значение true**, вызывающий поток должен убедиться, что соответствующее событие сигнально, прежде чем повторно использовать структуру. Это можно сделать с помощью функции [**WaitForSingleObject**](/windows/win32/api/winbase/nf-winbase-registerwaitforsingleobject) после вызова **GetOverlappedResult** , чтобы заставить поток ожидать завершения операции. Обратите внимание, что объект события должен быть объектом события ручного сброса. Если используется объект события автосброса, вызов **GetOverlappedResult** с параметром *бваит* , установленным в **значение true** , приводит к тому, что функция блокируется на неопределенное время. Это поведение изменилось начиная с Windows 7 и Windows Server 2008 R2 для приложений, которые задают Windows 7 в качестве поддерживаемой операционной системы в манифесте приложения. Дополнительные сведения см. в разделе [манифесты приложений](/previous-versions/windows/desktop/adrms_sdk/application-manifests).

## <a name="related-topics"></a>См. также

<dl> <dt>

[Основные понятия ввода-вывода](../fileio/i-o-concepts.md)
</dt> </dl>

 

 
