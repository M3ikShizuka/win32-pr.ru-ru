---
description: Создание библиотек DLL представляет ряд трудностей для разработчиков.
ms.assetid: 44EFC4B5-7A2F-43A6-914E-D4EB7446AC35
title: Рекомендации по использованию библиотеки Dynamic-Link
ms.topic: article
ms.date: 05/31/2018
ms.openlocfilehash: 95d02314b15a13de7658c0b87ba7cd998f48a0a3d9f2f2682b36539bd9f5bde3
ms.sourcegitcommit: e6600f550f79bddfe58bd4696ac50dd52cb03d7e
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 08/11/2021
ms.locfileid: "119696593"
---
# <a name="dynamic-link-library-best-practices"></a>Рекомендации по использованию библиотеки Dynamic-Link

* * Обновлено: * *

-   17 мая, 2006

**Важные API**

-   [**DllMain**](dllmain.md)
-   [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa)
-   [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa)

Создание библиотек DLL представляет ряд трудностей для разработчиков. Библиотеки DLL не имеют принудительного управления версиями. Если в системе существует несколько версий библиотеки DLL, простота переписывания в сочетании с отсутствием схемы управления версиями создает зависимости и конфликты API. Сложность среды разработки, реализация загрузчика и зависимости библиотек DLL создавали хрупкости в порядке загрузки и в поведении приложения. Наконец, многие приложения используют библиотеки DLL и имеют сложные наборы зависимостей, которые должны учитываться для правильной работы приложений. Этот документ содержит рекомендации для разработчиков библиотек DLL, помогающих создавать более надежные, переносимые и расширяемые библиотеки DLL.

Неправильная синхронизация в [**DllMain**](dllmain.md) может привести к взаимоблокировке приложения или доступу к данным или коду в неинициализированной библиотеке DLL. Вызов определенных функций из функции **DllMain** вызывает такие проблемы.

![что происходит при загрузке библиотеки](images/fig1.png)

## <a name="general-best-practices"></a>Общие рекомендации

Функция [**DllMain**](dllmain.md) вызывается во время удержания блокировки загрузчика. Поэтому в функциях, которые могут вызываться внутри **DllMain**, накладываются значительные ограничения. таким образом, функция **DllMain** предназначена для выполнения минимальных задач инициализации с помощью небольшого подмножества API Microsoft® Windows®. В **DllMain** нельзя вызывать функцию, которая напрямую или косвенно пытается получить блокировку загрузчика. В противном случае будет предпринята возможность возникновения взаимоблокировок или сбоев приложения. Ошибка в реализации **DllMain** может подвергнуть риску весь процесс и все его потоки.

Идеальная функция [**DllMain**](dllmain.md) — это просто пустая заглушка. Однако, учитывая сложность многих приложений, обычно это слишком мало. Хорошим правилом для функции **DllMain** является отложить как можно больше инициализации. Отложенная инициализация повышает надежность приложения, так как эта инициализация не выполняется во время удержания блокировки загрузчика. кроме того, отложенная инициализация позволяет безопасно использовать гораздо больше возможностей Windows API.

Некоторые задачи инициализации нельзя откладывать. Например, Библиотека DLL, которая зависит от файла конфигурации, не должна загружаться, если файл имеет неправильный формат или содержит мусор. Для этого типа инициализации библиотека DLL должна попытаться выполнить действие и быстро завершить работу, а не расходовать ресурсы, выполнив другие действия.

В [**DllMain**](dllmain.md)не следует выполнять следующие задачи.

-   Вызовите [**LoadLibrary**](/windows/win32/api/libloaderapi/nf-libloaderapi-loadlibrarya) или [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa) (напрямую или косвенно). Это может привести к взаимоблокировке или сбою.
-   Вызовите [**жетстрингтипеа**](/windows/desktop/api/winnls/nf-winnls-getstringtypea), [**жетстрингтипикс**](/windows/win32/api/stringapiset/nf-stringapiset-getstringtypeexw)или [**жетстрингтипев**](/windows/desktop/api/stringapiset/nf-stringapiset-getstringtypew) (прямо или косвенно). Это может привести к взаимоблокировке или сбою.
-   Синхронизация с другими потоками. Это может привести к взаимоблокировке.
-   Получите объект синхронизации, принадлежащий коду, который ожидает получения блокировки загрузчика. Это может привести к взаимоблокировке.
-   Инициализируйте потоки COM с помощью [**CoInitializeEx**](/windows/desktop/api/combaseapi/nf-combaseapi-coinitializeex). При определенных условиях эта функция может вызывать [**LoadLibraryEx**](/windows/desktop/api/LibLoaderAPI/nf-libloaderapi-loadlibraryexa).
-   Вызовите функции реестра. Эти функции реализуются в Advapi32.dll. Если Advapi32.dll не инициализирован перед библиотекой DLL, Библиотека DLL может получить доступ к неинициализированной памяти и привести к сбою процесса.
-   Вызовите функцию [**CreateProcess**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createprocessa). Создание процесса может загрузить другую библиотеку DLL.
-   Вызовите [**ExitThread**](/windows/win32/api/libloaderapi/nf-libloaderapi-freelibraryandexitthread). Выход из потока во время отключения библиотеки DLL может привести к повторному получению блокировки загрузчика, что приведет к взаимоблокировке или сбою.
-   Вызов функции [**CreateThread**](/windows/desktop/api/processthreadsapi/nf-processthreadsapi-createthread). Создание потока может работать, если не выполнить синхронизацию с другими потоками, но это рискованно.
-   создайте именованный канал или другой именованный объект (только Windows 2000). в Windows 2000 именованные объекты предоставляются библиотекой DLL служб терминалов. Если эта библиотека DLL не инициализирована, вызовы к библиотеке DLL могут привести к сбою процесса.
-   Используйте функцию управления памятью из динамического Run-Time C (CRT). Если DLL-библиотека CRT не инициализирована, вызовы этих функций могут привести к сбою процесса.
-   Вызывайте функции в User32.dll или Gdi32.dll. Некоторые функции загружают другую библиотеку DLL, которая не может быть инициализирована.
-   Использование управляемого кода.

Следующие задачи являются надежными для выполнения в **DllMain**:

-   Инициализируйте статические структуры данных и элементы во время компиляции.
-   Создание и инициализация объектов синхронизации.
-   Выделение памяти и инициализация динамических структур данных (без использования перечисленных выше функций).
-   Настройте локальную память потока (TLS).
-   Открытие, чтение и запись в файлы.
-   Вызывайте функции в Kernel32.dll (за исключением перечисленных выше функций).
-   Задайте глобальные указатели равными NULL, отключив инициализацию динамических членов. в™ Microsoft Windows Vista можно использовать одноразовые функции инициализации, чтобы блок кода выполнялся в многопоточной среде только один раз.

## <a name="deadlocks-caused-by-lock-order-inversion"></a>Взаимоблокировки, вызванные инверсией порядка блокировки

При реализации кода, использующего несколько объектов синхронизации, таких как блокировки, важно соблюдать порядок блокировки. Если необходимо получить более одной блокировки за раз, необходимо определить явный приоритет, который называется иерархией блокировок или порядком блокировки. Например, если блокировка, полученная перед блокировкой б где-то где-то в коде, и блокировка B получена перед блокировкой C в другом месте в коде, то порядок блокировки — A, B, C, и этот порядок должен соблюдаться во всем коде. Инверсия порядка блокировок происходит, когда не выполняется порядок блокировки — например, если блокировка B получена перед блокировкой A. Инверсия порядка блокировок может вызвать взаимоблокировки, которые трудно отладить. Чтобы избежать подобных проблем, все потоки должны получать блокировки в том же порядке.

Важно отметить, что загрузчик вызывает [**DllMain**](dllmain.md) с уже полученной блокировкой загрузчика, поэтому блокировка загрузчика должна иметь наивысший приоритет в иерархии блокировки. Также обратите внимание, что код должен получить только те блокировки, которые необходимы для правильной синхронизации. ему не нужно получать все одиночные блокировки, определенные в иерархии. Например, если в разделе кода требуется только блокировка A и C для правильной синхронизации, то код должен получить блокировку A перед получением блокировки C; в коде также нет необходимости получать блокировку B. Кроме того, код DLL не может явно получить блокировку загрузчика. Если код должен вызывать API, например [**GetModuleFileName**](/windows/win32/api/libloaderapi/nf-libloaderapi-getmodulefilenamea) , который может косвенно получить блокировку загрузчика, а код также должен получить закрытую блокировку, то код должен вызвать **GetModuleFileName** до того, как он получит блокировку P, что гарантирует, что порядок загрузки будет соблюдаться.

На рис. 2 показан пример инверсии порядка блокировок. Рассмотрим библиотеку DLL, основной поток которой содержит [**DllMain**](dllmain.md). Загрузчик библиотеки получает блокировку загрузчика L, а затем вызывает функцию **DllMain**. Главный поток создает объекты синхронизации A, B и G для сериализации доступа к его структурам данных, а затем пытается получить блокировку G. Рабочий поток, который уже успешно получил блокировку G, вызывает функцию, такую как ошибка GetModuleHandle, которая пытается получить блокировку в загрузчике L. Таким словами, Рабочий поток блокируется на L, а главный поток блокируется на G, что приводит к взаимоблокировке.

![взаимоблокировка, вызванная инверсией порядка блокировки](images/fig2.png)

Чтобы предотвратить взаимоблокировки, вызванные инверсией порядка блокировки, все потоки должны пытаться получить объекты синхронизации в определенном порядке загрузки.

## <a name="best-practices-for-synchronization"></a>Рекомендации по синхронизации

Рассмотрим библиотеку DLL, которая создает рабочие потоки в рамках своей инициализации. При очистке библиотеки DLL необходимо выполнить синхронизацию со всеми рабочими потоками, чтобы обеспечить согласованное состояние структур данных, а затем завершить работу рабочих потоков. В настоящее время нет удобного способа полностью решить проблему, связанную с аккуратной синхронизацией и завершением работы библиотек DLL в многопоточной среде. В этом разделе описаны текущие рекомендации по синхронизации потоков во время завершения работы библиотеки DLL.

Синхронизация потоков в [**DllMain**](dllmain.md) во время выхода из процесса

-   При вызове функции [**DllMain**](dllmain.md) во время завершения процесса все потоки процесса были принудительно очищены, и существует вероятность несоответствия адресного пространства. В этом случае синхронизация не требуется. Иными словами, идеальный \_ \_ обработчик отсоединения процесса DLL пуст.
-   Windows Vista гарантирует, что основные структуры данных (переменные среды, текущий каталог, куча процесса и т. д.) находятся в стабильном состоянии. Однако другие структуры данных могут быть повреждены, поэтому очистка памяти ненадежна.
-   Сохраняемое состояние, которое необходимо сохранить, должно быть записано в постоянное хранилище.

Синхронизация потоков в **DllMain** для \_ отключения потока DLL \_ во время выгрузки DLL

-   При выгрузке библиотеки DLL адресное пространство не создается. Поэтому библиотека DLL должна выполнить чистое завершение работы. Это включает синхронизацию потоков, открытые дескрипторы, устойчивое состояние и выделенные ресурсы.
-   Синхронизация потоков является сложной задачей, так как ожидание завершения потоков в [**DllMain**](dllmain.md) может привести к взаимоблокировке. Например, DLL A содержит блокировку загрузчика. Он сигнализирует потоку T выйти и ждет завершения потока. Поток T завершает работу, и загрузчик пытается получить блокировку загрузчика для вызова библиотеки DLL A в **DllMain** с \_ \_ отсоединением потока DLL. Это вызывает взаимоблокировку. Чтобы снизить риск взаимоблокировки:
    -   DLL A получает \_ \_ сообщение об отсоединении потока DLL в своей [**DllMain**](dllmain.md) и задает событие для потока T, чтобы сообщить ему о выходе.
    -   Поток T завершает свою текущую задачу, переводит себя в целостное состояние, передает DLL A и ожидает бесконечно. Обратите внимание, что подпрограммы проверки согласованности должны следовать тем же ограничениям, что и функция [**DllMain**](dllmain.md) , чтобы избежать взаимоблокировок.
    -   DLL A завершает T, зная, что она находится в стабильном состоянии.

Если библиотека DLL выгружается после создания всех ее потоков, но до начала выполнения, потоки могут завершиться со сбоем. Если библиотека DLL создала потоки в своей **DllMain** как часть инициализации, некоторые потоки могли не завершить инициализацию, а сообщение о \_ ПРИСОЕДИНЕНИИ потока библиотеки DLL \_ все еще ожидает доставки в библиотеку DLL. В этом случае, если библиотека DLL выгружена, она начнет завершать потоки. Однако некоторые потоки могут блокироваться за блокировкой загрузчика. \_ \_ Сообщения, присоединенные к ПОТОКу DLL, обрабатываются после того, как библиотека DLL не сопоставлена, что приводит к сбою процесса.

## <a name="recommendations"></a>Рекомендации

Ниже приведены рекомендуемые рекомендации.

-   Используйте средство проверки приложений для перехвата наиболее распространенных ошибок в [**DllMain**](dllmain.md).
-   При использовании закрытой блокировки в [**DllMain**](dllmain.md)Определите иерархию блокировки и используйте ее постоянно. Блокировка загрузчика должна находиться в нижней части этой иерархии.
-   Убедитесь, что никакие вызовы не зависят от другой библиотеки DLL, которая, возможно, еще не была полностью загружена.
-   Выполнять простые инициализации статически во время компиляции, а не в [**DllMain**](dllmain.md).
-   Отложите все вызовы функции [**DllMain**](dllmain.md) , которые могут ожидать позже.
-   Откладывание задач инициализации, которые могут дожидаться позже. Некоторые условия ошибок должны обнаруживаться на раннем этапе, чтобы приложение могла корректно обрабатывать ошибки. Однако существуют компромиссы между этим ранним выявлением и потерей надежности, которая может возникнуть в результате. Обычно рекомендуется отложить инициализацию.

 

 
